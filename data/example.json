{
    "/root/openzeppelin-contracts/contracts/utils/Packing.sol": [
        {
            "identifier": "OutOfRangeAccess",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error OutOfRangeAccess();",
            "start": "37",
            "end": "37",
            "class": "Packing",
            "signature": " OutOfRangeAccess",
            "full_signature": "function OutOfRangeAccess()",
            "class_method_signature": "Packing.OutOfRangeAccess",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating an out-of-range access attempt.\n * This error is thrown when an operation tries to access an index or value outside the valid range.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/SlotDerivation.sol": [
        {
            "identifier": "erc7201Slot",
            "parameters": "string memory namespace",
            "modifiers": "pure",
            "return": "returns (bytes32 slot)",
            "body": "function erc7201Slot(string memory namespace) internal pure returns (bytes32 slot) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, sub(keccak256(add(namespace, 0x20), mload(namespace)), 1))\n            slot := and(keccak256(0x00, 0x20), not(0xff))\n        }\n    }",
            "start": "45",
            "end": "50",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 slot) erc7201Slotstring memory namespace",
            "full_signature": "function erc7201Slot(string memory namespace) internal  pure returns (bytes32 slot)",
            "class_method_signature": "SlotDerivation.erc7201Slotstring memory namespace",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Computes the ERC-7201 storage slot for a given namespace.\n *\n * Steps:\n * 1. Load the namespace string into memory.\n * 2. Compute the keccak256 hash of the namespace.\n * 3. Subtract 1 from the hash to derive the slot.\n * 4. Apply a mask to ensure the slot is aligned to 256 bits.\n *\n * @param namespace The namespace string used to compute the storage slot.\n * @return slot The computed storage slot as a bytes32 value.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/ShortStrings.sol": [
        {
            "identifier": "FALLBACK_SENTINEL",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private constant FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;",
            "start": "42",
            "end": "42",
            "class": "ShortStrings",
            "signature": "bytes32 FALLBACK_SENTINEL",
            "full_signature": "bytes32 private constant FALLBACK_SENTINEL",
            "class_method_signature": "ShortStrings.FALLBACK_SENTINEL",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant `FALLBACK_SENTINEL` defined as a bytes32 value.\n * This value is likely used as a sentinel or marker to indicate a fallback or special condition in the contract.\n */"
        },
        {
            "identifier": "InvalidShortString",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error InvalidShortString();",
            "start": "45",
            "end": "45",
            "class": "ShortStrings",
            "signature": " InvalidShortString",
            "full_signature": "function InvalidShortString()",
            "class_method_signature": "ShortStrings.InvalidShortString",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a provided short string is invalid.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Create2.sol": [
        {
            "identifier": "Create2EmptyBytecode",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error Create2EmptyBytecode();",
            "start": "21",
            "end": "21",
            "class": "Create2",
            "signature": " Create2EmptyBytecode",
            "full_signature": "function Create2EmptyBytecode()",
            "class_method_signature": "Create2.Create2EmptyBytecode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Errors} from \"./Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the bytecode provided for a CREATE2 operation is empty.\n * This error is typically thrown when attempting to deploy a contract using CREATE2 with no bytecode.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Base64.sol": [
        {
            "identifier": "_TABLE",
            "parameters": "",
            "modifiers": "",
            "return": "string",
            "body": "string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";",
            "start": "14",
            "end": "14",
            "class": "Base64",
            "signature": "string _TABLE",
            "full_signature": "string internal constant _TABLE",
            "class_method_signature": "Base64._TABLE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant string representing the Base64 encoding table.\n * This table contains all the characters used in Base64 encoding, including uppercase letters,\n * lowercase letters, digits, and the '+' and '/' symbols.\n */"
        },
        {
            "identifier": "_TABLE_URL",
            "parameters": "",
            "modifiers": "",
            "return": "string",
            "body": "string internal constant _TABLE_URL = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";",
            "start": "15",
            "end": "15",
            "class": "Base64",
            "signature": "string _TABLE_URL",
            "full_signature": "string internal constant _TABLE_URL",
            "class_method_signature": "Base64._TABLE_URL",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant string representing a table of URL-safe characters.\n * The string includes uppercase letters, lowercase letters, digits, and the characters '-' and '_'.\n */"
        },
        {
            "identifier": "_encode",
            "parameters": "bytes memory data, string memory table, bool withPadding",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function _encode(bytes memory data, string memory table, bool withPadding) private pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // If padding is enabled, the final length should be `bytes` data length divided by 3 rounded up and then\n        // multiplied by 4 so that it leaves room for padding the last chunk\n        // - `data.length + 2`  -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // - `4 *`              -> 4 characters for each chunk\n        // This is equivalent to: 4 * Math.ceil(data.length / 3)\n        //\n        // If padding is disabled, the final length should be `bytes` data length multiplied by 4/3 rounded up as\n        // opposed to when padding is required to fill the last chunk.\n        // - `4 * data.length`  -> 4 characters for each chunk\n        // - ` + 2`             -> Prepare for division rounding up\n        // - `/ 3`              -> Number of 3-bytes chunks (rounded up)\n        // This is equivalent to: Math.ceil((4 * data.length) / 3)\n        uint256 resultLength = withPadding ? 4 * ((data.length + 2) / 3) : (4 * data.length + 2) / 3;\n\n        string memory result = new string(resultLength);\n\n        assembly (\"memory-safe\") {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 0x20)\n            let dataPtr := data\n            let endPtr := add(data, mload(data))\n\n            // In some cases, the last iteration will read bytes after the end of the data. We cache the value, and\n            // set it to zero to make sure no dirty bytes are read in that section.\n            let afterPtr := add(endPtr, 0x20)\n            let afterCache := mload(afterPtr)\n            mstore(afterPtr, 0x00)\n\n            // Run over the input, 3 bytes at a time\n            for {\n\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 byte (24 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F to bitmask the least significant 6 bits.\n                // Use this as an index into the lookup table, mload an entire word\n                // so the desired character is in the least significant byte, and\n                // mstore8 this least significant byte into the result and continue.\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // Reset the value that was cached\n            mstore(afterPtr, afterCache)\n\n            if withPadding {\n                // When data `bytes` is not exactly 3 bytes long\n                // it is padded with `=` characters at the end\n                switch mod(mload(data), 3)\n                case 1 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                    mstore8(sub(resultPtr, 2), 0x3d)\n                }\n                case 2 {\n                    mstore8(sub(resultPtr, 1), 0x3d)\n                }\n            }\n        }\n\n        return result;\n    }",
            "start": "35",
            "end": "122",
            "class": "Base64",
            "signature": "returns (string memory) _encodebytes memory data, string memory table, bool withPadding",
            "full_signature": "function _encode(bytes memory data, string memory table, bool withPadding) private  pure returns (string memory)",
            "class_method_signature": "Base64._encodebytes memory data, string memory table, bool withPadding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Encodes a given byte array into a Base64 string.\n * \n * @param data The byte array to be encoded.\n * @param table The Base64 encoding table to use.\n * @param withPadding A boolean flag indicating whether padding should be added to the output.\n * \n * @return result The Base64 encoded string.\n *\n * Steps:\n * 1. If the input data is empty, return an empty string.\n * 2. Calculate the length of the resulting Base64 string based on whether padding is enabled.\n * 3. Create a new string with the calculated length to store the result.\n * 4. Use assembly to efficiently encode the data:\n *    - Prepare the lookup table pointer.\n *    - Prepare pointers for the result, input data, and end of input data.\n *    - Cache and zero out the memory after the input data to prevent reading dirty bytes.\n *    - Iterate over the input data in chunks of 3 bytes, encoding each chunk into 4 Base64 characters.\n *    - Reset the cached memory value after encoding.\n * 5. If padding is enabled, add the appropriate number of '=' characters to the end of the result.\n * 6. Return the encoded Base64 string.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Arrays.sol": [
        {
            "identifier": "lowerBound",
            "parameters": "uint256[] storage array, uint256 element",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function lowerBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }",
            "start": "260",
            "end": "284",
            "class": "Arrays",
            "signature": "returns (uint256) lowerBounduint256[] storage array, uint256 element",
            "full_signature": "function lowerBound(uint256[] storage array, uint256 element) internal  view returns (uint256)",
            "class_method_signature": "Arrays.lowerBounduint256[] storage array, uint256 element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the lower bound index of a given element in a sorted array using binary search.\n *\n * Steps:\n * 1. Initialize `low` to 0 and `high` to the length of the array.\n * 2. If the array is empty, return 0.\n *\n * 3. Perform a binary search:\n *    - Calculate the midpoint `mid` using `Math.average(low, high)`.\n *    - If the value at `mid` is less than the target element, update `low` to `mid + 1`.\n *    - Otherwise, update `high` to `mid`.\n *\n * 4. The loop continues until `low` is no longer less than `high`.\n * 5. Return the index `low`, which is the lower bound for the element in the array.\n *\n * @dev The function assumes the array is sorted. The `unchecked` block is used to prevent overflow since `mid` is always less than `high`.\n */"
        },
        {
            "identifier": "_begin",
            "parameters": "uint256[] memory array",
            "modifiers": "pure",
            "return": "returns (uint256 ptr)",
            "body": "function _begin(uint256[] memory array) private pure returns (uint256 ptr) {\n        assembly (\"memory-safe\") {\n            ptr := add(array, 0x20)\n        }\n    }",
            "start": "142",
            "end": "146",
            "class": "Arrays",
            "signature": "returns (uint256 ptr) _beginuint256[] memory array",
            "full_signature": "function _begin(uint256[] memory array) private  pure returns (uint256 ptr)",
            "class_method_signature": "Arrays._beginuint256[] memory array",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that calculates the memory pointer for the start of a given array.\n *\n * Steps:\n * 1. Use inline assembly to calculate the memory pointer.\n * 2. The pointer is calculated by adding 0x20 (32 bytes) to the base address of the array, \n *    which skips the length slot and points to the first element of the array.\n * 3. Return the calculated pointer.\n */"
        },
        {
            "identifier": "unsafeSetLength",
            "parameters": "bytes32[] storage array, uint256 len",
            "modifiers": "",
            "return": "",
            "body": "function unsafeSetLength(bytes32[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }",
            "start": "466",
            "end": "470",
            "class": "Arrays",
            "signature": " unsafeSetLengthbytes32[] storage array, uint256 len",
            "full_signature": "function unsafeSetLength(bytes32[] storage array, uint256 len) internal",
            "class_method_signature": "Arrays.unsafeSetLengthbytes32[] storage array, uint256 len",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Unsafely sets the length of a bytes32 array in storage.\n * @dev This function uses inline assembly to directly modify the storage slot of the array.\n * @param array The storage array whose length is to be modified.\n * @param len The new length to set for the array.\n * @warning This function bypasses Solidity's safety checks and should be used with caution.\n */"
        },
        {
            "identifier": "unsafeSetLength",
            "parameters": "address[] storage array, uint256 len",
            "modifiers": "",
            "return": "",
            "body": "function unsafeSetLength(address[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }",
            "start": "455",
            "end": "459",
            "class": "Arrays",
            "signature": " unsafeSetLengthaddress[] storage array, uint256 len",
            "full_signature": "function unsafeSetLength(address[] storage array, uint256 len) internal",
            "class_method_signature": "Arrays.unsafeSetLengthaddress[] storage array, uint256 len",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Sets the length of an array in storage without checking for safety.\n * @dev This function uses inline assembly to directly modify the storage slot of the array.\n * @param array The storage array whose length is to be modified.\n * @param len The new length to set for the array.\n * @warning This function is unsafe as it bypasses Solidity's safety checks and can lead to undefined behavior if used incorrectly.\n */"
        },
        {
            "identifier": "unsafeAccess",
            "parameters": "bytes32[] storage arr, uint256 pos",
            "modifiers": "pure",
            "return": "returns (StorageSlot.Bytes32Slot storage)",
            "body": "function unsafeAccess(bytes32[] storage arr, uint256 pos) internal pure returns (StorageSlot.Bytes32Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getBytes32Slot();\n    }",
            "start": "396",
            "end": "402",
            "class": "Arrays",
            "signature": "returns (StorageSlot.Bytes32Slot storage) unsafeAccessbytes32[] storage arr, uint256 pos",
            "full_signature": "function unsafeAccess(bytes32[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Bytes32Slot storage)",
            "class_method_signature": "Arrays.unsafeAccessbytes32[] storage arr, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function Bytes32Slot()', 'function deriveArray(bytes32 slot) internal  pure returns (bytes32 result)', 'function offset(bytes32 slot, uint256 pos) internal  pure returns (bytes32 result)', 'function getBytes32Slot(bytes32 slot) internal  pure returns (Bytes32Slot storage r)'}",
            "human_labeled_comment": "/**\n * @notice Accesses a specific position in a `bytes32` array stored in storage.\n * \n * @param arr The storage array of `bytes32` elements.\n * @param pos The position in the array to access.\n * @return A `Bytes32Slot` representing the storage slot of the element at the specified position.\n * \n * Steps:\n * 1. Retrieve the base storage slot of the array.\n * 2. Derive the storage slot for the element at the specified position.\n * 3. Return the `Bytes32Slot` for the derived storage slot.\n */"
        },
        {
            "identifier": "_castToUint256Array",
            "parameters": "address[] memory input",
            "modifiers": "pure",
            "return": "returns (uint256[] memory output)",
            "body": "function _castToUint256Array(address[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }",
            "start": "180",
            "end": "184",
            "class": "Arrays",
            "signature": "returns (uint256[] memory output) _castToUint256Arrayaddress[] memory input",
            "full_signature": "function _castToUint256Array(address[] memory input) private  pure returns (uint256[] memory output)",
            "class_method_signature": "Arrays._castToUint256Arrayaddress[] memory input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of addresses into an array of uint256 values.\n * @dev This function uses inline assembly to directly cast the input array of addresses to an array of uint256.\n * @param input The array of addresses to be cast.\n * @return output The resulting array of uint256 values.\n */"
        },
        {
            "identifier": "_mload",
            "parameters": "uint256 ptr",
            "modifiers": "pure",
            "return": "returns (uint256 value)",
            "body": "function _mload(uint256 ptr) private pure returns (uint256 value) {\n        assembly {\n            value := mload(ptr)\n        }\n    }",
            "start": "161",
            "end": "165",
            "class": "Arrays",
            "signature": "returns (uint256 value) _mloaduint256 ptr",
            "full_signature": "function _mload(uint256 ptr) private  pure returns (uint256 value)",
            "class_method_signature": "Arrays._mloaduint256 ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Loads a 256-bit value from memory at the specified pointer.\n * @dev This function uses inline assembly to perform the memory load operation.\n * @param ptr The memory pointer from which to load the value.\n * @return value The 256-bit value loaded from memory.\n */"
        },
        {
            "identifier": "_end",
            "parameters": "uint256[] memory array",
            "modifiers": "pure",
            "return": "returns (uint256 ptr)",
            "body": "function _end(uint256[] memory array) private pure returns (uint256 ptr) {\n        unchecked {\n            return _begin(array) + array.length * 0x20;\n        }\n    }",
            "start": "152",
            "end": "156",
            "class": "Arrays",
            "signature": "returns (uint256 ptr) _enduint256[] memory array",
            "full_signature": "function _end(uint256[] memory array) private  pure returns (uint256 ptr)",
            "class_method_signature": "Arrays._enduint256[] memory array",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Calculates the end pointer of a dynamic array in memory.\n * \n * Steps:\n * 1. Takes a dynamic array of uint256 as input.\n * 2. Uses the `_begin` function to get the starting pointer of the array.\n * 3. Adds the length of the array multiplied by 0x20 (32 bytes, the size of each uint256 element) to the starting pointer.\n * 4. Returns the calculated end pointer.\n * \n * @param array The dynamic array of uint256 for which the end pointer is calculated.\n * @return ptr The end pointer of the array in memory.\n */"
        },
        {
            "identifier": "unsafeAccess",
            "parameters": "uint256[] storage arr, uint256 pos",
            "modifiers": "pure",
            "return": "returns (StorageSlot.Uint256Slot storage)",
            "body": "function unsafeAccess(uint256[] storage arr, uint256 pos) internal pure returns (StorageSlot.Uint256Slot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getUint256Slot();\n    }",
            "start": "409",
            "end": "415",
            "class": "Arrays",
            "signature": "returns (StorageSlot.Uint256Slot storage) unsafeAccessuint256[] storage arr, uint256 pos",
            "full_signature": "function unsafeAccess(uint256[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Uint256Slot storage)",
            "class_method_signature": "Arrays.unsafeAccessuint256[] storage arr, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function Uint256Slot()', 'function deriveArray(bytes32 slot) internal  pure returns (bytes32 result)', 'function offset(bytes32 slot, uint256 pos) internal  pure returns (bytes32 result)', 'function getUint256Slot(bytes32 slot) internal  pure returns (Uint256Slot storage r)'}",
            "human_labeled_comment": "/**\n * @notice Provides unsafe access to a specific position in a uint256 array stored in storage.\n *\n * Steps:\n * 1. Retrieve the storage slot of the array.\n * 2. Derive the storage slot for the array and calculate the offset for the specified position.\n * 3. Return the Uint256Slot for the specified position in the array.\n *\n * @param arr The uint256 array in storage.\n * @param pos The position in the array to access.\n * @return The Uint256Slot for the specified position in the array.\n */"
        },
        {
            "identifier": "_castToUint256Array",
            "parameters": "bytes32[] memory input",
            "modifiers": "pure",
            "return": "returns (uint256[] memory output)",
            "body": "function _castToUint256Array(bytes32[] memory input) private pure returns (uint256[] memory output) {\n        assembly {\n            output := input\n        }\n    }",
            "start": "187",
            "end": "191",
            "class": "Arrays",
            "signature": "returns (uint256[] memory output) _castToUint256Arraybytes32[] memory input",
            "full_signature": "function _castToUint256Array(bytes32[] memory input) private  pure returns (uint256[] memory output)",
            "class_method_signature": "Arrays._castToUint256Arraybytes32[] memory input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of `bytes32` to an array of `uint256`.\n * @dev This function uses inline assembly to directly cast the input array to the output array.\n * @param input The input array of `bytes32` values.\n * @return output The output array of `uint256` values.\n */"
        },
        {
            "identifier": "_castToUint256Comp",
            "parameters": "function(bytes32, bytes32) pure returns (bool) input",
            "modifiers": "pure",
            "return": "returns (function(uint256, uint256) pure returns (bool) output)",
            "body": "function _castToUint256Comp(\n        function(bytes32, bytes32) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }",
            "start": "203",
            "end": "209",
            "class": "Arrays",
            "signature": "returns (function(uint256, uint256) pure returns (bool) output) _castToUint256Compfunction(bytes32, bytes32) pure returns (bool) input",
            "full_signature": "function _castToUint256Comp(function(bytes32, bytes32) pure returns (bool) input) private  pure returns (function(uint256, uint256) pure returns (bool) output)",
            "class_method_signature": "Arrays._castToUint256Compfunction(bytes32, bytes32) pure returns (bool) input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Casts a function that takes two `bytes32` inputs and returns a `bool` \n *         into a function that takes two `uint256` inputs and returns a `bool`.\n * \n * @dev This is achieved using inline assembly to directly assign the input function \n *      to the output function without any runtime checks or conversions.\n * \n * @param input The original function with `bytes32` inputs.\n * @return output The casted function with `uint256` inputs.\n */"
        },
        {
            "identifier": "unsafeMemoryAccess",
            "parameters": "uint256[] memory arr, uint256 pos",
            "modifiers": "pure",
            "return": "returns (uint256 res)",
            "body": "function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal pure returns (uint256 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }",
            "start": "444",
            "end": "448",
            "class": "Arrays",
            "signature": "returns (uint256 res) unsafeMemoryAccessuint256[] memory arr, uint256 pos",
            "full_signature": "function unsafeMemoryAccess(uint256[] memory arr, uint256 pos) internal  pure returns (uint256 res)",
            "class_method_signature": "Arrays.unsafeMemoryAccessuint256[] memory arr, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Accesses an element in a memory array at a specific position without bounds checking.\n * \n * @param arr The memory array to access.\n * @param pos The position of the element to retrieve.\n * @return res The value at the specified position in the array.\n * \n * @dev This function uses inline assembly to directly access memory, which is unsafe as it does not perform bounds checking.\n *      The caller must ensure that the position is within the array's bounds to avoid undefined behavior.\n */"
        },
        {
            "identifier": "upperBoundMemory",
            "parameters": "uint256[] memory array, uint256 element",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function upperBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }",
            "start": "352",
            "end": "376",
            "class": "Arrays",
            "signature": "returns (uint256) upperBoundMemoryuint256[] memory array, uint256 element",
            "full_signature": "function upperBoundMemory(uint256[] memory array, uint256 element) internal  pure returns (uint256)",
            "class_method_signature": "Arrays.upperBoundMemoryuint256[] memory array, uint256 element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the upper bound index for a given element in a sorted memory array using binary search.\n *\n * Steps:\n * 1. Initialize `low` to 0 and `high` to the length of the array.\n * 2. If the array is empty, return 0 immediately.\n * 3. Perform a binary search:\n *    - Calculate the middle index `mid` using `Math.average`.\n *    - If the element at `mid` is greater than the target element, set `high` to `mid`.\n *    - Otherwise, set `low` to `mid + 1` (this cannot overflow due to `mid < high`).\n * 4. Return the `low` index, which represents the upper bound for the element.\n *\n * @param array The sorted memory array to search.\n * @param element The element to find the upper bound for.\n * @return The index of the upper bound for the element.\n */"
        },
        {
            "identifier": "_castToUint256Comp",
            "parameters": "function(address, address) pure returns (bool) input",
            "modifiers": "pure",
            "return": "returns (function(uint256, uint256) pure returns (bool) output)",
            "body": "function _castToUint256Comp(\n        function(address, address) pure returns (bool) input\n    ) private pure returns (function(uint256, uint256) pure returns (bool) output) {\n        assembly {\n            output := input\n        }\n    }",
            "start": "194",
            "end": "200",
            "class": "Arrays",
            "signature": "returns (function(uint256, uint256) pure returns (bool) output) _castToUint256Compfunction(address, address) pure returns (bool) input",
            "full_signature": "function _castToUint256Comp(function(address, address) pure returns (bool) input) private  pure returns (function(uint256, uint256) pure returns (bool) output)",
            "class_method_signature": "Arrays._castToUint256Compfunction(address, address) pure returns (bool) input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Casts a function that takes two `address` parameters and returns a `bool` \n *         into a function that takes two `uint256` parameters and returns a `bool`.\n * \n * @dev This is achieved using inline assembly to directly assign the input function \n *      to the output function pointer without any runtime checks or conversions.\n * \n * @param input The original function with `address` parameters.\n * @return output The casted function with `uint256` parameters.\n */"
        },
        {
            "identifier": "_swap",
            "parameters": "uint256 ptr1, uint256 ptr2",
            "modifiers": "pure",
            "return": "",
            "body": "function _swap(uint256 ptr1, uint256 ptr2) private pure {\n        assembly {\n            let value1 := mload(ptr1)\n            let value2 := mload(ptr2)\n            mstore(ptr1, value2)\n            mstore(ptr2, value1)\n        }\n    }",
            "start": "170",
            "end": "177",
            "class": "Arrays",
            "signature": " _swapuint256 ptr1, uint256 ptr2",
            "full_signature": "function _swap(uint256 ptr1, uint256 ptr2) private  pure",
            "class_method_signature": "Arrays._swapuint256 ptr1, uint256 ptr2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Swaps the values stored at two memory pointers.\n *\n * Steps:\n * 1. Load the value from the first pointer (`ptr1`) into `value1`.\n * 2. Load the value from the second pointer (`ptr2`) into `value2`.\n * 3. Store `value2` at the memory location of `ptr1`.\n * 4. Store `value1` at the memory location of `ptr2`.\n *\n * @dev This function uses inline assembly to perform the swap operation efficiently.\n */"
        },
        {
            "identifier": "lowerBoundMemory",
            "parameters": "uint256[] memory array, uint256 element",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lowerBoundMemory(uint256[] memory array, uint256 element) internal pure returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeMemoryAccess(array, mid) < element) {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }",
            "start": "323",
            "end": "347",
            "class": "Arrays",
            "signature": "returns (uint256) lowerBoundMemoryuint256[] memory array, uint256 element",
            "full_signature": "function lowerBoundMemory(uint256[] memory array, uint256 element) internal  pure returns (uint256)",
            "class_method_signature": "Arrays.lowerBoundMemoryuint256[] memory array, uint256 element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the lower bound index for a given element in a sorted memory array using binary search.\n *\n * Steps:\n * 1. Initialize `low` to 0 and `high` to the length of the array.\n * 2. If the array is empty, return 0.\n * 3. Perform binary search:\n *    a. Calculate the middle index `mid` using `Math.average`.\n *    b. If the element at `mid` is less than the target element, adjust `low` to `mid + 1`.\n *    c. Otherwise, adjust `high` to `mid`.\n * 4. Continue the search until `low` is no longer less than `high`.\n * 5. Return the `low` index as the lower bound.\n *\n * @dev The function assumes the array is sorted. It uses `unsafeMemoryAccess` to access array elements.\n *      The `unchecked` block is used to prevent overflow since `mid` is always less than `high`.\n *\n * @param array The sorted memory array to search.\n * @param element The element to find the lower bound for.\n * @return The index of the lower bound for the element in the array.\n */"
        },
        {
            "identifier": "unsafeMemoryAccess",
            "parameters": "address[] memory arr, uint256 pos",
            "modifiers": "pure",
            "return": "returns (address res)",
            "body": "function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal pure returns (address res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }",
            "start": "422",
            "end": "426",
            "class": "Arrays",
            "signature": "returns (address res) unsafeMemoryAccessaddress[] memory arr, uint256 pos",
            "full_signature": "function unsafeMemoryAccess(address[] memory arr, uint256 pos) internal  pure returns (address res)",
            "class_method_signature": "Arrays.unsafeMemoryAccessaddress[] memory arr, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Accesses an element in a memory array at a specific position without bounds checking.\n * \n * @param arr The memory array of addresses to access.\n * @param pos The position of the element to retrieve.\n * @return res The address at the specified position in the array.\n *\n * @dev This function uses inline assembly to directly access memory, which is unsafe as it does not perform bounds checking.\n *      Use with caution to avoid out-of-bounds memory access.\n */"
        },
        {
            "identifier": "upperBound",
            "parameters": "uint256[] storage array, uint256 element",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function upperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                // this cannot overflow because mid < high\n                unchecked {\n                    low = mid + 1;\n                }\n            }\n        }\n\n        return low;\n    }",
            "start": "294",
            "end": "318",
            "class": "Arrays",
            "signature": "returns (uint256) upperBounduint256[] storage array, uint256 element",
            "full_signature": "function upperBound(uint256[] storage array, uint256 element) internal  view returns (uint256)",
            "class_method_signature": "Arrays.upperBounduint256[] storage array, uint256 element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the upper bound of a given element in a sorted array using binary search.\n *\n * Steps:\n * 1. Initialize `low` to 0 and `high` to the length of the array.\n * 2. If the array is empty, return 0 immediately.\n *\n * 3. Perform binary search:\n *    - Calculate the midpoint `mid` using `Math.average(low, high)`.\n *    - If the value at `mid` is greater than the target `element`, set `high` to `mid`.\n *    - Otherwise, increment `low` to `mid + 1` (this cannot overflow due to `mid < high`).\n *\n * 4. Return the index `low`, which represents the upper bound of the element in the array.\n *\n * @dev The function assumes the array is sorted in ascending order.\n * @param array The sorted array to search.\n * @param element The element to find the upper bound for.\n * @return The index of the upper bound of the element in the array.\n */"
        },
        {
            "identifier": "findUpperBound",
            "parameters": "uint256[] storage array, uint256 element",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function findUpperBound(uint256[] storage array, uint256 element) internal view returns (uint256) {\n        uint256 low = 0;\n        uint256 high = array.length;\n\n        if (high == 0) {\n            return 0;\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n\n            // Note that mid will always be strictly less than high (i.e. it will be a valid array index)\n            // because Math.average rounds towards zero (it does integer division with truncation).\n            if (unsafeAccess(array, mid).value > element) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        // At this point `low` is the exclusive upper bound. We will return the inclusive upper bound.\n        if (low > 0 && unsafeAccess(array, low - 1).value == element) {\n            return low - 1;\n        } else {\n            return low;\n        }\n    }",
            "start": "224",
            "end": "250",
            "class": "Arrays",
            "signature": "returns (uint256) findUpperBounduint256[] storage array, uint256 element",
            "full_signature": "function findUpperBound(uint256[] storage array, uint256 element) internal  view returns (uint256)",
            "class_method_signature": "Arrays.findUpperBounduint256[] storage array, uint256 element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the upper bound of a given element in a sorted array using binary search.\n *\n * Steps:\n * 1. Initialize `low` to 0 and `high` to the length of the array.\n * 2. If the array is empty, return 0.\n *\n * 3. Perform a binary search:\n *    - Calculate the midpoint `mid` using `Math.average(low, high)`.\n *    - If the value at `mid` is greater than the target element, set `high` to `mid`.\n *    - Otherwise, set `low` to `mid + 1`.\n *\n * 4. After the loop, `low` represents the exclusive upper bound.\n * 5. If the element at `low - 1` equals the target element, return `low - 1` (inclusive upper bound).\n * 6. Otherwise, return `low` (exclusive upper bound).\n */"
        },
        {
            "identifier": "_quickSort",
            "parameters": "uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp",
            "modifiers": "pure",
            "return": "",
            "body": "function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private pure {\n        unchecked {\n            if (end - begin < 0x40) return;\n\n            // Use first element as pivot\n            uint256 pivot = _mload(begin);\n            // Position where the pivot should be at the end of the loop\n            uint256 pos = begin;\n\n            for (uint256 it = begin + 0x20; it < end; it += 0x20) {\n                if (comp(_mload(it), pivot)) {\n                    // If the value stored at the iterator's position comes before the pivot, we increment the\n                    // position of the pivot and move the value there.\n                    pos += 0x20;\n                    _swap(pos, it);\n                }\n            }\n\n            _swap(begin, pos); // Swap pivot into place\n            _quickSort(begin, pos, comp); // Sort the left side of the pivot\n            _quickSort(pos + 0x20, end, comp); // Sort the right side of the pivot\n        }\n    }",
            "start": "115",
            "end": "137",
            "class": "Arrays",
            "signature": " _quickSortuint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp",
            "full_signature": "function _quickSort(uint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp) private  pure",
            "class_method_signature": "Arrays._quickSortuint256 begin, uint256 end, function(uint256, uint256) pure returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Implements the QuickSort algorithm to sort a range of elements in memory.\n *\n * Steps:\n * 1. Check if the range (end - begin) is less than 0x40 (64 bytes). If so, return early as no sorting is needed.\n * 2. Use the first element in the range as the pivot.\n * 3. Initialize a position variable `pos` to track where the pivot should be placed.\n * 4. Iterate through the range starting from the second element.\n * 5. For each element, compare it with the pivot using the provided comparison function `comp`.\n * 6. If the element should come before the pivot, increment `pos` and swap the element with the element at `pos`.\n * 7. After the loop, swap the pivot into its correct position at `pos`.\n * 8. Recursively sort the left side of the pivot (from `begin` to `pos`).\n * 9. Recursively sort the right side of the pivot (from `pos + 0x20` to `end`).\n *\n * @param begin The starting memory position of the range to sort.\n * @param end The ending memory position of the range to sort.\n * @param comp A comparison function that determines the order of elements.\n */"
        },
        {
            "identifier": "unsafeSetLength",
            "parameters": "uint256[] storage array, uint256 len",
            "modifiers": "",
            "return": "",
            "body": "function unsafeSetLength(uint256[] storage array, uint256 len) internal {\n        assembly (\"memory-safe\") {\n            sstore(array.slot, len)\n        }\n    }",
            "start": "477",
            "end": "481",
            "class": "Arrays",
            "signature": " unsafeSetLengthuint256[] storage array, uint256 len",
            "full_signature": "function unsafeSetLength(uint256[] storage array, uint256 len) internal",
            "class_method_signature": "Arrays.unsafeSetLengthuint256[] storage array, uint256 len",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Unsafely sets the length of a storage array.\n * \n * @dev This function directly modifies the length of the array in storage using inline assembly.\n *      It should be used with caution as it bypasses Solidity's safety checks.\n * \n * @param array The storage array whose length is to be modified.\n * @param len The new length to set for the array.\n */"
        },
        {
            "identifier": "unsafeMemoryAccess",
            "parameters": "bytes32[] memory arr, uint256 pos",
            "modifiers": "pure",
            "return": "returns (bytes32 res)",
            "body": "function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal pure returns (bytes32 res) {\n        assembly {\n            res := mload(add(add(arr, 0x20), mul(pos, 0x20)))\n        }\n    }",
            "start": "433",
            "end": "437",
            "class": "Arrays",
            "signature": "returns (bytes32 res) unsafeMemoryAccessbytes32[] memory arr, uint256 pos",
            "full_signature": "function unsafeMemoryAccess(bytes32[] memory arr, uint256 pos) internal  pure returns (bytes32 res)",
            "class_method_signature": "Arrays.unsafeMemoryAccessbytes32[] memory arr, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Accesses a specific element in a `bytes32` array without bounds checking.\n * \n * @param arr The `bytes32` array from which to access the element.\n * @param pos The index of the element to access.\n * @return res The value of the element at the specified position.\n * \n * @dev This function uses inline assembly to directly access memory, which is unsafe as it does not perform bounds checking.\n *      It assumes the caller ensures the position is within the array's bounds.\n */"
        },
        {
            "identifier": "unsafeAccess",
            "parameters": "address[] storage arr, uint256 pos",
            "modifiers": "pure",
            "return": "returns (StorageSlot.AddressSlot storage)",
            "body": "function unsafeAccess(address[] storage arr, uint256 pos) internal pure returns (StorageSlot.AddressSlot storage) {\n        bytes32 slot;\n        assembly (\"memory-safe\") {\n            slot := arr.slot\n        }\n        return slot.deriveArray().offset(pos).getAddressSlot();\n    }",
            "start": "383",
            "end": "389",
            "class": "Arrays",
            "signature": "returns (StorageSlot.AddressSlot storage) unsafeAccessaddress[] storage arr, uint256 pos",
            "full_signature": "function unsafeAccess(address[] storage arr, uint256 pos) internal  pure returns (StorageSlot.AddressSlot storage)",
            "class_method_signature": "Arrays.unsafeAccessaddress[] storage arr, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function getAddressSlot(bytes32 slot) internal  pure returns (AddressSlot storage r)', 'function deriveArray(bytes32 slot) internal  pure returns (bytes32 result)', 'function offset(bytes32 slot, uint256 pos) internal  pure returns (bytes32 result)', 'function AddressSlot()'}",
            "human_labeled_comment": "/**\n * @notice Provides unsafe access to an address array's storage slot at a specific position.\n *\n * Steps:\n * 1. Retrieve the storage slot of the array using inline assembly.\n * 2. Derive the array's base slot and offset it by the specified position.\n * 3. Return the address slot at the calculated position.\n *\n * @dev This function uses low-level assembly to directly access storage, which can be unsafe if not used carefully.\n *\n * @param arr The address array to access.\n * @param pos The position in the array to access.\n * @return The storage slot for the address at the specified position.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Strings.sol": [
        {
            "identifier": "_tryParseIntUncheckedBounds",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, int256 value)",
            "body": "function _tryParseIntUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, int256 value) {\n        bytes memory buffer = bytes(input);\n\n        // Check presence of a negative sign.\n        bytes1 sign = begin == end ? bytes1(0) : bytes1(_unsafeReadBytesOffset(buffer, begin)); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        bool positiveSign = sign == bytes1(\"+\");\n        bool negativeSign = sign == bytes1(\"-\");\n        uint256 offset = (positiveSign || negativeSign).toUint();\n\n        (bool absSuccess, uint256 absValue) = tryParseUint(input, begin + offset, end);\n\n        if (absSuccess && absValue < ABS_MIN_INT256) {\n            return (true, negativeSign ? -int256(absValue) : int256(absValue));\n        } else if (absSuccess && negativeSign && absValue == ABS_MIN_INT256) {\n            return (true, type(int256).min);\n        } else return (false, 0);\n    }",
            "start": "256",
            "end": "276",
            "class": "Strings",
            "signature": "returns (bool success, int256 value) _tryParseIntUncheckedBoundsstring memory input, uint256 begin, uint256 end",
            "full_signature": "function _tryParseIntUncheckedBounds(string memory input, uint256 begin, uint256 end) private  pure returns (bool success, int256 value)",
            "class_method_signature": "Strings._tryParseIntUncheckedBoundsstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "{'function abs(int256 n) internal  pure returns (uint256)', 'function min(int256 a, int256 b) internal  pure returns (int256)', 'function toUint(bool b) internal  pure returns (uint256 u)', 'function min(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a substring of a string into an integer without checking bounds.\n *\n * @param input The input string to parse.\n * @param begin The starting index of the substring to parse.\n * @param end The ending index of the substring to parse.\n *\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed integer value, or 0 if parsing failed.\n *\n * Steps:\n * 1. Convert the input string into a byte array for easier manipulation.\n * 2. Check if the substring contains a negative or positive sign at the beginning.\n * 3. Determine the offset for the start of the numeric part of the substring.\n * 4. Attempt to parse the numeric part of the substring into an unsigned integer.\n * 5. If the parsing is successful and the value is within the valid range for int256:\n *    - Return the parsed value with the appropriate sign.\n *    - Handle the special case for the minimum int256 value.\n * 6. If parsing fails or the value is out of bounds, return (false, 0).\n */"
        },
        {
            "identifier": "equal",
            "parameters": "string memory a, string memory b",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }",
            "start": "126",
            "end": "128",
            "class": "Strings",
            "signature": "returns (bool) equalstring memory a, string memory b",
            "full_signature": "function equal(string memory a, string memory b) internal  pure returns (bool)",
            "class_method_signature": "Strings.equalstring memory a, string memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Compares two strings for equality.\n *\n * Steps:\n * 1. Check if the lengths of the two strings are equal.\n * 2. Compare the keccak256 hash of the two strings.\n * 3. Return true if both the length and hash match, otherwise return false.\n */"
        },
        {
            "identifier": "HEX_DIGITS",
            "parameters": "",
            "modifiers": "",
            "return": "bytes16",
            "body": "bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";",
            "start": "16",
            "end": "16",
            "class": "Strings",
            "signature": "bytes16 HEX_DIGITS",
            "full_signature": "bytes16 private constant HEX_DIGITS",
            "class_method_signature": "Strings.HEX_DIGITS",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant `HEX_DIGITS` that stores the hexadecimal digits as a bytes16 value.\n * The constant is used for hexadecimal encoding or decoding operations.\n */"
        },
        {
            "identifier": "tryParseUint",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 value)",
            "body": "function tryParseUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseUintUncheckedBounds(input, begin, end);\n    }",
            "start": "170",
            "end": "177",
            "class": "Strings",
            "signature": "returns (bool success, uint256 value) tryParseUintstring memory input, uint256 begin, uint256 end",
            "full_signature": "function tryParseUint(string memory input, uint256 begin, uint256 end) internal  pure returns (bool success, uint256 value)",
            "class_method_signature": "Strings.tryParseUintstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a substring of a string into a uint256 value.\n *\n * @param input The input string to parse.\n * @param begin The starting index of the substring to parse.\n * @param end The ending index of the substring to parse.\n *\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed uint256 value if successful, otherwise 0.\n *\n * Steps:\n * 1. Check if the provided `end` index is out of bounds or if `begin` is greater than `end`.\n * 2. If either condition is true, return `false` and `0`.\n * 3. Otherwise, call the internal `_tryParseUintUncheckedBounds` function to parse the substring.\n */"
        },
        {
            "identifier": "_tryParseUintUncheckedBounds",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 value)",
            "body": "function _tryParseUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        uint256 result = 0;\n        for (uint256 i = begin; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 9) return (false, 0);\n            result *= 10;\n            result += chr;\n        }\n        return (true, result);\n    }",
            "start": "183",
            "end": "198",
            "class": "Strings",
            "signature": "returns (bool success, uint256 value) _tryParseUintUncheckedBoundsstring memory input, uint256 begin, uint256 end",
            "full_signature": "function _tryParseUintUncheckedBounds(string memory input, uint256 begin, uint256 end) private  pure returns (bool success, uint256 value)",
            "class_method_signature": "Strings._tryParseUintUncheckedBoundsstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a substring of a string into an unsigned integer without checking bounds.\n *\n * @param input The input string to parse.\n * @param begin The starting index of the substring to parse.\n * @param end The ending index of the substring to parse.\n *\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed unsigned integer value if successful, otherwise 0.\n *\n * Steps:\n * 1. Convert the input string into a byte array.\n * 2. Initialize a result variable to store the parsed integer.\n * 3. Iterate over the specified substring range.\n * 4. For each character, attempt to parse it into a digit (0-9).\n * 5. If a character is not a digit, return `false` and `0`.\n * 6. Multiply the current result by 10 and add the parsed digit.\n * 7. Return `true` and the parsed integer if all characters are valid digits.\n */"
        },
        {
            "identifier": "tryParseInt",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, int256 value)",
            "body": "function tryParseInt(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, int256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseIntUncheckedBounds(input, begin, end);\n    }",
            "start": "243",
            "end": "250",
            "class": "Strings",
            "signature": "returns (bool success, int256 value) tryParseIntstring memory input, uint256 begin, uint256 end",
            "full_signature": "function tryParseInt(string memory input, uint256 begin, uint256 end) internal  pure returns (bool success, int256 value)",
            "class_method_signature": "Strings.tryParseIntstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to parse an integer from a substring of the input string.\n *\n * @param input The input string from which to parse the integer.\n * @param begin The starting index of the substring to parse.\n * @param end The ending index of the substring to parse.\n *\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed integer value if successful, otherwise 0.\n *\n * Steps:\n * 1. Check if the provided indices are out of bounds or invalid.\n * 2. If invalid, return `false` and `0`.\n * 3. Otherwise, call the internal `_tryParseIntUncheckedBounds` function to parse the integer.\n */"
        },
        {
            "identifier": "StringsInvalidAddressFormat",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error StringsInvalidAddressFormat();",
            "start": "32",
            "end": "32",
            "class": "Strings",
            "signature": " StringsInvalidAddressFormat",
            "full_signature": "function StringsInvalidAddressFormat()",
            "class_method_signature": "Strings.StringsInvalidAddressFormat",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the provided address string format is invalid.\n */"
        },
        {
            "identifier": "tryParseUint",
            "parameters": "string memory input",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 value)",
            "body": "function tryParseUint(string memory input) internal pure returns (bool success, uint256 value) {\n        return _tryParseUintUncheckedBounds(input, 0, bytes(input).length);\n    }",
            "start": "160",
            "end": "162",
            "class": "Strings",
            "signature": "returns (bool success, uint256 value) tryParseUintstring memory input",
            "full_signature": "function tryParseUint(string memory input) internal  pure returns (bool success, uint256 value)",
            "class_method_signature": "Strings.tryParseUintstring memory input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a string into an unsigned integer (uint256).\n * \n * @param input The string to be parsed.\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed unsigned integer value if successful, otherwise 0.\n * \n * Internally calls `_tryParseUintUncheckedBounds` with the input string, starting index 0, and the length of the input string.\n */"
        },
        {
            "identifier": "tryParseInt",
            "parameters": "string memory input",
            "modifiers": "pure",
            "return": "returns (bool success, int256 value)",
            "body": "function tryParseInt(string memory input) internal pure returns (bool success, int256 value) {\n        return _tryParseIntUncheckedBounds(input, 0, bytes(input).length);\n    }",
            "start": "231",
            "end": "233",
            "class": "Strings",
            "signature": "returns (bool success, int256 value) tryParseIntstring memory input",
            "full_signature": "function tryParseInt(string memory input) internal  pure returns (bool success, int256 value)",
            "class_method_signature": "Strings.tryParseIntstring memory input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a string into an integer.\n * @dev This function is internal and pure, meaning it does not modify the state and can only be called internally.\n * @param input The string to be parsed into an integer.\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed integer value if successful, otherwise undefined.\n */"
        },
        {
            "identifier": "_tryParseChr",
            "parameters": "bytes1 chr",
            "modifiers": "pure",
            "return": "returns (uint8)",
            "body": "function _tryParseChr(bytes1 chr) private pure returns (uint8) {\n        uint8 value = uint8(chr);\n\n        // Try to parse `chr`:\n        // - Case 1: [0-9]\n        // - Case 2: [a-f]\n        // - Case 3: [A-F]\n        // - otherwise not supported\n        unchecked {\n            if (value > 47 && value < 58) value -= 48;\n            else if (value > 96 && value < 103) value -= 87;\n            else if (value > 64 && value < 71) value -= 55;\n            else return type(uint8).max;\n        }\n\n        return value;\n    }",
            "start": "411",
            "end": "427",
            "class": "Strings",
            "signature": "returns (uint8) _tryParseChrbytes1 chr",
            "full_signature": "function _tryParseChr(bytes1 chr) private  pure returns (uint8)",
            "class_method_signature": "Strings._tryParseChrbytes1 chr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "{'function max(int256 a, int256 b) internal  pure returns (int256)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a single byte character into its corresponding hexadecimal value.\n * \n * The function handles three cases:\n * 1. If the character is a digit (0-9), it returns the corresponding integer value.\n * 2. If the character is a lowercase letter (a-f), it returns the corresponding hexadecimal value.\n * 3. If the character is an uppercase letter (A-F), it returns the corresponding hexadecimal value.\n * \n * If the character does not fall into any of the above categories, the function returns the maximum value of uint8 (255).\n * \n * @param chr The byte character to be parsed.\n * @return The parsed hexadecimal value as a uint8, or type(uint8).max if the character is not supported.\n */"
        },
        {
            "identifier": "StringsInvalidChar",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error StringsInvalidChar();",
            "start": "27",
            "end": "27",
            "class": "Strings",
            "signature": " StringsInvalidChar",
            "full_signature": "function StringsInvalidChar()",
            "class_method_signature": "Strings.StringsInvalidChar",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that an invalid character was encountered in a string operation.\n */"
        },
        {
            "identifier": "StringsInsufficientHexLength",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error StringsInsufficientHexLength(uint256 value, uint256 length);",
            "start": "22",
            "end": "22",
            "class": "Strings",
            "signature": " StringsInsufficientHexLength",
            "full_signature": "function StringsInsufficientHexLength()",
            "class_method_signature": "Strings.StringsInsufficientHexLength",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the provided hexadecimal string length is insufficient.\n * @param value The value that was provided.\n * @param length The required length for the hexadecimal string.\n */"
        },
        {
            "identifier": "ABS_MIN_INT256",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant ABS_MIN_INT256 = 2 ** 255;",
            "start": "235",
            "end": "235",
            "class": "Strings",
            "signature": "uint256 ABS_MIN_INT256",
            "full_signature": "uint256 private constant ABS_MIN_INT256",
            "class_method_signature": "Strings.ABS_MIN_INT256",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the absolute minimum value of a signed 256-bit integer.\n * This value is calculated as 2^255, which is the smallest possible value for a signed 256-bit integer.\n */"
        },
        {
            "identifier": "_unsafeReadBytesOffset",
            "parameters": "bytes memory buffer, uint256 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 value)",
            "body": "function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private pure returns (bytes32 value) {\n        // This is not memory safe in the general case, but all calls to this private function are within bounds.\n        assembly (\"memory-safe\") {\n            value := mload(add(buffer, add(0x20, offset)))\n        }\n    }",
            "start": "435",
            "end": "440",
            "class": "Strings",
            "signature": "returns (bytes32 value) _unsafeReadBytesOffsetbytes memory buffer, uint256 offset",
            "full_signature": "function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private  pure returns (bytes32 value)",
            "class_method_signature": "Strings._unsafeReadBytesOffsetbytes memory buffer, uint256 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Reads a bytes32 value from a specific offset within a bytes memory buffer.\n * @dev This function is marked as \"memory-safe\" in assembly, but it is not memory safe in the general case.\n *      It assumes that all calls to this function are within bounds.\n * @param buffer The bytes memory buffer from which to read the value.\n * @param offset The offset within the buffer to read the value from.\n * @return value The bytes32 value read from the specified offset in the buffer.\n */"
        },
        {
            "identifier": "_tryParseHexUintUncheckedBounds",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 value)",
            "body": "function _tryParseHexUintUncheckedBounds(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) private pure returns (bool success, uint256 value) {\n        bytes memory buffer = bytes(input);\n\n        // skip 0x prefix if present\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(buffer, begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 offset = hasPrefix.toUint() * 2;\n\n        uint256 result = 0;\n        for (uint256 i = begin + offset; i < end; ++i) {\n            uint8 chr = _tryParseChr(bytes1(_unsafeReadBytesOffset(buffer, i)));\n            if (chr > 15) return (false, 0);\n            result *= 16;\n            unchecked {\n                // Multiplying by 16 is equivalent to a shift of 4 bits (with additional overflow check).\n                // This guaratees that adding a value < 16 will not cause an overflow, hence the unchecked.\n                result += chr;\n            }\n        }\n        return (true, result);\n    }",
            "start": "331",
            "end": "354",
            "class": "Strings",
            "signature": "returns (bool success, uint256 value) _tryParseHexUintUncheckedBoundsstring memory input, uint256 begin, uint256 end",
            "full_signature": "function _tryParseHexUintUncheckedBounds(string memory input, uint256 begin, uint256 end) private  pure returns (bool success, uint256 value)",
            "class_method_signature": "Strings._tryParseHexUintUncheckedBoundsstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a hexadecimal string into a uint256 value within specified bounds.\n *\n * Steps:\n * 1. Convert the input string into a byte array for easier manipulation.\n * 2. Check if the input string has a \"0x\" prefix and adjust the starting index accordingly.\n * 3. Initialize a result variable to store the parsed value.\n * 4. Iterate through the byte array, starting from the adjusted index, and parse each character.\n * 5. If any character is not a valid hexadecimal digit, return `false` and `0`.\n * 6. Multiply the result by 16 (equivalent to a left shift by 4 bits) and add the parsed digit.\n * 7. Use `unchecked` to avoid overflow checks since the multiplication and addition are safe within the bounds.\n * 8. Return `true` and the parsed value if the entire string is successfully parsed.\n */"
        },
        {
            "identifier": "ADDRESS_LENGTH",
            "parameters": "",
            "modifiers": "",
            "return": "uint8",
            "body": "uint8 private constant ADDRESS_LENGTH = 20;",
            "start": "17",
            "end": "17",
            "class": "Strings",
            "signature": "uint8 ADDRESS_LENGTH",
            "full_signature": "uint8 private constant ADDRESS_LENGTH",
            "class_method_signature": "Strings.ADDRESS_LENGTH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant variable representing the length of an Ethereum address in bytes.\n * @dev Ethereum addresses are 20 bytes long, so this constant is set to 20.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/cryptography/P256.sol": [
        {
            "identifier": "_affineFromJacobian",
            "parameters": "uint256 jx, uint256 jy, uint256 jz",
            "modifiers": "view",
            "return": "returns (uint256 ax, uint256 ay)",
            "body": "function _affineFromJacobian(uint256 jx, uint256 jy, uint256 jz) private view returns (uint256 ax, uint256 ay) {\n        if (jz == 0) return (0, 0);\n        uint256 p = P; // cache P on the stack\n        uint256 zinv = Math.invModPrime(jz, p);\n        assembly (\"memory-safe\") {\n            let zzinv := mulmod(zinv, zinv, p)\n            ax := mulmod(jx, zzinv, p)\n            ay := mulmod(jy, mulmod(zzinv, zinv, p), p)\n        }\n    }",
            "start": "175",
            "end": "184",
            "class": "P256",
            "signature": "returns (uint256 ax, uint256 ay) _affineFromJacobianuint256 jx, uint256 jy, uint256 jz",
            "full_signature": "function _affineFromJacobian(uint256 jx, uint256 jy, uint256 jz) private  view returns (uint256 ax, uint256 ay)",
            "class_method_signature": "P256._affineFromJacobianuint256 jx, uint256 jy, uint256 jz",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "{'function invModPrime(uint256 a, uint256 p) internal  view returns (uint256)', 'function invMod(uint256 a, uint256 n) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Converts a point from Jacobian coordinates to affine coordinates.\n *\n * Steps:\n * 1. Check if the z-coordinate (jz) is zero. If so, return (0, 0) as the affine coordinates.\n * 2. Cache the prime number P on the stack.\n * 3. Calculate the modular inverse of the z-coordinate (jz) using Math.invModPrime.\n * 4. Use assembly to perform efficient modular arithmetic:\n *    - Compute zzinv as the square of zinv modulo p.\n *    - Compute ax as jx multiplied by zzinv modulo p.\n *    - Compute ay as jy multiplied by zzinv multiplied by zinv modulo p.\n * 5. Return the computed affine coordinates (ax, ay).\n */"
        },
        {
            "identifier": "verifyNative",
            "parameters": "bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function verifyNative(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal view returns (bool) {\n        (bool valid, bool supported) = _tryVerifyNative(h, r, s, qx, qy);\n        if (supported) {\n            return valid;\n        } else {\n            revert Errors.MissingPrecompile(address(0x100));\n        }\n    }",
            "start": "72",
            "end": "79",
            "class": "P256",
            "signature": "returns (bool) verifyNativebytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "full_signature": "function verifyNative(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal  view returns (bool)",
            "class_method_signature": "P256.verifyNativebytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "{'function MissingPrecompile()'}",
            "human_labeled_comment": "/**\n * @notice Verifies a native signature using the provided parameters.\n *\n * Steps:\n * 1. Calls `_tryVerifyNative` with the provided hash (`h`), signature components (`r`, `s`), and public key coordinates (`qx`, `qy`).\n * 2. Checks if the precompile is supported.\n * 3. If supported, returns the validity of the signature.\n * 4. If not supported, reverts with an error indicating the missing precompile at address `0x100`.\n */"
        },
        {
            "identifier": "_jDouble",
            "parameters": "uint256 x, uint256 y, uint256 z",
            "modifiers": "pure",
            "return": "returns (uint256 rx, uint256 ry, uint256 rz)",
            "body": "function _jDouble(uint256 x, uint256 y, uint256 z) private pure returns (uint256 rx, uint256 ry, uint256 rz) {\n        assembly (\"memory-safe\") {\n            let p := P\n            let yy := mulmod(y, y, p)\n            let zz := mulmod(z, z, p)\n            let m := addmod(mulmod(3, mulmod(x, x, p), p), mulmod(A, mulmod(zz, zz, p), p), p) // m = 3*x\u00b2+a*z\u2074\n            let s := mulmod(4, mulmod(x, yy, p), p) // s = 4*x*y\u00b2\n\n            // x' = t = m\u00b2-2*s\n            rx := addmod(mulmod(m, m, p), sub(p, mulmod(2, s, p)), p)\n            // y' = m*(s-t)-8*y\u2074 = m*(s-x')-8*y\u2074\n            ry := addmod(mulmod(m, addmod(s, sub(p, rx), p), p), sub(p, mulmod(8, mulmod(yy, yy, p), p)), p)\n            // z' = 2*y*z\n            rz := mulmod(2, mulmod(y, z, p), p)\n        }\n    }",
            "start": "262",
            "end": "277",
            "class": "P256",
            "signature": "returns (uint256 rx, uint256 ry, uint256 rz) _jDoubleuint256 x, uint256 y, uint256 z",
            "full_signature": "function _jDouble(uint256 x, uint256 y, uint256 z) private  pure returns (uint256 rx, uint256 ry, uint256 rz)",
            "class_method_signature": "P256._jDoubleuint256 x, uint256 y, uint256 z",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a Jacobian doubling operation on elliptic curve points.\n *\n * @param x The x-coordinate of the point.\n * @param y The y-coordinate of the point.\n * @param z The z-coordinate of the point.\n *\n * @return rx The resulting x-coordinate after doubling.\n * @return ry The resulting y-coordinate after doubling.\n * @return rz The resulting z-coordinate after doubling.\n *\n * Steps:\n * 1. Compute intermediate values:\n *    - `yy` as the square of `y` modulo `p`.\n *    - `zz` as the square of `z` modulo `p`.\n *    - `m` as `3*x\u00b2 + a*z\u2074` modulo `p`.\n *    - `s` as `4*x*y\u00b2` modulo `p`.\n *\n * 2. Calculate the resulting coordinates:\n *    - `rx` as `m\u00b2 - 2*s` modulo `p`.\n *    - `ry` as `m*(s - rx) - 8*y\u2074` modulo `p`.\n *    - `rz` as `2*y*z` modulo `p`.\n *\n * The function uses inline assembly for efficient computation.\n */"
        },
        {
            "identifier": "_jMultShamir",
            "parameters": "JPoint[16] memory points, uint256 u1, uint256 u2",
            "modifiers": "view",
            "return": "returns (uint256 rx, uint256 ry)",
            "body": "function _jMultShamir(\n        JPoint[16] memory points,\n        uint256 u1,\n        uint256 u2\n    ) private view returns (uint256 rx, uint256 ry) {\n        uint256 x = 0;\n        uint256 y = 0;\n        uint256 z = 0;\n        unchecked {\n            for (uint256 i = 0; i < 128; ++i) {\n                if (z > 0) {\n                    (x, y, z) = _jDouble(x, y, z);\n                    (x, y, z) = _jDouble(x, y, z);\n                }\n                // Read 2 bits of u1, and 2 bits of u2. Combining the two gives the lookup index in the table.\n                uint256 pos = ((u1 >> 252) & 0xc) | ((u2 >> 254) & 0x3);\n                // Points that have z = 0 are points at infinity. They are the additive 0 of the group\n                // - if the lookup point is a 0, we can skip it\n                // - otherwise:\n                //   - if the current point (x, y, z) is 0, we use the lookup point as our new value (0+P=P)\n                //   - if the current point (x, y, z) is not 0, both points are valid and we can use `_jAdd`\n                if (points[pos].z != 0) {\n                    if (z == 0) {\n                        (x, y, z) = (points[pos].x, points[pos].y, points[pos].z);\n                    } else {\n                        (x, y, z) = _jAdd(points[pos], x, y, z);\n                    }\n                }\n                u1 <<= 2;\n                u2 <<= 2;\n            }\n        }\n        return _affineFromJacobian(x, y, z);\n    }",
            "start": "289",
            "end": "322",
            "class": "P256",
            "signature": "returns (uint256 rx, uint256 ry) _jMultShamirJPoint[16] memory points, uint256 u1, uint256 u2",
            "full_signature": "function _jMultShamir(JPoint[16] memory points, uint256 u1, uint256 u2) private  view returns (uint256 rx, uint256 ry)",
            "class_method_signature": "P256._jMultShamirJPoint[16] memory points, uint256 u1, uint256 u2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a Jacobian multiplication using Shamir's trick for elliptic curve points.\n *\n * @param points An array of 16 precomputed Jacobian points.\n * @param u1 A 256-bit scalar value used for the multiplication.\n * @param u2 A 256-bit scalar value used for the multiplication.\n *\n * Steps:\n * 1. Initialize variables `x`, `y`, and `z` to 0.\n * 2. Iterate over 128 steps to process the scalar values `u1` and `u2`:\n *    - If `z` is greater than 0, perform a double operation on the current point twice.\n *    - Extract 2 bits from `u1` and 2 bits from `u2` to determine the lookup index in the `points` array.\n *    - If the lookup point is not at infinity (i.e., `z != 0`):\n *      - If the current point is at infinity (`z == 0`), set the current point to the lookup point.\n *      - Otherwise, add the lookup point to the current point using Jacobian addition.\n *    - Shift `u1` and `u2` left by 2 bits for the next iteration.\n * 3. Convert the final Jacobian point to affine coordinates and return the result.\n *\n * @return rx The x-coordinate of the resulting affine point.\n * @return ry The y-coordinate of the resulting affine point.\n */"
        },
        {
            "identifier": "JPoint",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct JPoint {\n        uint256 x;\n        uint256 y;\n        uint256 z;\n    }",
            "start": "22",
            "end": "26",
            "class": "P256",
            "signature": " JPoint",
            "full_signature": "function JPoint()",
            "class_method_signature": "P256.JPoint",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `JPoint` with three unsigned integer fields: `x`, `y`, and `z`.\n * This struct can be used to represent a point in 3D space or any other context requiring three numerical values.\n */"
        },
        {
            "identifier": "A",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant A = 0xFFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC;",
            "start": "37",
            "end": "37",
            "class": "P256",
            "signature": "uint256 A",
            "full_signature": "uint256 internal constant A",
            "class_method_signature": "P256.A",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice An internal constant representing a specific 256-bit value.\n * The value is a hexadecimal constant used for cryptographic or mathematical operations.\n */"
        },
        {
            "identifier": "P1DIV4",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant P1DIV4 = 0x3fffffffc0000000400000000000000000000000400000000000000000000000;",
            "start": "42",
            "end": "42",
            "class": "P256",
            "signature": "uint256 P1DIV4",
            "full_signature": "uint256 private constant P1DIV4",
            "class_method_signature": "P256.P1DIV4",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a specific 256-bit value.\n * The value is defined as `0x3fffffffc0000000400000000000000000000000400000000000000000000000`.\n * This constant is likely used for mathematical operations or as a specific configuration value.\n */"
        },
        {
            "identifier": "isValidPublicKey",
            "parameters": "bytes32 x, bytes32 y",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isValidPublicKey(bytes32 x, bytes32 y) internal pure returns (bool result) {\n        assembly (\"memory-safe\") {\n            let p := P\n            let lhs := mulmod(y, y, p) // y^2\n            let rhs := addmod(mulmod(addmod(mulmod(x, x, p), A, p), x, p), B, p) // ((x^2 + a) * x) + b = x^3 + ax + b\n            result := and(and(lt(x, p), lt(y, p)), eq(lhs, rhs)) // Should conform with the Weierstrass equation\n        }\n    }",
            "start": "150",
            "end": "157",
            "class": "P256",
            "signature": "returns (bool result) isValidPublicKeybytes32 x, bytes32 y",
            "full_signature": "function isValidPublicKey(bytes32 x, bytes32 y) internal  pure returns (bool result)",
            "class_method_signature": "P256.isValidPublicKeybytes32 x, bytes32 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the given public key coordinates (x, y) are valid on the elliptic curve.\n *\n * Steps:\n * 1. Load the prime modulus `p` of the elliptic curve.\n * 2. Compute the left-hand side (LHS) of the Weierstrass equation: `y^2 mod p`.\n * 3. Compute the right-hand side (RHS) of the Weierstrass equation: `(x^3 + a*x + b) mod p`, where `a` and `b` are curve parameters.\n * 4. Ensure that both `x` and `y` are less than the prime modulus `p`.\n * 5. Check if the LHS equals the RHS, confirming the point lies on the curve.\n * 6. Return `true` if the point is valid, otherwise `false`.\n */"
        },
        {
            "identifier": "_jDoublePoint",
            "parameters": "JPoint memory p",
            "modifiers": "pure",
            "return": "returns (JPoint memory)",
            "body": "function _jDoublePoint(JPoint memory p) private pure returns (JPoint memory) {\n        (uint256 x, uint256 y, uint256 z) = _jDouble(p.x, p.y, p.z);\n        return JPoint(x, y, z);\n    }",
            "start": "366",
            "end": "369",
            "class": "P256",
            "signature": "returns (JPoint memory) _jDoublePointJPoint memory p",
            "full_signature": "function _jDoublePoint(JPoint memory p) private  pure returns (JPoint memory)",
            "class_method_signature": "P256._jDoublePointJPoint memory p",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Doubles a Jacobian point (x, y, z) and returns the result as a new Jacobian point.\n *\n * @param p The Jacobian point to double.\n * @return A new Jacobian point representing the result of the doubling operation.\n */"
        },
        {
            "identifier": "_tryVerifyNative",
            "parameters": "bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "modifiers": "view",
            "return": "returns (bool valid, bool supported)",
            "body": "function _tryVerifyNative(\n        bytes32 h,\n        bytes32 r,\n        bytes32 s,\n        bytes32 qx,\n        bytes32 qy\n    ) private view returns (bool valid, bool supported) {\n        if (!_isProperSignature(r, s) || !isValidPublicKey(qx, qy)) {\n            return (false, true); // signature is invalid, and its not because the precompile is missing\n        }\n\n        (bool success, bytes memory returndata) = address(0x100).staticcall(abi.encode(h, r, s, qx, qy));\n        return (success && returndata.length == 0x20) ? (abi.decode(returndata, (bool)), true) : (false, false);\n    }",
            "start": "84",
            "end": "97",
            "class": "P256",
            "signature": "returns (bool valid, bool supported) _tryVerifyNativebytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "full_signature": "function _tryVerifyNative(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) private  view returns (bool valid, bool supported)",
            "class_method_signature": "P256._tryVerifyNativebytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to verify a native signature using the provided parameters.\n *\n * @param h The hash of the message to be verified.\n * @param r The r component of the signature.\n * @param s The s component of the signature.\n * @param qx The x-coordinate of the public key.\n * @param qy The y-coordinate of the public key.\n *\n * @return valid A boolean indicating whether the signature is valid.\n * @return supported A boolean indicating whether the signature verification is supported.\n *\n * Steps:\n * 1. Check if the signature components (r, s) are valid and if the public key (qx, qy) is valid.\n * 2. If either check fails, return (false, true) indicating the signature is invalid but the precompile is supported.\n * 3. Otherwise, perform a static call to the native precompile at address 0x100 with the encoded parameters.\n * 4. If the call is successful and the return data length is 0x20, decode the result and return (valid, true).\n * 5. If the call fails or the return data length is not 0x20, return (false, false) indicating the signature is invalid and the precompile is not supported.\n */"
        },
        {
            "identifier": "HALF_N",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant HALF_N = 0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8;",
            "start": "45",
            "end": "45",
            "class": "P256",
            "signature": "uint256 HALF_N",
            "full_signature": "uint256 private constant HALF_N",
            "class_method_signature": "P256.HALF_N",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant variable `HALF_N` representing a large 256-bit integer value.\n * This value is likely used for cryptographic or mathematical operations within the contract.\n */"
        },
        {
            "identifier": "_jAdd",
            "parameters": "JPoint memory p1, uint256 x2, uint256 y2, uint256 z2",
            "modifiers": "pure",
            "return": "returns (uint256 rx, uint256 ry, uint256 rz)",
            "body": "function _jAdd(\n        JPoint memory p1,\n        uint256 x2,\n        uint256 y2,\n        uint256 z2\n    ) private pure returns (uint256 rx, uint256 ry, uint256 rz) {\n        assembly (\"memory-safe\") {\n            let p := P\n            let z1 := mload(add(p1, 0x40))\n            let zz1 := mulmod(z1, z1, p) // zz1 = z1\u00b2\n            let s1 := mulmod(mload(add(p1, 0x20)), mulmod(mulmod(z2, z2, p), z2, p), p) // s1 = y1*z2\u00b3\n            let r := addmod(mulmod(y2, mulmod(zz1, z1, p), p), sub(p, s1), p) // r = s2-s1 = y2*z1\u00b3-s1 = y2*z1\u00b3-y1*z2\u00b3\n            let u1 := mulmod(mload(p1), mulmod(z2, z2, p), p) // u1 = x1*z2\u00b2\n            let h := addmod(mulmod(x2, zz1, p), sub(p, u1), p) // h = u2-u1 = x2*z1\u00b2-u1 = x2*z1\u00b2-x1*z2\u00b2\n\n            // detect edge cases where inputs are identical\n            switch and(iszero(r), iszero(h))\n            // case 0: points are different\n            case 0 {\n                let hh := mulmod(h, h, p) // h\u00b2\n\n                // x' = r\u00b2-h\u00b3-2*u1*h\u00b2\n                rx := addmod(\n                    addmod(mulmod(r, r, p), sub(p, mulmod(h, hh, p)), p),\n                    sub(p, mulmod(2, mulmod(u1, hh, p), p)),\n                    p\n                )\n                // y' = r*(u1*h\u00b2-x')-s1*h\u00b3\n                ry := addmod(\n                    mulmod(r, addmod(mulmod(u1, hh, p), sub(p, rx), p), p),\n                    sub(p, mulmod(s1, mulmod(h, hh, p), p)),\n                    p\n                )\n                // z' = h*z1*z2\n                rz := mulmod(h, mulmod(z1, z2, p), p)\n            }\n            // case 1: points are equal\n            case 1 {\n                let x := x2\n                let y := y2\n                let z := z2\n                let yy := mulmod(y, y, p)\n                let zz := mulmod(z, z, p)\n                let m := addmod(mulmod(3, mulmod(x, x, p), p), mulmod(A, mulmod(zz, zz, p), p), p) // m = 3*x\u00b2+a*z\u2074\n                let s := mulmod(4, mulmod(x, yy, p), p) // s = 4*x*y\u00b2\n\n                // x' = t = m\u00b2-2*s\n                rx := addmod(mulmod(m, m, p), sub(p, mulmod(2, s, p)), p)\n\n                // y' = m*(s-t)-8*y\u2074 = m*(s-x')-8*y\u2074\n                // cut the computation to avoid stack too deep\n                let rytmp1 := sub(p, mulmod(8, mulmod(yy, yy, p), p)) // -8*y\u2074\n                let rytmp2 := addmod(s, sub(p, rx), p) // s-x'\n                ry := addmod(mulmod(m, rytmp2, p), rytmp1, p) // m*(s-x')-8*y\u2074\n\n                // z' = 2*y*z\n                rz := mulmod(2, mulmod(y, z, p), p)\n            }\n        }\n    }",
            "start": "197",
            "end": "256",
            "class": "P256",
            "signature": "returns (uint256 rx, uint256 ry, uint256 rz) _jAddJPoint memory p1, uint256 x2, uint256 y2, uint256 z2",
            "full_signature": "function _jAdd(JPoint memory p1, uint256 x2, uint256 y2, uint256 z2) private  pure returns (uint256 rx, uint256 ry, uint256 rz)",
            "class_method_signature": "P256._jAddJPoint memory p1, uint256 x2, uint256 y2, uint256 z2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs Jacobian point addition on elliptic curve points.\n *\n * @param p1 The first Jacobian point (x1, y1, z1).\n * @param x2 The x-coordinate of the second point.\n * @param y2 The y-coordinate of the second point.\n * @param z2 The z-coordinate of the second point.\n *\n * @return rx The x-coordinate of the resulting point.\n * @return ry The y-coordinate of the resulting point.\n * @return rz The z-coordinate of the resulting point.\n *\n * Steps:\n * 1. Load the prime field modulus `p`.\n * 2. Compute intermediate values `zz1`, `s1`, `r`, `u1`, and `h` for point addition.\n * 3. Check if the points are identical or different.\n *\n * If points are different:\n * 4. Compute `hh` (h\u00b2).\n * 5. Calculate the resulting x-coordinate `rx` using the formula: r\u00b2 - h\u00b3 - 2*u1*h\u00b2.\n * 6. Calculate the resulting y-coordinate `ry` using the formula: r*(u1*h\u00b2 - rx) - s1*h\u00b3.\n * 7. Calculate the resulting z-coordinate `rz` using the formula: h*z1*z2.\n *\n * If points are identical (doubling):\n * 8. Compute intermediate values `yy`, `zz`, `m`, and `s` for point doubling.\n * 9. Calculate the resulting x-coordinate `rx` using the formula: m\u00b2 - 2*s.\n * 10. Calculate the resulting y-coordinate `ry` using the formula: m*(s - rx) - 8*y\u2074.\n * 11. Calculate the resulting z-coordinate `rz` using the formula: 2*y*z.\n */"
        },
        {
            "identifier": "_jAddPoint",
            "parameters": "JPoint memory p1, JPoint memory p2",
            "modifiers": "pure",
            "return": "returns (JPoint memory)",
            "body": "function _jAddPoint(JPoint memory p1, JPoint memory p2) private pure returns (JPoint memory) {\n        (uint256 x, uint256 y, uint256 z) = _jAdd(p1, p2.x, p2.y, p2.z);\n        return JPoint(x, y, z);\n    }",
            "start": "361",
            "end": "364",
            "class": "P256",
            "signature": "returns (JPoint memory) _jAddPointJPoint memory p1, JPoint memory p2",
            "full_signature": "function _jAddPoint(JPoint memory p1, JPoint memory p2) private  pure returns (JPoint memory)",
            "class_method_signature": "P256._jAddPointJPoint memory p1, JPoint memory p2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Adds two Jacobian points (p1 and p2) and returns the resulting Jacobian point.\n *\n * Steps:\n * 1. Calls the internal `_jAdd` function with the coordinates of p1 and p2.\n * 2. Returns a new JPoint struct with the resulting x, y, and z coordinates.\n */"
        },
        {
            "identifier": "_isProperSignature",
            "parameters": "bytes32 r, bytes32 s",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function _isProperSignature(bytes32 r, bytes32 s) private pure returns (bool) {\n        return uint256(r) > 0 && uint256(r) < N && uint256(s) > 0 && uint256(s) <= HALF_N;\n    }",
            "start": "163",
            "end": "165",
            "class": "P256",
            "signature": "returns (bool) _isProperSignaturebytes32 r, bytes32 s",
            "full_signature": "function _isProperSignature(bytes32 r, bytes32 s) private  pure returns (bool)",
            "class_method_signature": "P256._isProperSignaturebytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the provided signature components (r, s) are valid for ECDSA.\n *\n * @param r The r component of the ECDSA signature.\n * @param s The s component of the ECDSA signature.\n * @return bool Returns true if the signature components are within valid bounds, otherwise false.\n *\n * Conditions:\n * 1. `r` must be greater than 0 and less than the curve order `N`.\n * 2. `s` must be greater than 0 and less than or equal to half of the curve order `HALF_N`.\n */"
        },
        {
            "identifier": "GX",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant GX = 0x6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296;",
            "start": "29",
            "end": "29",
            "class": "P256",
            "signature": "uint256 GX",
            "full_signature": "uint256 internal constant GX",
            "class_method_signature": "P256.GX",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the x-coordinate of the generator point on the elliptic curve.\n *         This value is used in cryptographic operations, particularly in elliptic curve cryptography.\n *         The value is a 256-bit unsigned integer in hexadecimal format.\n */"
        },
        {
            "identifier": "GY",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant GY = 0x4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5;",
            "start": "31",
            "end": "31",
            "class": "P256",
            "signature": "uint256 GY",
            "full_signature": "uint256 internal constant GY",
            "class_method_signature": "P256.GY",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant variable representing a 256-bit unsigned integer value.\n * The value is a fixed hexadecimal constant used for specific purposes in the contract.\n */"
        },
        {
            "identifier": "B",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant B = 0x5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B;",
            "start": "39",
            "end": "39",
            "class": "P256",
            "signature": "uint256 B",
            "full_signature": "uint256 internal constant B",
            "class_method_signature": "P256.B",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant variable `B` representing a 256-bit hexadecimal value.\n * The value is a large constant used for cryptographic or mathematical operations.\n * The specific use case depends on the context of the contract.\n */"
        },
        {
            "identifier": "_preComputeJacobianPoints",
            "parameters": "uint256 px, uint256 py",
            "modifiers": "pure",
            "return": "returns (JPoint[16] memory points)",
            "body": "function _preComputeJacobianPoints(uint256 px, uint256 py) private pure returns (JPoint[16] memory points) {\n        points[0x00] = JPoint(0, 0, 0); // 0,0\n        points[0x01] = JPoint(px, py, 1); // 1,0 (p)\n        points[0x04] = JPoint(GX, GY, 1); // 0,1 (g)\n        points[0x02] = _jDoublePoint(points[0x01]); // 2,0 (2p)\n        points[0x08] = _jDoublePoint(points[0x04]); // 0,2 (2g)\n        points[0x03] = _jAddPoint(points[0x01], points[0x02]); // 3,0 (p+2p = 3p)\n        points[0x05] = _jAddPoint(points[0x01], points[0x04]); // 1,1 (p+g)\n        points[0x06] = _jAddPoint(points[0x02], points[0x04]); // 2,1 (2p+g)\n        points[0x07] = _jAddPoint(points[0x03], points[0x04]); // 3,1 (3p+g)\n        points[0x09] = _jAddPoint(points[0x01], points[0x08]); // 1,2 (p+2g)\n        points[0x0a] = _jAddPoint(points[0x02], points[0x08]); // 2,2 (2p+2g)\n        points[0x0b] = _jAddPoint(points[0x03], points[0x08]); // 3,2 (3p+2g)\n        points[0x0c] = _jAddPoint(points[0x04], points[0x08]); // 0,3 (g+2g = 3g)\n        points[0x0d] = _jAddPoint(points[0x01], points[0x0c]); // 1,3 (p+3g)\n        points[0x0e] = _jAddPoint(points[0x02], points[0x0c]); // 2,3 (2p+3g)\n        points[0x0f] = _jAddPoint(points[0x03], points[0x0c]); // 3,3 (3p+3g)\n    }",
            "start": "342",
            "end": "359",
            "class": "P256",
            "signature": "returns (JPoint[16] memory points) _preComputeJacobianPointsuint256 px, uint256 py",
            "full_signature": "function _preComputeJacobianPoints(uint256 px, uint256 py) private  pure returns (JPoint[16] memory points)",
            "class_method_signature": "P256._preComputeJacobianPointsuint256 px, uint256 py",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Pre-computes Jacobian points for elliptic curve operations.\n *\n * Steps:\n * 1. Initialize an array of 16 JPoint structures.\n * 2. Set the first point (0x00) to the origin (0, 0, 0).\n * 3. Set the second point (0x01) to the input point (px, py, 1).\n * 4. Set the fourth point (0x04) to the generator point (GX, GY, 1).\n * 5. Compute the third point (0x02) by doubling the input point (2p).\n * 6. Compute the eighth point (0x08) by doubling the generator point (2g).\n * 7. Compute the fourth point (0x03) by adding the input point and its double (3p).\n * 8. Compute the fifth point (0x05) by adding the input point and the generator point (p+g).\n * 9. Compute the sixth point (0x06) by adding the doubled input point and the generator point (2p+g).\n * 10. Compute the seventh point (0x07) by adding the tripled input point and the generator point (3p+g).\n * 11. Compute the ninth point (0x09) by adding the input point and the doubled generator point (p+2g).\n * 12. Compute the tenth point (0x0a) by adding the doubled input point and the doubled generator point (2p+2g).\n * 13. Compute the eleventh point (0x0b) by adding the tripled input point and the doubled generator point (3p+2g).\n * 14. Compute the twelfth point (0x0c) by adding the generator point and its double (3g).\n * 15. Compute the thirteenth point (0x0d) by adding the input point and the tripled generator point (p+3g).\n * 16. Compute the fourteenth point (0x0e) by adding the doubled input point and the tripled generator point (2p+3g).\n * 17. Compute the fifteenth point (0x0f) by adding the tripled input point and the tripled generator point (3p+3g).\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/math/Math.sol": [
        {
            "identifier": "trySub",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 result)",
            "body": "function trySub(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }",
            "start": "34",
            "end": "39",
            "class": "Math",
            "signature": "returns (bool success, uint256 result) trySubuint256 a, uint256 b",
            "full_signature": "function trySub(uint256 a, uint256 b) internal  pure returns (bool success, uint256 result)",
            "class_method_signature": "Math.trySubuint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely subtracts two unsigned integers and returns a boolean indicating success or failure.\n * \n * Steps:\n * 1. Check if the second number `b` is greater than the first number `a`.\n * 2. If `b` is greater than `a`, return `false` and `0` to indicate subtraction would result in underflow.\n * 3. Otherwise, return `true` and the result of `a - b`.\n * \n * @param a The first unsigned integer (minuend).\n * @param b The second unsigned integer (subtrahend).\n * @return success A boolean indicating whether the subtraction was successful.\n * @return result The result of the subtraction if successful, otherwise `0`.\n */"
        },
        {
            "identifier": "average",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }",
            "start": "110",
            "end": "113",
            "class": "Math",
            "signature": "returns (uint256) averageuint256 a, uint256 b",
            "full_signature": "function average(uint256 a, uint256 b) internal  pure returns (uint256)",
            "class_method_signature": "Math.averageuint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the average of two unsigned integers without overflow.\n * @dev Uses bitwise operations to avoid overflow when summing `a` and `b`.\n * @param a The first unsigned integer.\n * @param b The second unsigned integer.\n * @return The average of `a` and `b`.\n */"
        },
        {
            "identifier": "tryAdd",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 result)",
            "body": "function tryAdd(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }",
            "start": "23",
            "end": "29",
            "class": "Math",
            "signature": "returns (bool success, uint256 result) tryAdduint256 a, uint256 b",
            "full_signature": "function tryAdd(uint256 a, uint256 b) internal  pure returns (bool success, uint256 result)",
            "class_method_signature": "Math.tryAdduint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely adds two unsigned integers and checks for overflow.\n *\n * Steps:\n * 1. Perform unchecked addition of `a` and `b` to get `c`.\n * 2. Check if `c` is less than `a` to detect overflow.\n * 3. If overflow is detected, return `false` and `0`.\n * 4. If no overflow, return `true` and the result of the addition `c`.\n */"
        },
        {
            "identifier": "invModPrime",
            "parameters": "uint256 a, uint256 p",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function invModPrime(uint256 a, uint256 p) internal view returns (uint256) {\n        unchecked {\n            return Math.modExp(a, p - 2, p);\n        }\n    }",
            "start": "300",
            "end": "304",
            "class": "Math",
            "signature": "returns (uint256) invModPrimeuint256 a, uint256 p",
            "full_signature": "function invModPrime(uint256 a, uint256 p) internal  view returns (uint256)",
            "class_method_signature": "Math.invModPrimeuint256 a, uint256 p",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Computes the modular inverse of `a` modulo a prime `p` using Fermat's Little Theorem.\n * \n * @param a The number for which the modular inverse is to be computed.\n * @param p The prime modulus.\n * @return The modular inverse of `a` modulo `p`.\n * \n * Steps:\n * 1. Use Fermat's Little Theorem, which states that `a^(p-1) \u2261 1 mod p` for a prime `p` and `a` not divisible by `p`.\n * 2. Therefore, the modular inverse of `a` is `a^(p-2) mod p`.\n * 3. Compute `a^(p-2) mod p` using the `modExp` function from the Math library.\n */"
        },
        {
            "identifier": "_zeroBytes",
            "parameters": "bytes memory byteArray",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function _zeroBytes(bytes memory byteArray) private pure returns (bool) {\n        for (uint256 i = 0; i < byteArray.length; ++i) {\n            if (byteArray[i] != 0) {\n                return false;\n            }\n        }\n        return true;\n    }",
            "start": "404",
            "end": "411",
            "class": "Math",
            "signature": "returns (bool) _zeroBytesbytes memory byteArray",
            "full_signature": "function _zeroBytes(bytes memory byteArray) private  pure returns (bool)",
            "class_method_signature": "Math._zeroBytesbytes memory byteArray",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a given byte array consists entirely of zero bytes.\n *\n * @param byteArray The byte array to be checked.\n * @return bool Returns true if all bytes in the array are zero, otherwise returns false.\n *\n * Steps:\n * 1. Iterate through each byte in the byte array.\n * 2. If any byte is not zero, return false.\n * 3. If all bytes are zero, return true.\n */"
        },
        {
            "identifier": "tryDiv",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 result)",
            "body": "function tryDiv(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }",
            "start": "59",
            "end": "64",
            "class": "Math",
            "signature": "returns (bool success, uint256 result) tryDivuint256 a, uint256 b",
            "full_signature": "function tryDiv(uint256 a, uint256 b) internal  pure returns (bool success, uint256 result)",
            "class_method_signature": "Math.tryDivuint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to divide two unsigned integers and returns the result along with a success flag.\n *\n * Steps:\n * 1. Check if the divisor `b` is zero.\n * 2. If `b` is zero, return `false` and `0` to indicate division by zero.\n * 3. Otherwise, perform the division and return `true` along with the result of `a / b`.\n *\n * @param a The dividend.\n * @param b The divisor.\n * @return success A boolean indicating whether the division was successful.\n * @return result The result of the division if successful, otherwise `0`.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/structs/Checkpoints.sol": [
        {
            "identifier": "_lowerBinaryLookup",
            "parameters": "Checkpoint160[] storage self, uint96 key, uint256 low, uint256 high",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _lowerBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }",
            "start": "601",
            "end": "616",
            "class": "Checkpoints",
            "signature": "returns (uint256) _lowerBinaryLookupCheckpoint160[] storage self, uint96 key, uint256 low, uint256 high",
            "full_signature": "function _lowerBinaryLookup(Checkpoint160[] storage self, uint96 key, uint256 low, uint256 high) private  view returns (uint256)",
            "class_method_signature": "Checkpoints._lowerBinaryLookupCheckpoint160[] storage self, uint96 key, uint256 low, uint256 high",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Performs a binary search to find the position of a key in a sorted array of Checkpoint160 structs.\n *\n * @param self The storage array of Checkpoint160 structs to search within.\n * @param key The key to search for.\n * @param low The lower bound of the search range.\n * @param high The upper bound of the search range.\n *\n * @return The index of the key in the array, or the position where it should be inserted to maintain order.\n *\n * Steps:\n * 1. While the lower bound is less than the upper bound:\n *    a. Calculate the midpoint of the current search range.\n *    b. Compare the key at the midpoint with the target key.\n *    c. Adjust the search range based on the comparison:\n *       - If the midpoint key is less than the target key, move the lower bound up.\n *       - Otherwise, move the upper bound down.\n * 2. Return the final position (high) where the key is found or should be inserted.\n */"
        },
        {
            "identifier": "_upperBinaryLookup",
            "parameters": "Checkpoint208[] storage self, uint48 key, uint256 low, uint256 high",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _upperBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }",
            "start": "374",
            "end": "389",
            "class": "Checkpoints",
            "signature": "returns (uint256) _upperBinaryLookupCheckpoint208[] storage self, uint48 key, uint256 low, uint256 high",
            "full_signature": "function _upperBinaryLookup(Checkpoint208[] storage self, uint48 key, uint256 low, uint256 high) private  view returns (uint256)",
            "class_method_signature": "Checkpoints._upperBinaryLookupCheckpoint208[] storage self, uint48 key, uint256 low, uint256 high",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a sorted array of Checkpoint208 structs.\n *\n * @param self The storage array of Checkpoint208 structs to search.\n * @param key The key to search for within the array.\n * @param low The lower bound index for the binary search.\n * @param high The upper bound index for the binary search.\n *\n * @return high The index of the first element in the array that is greater than the key.\n *\n * Steps:\n * 1. While the lower bound is less than the upper bound:\n *    a. Calculate the middle index.\n *    b. If the key at the middle index is greater than the search key:\n *       - Set the upper bound to the middle index.\n *    c. Else:\n *       - Set the lower bound to the middle index + 1.\n * 2. Return the upper bound index as the result.\n */"
        },
        {
            "identifier": "CheckpointUnorderedInsertion",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error CheckpointUnorderedInsertion();",
            "start": "20",
            "end": "20",
            "class": "Checkpoints",
            "signature": " CheckpointUnorderedInsertion",
            "full_signature": "function CheckpointUnorderedInsertion()",
            "class_method_signature": "Checkpoints.CheckpointUnorderedInsertion",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a checkpoint insertion is unordered.\n * This error is likely thrown when attempting to insert a checkpoint in a sequence that violates the expected order.\n */"
        },
        {
            "identifier": "Checkpoint208",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Checkpoint208 {\n        uint48 _key;\n        uint208 _value;\n    }",
            "start": "229",
            "end": "232",
            "class": "Checkpoints",
            "signature": " Checkpoint208",
            "full_signature": "function Checkpoint208()",
            "class_method_signature": "Checkpoints.Checkpoint208",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `Checkpoint208` with two fields:\n * - `_key`: A 48-bit unsigned integer representing the key.\n * - `_value`: A 208-bit unsigned integer representing the value.\n */"
        },
        {
            "identifier": "Trace208",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Trace208 {\n        Checkpoint208[] _checkpoints;\n    }",
            "start": "225",
            "end": "227",
            "class": "Checkpoints",
            "signature": " Trace208",
            "full_signature": "function Trace208()",
            "class_method_signature": "Checkpoints.Trace208",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `Trace208` that contains an array of `Checkpoint208` structs.\n * - `_checkpoints`: An array of `Checkpoint208` structs, representing a sequence of checkpoints.\n */"
        },
        {
            "identifier": "_insert",
            "parameters": "Checkpoint224[] storage self, uint32 key, uint224 value",
            "modifiers": "",
            "return": "returns (uint224 oldValue, uint224 newValue)",
            "body": "function _insert(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint224 value\n    ) private returns (uint224 oldValue, uint224 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint224 storage last = _unsafeAccess(self, pos - 1);\n            uint32 lastKey = last._key;\n            uint224 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint224({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint224({_key: key, _value: value}));\n            return (0, value);\n        }\n    }",
            "start": "134",
            "end": "162",
            "class": "Checkpoints",
            "signature": "returns (uint224 oldValue, uint224 newValue) _insertCheckpoint224[] storage self, uint32 key, uint224 value",
            "full_signature": "function _insert(Checkpoint224[] storage self, uint32 key, uint224 value) private   returns (uint224 oldValue, uint224 newValue)",
            "class_method_signature": "Checkpoints._insertCheckpoint224[] storage self, uint32 key, uint224 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Inserts a new checkpoint into the storage array or updates an existing one.\n *\n * Steps:\n * 1. Determine the current length of the checkpoint array.\n * 2. If the array is not empty:\n *    a. Access the last checkpoint in the array.\n *    b. Retrieve the key and value of the last checkpoint.\n *    c. Ensure that the new key is not less than the last key to maintain order.\n *    d. If the keys match, update the value of the last checkpoint.\n *    e. If the keys do not match, push a new checkpoint to the array.\n *    f. Return the old value and the new value.\n * 3. If the array is empty:\n *    a. Push a new checkpoint to the array.\n *    b. Return 0 as the old value and the new value.\n *\n * @param self The storage array of Checkpoint224.\n * @param key The key of the checkpoint to insert or update.\n * @param value The value of the checkpoint to insert or update.\n * @return oldValue The previous value associated with the key (0 if new).\n * @return newValue The new value associated with the key.\n *\n * @dev Reverts if the key is less than the last key in the array.\n */"
        },
        {
            "identifier": "_unsafeAccess",
            "parameters": "Checkpoint208[] storage self, uint256 pos",
            "modifiers": "pure",
            "return": "returns (Checkpoint208 storage result)",
            "body": "function _unsafeAccess(\n        Checkpoint208[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint208 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }",
            "start": "418",
            "end": "426",
            "class": "Checkpoints",
            "signature": "returns (Checkpoint208 storage result) _unsafeAccessCheckpoint208[] storage self, uint256 pos",
            "full_signature": "function _unsafeAccess(Checkpoint208[] storage self, uint256 pos) private  pure returns (Checkpoint208 storage result)",
            "class_method_signature": "Checkpoints._unsafeAccessCheckpoint208[] storage self, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Accesses a specific checkpoint in a storage array at a given position without bounds checking.\n * \n * Steps:\n * 1. Store the slot of the storage array in memory.\n * 2. Calculate the storage slot of the checkpoint at the given position using keccak256.\n * 3. Return the checkpoint at the calculated storage slot.\n *\n * @dev This function is marked as private and pure, meaning it does not modify state and is only callable within the contract.\n * @dev The function uses inline assembly to directly manipulate storage slots, which is unsafe and should be used with caution.\n *\n * @param self The storage array of Checkpoint208 to access.\n * @param pos The position in the array to access.\n * @return result The checkpoint at the specified position.\n */"
        },
        {
            "identifier": "_insert",
            "parameters": "Checkpoint208[] storage self, uint48 key, uint208 value",
            "modifiers": "",
            "return": "returns (uint208 oldValue, uint208 newValue)",
            "body": "function _insert(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint208 value\n    ) private returns (uint208 oldValue, uint208 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint208 storage last = _unsafeAccess(self, pos - 1);\n            uint48 lastKey = last._key;\n            uint208 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint208({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint208({_key: key, _value: value}));\n            return (0, value);\n        }\n    }",
            "start": "337",
            "end": "365",
            "class": "Checkpoints",
            "signature": "returns (uint208 oldValue, uint208 newValue) _insertCheckpoint208[] storage self, uint48 key, uint208 value",
            "full_signature": "function _insert(Checkpoint208[] storage self, uint48 key, uint208 value) private   returns (uint208 oldValue, uint208 newValue)",
            "class_method_signature": "Checkpoints._insertCheckpoint208[] storage self, uint48 key, uint208 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Inserts a new checkpoint into the checkpoint array or updates an existing one.\n *\n * @param self The storage array of checkpoints.\n * @param key The key (timestamp) for the checkpoint.\n * @param value The value associated with the key.\n *\n * @return oldValue The previous value associated with the key (if any).\n * @return newValue The new value being inserted or updated.\n *\n * Steps:\n * 1. Determine the position in the checkpoint array.\n * 2. If the array is not empty:\n *    a. Access the last checkpoint in the array.\n *    b. Ensure the new key is not less than the last key (checkpoints must be non-decreasing).\n *    c. If the key matches the last key, update the value.\n *    d. If the key is new, push a new checkpoint to the array.\n * 3. If the array is empty, push a new checkpoint to the array.\n * 4. Return the old and new values.\n *\n * Reverts:\n * - If the key is less than the last key in the array, reverts with `CheckpointUnorderedInsertion`.\n */"
        },
        {
            "identifier": "_lowerBinaryLookup",
            "parameters": "Checkpoint208[] storage self, uint48 key, uint256 low, uint256 high",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _lowerBinaryLookup(\n        Checkpoint208[] storage self,\n        uint48 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }",
            "start": "398",
            "end": "413",
            "class": "Checkpoints",
            "signature": "returns (uint256) _lowerBinaryLookupCheckpoint208[] storage self, uint48 key, uint256 low, uint256 high",
            "full_signature": "function _lowerBinaryLookup(Checkpoint208[] storage self, uint48 key, uint256 low, uint256 high) private  view returns (uint256)",
            "class_method_signature": "Checkpoints._lowerBinaryLookupCheckpoint208[] storage self, uint48 key, uint256 low, uint256 high",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Performs a binary search to find the lower bound of a key in a sorted array of Checkpoint208 structs.\n *\n * @param self The storage array of Checkpoint208 structs to search within.\n * @param key The key to search for.\n * @param low The lower bound index of the search range.\n * @param high The upper bound index of the search range.\n * @return The index of the lower bound of the key in the array.\n *\n * Steps:\n * 1. While the lower bound is less than the upper bound:\n *    a. Calculate the middle index of the current search range.\n *    b. If the key at the middle index is less than the target key, adjust the lower bound to mid + 1.\n *    c. Otherwise, adjust the upper bound to mid.\n * 2. Return the upper bound index as the result of the search.\n */"
        },
        {
            "identifier": "_upperBinaryLookup",
            "parameters": "Checkpoint224[] storage self, uint32 key, uint256 low, uint256 high",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _upperBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }",
            "start": "171",
            "end": "186",
            "class": "Checkpoints",
            "signature": "returns (uint256) _upperBinaryLookupCheckpoint224[] storage self, uint32 key, uint256 low, uint256 high",
            "full_signature": "function _upperBinaryLookup(Checkpoint224[] storage self, uint32 key, uint256 low, uint256 high) private  view returns (uint256)",
            "class_method_signature": "Checkpoints._upperBinaryLookupCheckpoint224[] storage self, uint32 key, uint256 low, uint256 high",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a sorted array of Checkpoint224 structs.\n * \n * @param self The storage array of Checkpoint224 structs to search.\n * @param key The key to search for in the array.\n * @param low The lower bound index for the search.\n * @param high The upper bound index for the search.\n * \n * @return high The index of the first element in the array that is greater than the key.\n * \n * Steps:\n * 1. While the lower bound is less than the upper bound:\n *    a. Calculate the midpoint between the lower and upper bounds.\n *    b. If the key at the midpoint is greater than the search key, set the upper bound to the midpoint.\n *    c. Otherwise, set the lower bound to the midpoint + 1.\n * 2. Return the upper bound index, which is the first element greater than the key.\n */"
        },
        {
            "identifier": "Trace160",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Trace160 {\n        Checkpoint160[] _checkpoints;\n    }",
            "start": "428",
            "end": "430",
            "class": "Checkpoints",
            "signature": " Trace160",
            "full_signature": "function Trace160()",
            "class_method_signature": "Checkpoints.Trace160",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A struct representing a trace of 160-bit checkpoints.\n * @dev Contains an array of Checkpoint160 structs to store historical data or state changes.\n */"
        },
        {
            "identifier": "_upperBinaryLookup",
            "parameters": "Checkpoint160[] storage self, uint96 key, uint256 low, uint256 high",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _upperBinaryLookup(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key > key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high;\n    }",
            "start": "577",
            "end": "592",
            "class": "Checkpoints",
            "signature": "returns (uint256) _upperBinaryLookupCheckpoint160[] storage self, uint96 key, uint256 low, uint256 high",
            "full_signature": "function _upperBinaryLookup(Checkpoint160[] storage self, uint96 key, uint256 low, uint256 high) private  view returns (uint256)",
            "class_method_signature": "Checkpoints._upperBinaryLookupCheckpoint160[] storage self, uint96 key, uint256 low, uint256 high",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a sorted array of Checkpoint160 structs.\n *\n * @param self The storage array of Checkpoint160 structs to search.\n * @param key The key to search for in the array.\n * @param low The lower bound index for the search.\n * @param high The upper bound index for the search.\n *\n * @return The index of the first element in the array that is greater than the key.\n *\n * Steps:\n * 1. While the lower bound is less than the upper bound:\n *    a. Calculate the midpoint index.\n *    b. If the key at the midpoint is greater than the search key, adjust the upper bound to the midpoint.\n *    c. Otherwise, adjust the lower bound to the midpoint + 1.\n * 2. Return the upper bound index as the result.\n */"
        },
        {
            "identifier": "_lowerBinaryLookup",
            "parameters": "Checkpoint224[] storage self, uint32 key, uint256 low, uint256 high",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _lowerBinaryLookup(\n        Checkpoint224[] storage self,\n        uint32 key,\n        uint256 low,\n        uint256 high\n    ) private view returns (uint256) {\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(self, mid)._key < key) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return high;\n    }",
            "start": "195",
            "end": "210",
            "class": "Checkpoints",
            "signature": "returns (uint256) _lowerBinaryLookupCheckpoint224[] storage self, uint32 key, uint256 low, uint256 high",
            "full_signature": "function _lowerBinaryLookup(Checkpoint224[] storage self, uint32 key, uint256 low, uint256 high) private  view returns (uint256)",
            "class_method_signature": "Checkpoints._lowerBinaryLookupCheckpoint224[] storage self, uint32 key, uint256 low, uint256 high",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function average(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Performs a binary search on a sorted array of Checkpoint224 structs to find the highest index where the key is less than the specified key.\n *\n * @param self The storage array of Checkpoint224 structs to search.\n * @param key The key to search for.\n * @param low The lower bound of the search range.\n * @param high The upper bound of the search range.\n *\n * @return The highest index where the key is less than the specified key.\n *\n * Steps:\n * 1. While the lower bound is less than the upper bound:\n *    a. Calculate the midpoint of the current search range.\n *    b. If the key at the midpoint is less than the specified key, adjust the lower bound to midpoint + 1.\n *    c. Otherwise, adjust the upper bound to the midpoint.\n * 2. Return the adjusted upper bound as the result.\n */"
        },
        {
            "identifier": "Checkpoint224",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Checkpoint224 {\n        uint32 _key;\n        uint224 _value;\n    }",
            "start": "26",
            "end": "29",
            "class": "Checkpoints",
            "signature": " Checkpoint224",
            "full_signature": "function Checkpoint224()",
            "class_method_signature": "Checkpoints.Checkpoint224",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `Checkpoint224` with two fields:\n * - `_key`: A 32-bit unsigned integer representing the key.\n * - `_value`: A 224-bit unsigned integer representing the value.\n */"
        },
        {
            "identifier": "Checkpoint160",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Checkpoint160 {\n        uint96 _key;\n        uint160 _value;\n    }",
            "start": "432",
            "end": "435",
            "class": "Checkpoints",
            "signature": " Checkpoint160",
            "full_signature": "function Checkpoint160()",
            "class_method_signature": "Checkpoints.Checkpoint160",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A struct representing a checkpoint with a 96-bit key and a 160-bit value.\n * @dev This struct can be used to store key-value pairs where the key is a 96-bit unsigned integer and the value is a 160-bit unsigned integer.\n * @param _key The 96-bit unsigned integer key.\n * @param _value The 160-bit unsigned integer value.\n */"
        },
        {
            "identifier": "_unsafeAccess",
            "parameters": "Checkpoint160[] storage self, uint256 pos",
            "modifiers": "pure",
            "return": "returns (Checkpoint160 storage result)",
            "body": "function _unsafeAccess(\n        Checkpoint160[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint160 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }",
            "start": "621",
            "end": "629",
            "class": "Checkpoints",
            "signature": "returns (Checkpoint160 storage result) _unsafeAccessCheckpoint160[] storage self, uint256 pos",
            "full_signature": "function _unsafeAccess(Checkpoint160[] storage self, uint256 pos) private  pure returns (Checkpoint160 storage result)",
            "class_method_signature": "Checkpoints._unsafeAccessCheckpoint160[] storage self, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Accesses a specific checkpoint in a storage array at a given position.\n * @dev This function uses inline assembly to directly access storage, which is unsafe and should be used with caution.\n * \n * Steps:\n * 1. Store the slot of the storage array in memory.\n * 2. Calculate the storage slot of the checkpoint at the given position using keccak256.\n * 3. Return the checkpoint at the calculated storage slot.\n */"
        },
        {
            "identifier": "_unsafeAccess",
            "parameters": "Checkpoint224[] storage self, uint256 pos",
            "modifiers": "pure",
            "return": "returns (Checkpoint224 storage result)",
            "body": "function _unsafeAccess(\n        Checkpoint224[] storage self,\n        uint256 pos\n    ) private pure returns (Checkpoint224 storage result) {\n        assembly {\n            mstore(0, self.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }",
            "start": "215",
            "end": "223",
            "class": "Checkpoints",
            "signature": "returns (Checkpoint224 storage result) _unsafeAccessCheckpoint224[] storage self, uint256 pos",
            "full_signature": "function _unsafeAccess(Checkpoint224[] storage self, uint256 pos) private  pure returns (Checkpoint224 storage result)",
            "class_method_signature": "Checkpoints._unsafeAccessCheckpoint224[] storage self, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Accesses a Checkpoint224 element in a storage array at a specific position without bounds checking.\n * \n * @param self The storage array of Checkpoint224 elements.\n * @param pos The position in the array to access.\n * @return result The storage reference to the Checkpoint224 element at the specified position.\n *\n * Steps:\n * 1. Store the slot of the storage array in memory.\n * 2. Calculate the storage slot of the element at the specified position using keccak256.\n * 3. Return the storage reference to the element.\n */"
        },
        {
            "identifier": "_insert",
            "parameters": "Checkpoint160[] storage self, uint96 key, uint160 value",
            "modifiers": "",
            "return": "returns (uint160 oldValue, uint160 newValue)",
            "body": "function _insert(\n        Checkpoint160[] storage self,\n        uint96 key,\n        uint160 value\n    ) private returns (uint160 oldValue, uint160 newValue) {\n        uint256 pos = self.length;\n\n        if (pos > 0) {\n            Checkpoint160 storage last = _unsafeAccess(self, pos - 1);\n            uint96 lastKey = last._key;\n            uint160 lastValue = last._value;\n\n            // Checkpoint keys must be non-decreasing.\n            if (lastKey > key) {\n                revert CheckpointUnorderedInsertion();\n            }\n\n            // Update or push new checkpoint\n            if (lastKey == key) {\n                last._value = value;\n            } else {\n                self.push(Checkpoint160({_key: key, _value: value}));\n            }\n            return (lastValue, value);\n        } else {\n            self.push(Checkpoint160({_key: key, _value: value}));\n            return (0, value);\n        }\n    }",
            "start": "540",
            "end": "568",
            "class": "Checkpoints",
            "signature": "returns (uint160 oldValue, uint160 newValue) _insertCheckpoint160[] storage self, uint96 key, uint160 value",
            "full_signature": "function _insert(Checkpoint160[] storage self, uint96 key, uint160 value) private   returns (uint160 oldValue, uint160 newValue)",
            "class_method_signature": "Checkpoints._insertCheckpoint160[] storage self, uint96 key, uint160 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Inserts a new checkpoint into a storage array of Checkpoint160.\n * \n * Steps:\n * 1. Determine the current length of the checkpoint array.\n * 2. If the array is not empty:\n *    a. Access the last checkpoint in the array.\n *    b. Retrieve the key and value of the last checkpoint.\n *    c. Ensure the new key is not less than the last key (keys must be non-decreasing).\n *    d. If the new key matches the last key, update the last checkpoint's value.\n *    e. If the new key is greater, push a new checkpoint to the array.\n *    f. Return the old value and the new value.\n * 3. If the array is empty:\n *    a. Push a new checkpoint to the array.\n *    b. Return 0 as the old value and the new value.\n *\n * @param self The storage array of Checkpoint160.\n * @param key The key of the new checkpoint.\n * @param value The value of the new checkpoint.\n * @return oldValue The previous value associated with the key (or 0 if the key was not present).\n * @return newValue The new value associated with the key.\n *\n * @dev Reverts if the key is less than the last key in the array (unordered insertion).\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/structs/Heap.sol": [
        {
            "identifier": "_siftUp",
            "parameters": "Uint256Heap storage self, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "modifiers": "",
            "return": "",
            "body": "function _siftUp(\n        Uint256Heap storage self,\n        uint256 index,\n        uint256 value,\n        function(uint256, uint256) view returns (bool) comp\n    ) private {\n        unchecked {\n            while (index > 0) {\n                uint256 parentIndex = (index - 1) / 2;\n                uint256 parentValue = self.tree.unsafeAccess(parentIndex).value;\n                if (comp(parentValue, value)) break;\n                _swap(self, index, parentIndex);\n                index = parentIndex;\n            }\n        }\n    }",
            "start": "240",
            "end": "255",
            "class": "Heap",
            "signature": " _siftUpUint256Heap storage self, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "full_signature": "function _siftUp(Uint256Heap storage self, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp) private",
            "class_method_signature": "Heap._siftUpUint256Heap storage self, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function unsafeAccess(uint256[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Uint256Slot storage)', 'function unsafeAccess(bytes32[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Bytes32Slot storage)', 'function _swap(uint256 ptr1, uint256 ptr2) private  pure', 'function unsafeAccess(address[] storage arr, uint256 pos) internal  pure returns (StorageSlot.AddressSlot storage)'}",
            "human_labeled_comment": "/**\n * @notice Sifts up a value in a heap to maintain the heap property.\n *\n * Steps:\n * 1. Check if the index is greater than 0 (i.e., not the root).\n * 2. Calculate the parent index of the current index.\n * 3. Retrieve the parent value from the heap.\n * 4. If the parent value satisfies the comparison condition, break the loop.\n * 5. Otherwise, swap the current value with the parent value.\n * 6. Update the index to the parent index and repeat the process.\n *\n * @param self The heap storage reference.\n * @param index The index of the value to sift up.\n * @param value The value to sift up.\n * @param comp The comparison function to determine the heap property.\n */"
        },
        {
            "identifier": "replace",
            "parameters": "Uint256Heap storage self, uint256 newValue",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function replace(Uint256Heap storage self, uint256 newValue) internal returns (uint256) {\n        return replace(self, newValue, Comparators.lt);\n    }",
            "start": "134",
            "end": "136",
            "class": "Heap",
            "signature": "returns (uint256) replaceUint256Heap storage self, uint256 newValue",
            "full_signature": "function replace(Uint256Heap storage self, uint256 newValue) internal   returns (uint256)",
            "class_method_signature": "Heap.replaceUint256Heap storage self, uint256 newValue",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function lt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Replaces a value in the Uint256Heap with a new value using the default comparator (less than).\n * @param self The heap storage reference.\n * @param newValue The new value to replace the existing value.\n * @return The replaced value.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "Uint256Heap storage self",
            "modifiers": "",
            "return": "",
            "body": "function clear(Uint256Heap storage self) internal {\n        self.tree.unsafeSetLength(0);\n    }",
            "start": "173",
            "end": "175",
            "class": "Heap",
            "signature": " clearUint256Heap storage self",
            "full_signature": "function clear(Uint256Heap storage self) internal",
            "class_method_signature": "Heap.clearUint256Heap storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function unsafeSetLength(address[] storage array, uint256 len) internal', 'function unsafeSetLength(uint256[] storage array, uint256 len) internal', 'function unsafeSetLength(bytes32[] storage array, uint256 len) internal'}",
            "human_labeled_comment": "/**\n * @notice Clears the contents of a Uint256Heap storage.\n * \n * Steps:\n * 1. Sets the length of the underlying tree array to 0, effectively clearing it.\n */"
        },
        {
            "identifier": "_swap",
            "parameters": "Uint256Heap storage self, uint256 i, uint256 j",
            "modifiers": "",
            "return": "",
            "body": "function _swap(Uint256Heap storage self, uint256 i, uint256 j) private {\n        StorageSlot.Uint256Slot storage ni = self.tree.unsafeAccess(i);\n        StorageSlot.Uint256Slot storage nj = self.tree.unsafeAccess(j);\n        (ni.value, nj.value) = (nj.value, ni.value);\n    }",
            "start": "180",
            "end": "184",
            "class": "Heap",
            "signature": " _swapUint256Heap storage self, uint256 i, uint256 j",
            "full_signature": "function _swap(Uint256Heap storage self, uint256 i, uint256 j) private",
            "class_method_signature": "Heap._swapUint256Heap storage self, uint256 i, uint256 j",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function unsafeAccess(uint256[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Uint256Slot storage)', 'function unsafeAccess(bytes32[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Bytes32Slot storage)', 'function _swap(uint256 ptr1, uint256 ptr2) private  pure', 'function Uint256Slot()', 'function unsafeAccess(address[] storage arr, uint256 pos) internal  pure returns (StorageSlot.AddressSlot storage)'}",
            "human_labeled_comment": "/**\n * @notice Swaps the values of two nodes in a Uint256Heap.\n *\n * Steps:\n * 1. Access the storage slots for the nodes at indices `i` and `j`.\n * 2. Swap the values of the two nodes.\n */"
        },
        {
            "identifier": "_siftDown",
            "parameters": "Uint256Heap storage self, uint256 size, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "modifiers": "",
            "return": "",
            "body": "function _siftDown(\n        Uint256Heap storage self,\n        uint256 size,\n        uint256 index,\n        uint256 value,\n        function(uint256, uint256) view returns (bool) comp\n    ) private {\n        unchecked {\n            // Check if there is a risk of overflow when computing the indices of the child nodes. If that is the case,\n            // there cannot be child nodes in the tree, so sifting is done.\n            if (index >= type(uint256).max / 2) return;\n\n            // Compute the indices of the potential child nodes\n            uint256 lIndex = 2 * index + 1;\n            uint256 rIndex = 2 * index + 2;\n\n            // Three cases:\n            // 1. Both children exist: sifting may continue on one of the branch (selection required)\n            // 2. Only left child exist: sifting may continue on the left branch (no selection required)\n            // 3. Neither child exist: sifting is done\n            if (rIndex < size) {\n                uint256 lValue = self.tree.unsafeAccess(lIndex).value;\n                uint256 rValue = self.tree.unsafeAccess(rIndex).value;\n                if (comp(lValue, value) || comp(rValue, value)) {\n                    uint256 cIndex = comp(lValue, rValue).ternary(lIndex, rIndex);\n                    _swap(self, index, cIndex);\n                    _siftDown(self, size, cIndex, value, comp);\n                }\n            } else if (lIndex < size) {\n                uint256 lValue = self.tree.unsafeAccess(lIndex).value;\n                if (comp(lValue, value)) {\n                    _swap(self, index, lIndex);\n                    _siftDown(self, size, lIndex, value, comp);\n                }\n            }\n        }\n    }",
            "start": "194",
            "end": "230",
            "class": "Heap",
            "signature": " _siftDownUint256Heap storage self, uint256 size, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "full_signature": "function _siftDown(Uint256Heap storage self, uint256 size, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp) private",
            "class_method_signature": "Heap._siftDownUint256Heap storage self, uint256 size, uint256 index, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function unsafeAccess(uint256[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Uint256Slot storage)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function unsafeAccess(bytes32[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Bytes32Slot storage)', 'function _swap(uint256 ptr1, uint256 ptr2) private  pure', 'function ternary(bool condition, uint256 a, uint256 b) internal  pure returns (uint256)', 'function unsafeAccess(address[] storage arr, uint256 pos) internal  pure returns (StorageSlot.AddressSlot storage)'}",
            "human_labeled_comment": "/**\n * @notice Sifts down a value in a heap to maintain the heap property.\n *\n * Steps:\n * 1. Check if the current index is at risk of overflow when computing child indices. If so, sifting is done.\n * 2. Compute the indices of the left and right child nodes.\n * 3. Handle three cases:\n *    a. Both children exist: Continue sifting on the branch with the appropriate child based on the comparison function.\n *    b. Only the left child exists: Continue sifting on the left branch if necessary.\n *    c. Neither child exists: Sifting is complete.\n * 4. If sifting continues, swap the current node with the appropriate child and recursively call `_siftDown`.\n *\n * @param self The heap storage reference.\n * @param size The size of the heap.\n * @param index The current index to sift down from.\n * @param value The value to sift down.\n * @param comp The comparison function used to determine the heap order.\n */"
        },
        {
            "identifier": "replace",
            "parameters": "Uint256Heap storage self, uint256 newValue, function(uint256, uint256) view returns (bool) comp",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function replace(\n        Uint256Heap storage self,\n        uint256 newValue,\n        function(uint256, uint256) view returns (bool) comp\n    ) internal returns (uint256) {\n        uint256 size = length(self);\n        if (size == 0) Panic.panic(Panic.EMPTY_ARRAY_POP);\n\n        // cache\n        uint256 oldValue = self.tree.unsafeAccess(0).value;\n\n        // replace and re-heapify\n        self.tree.unsafeAccess(0).value = newValue;\n        _siftDown(self, size, 0, newValue, comp);\n\n        return oldValue;\n    }",
            "start": "145",
            "end": "161",
            "class": "Heap",
            "signature": "returns (uint256) replaceUint256Heap storage self, uint256 newValue, function(uint256, uint256) view returns (bool) comp",
            "full_signature": "function replace(Uint256Heap storage self, uint256 newValue, function(uint256, uint256) view returns (bool) comp) internal   returns (uint256)",
            "class_method_signature": "Heap.replaceUint256Heap storage self, uint256 newValue, function(uint256, uint256) view returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function unsafeAccess(uint256[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Uint256Slot storage)', 'function unsafeAccess(bytes32[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Bytes32Slot storage)', 'function panic(uint256 code) internal  pure', 'uint256 internal constant EMPTY_ARRAY_POP', 'function unsafeAccess(address[] storage arr, uint256 pos) internal  pure returns (StorageSlot.AddressSlot storage)'}",
            "human_labeled_comment": "/**\n * @notice Replaces the root value of a heap with a new value and re-heapifies the structure.\n *\n * Steps:\n * 1. Check the size of the heap. If it is empty, panic with an EMPTY_ARRAY_POP error.\n * 2. Cache the current root value of the heap.\n * 3. Replace the root value with the new value.\n * 4. Re-heapify the heap by sifting down the new value to maintain the heap property.\n * 5. Return the old root value that was replaced.\n *\n * @param self The heap storage reference.\n * @param newValue The new value to replace the root with.\n * @param comp The comparison function used to maintain the heap property.\n * @return The old root value that was replaced.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/metatx/ERC2771Forwarder.sol": [
        {
            "identifier": "ExecutedForwardRequest",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "event ExecutedForwardRequest(address indexed signer, uint256 nonce, bool success);",
            "start": "76",
            "end": "76",
            "class": "ERC2771Forwarder",
            "signature": " ExecutedForwardRequest",
            "full_signature": "function ExecutedForwardRequest()",
            "class_method_signature": "ERC2771Forwarder.ExecutedForwardRequest",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Emitted when a forward request is executed.\n * @param signer The address of the signer who initiated the request.\n * @param nonce The nonce associated with the request to ensure uniqueness.\n * @param success Indicates whether the execution was successful.\n */"
        },
        {
            "identifier": "ERC2771UntrustfulTarget",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC2771UntrustfulTarget(address target, address forwarder);",
            "start": "96",
            "end": "96",
            "class": "ERC2771Forwarder",
            "signature": " ERC2771UntrustfulTarget",
            "full_signature": "function ERC2771UntrustfulTarget()",
            "class_method_signature": "ERC2771Forwarder.ERC2771UntrustfulTarget",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the target contract does not trust the forwarder.\n * @param target The address of the target contract.\n * @param forwarder The address of the forwarder that is not trusted by the target.\n */"
        },
        {
            "identifier": "ERC2771ForwarderMismatchedValue",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC2771ForwarderMismatchedValue(uint256 requestedValue, uint256 msgValue);",
            "start": "86",
            "end": "86",
            "class": "ERC2771Forwarder",
            "signature": " ERC2771ForwarderMismatchedValue",
            "full_signature": "function ERC2771ForwarderMismatchedValue()",
            "class_method_signature": "ERC2771Forwarder.ERC2771ForwarderMismatchedValue",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error for ERC2771 Forwarder when the requested value does not match the sent value.\n * @param requestedValue The value that was requested by the forwarder.\n * @param msgValue The actual value sent in the transaction.\n */"
        },
        {
            "identifier": "_checkForwardedGas",
            "parameters": "uint256 gasLeft, ForwardRequestData calldata request",
            "modifiers": "pure",
            "return": "",
            "body": "function _checkForwardedGas(uint256 gasLeft, ForwardRequestData calldata request) private pure {\n        // To avoid insufficient gas griefing attacks, as referenced in https://ronan.eth.limo/blog/ethereum-gas-dangers/\n        //\n        // A malicious relayer can attempt to shrink the gas forwarded so that the underlying call reverts out-of-gas\n        // but the forwarding itself still succeeds. In order to make sure that the subcall received sufficient gas,\n        // we will inspect gasleft() after the forwarding.\n        //\n        // Let X be the gas available before the subcall, such that the subcall gets at most X * 63 / 64.\n        // We can't know X after CALL dynamic costs, but we want it to be such that X * 63 / 64 >= req.gas.\n        // Let Y be the gas used in the subcall. gasleft() measured immediately after the subcall will be gasleft() = X - Y.\n        // If the subcall ran out of gas, then Y = X * 63 / 64 and gasleft() = X - Y = X / 64.\n        // Under this assumption req.gas / 63 > gasleft() is true if and only if\n        // req.gas / 63 > X / 64, or equivalently req.gas > X * 63 / 64.\n        // This means that if the subcall runs out of gas we are able to detect that insufficient gas was passed.\n        //\n        // We will now also see that req.gas / 63 > gasleft() implies that req.gas >= X * 63 / 64.\n        // The contract guarantees Y <= req.gas, thus gasleft() = X - Y >= X - req.gas.\n        // -    req.gas / 63 > gasleft()\n        // -    req.gas / 63 >= X - req.gas\n        // -    req.gas >= X * 63 / 64\n        // In other words if req.gas < X * 63 / 64 then req.gas / 63 <= gasleft(), thus if the relayer behaves honestly\n        // the forwarding does not revert.\n        if (gasLeft < request.gas / 63) {\n            // We explicitly trigger invalid opcode to consume all gas and bubble-up the effects, since\n            // neither revert or assert consume all gas since Solidity 0.8.20\n            // https://docs.soliditylang.org/en/v0.8.20/control-structures.html#panic-via-assert-and-error-via-require\n            assembly (\"memory-safe\") {\n                invalid()\n            }\n        }\n    }",
            "start": "338",
            "end": "368",
            "class": "ERC2771Forwarder",
            "signature": " _checkForwardedGasuint256 gasLeft, ForwardRequestData calldata request",
            "full_signature": "function _checkForwardedGas(uint256 gasLeft, ForwardRequestData calldata request) private  pure",
            "class_method_signature": "ERC2771Forwarder._checkForwardedGasuint256 gasLeft, ForwardRequestData calldata request",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the forwarded gas is sufficient to avoid insufficient gas griefing attacks.\n *\n * @dev This function ensures that the subcall received sufficient gas by inspecting `gasleft()` after the forwarding.\n * A malicious relayer could attempt to shrink the gas forwarded, causing the subcall to revert out-of-gas while the\n * forwarding itself succeeds. This function prevents such attacks by verifying that the gas left after the subcall\n * is sufficient.\n *\n * Steps:\n * 1. Calculate if the remaining gas (`gasLeft`) is less than `request.gas / 63`.\n * 2. If the condition is met, trigger an invalid opcode to consume all gas and revert the transaction.\n *    This ensures that the relayer cannot exploit insufficient gas scenarios.\n *\n * @param gasLeft The amount of gas remaining after the subcall.\n * @param request The forwarded request data containing the required gas amount.\n */"
        },
        {
            "identifier": "ERC2771ForwarderExpiredRequest",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC2771ForwarderExpiredRequest(uint48 deadline);",
            "start": "91",
            "end": "91",
            "class": "ERC2771Forwarder",
            "signature": " ERC2771ForwarderExpiredRequest",
            "full_signature": "function ERC2771ForwarderExpiredRequest()",
            "class_method_signature": "ERC2771Forwarder.ERC2771ForwarderExpiredRequest",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a request has expired.\n * @param deadline The timestamp at which the request expired.\n */"
        },
        {
            "identifier": "_isTrustedByTarget",
            "parameters": "address target",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function _isTrustedByTarget(address target) private view returns (bool) {\n        bytes memory encodedParams = abi.encodeCall(ERC2771Context.isTrustedForwarder, (address(this)));\n\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly (\"memory-safe\") {\n            // Perform the staticcall and save the result in the scratch space.\n            // | Location  | Content  | Content (Hex)                                                      |\n            // |-----------|----------|--------------------------------------------------------------------|\n            // |           |          |                                                           result \u2193 |\n            // | 0x00:0x1F | selector | 0x0000000000000000000000000000000000000000000000000000000000000001 |\n            success := staticcall(gas(), target, add(encodedParams, 0x20), mload(encodedParams), 0, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }",
            "start": "306",
            "end": "324",
            "class": "ERC2771Forwarder",
            "signature": "returns (bool) _isTrustedByTargetaddress target",
            "full_signature": "function _isTrustedByTarget(address target) private  view returns (bool)",
            "class_method_signature": "ERC2771Forwarder._isTrustedByTargetaddress target",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function isTrustedForwarder(address forwarder) public virtual view returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Checks if the current contract is trusted by the target contract.\n *\n * Steps:\n * 1. Encode the `isTrustedForwarder` function call with the current contract's address as the parameter.\n * 2. Perform a static call to the target contract using the encoded parameters.\n * 3. Check if the call was successful and if the return data size is at least 32 bytes.\n * 4. Return true if the call was successful, the return data size is valid, and the return value is greater than 0.\n */"
        },
        {
            "identifier": "verify",
            "parameters": "ForwardRequestData calldata request",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function verify(ForwardRequestData calldata request) public view virtual returns (bool) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, ) = _validate(request);\n        return isTrustedForwarder && active && signerMatch;\n    }",
            "start": "112",
            "end": "115",
            "class": "ERC2771Forwarder",
            "signature": "returns (bool) verifyForwardRequestData calldata request",
            "full_signature": "function verify(ForwardRequestData calldata request) public virtual view returns (bool)",
            "class_method_signature": "ERC2771Forwarder.verifyForwardRequestData calldata request",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function isTrustedForwarder(address forwarder) public virtual view returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Verifies the validity of a forward request by checking if the forwarder is trusted, active, and if the signer matches.\n *\n * Steps:\n * 1. Calls the internal `_validate` function to check the following:\n *    - Whether the forwarder is trusted.\n *    - Whether the forwarder is active.\n *    - Whether the signer of the request matches the expected signer.\n *\n * 2. Returns `true` if all checks pass (forwarder is trusted, active, and signer matches), otherwise returns `false`.\n */"
        },
        {
            "identifier": "ERC2771ForwarderInvalidSigner",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC2771ForwarderInvalidSigner(address signer, address from);",
            "start": "81",
            "end": "81",
            "class": "ERC2771Forwarder",
            "signature": " ERC2771ForwarderInvalidSigner",
            "full_signature": "function ERC2771ForwarderInvalidSigner()",
            "class_method_signature": "ERC2771Forwarder.ERC2771ForwarderInvalidSigner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the signer of a forwarded transaction is invalid.\n * @param signer The address of the signer.\n * @param from The address from which the transaction was forwarded.\n */"
        },
        {
            "identifier": "_recoverForwardRequestSigner",
            "parameters": "ForwardRequestData calldata request",
            "modifiers": "view",
            "return": "returns (bool isValid, address signer)",
            "body": "function _recoverForwardRequestSigner(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isValid, address signer) {\n        (address recovered, ECDSA.RecoverError err, ) = _hashTypedDataV4(\n            keccak256(\n                abi.encode(\n                    _FORWARD_REQUEST_TYPEHASH,\n                    request.from,\n                    request.to,\n                    request.value,\n                    request.gas,\n                    nonces(request.from),\n                    request.deadline,\n                    keccak256(request.data)\n                )\n            )\n        ).tryRecover(request.signature);\n\n        return (err == ECDSA.RecoverError.NoError, recovered);\n    }",
            "start": "219",
            "end": "238",
            "class": "ERC2771Forwarder",
            "signature": "returns (bool isValid, address signer) _recoverForwardRequestSignerForwardRequestData calldata request",
            "full_signature": "function _recoverForwardRequestSigner(ForwardRequestData calldata request) internal virtual view returns (bool isValid, address signer)",
            "class_method_signature": "ERC2771Forwarder._recoverForwardRequestSignerForwardRequestData calldata request",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function recover(bytes32 hash, bytes memory signature) internal  pure returns (address)', 'function tryRecover(bytes32 hash, bytes memory signature) internal  pure returns (address recovered, RecoverError err, bytes32 errArg)', 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal  pure returns (address, RecoverError, bytes32)', 'function tryRecover(bytes32 hash, bytes memory signature) internal  pure returns (address, RecoverError, bytes32)', 'function tryRecover(bytes32 hash, bytes memory signature) internal  pure returns (address, RecoverError)', 'function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  pure returns (address recovered, RecoverError err, bytes32 errArg)', 'function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  pure returns (address, RecoverError)', 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal  pure returns (address)', 'function nonces(address owner) public virtual view returns (uint256)', 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal  pure returns (address, RecoverError)', 'function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  pure returns (address, RecoverError, bytes32)', 'function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal  pure returns (address recovered, RecoverError err, bytes32 errArg)', 'function _hashTypedDataV4(bytes32 structHash) internal virtual view returns (bytes32)', 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  pure returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Recovers the signer of a forward request and checks if the signature is valid.\n *\n * Steps:\n * 1. Compute the hash of the forward request data using the EIP-712 typed data format.\n * 2. Attempt to recover the signer's address from the provided signature using the computed hash.\n * 3. Return a tuple containing:\n *    - A boolean indicating whether the signature is valid (no error during recovery).\n *    - The recovered signer's address.\n */"
        },
        {
            "identifier": "executeBatch",
            "parameters": "ForwardRequestData[] calldata requests, address payable refundReceiver",
            "modifiers": "payable",
            "return": "",
            "body": "function executeBatch(\n        ForwardRequestData[] calldata requests,\n        address payable refundReceiver\n    ) public payable virtual {\n        bool atomic = refundReceiver == address(0);\n\n        uint256 requestsValue;\n        uint256 refundValue;\n\n        for (uint256 i; i < requests.length; ++i) {\n            requestsValue += requests[i].value;\n            bool success = _execute(requests[i], atomic);\n            if (!success) {\n                refundValue += requests[i].value;\n            }\n        }\n\n        // The batch should revert if there's a mismatched msg.value provided\n        // to avoid request value tampering\n        if (requestsValue != msg.value) {\n            revert ERC2771ForwarderMismatchedValue(requestsValue, msg.value);\n        }\n\n        // Some requests with value were invalid (possibly due to frontrunning).\n        // To avoid leaving ETH in the contract this value is refunded.\n        if (refundValue != 0) {\n            // We know refundReceiver != address(0) && requestsValue == msg.value\n            // meaning we can ensure refundValue is not taken from the original contract's balance\n            // and refundReceiver is a known account.\n            Address.sendValue(refundReceiver, refundValue);\n        }\n    }",
            "start": "163",
            "end": "194",
            "class": "ERC2771Forwarder",
            "signature": " executeBatchForwardRequestData[] calldata requests, address payable refundReceiver",
            "full_signature": "function executeBatch(ForwardRequestData[] calldata requests, address payable refundReceiver) public virtual payable",
            "class_method_signature": "ERC2771Forwarder.executeBatchForwardRequestData[] calldata requests, address payable refundReceiver",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function sendValue(address payable recipient, uint256 amount) internal'}",
            "human_labeled_comment": "/**\n * @notice Executes a batch of forward requests and handles refunds for failed requests.\n *\n * Steps:\n * 1. Determine if the batch execution is atomic (no refund receiver provided).\n * 2. Initialize variables to track the total value of requests and refunds.\n *\n * 3. Iterate through each request in the batch:\n *    - Accumulate the total value of all requests.\n *    - Attempt to execute the request using `_execute`.\n *    - If the execution fails, accumulate the refund value.\n *\n * 4. Revert the entire batch if the total value of requests does not match the provided `msg.value`.\n *    This prevents tampering with request values.\n *\n * 5. If there are any refunds due to failed requests:\n *    - Send the refund value to the specified `refundReceiver`.\n *    - Ensure the refund does not affect the contract's balance and is sent to a known account.\n */"
        },
        {
            "identifier": "_validate",
            "parameters": "ForwardRequestData calldata request",
            "modifiers": "view",
            "return": "returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer)",
            "body": "function _validate(\n        ForwardRequestData calldata request\n    ) internal view virtual returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) {\n        (bool isValid, address recovered) = _recoverForwardRequestSigner(request);\n\n        return (\n            _isTrustedByTarget(request.to),\n            request.deadline >= block.timestamp,\n            isValid && recovered == request.from,\n            recovered\n        );\n    }",
            "start": "200",
            "end": "211",
            "class": "ERC2771Forwarder",
            "signature": "returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer) _validateForwardRequestData calldata request",
            "full_signature": "function _validate(ForwardRequestData calldata request) internal virtual view returns (bool isTrustedForwarder, bool active, bool signerMatch, address signer)",
            "class_method_signature": "ERC2771Forwarder._validateForwardRequestData calldata request",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function recover(bytes32 hash, bytes memory signature) internal  pure returns (address)', 'function recover(bytes32 hash, bytes32 r, bytes32 vs) internal  pure returns (address)', 'function isTrustedForwarder(address forwarder) public virtual view returns (bool)', 'function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  pure returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Validates a forward request by checking the following:\n * 1. Whether the forwarder is trusted by the target contract.\n * 2. Whether the request is still active (i.e., the deadline has not passed).\n * 3. Whether the recovered signer matches the `from` address in the request.\n * 4. Returns the recovered signer address.\n *\n * @param request The forward request data to validate.\n * @return isTrustedForwarder True if the forwarder is trusted by the target.\n * @return active True if the request is still active (deadline not passed).\n * @return signerMatch True if the recovered signer matches the `from` address.\n * @return signer The address of the recovered signer.\n */"
        },
        {
            "identifier": "execute",
            "parameters": "ForwardRequestData calldata request",
            "modifiers": "payable",
            "return": "",
            "body": "function execute(ForwardRequestData calldata request) public payable virtual {\n        // We make sure that msg.value and request.value match exactly.\n        // If the request is invalid or the call reverts, this whole function\n        // will revert, ensuring value isn't stuck.\n        if (msg.value != request.value) {\n            revert ERC2771ForwarderMismatchedValue(request.value, msg.value);\n        }\n\n        if (!_execute(request, true)) {\n            revert Errors.FailedCall();\n        }\n    }",
            "start": "127",
            "end": "138",
            "class": "ERC2771Forwarder",
            "signature": " executeForwardRequestData calldata request",
            "full_signature": "function execute(ForwardRequestData calldata request) public virtual payable",
            "class_method_signature": "ERC2771Forwarder.executeForwardRequestData calldata request",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function FailedCall()'}",
            "human_labeled_comment": "/**\n * @notice Executes a forwarded request, ensuring the sent value matches the requested value.\n *\n * Steps:\n * 1. Check if the sent value (`msg.value`) matches the requested value (`request.value`).\n *    - If they do not match, revert with an error indicating the mismatch.\n * 2. Attempt to execute the request using the internal `_execute` function.\n *    - If the execution fails, revert with a \"FailedCall\" error.\n * 3. The function ensures that no value is stuck if the request is invalid or the call reverts.\n */"
        },
        {
            "identifier": "_execute",
            "parameters": "ForwardRequestData calldata request, bool requireValidRequest",
            "modifiers": "",
            "return": "returns (bool success)",
            "body": "function _execute(\n        ForwardRequestData calldata request,\n        bool requireValidRequest\n    ) internal virtual returns (bool success) {\n        (bool isTrustedForwarder, bool active, bool signerMatch, address signer) = _validate(request);\n\n        // Need to explicitly specify if a revert is required since non-reverting is default for\n        // batches and reversion is opt-in since it could be useful in some scenarios\n        if (requireValidRequest) {\n            if (!isTrustedForwarder) {\n                revert ERC2771UntrustfulTarget(request.to, address(this));\n            }\n\n            if (!active) {\n                revert ERC2771ForwarderExpiredRequest(request.deadline);\n            }\n\n            if (!signerMatch) {\n                revert ERC2771ForwarderInvalidSigner(signer, request.from);\n            }\n        }\n\n        // Ignore an invalid request because requireValidRequest = false\n        if (isTrustedForwarder && signerMatch && active) {\n            // Nonce should be used before the call to prevent reusing by reentrancy\n            uint256 currentNonce = _useNonce(signer);\n\n            uint256 reqGas = request.gas;\n            address to = request.to;\n            uint256 value = request.value;\n            bytes memory data = abi.encodePacked(request.data, request.from);\n\n            uint256 gasLeft;\n\n            assembly (\"memory-safe\") {\n                success := call(reqGas, to, value, add(data, 0x20), mload(data), 0, 0)\n                gasLeft := gas()\n            }\n\n            _checkForwardedGas(gasLeft, request);\n\n            emit ExecutedForwardRequest(signer, currentNonce, success);\n        }\n    }",
            "start": "255",
            "end": "298",
            "class": "ERC2771Forwarder",
            "signature": "returns (bool success) _executeForwardRequestData calldata request, bool requireValidRequest",
            "full_signature": "function _execute(ForwardRequestData calldata request, bool requireValidRequest) internal virtual  returns (bool success)",
            "class_method_signature": "ERC2771Forwarder._executeForwardRequestData calldata request, bool requireValidRequest",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function isTrustedForwarder(address forwarder) public virtual view returns (bool)', 'function _useNonce(address owner) internal virtual  returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Executes a forwarded request after validating its authenticity and expiration.\n *\n * Steps:\n * 1. Validate the request by checking if the forwarder is trusted, if the request is active, and if the signer matches.\n * 2. If `requireValidRequest` is true, revert the transaction if:\n *    - The forwarder is not trusted.\n *    - The request is expired.\n *    - The signer does not match the expected signer.\n * 3. If the request is valid (trusted forwarder, active, and signer match), proceed with execution:\n *    - Use the signer's nonce to prevent replay attacks.\n *    - Extract the gas, target address, value, and data from the request.\n *    - Execute the call to the target address with the provided data and gas.\n *    - Check the remaining gas to ensure the call was executed correctly.\n *    - Emit an event indicating the execution status of the request.\n *\n * @param request The forwarded request data containing details like target address, gas, value, and data.\n * @param requireValidRequest A flag indicating whether the request must be valid for execution.\n * @return success A boolean indicating whether the execution was successful.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol": [
        {
            "identifier": "deposit",
            "parameters": "uint256 assets, address receiver",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function deposit(uint256 assets, address receiver) public virtual returns (uint256) {\n        uint256 maxAssets = maxDeposit(receiver);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);\n        }\n\n        uint256 shares = previewDeposit(assets);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return shares;\n    }",
            "start": "171",
            "end": "181",
            "class": "ERC4626",
            "signature": "returns (uint256) deposituint256 assets, address receiver",
            "full_signature": "function deposit(uint256 assets, address receiver) public virtual  returns (uint256)",
            "class_method_signature": "ERC4626.deposituint256 assets, address receiver",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function Deposit()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function asset() external  view returns (address assetTokenAddress)', 'function maxDeposit(address receiver) external  view returns (uint256 maxAssets)', 'function deposit(uint256 assets, address receiver) external   returns (uint256 shares)', 'function previewDeposit(uint256 assets) external  view returns (uint256 shares)'}",
            "human_labeled_comment": "/**\n * @notice Deposits assets into the contract and mints shares to the receiver.\n *\n * Steps:\n * 1. Retrieve the maximum allowed deposit amount for the receiver.\n * 2. If the requested deposit amount exceeds the maximum allowed, revert with an error.\n * 3. Calculate the number of shares to be minted based on the deposited assets.\n * 4. Perform the deposit operation, transferring assets from the sender to the contract and minting shares to the receiver.\n * 5. Return the number of shares minted.\n */"
        },
        {
            "identifier": "decimals",
            "parameters": "",
            "modifiers": "override(IERC20Metadata, ERC20)",
            "return": "returns (uint8)",
            "body": "function decimals() public view virtual override(IERC20Metadata, ERC20) returns (uint8) {\n        return _underlyingDecimals + _decimalsOffset();\n    }",
            "start": "106",
            "end": "108",
            "class": "ERC4626",
            "signature": "returns (uint8) decimals",
            "full_signature": "function decimals() public virtual override(IERC20Metadata, ERC20) returns (uint8)",
            "class_method_signature": "ERC4626.decimals",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function decimals() public virtual override returns (uint8)', 'function decimals() external  override returns (uint8)', 'uint8 public  decimals', 'function decimals() external  view returns (uint8)', 'function decimals() public virtual view returns (uint8)', 'uint8 internal  _decimals'}",
            "human_labeled_comment": "/**\n * @notice Returns the number of decimals used by the token.\n * @dev This function overrides the `decimals` function from both `IERC20Metadata` and `ERC20`.\n * @return uint8 The total number of decimals, calculated as the sum of `_underlyingDecimals` and `_decimalsOffset`.\n */"
        },
        {
            "identifier": "previewRedeem",
            "parameters": "uint256 shares",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function previewRedeem(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }",
            "start": "166",
            "end": "168",
            "class": "ERC4626",
            "signature": "returns (uint256) previewRedeemuint256 shares",
            "full_signature": "function previewRedeem(uint256 shares) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.previewRedeemuint256 shares",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function previewRedeem(uint256 shares) external  view returns (uint256 assets)', 'function convertToAssets(uint256 shares) external  view returns (uint256 assets)'}",
            "human_labeled_comment": "/**\n * @notice Previews the amount of assets that would be received upon redeeming a given number of shares.\n * @param shares The number of shares to be redeemed.\n * @return The amount of assets that would be received, calculated using the `_convertToAssets` function with rounding down.\n */"
        },
        {
            "identifier": "_underlyingDecimals",
            "parameters": "",
            "modifiers": "",
            "return": "uint8",
            "body": "uint8 private immutable _underlyingDecimals;",
            "start": "52",
            "end": "52",
            "class": "ERC4626",
            "signature": "uint8 _underlyingDecimals",
            "full_signature": "uint8 private  _underlyingDecimals",
            "class_method_signature": "ERC4626._underlyingDecimals",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Declares a private immutable variable `_underlyingDecimals` of type `uint8`.\n * This variable is immutable, meaning its value can only be set once during construction and cannot be modified afterward.\n */"
        },
        {
            "identifier": "ERC4626ExceededMaxDeposit",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC4626ExceededMaxDeposit(address receiver, uint256 assets, uint256 max);",
            "start": "57",
            "end": "57",
            "class": "ERC4626",
            "signature": " ERC4626ExceededMaxDeposit",
            "full_signature": "function ERC4626ExceededMaxDeposit()",
            "class_method_signature": "ERC4626.ERC4626ExceededMaxDeposit",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function Deposit()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function asset() external  view returns (address assetTokenAddress)'}",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the deposit amount exceeds the maximum allowed for the receiver.\n *\n * @param receiver The address of the receiver attempting the deposit.\n * @param assets The amount of assets attempted to be deposited.\n * @param max The maximum allowed deposit amount for the receiver.\n */"
        },
        {
            "identifier": "convertToAssets",
            "parameters": "uint256 shares",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function convertToAssets(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Floor);\n    }",
            "start": "126",
            "end": "128",
            "class": "ERC4626",
            "signature": "returns (uint256) convertToAssetsuint256 shares",
            "full_signature": "function convertToAssets(uint256 shares) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.convertToAssetsuint256 shares",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function convertToAssets(uint256 shares) external  view returns (uint256 assets)'}",
            "human_labeled_comment": "/**\n * @notice Converts a given amount of shares to the corresponding amount of assets.\n * @dev This function is a virtual view function that internally calls `_convertToAssets` with the specified rounding mode (Floor).\n * @param shares The amount of shares to convert.\n * @return The equivalent amount of assets based on the provided shares.\n */"
        },
        {
            "identifier": "previewMint",
            "parameters": "uint256 shares",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function previewMint(uint256 shares) public view virtual returns (uint256) {\n        return _convertToAssets(shares, Math.Rounding.Ceil);\n    }",
            "start": "156",
            "end": "158",
            "class": "ERC4626",
            "signature": "returns (uint256) previewMintuint256 shares",
            "full_signature": "function previewMint(uint256 shares) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.previewMintuint256 shares",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function previewMint(uint256 shares) external  view returns (uint256 assets)', 'function convertToAssets(uint256 shares) external  view returns (uint256 assets)'}",
            "human_labeled_comment": "/**\n * @notice Previews the amount of assets that would be minted for a given number of shares.\n * @param shares The number of shares to preview the minting for.\n * @return The amount of assets that would be minted, rounded up to the nearest whole number.\n */"
        },
        {
            "identifier": "previewWithdraw",
            "parameters": "uint256 assets",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function previewWithdraw(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Ceil);\n    }",
            "start": "161",
            "end": "163",
            "class": "ERC4626",
            "signature": "returns (uint256) previewWithdrawuint256 assets",
            "full_signature": "function previewWithdraw(uint256 assets) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.previewWithdrawuint256 assets",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function Withdraw()', 'function asset() external  view returns (address assetTokenAddress)', 'function convertToShares(uint256 assets) external  view returns (uint256 shares)', 'function previewWithdraw(uint256 assets) external  view returns (uint256 shares)'}",
            "human_labeled_comment": "/**\n * @notice Previews the amount of shares that would be received when withdrawing a given amount of assets.\n * @param assets The amount of assets to be withdrawn.\n * @return The amount of shares that would be received, rounded up to the nearest integer.\n */"
        },
        {
            "identifier": "_convertToAssets",
            "parameters": "uint256 shares, Math.Rounding rounding",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return shares.mulDiv(totalAssets() + 1, totalSupply() + 10 ** _decimalsOffset(), rounding);\n    }",
            "start": "232",
            "end": "234",
            "class": "ERC4626",
            "signature": "returns (uint256) _convertToAssetsuint256 shares, Math.Rounding rounding",
            "full_signature": "function _convertToAssets(uint256 shares, Math.Rounding rounding) internal virtual view returns (uint256)",
            "class_method_signature": "ERC4626._convertToAssetsuint256 shares, Math.Rounding rounding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function mul(uint256 a, uint256 b) internal  pure returns (uint256)', 'function totalSupply() external  override returns (uint256)', 'function convertToAssets(uint256 shares) external  view returns (uint256 assets)', 'function totalAssets() external  view returns (uint256 totalManagedAssets)', 'function totalSupply() public virtual view returns (uint256)', 'uint256 public  totalSupply', 'function mul(int256 a, int256 b) internal  pure returns (int256)', 'function decimals() public virtual override returns (uint8)', 'function decimals() external  override returns (uint8)', 'function totalSupply() external  view returns (uint256)', 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal  pure returns (uint256 result)', 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal  pure returns (uint256)', 'function totalSupply() public virtual override returns (uint256)', 'function totalSupply() public virtual view returns (uint256 result)', 'uint8 public  decimals', 'function decimals() external  view returns (uint8)', 'function decimals() public virtual view returns (uint8)', 'uint8 internal  _decimals'}",
            "human_labeled_comment": "/**\n * @notice Converts a given number of shares into the corresponding amount of assets.\n *\n * @param shares The number of shares to convert.\n * @param rounding The rounding mode to use during the calculation.\n * @return The equivalent amount of assets based on the current total assets and total supply.\n *\n * The calculation uses the formula: \n * assets = shares * (totalAssets + 1) / (totalSupply + 10 ** _decimalsOffset())\n * where _decimalsOffset() is used to adjust for decimal precision.\n */"
        },
        {
            "identifier": "maxRedeem",
            "parameters": "address owner",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function maxRedeem(address owner) public view virtual returns (uint256) {\n        return balanceOf(owner);\n    }",
            "start": "146",
            "end": "148",
            "class": "ERC4626",
            "signature": "returns (uint256) maxRedeemaddress owner",
            "full_signature": "function maxRedeem(address owner) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.maxRedeemaddress owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function balanceOf(address account) external  view returns (uint256)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function maxRedeem(address owner) external  view returns (uint256 maxShares)', 'function balanceOf(address account) public virtual override returns (uint256)', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function balanceOf(address account) public virtual view returns (uint256)', 'mapping(address => uint256) public  balanceOf', 'mapping (address => uint) public  balanceOf', 'function balanceOf(address owner) external  override returns (uint256)', 'function balanceOf(address owner) public virtual view returns (uint256 result)'}",
            "human_labeled_comment": "/**\n * @notice Returns the maximum amount of tokens that can be redeemed by the specified owner.\n * @dev This function is virtual and can be overridden by derived contracts.\n * @param owner The address of the token owner.\n * @return uint256 The maximum amount of tokens that can be redeemed, which is equal to the owner's balance.\n */"
        },
        {
            "identifier": "previewDeposit",
            "parameters": "uint256 assets",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function previewDeposit(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }",
            "start": "151",
            "end": "153",
            "class": "ERC4626",
            "signature": "returns (uint256) previewDeposituint256 assets",
            "full_signature": "function previewDeposit(uint256 assets) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.previewDeposituint256 assets",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function asset() external  view returns (address assetTokenAddress)', 'function convertToShares(uint256 assets) external  view returns (uint256 shares)', 'function previewDeposit(uint256 assets) external  view returns (uint256 shares)', 'function Deposit()'}",
            "human_labeled_comment": "/**\n * @notice Previews the amount of shares that would be received for depositing a given amount of assets.\n * @param assets The amount of assets to be deposited.\n * @return The amount of shares that would be received, calculated using the `_convertToShares` function with rounding down.\n */"
        },
        {
            "identifier": "_asset",
            "parameters": "",
            "modifiers": "",
            "return": "IERC20",
            "body": "IERC20 private immutable _asset;",
            "start": "51",
            "end": "51",
            "class": "ERC4626",
            "signature": "IERC20 _asset",
            "full_signature": "IERC20 private  _asset",
            "class_method_signature": "ERC4626._asset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function asset() external  view returns (address assetTokenAddress)'}",
            "human_labeled_comment": "/**\n * @notice A private immutable variable that holds a reference to an ERC20 token contract.\n * @dev The `_asset` variable is immutable, meaning it can only be set once during contract deployment and cannot be modified afterward.\n */"
        },
        {
            "identifier": "redeem",
            "parameters": "uint256 shares, address receiver, address owner",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function redeem(uint256 shares, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxShares = maxRedeem(owner);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxRedeem(owner, shares, maxShares);\n        }\n\n        uint256 assets = previewRedeem(shares);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return assets;\n    }",
            "start": "210",
            "end": "220",
            "class": "ERC4626",
            "signature": "returns (uint256) redeemuint256 shares, address receiver, address owner",
            "full_signature": "function redeem(uint256 shares, address receiver, address owner) public virtual  returns (uint256)",
            "class_method_signature": "ERC4626.redeemuint256 shares, address receiver, address owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function previewRedeem(uint256 shares) external  view returns (uint256 assets)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function maxRedeem(address owner) external  view returns (uint256 maxShares)', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function redeem(uint256 shares, address receiver, address owner) external   returns (uint256 assets)', 'function asset() external  view returns (address assetTokenAddress)', 'function withdraw(uint256 assets, address receiver, address owner) external   returns (uint256 shares)'}",
            "human_labeled_comment": "/**\n * @notice Redeems shares for assets and transfers them to the receiver.\n *\n * Steps:\n * 1. Retrieve the maximum number of shares that can be redeemed by the owner.\n * 2. If the requested shares exceed the maximum redeemable shares, revert with an error.\n *\n * 3. Calculate the equivalent assets for the given shares using `previewRedeem`.\n * 4. Withdraw the assets from the owner and transfer them to the receiver.\n *\n * 5. Return the amount of assets redeemed.\n *\n * @param shares The number of shares to redeem.\n * @param receiver The address to receive the redeemed assets.\n * @param owner The address of the owner of the shares.\n * @return The amount of assets redeemed.\n */"
        },
        {
            "identifier": "maxDeposit",
            "parameters": "address",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function maxDeposit(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }",
            "start": "131",
            "end": "133",
            "class": "ERC4626",
            "signature": "returns (uint256) maxDepositaddress",
            "full_signature": "function maxDeposit(address) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.maxDepositaddress",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function Deposit()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function maxDeposit(address receiver) external  view returns (uint256 maxAssets)'}",
            "human_labeled_comment": "/**\n * @notice Returns the maximum deposit amount allowed for a given address.\n * @dev This is a virtual function that can be overridden by derived contracts.\n * @param address The address for which the maximum deposit is being queried.\n * @return uint256 The maximum deposit amount, which is set to the maximum value of uint256.\n */"
        },
        {
            "identifier": "ERC4626ExceededMaxWithdraw",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC4626ExceededMaxWithdraw(address owner, uint256 assets, uint256 max);",
            "start": "67",
            "end": "67",
            "class": "ERC4626",
            "signature": " ERC4626ExceededMaxWithdraw",
            "full_signature": "function ERC4626ExceededMaxWithdraw()",
            "class_method_signature": "ERC4626.ERC4626ExceededMaxWithdraw",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function Withdraw()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function asset() external  view returns (address assetTokenAddress)'}",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the requested withdrawal amount exceeds the maximum allowed for the owner.\n * @param owner The address of the owner attempting the withdrawal.\n * @param assets The amount of assets requested for withdrawal.\n * @param max The maximum amount of assets allowed for withdrawal.\n */"
        },
        {
            "identifier": "maxMint",
            "parameters": "address",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function maxMint(address) public view virtual returns (uint256) {\n        return type(uint256).max;\n    }",
            "start": "136",
            "end": "138",
            "class": "ERC4626",
            "signature": "returns (uint256) maxMintaddress",
            "full_signature": "function maxMint(address) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.maxMintaddress",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function maxMint(address receiver) external  view returns (uint256 maxShares)'}",
            "human_labeled_comment": "/**\n * @notice Returns the maximum amount of tokens that can be minted for a given address.\n * @dev This function is virtual and can be overridden by derived contracts.\n * @param address The address for which the maximum mintable amount is queried.\n * @return uint256 The maximum amount of tokens that can be minted, which is the maximum value of uint256.\n */"
        },
        {
            "identifier": "_convertToShares",
            "parameters": "uint256 assets, Math.Rounding rounding",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {\n        return assets.mulDiv(totalSupply() + 10 ** _decimalsOffset(), totalAssets() + 1, rounding);\n    }",
            "start": "225",
            "end": "227",
            "class": "ERC4626",
            "signature": "returns (uint256) _convertToSharesuint256 assets, Math.Rounding rounding",
            "full_signature": "function _convertToShares(uint256 assets, Math.Rounding rounding) internal virtual view returns (uint256)",
            "class_method_signature": "ERC4626._convertToSharesuint256 assets, Math.Rounding rounding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function mul(uint256 a, uint256 b) internal  pure returns (uint256)', 'function totalAssets() external  view returns (uint256 totalManagedAssets)', 'function totalSupply() public virtual view returns (uint256)', 'function decimals() external  view returns (uint8)', 'uint8 internal  _decimals', 'function totalSupply() external  override returns (uint256)', 'function asset() external  view returns (address assetTokenAddress)', 'uint256 public  totalSupply', 'function decimals() public virtual override returns (uint8)', 'function mul(int256 a, int256 b) internal  pure returns (int256)', 'function decimals() external  override returns (uint8)', 'function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal  pure returns (uint256)', 'function decimals() public virtual view returns (uint8)', 'function convertToShares(uint256 assets) external  view returns (uint256 shares)', 'function totalSupply() public virtual override returns (uint256)', 'function mulDiv(uint256 x, uint256 y, uint256 denominator) internal  pure returns (uint256 result)', 'function totalSupply() external  view returns (uint256)', 'uint8 public  decimals', 'function totalSupply() public virtual view returns (uint256 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a given amount of assets into shares based on the current total supply and total assets.\n * \n * @param assets The amount of assets to convert into shares.\n * @param rounding The rounding mode to use during the calculation.\n * \n * @return The calculated amount of shares corresponding to the provided assets.\n * \n * The calculation uses the formula: \n * shares = assets * (totalSupply + 10^decimalsOffset) / (totalAssets + 1)\n * \n * This function is internal and virtual, allowing it to be overridden by derived contracts.\n */"
        },
        {
            "identifier": "totalAssets",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function totalAssets() public view virtual returns (uint256) {\n        return _asset.balanceOf(address(this));\n    }",
            "start": "116",
            "end": "118",
            "class": "ERC4626",
            "signature": "returns (uint256) totalAssets",
            "full_signature": "function totalAssets() public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.totalAssets",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function balanceOf(address account) external  view returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function totalAssets() external  view returns (uint256 totalManagedAssets)', 'function balanceOf(address account) public virtual override returns (uint256)', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function balanceOf(address account) public virtual view returns (uint256)', 'function asset() external  view returns (address assetTokenAddress)', 'mapping (address => uint) public  balanceOf', 'mapping(address => uint256) public  balanceOf', 'function balanceOf(address owner) external  override returns (uint256)', 'function balanceOf(address owner) public virtual view returns (uint256 result)'}",
            "human_labeled_comment": "/**\n * @notice Returns the total amount of assets held by the contract.\n *\n * @return The balance of the asset held by the contract.\n */"
        },
        {
            "identifier": "_withdraw",
            "parameters": "address caller, address receiver, address owner, uint256 assets, uint256 shares",
            "modifiers": "",
            "return": "",
            "body": "function _withdraw(\n        address caller,\n        address receiver,\n        address owner,\n        uint256 assets,\n        uint256 shares\n    ) internal virtual {\n        if (caller != owner) {\n            _spendAllowance(owner, caller, shares);\n        }\n\n        // If _asset is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the\n        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the\n        // shares are burned and after the assets are transferred, which is a valid state.\n        _burn(owner, shares);\n        SafeERC20.safeTransfer(_asset, receiver, assets);\n\n        emit Withdraw(caller, receiver, owner, assets, shares);\n    }",
            "start": "256",
            "end": "277",
            "class": "ERC4626",
            "signature": " _withdrawaddress caller, address receiver, address owner, uint256 assets, uint256 shares",
            "full_signature": "function _withdraw(address caller, address receiver, address owner, uint256 assets, uint256 shares) internal virtual",
            "class_method_signature": "ERC4626._withdrawaddress caller, address receiver, address owner, uint256 assets, uint256 shares",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function _spendAllowance(address owner, address spender, uint256 value) internal virtual', 'function withdraw(uint256 assets, address receiver, address owner) external   returns (uint256 shares)', 'function transfer(address to, uint256 value) external   returns (bool)', 'function _spendAllowance(address owner, address spender, uint256 amount) internal virtual', 'function add(uint x, uint y) internal  pure returns (uint z)', 'function transfer(address to, uint256 value) public virtual  returns (bool)', 'function burn(address from, uint256 value) public virtual', 'function Withdraw()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function transfer(address to, uint256 amount) external   returns (bool)', 'function transfer(address to, uint256 amount) public virtual  returns (bool)', 'function asset() external  view returns (address assetTokenAddress)', 'function _burn(address from, uint256 amount) internal virtual', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function _burn(address account, uint256 amount) internal virtual', 'function _burn(address account, uint256 value) internal', 'function transfer(address to, uint256 amount) public virtual override returns (bool)', 'function transfer(address dst, uint wad) public virtual  returns (bool)', 'function Transfer()', 'function safeTransfer(IERC20 token, address to, uint256 value) internal', 'function transfer(address recipient, uint256 amount) external virtual override returns (bool)', 'function transfer(address recipient, uint256 amount) external   returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Internal function to handle the withdrawal of assets and shares.\n *\n * Steps:\n * 1. Check if the caller is not the owner. If true, spend the allowance granted to the caller by the owner.\n * 2. Burn the shares from the owner's account.\n * 3. Transfer the specified amount of assets to the receiver using SafeERC20.safeTransfer.\n * 4. Emit a Withdraw event with the details of the withdrawal.\n *\n * Notes:\n * - If the asset is ERC-777, the transfer can trigger a reentrancy attack after the transfer via the `tokensReceived` hook.\n * - The `tokensToSend` hook, triggered before the transfer, calls the vault, which is assumed to be non-malicious.\n * - To mitigate reentrancy, the transfer is performed after burning the shares, ensuring any reentrancy occurs after the state is valid.\n */"
        },
        {
            "identifier": "maxWithdraw",
            "parameters": "address owner",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function maxWithdraw(address owner) public view virtual returns (uint256) {\n        return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);\n    }",
            "start": "141",
            "end": "143",
            "class": "ERC4626",
            "signature": "returns (uint256) maxWithdrawaddress owner",
            "full_signature": "function maxWithdraw(address owner) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.maxWithdrawaddress owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function maxWithdraw(address owner) external  view returns (uint256 maxAssets)', 'function balanceOf(address account) external  view returns (uint256)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function balanceOf(address account) public virtual override returns (uint256)', 'function Withdraw()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function balanceOf(address account) public virtual view returns (uint256)', 'mapping(address => uint256) public  balanceOf', 'mapping (address => uint) public  balanceOf', 'function balanceOf(address owner) external  override returns (uint256)', 'function balanceOf(address owner) public virtual view returns (uint256 result)', 'function convertToAssets(uint256 shares) external  view returns (uint256 assets)'}",
            "human_labeled_comment": "/**\n * @notice Returns the maximum amount of assets that can be withdrawn by the owner.\n * @param owner The address of the owner whose maximum withdrawable assets are being queried.\n * @return The maximum amount of assets that can be withdrawn, calculated by converting the owner's balance to assets using floor rounding.\n */"
        },
        {
            "identifier": "ERC4626ExceededMaxMint",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC4626ExceededMaxMint(address receiver, uint256 shares, uint256 max);",
            "start": "62",
            "end": "62",
            "class": "ERC4626",
            "signature": " ERC4626ExceededMaxMint",
            "full_signature": "function ERC4626ExceededMaxMint()",
            "class_method_signature": "ERC4626.ERC4626ExceededMaxMint",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function add(int256 a, int256 b) internal  pure returns (int256)'}",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the mint operation exceeds the maximum allowed shares for the receiver.\n * @param receiver The address of the receiver attempting to mint shares.\n * @param shares The number of shares attempted to be minted.\n * @param max The maximum number of shares allowed to be minted.\n */"
        },
        {
            "identifier": "_decimalsOffset",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint8)",
            "body": "function _decimalsOffset() internal view virtual returns (uint8) {\n        return 0;\n    }",
            "start": "279",
            "end": "281",
            "class": "ERC4626",
            "signature": "returns (uint8) _decimalsOffset",
            "full_signature": "function _decimalsOffset() internal virtual view returns (uint8)",
            "class_method_signature": "ERC4626._decimalsOffset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function decimals() public virtual override returns (uint8)', 'function decimals() external  override returns (uint8)', 'uint8 public  decimals', 'function decimals() external  view returns (uint8)', 'function decimals() public virtual view returns (uint8)', 'uint8 internal  _decimals'}",
            "human_labeled_comment": "/**\n * @notice Returns the decimal offset for the token.\n * @dev This is a virtual function that can be overridden by derived contracts.\n * @return uint8 The decimal offset, which is 0 by default.\n */"
        },
        {
            "identifier": "asset",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (address)",
            "body": "function asset() public view virtual returns (address) {\n        return address(_asset);\n    }",
            "start": "111",
            "end": "113",
            "class": "ERC4626",
            "signature": "returns (address) asset",
            "full_signature": "function asset() public virtual view returns (address)",
            "class_method_signature": "ERC4626.asset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(int256 a, int256 b) internal  pure returns (int256)', 'function add(uint x, uint y) internal  pure returns (uint z)', 'function asset() external  view returns (address assetTokenAddress)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Returns the address of the underlying asset.\n *\n * @return The address of the asset stored in the `_asset` variable.\n */"
        },
        {
            "identifier": "mint",
            "parameters": "uint256 shares, address receiver",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function mint(uint256 shares, address receiver) public virtual returns (uint256) {\n        uint256 maxShares = maxMint(receiver);\n        if (shares > maxShares) {\n            revert ERC4626ExceededMaxMint(receiver, shares, maxShares);\n        }\n\n        uint256 assets = previewMint(shares);\n        _deposit(_msgSender(), receiver, assets, shares);\n\n        return assets;\n    }",
            "start": "184",
            "end": "194",
            "class": "ERC4626",
            "signature": "returns (uint256) mintuint256 shares, address receiver",
            "full_signature": "function mint(uint256 shares, address receiver) public virtual  returns (uint256)",
            "class_method_signature": "ERC4626.mintuint256 shares, address receiver",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function min(int256 a, int256 b) internal  pure returns (int256)', 'function add(uint x, uint y) internal  pure returns (uint z)', 'function mint(uint256 shares, address receiver) external   returns (uint256 assets)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function asset() external  view returns (address assetTokenAddress)', 'function deposit(uint256 assets, address receiver) external   returns (uint256 shares)', 'function previewMint(uint256 shares) external  view returns (uint256 assets)', 'function min(uint256 a, uint256 b) internal  pure returns (uint256)', 'function mint(address usr, uint wad) public virtual', 'function maxMint(address receiver) external  view returns (uint256 maxShares)', 'function mint(address to, uint256 value) public virtual'}",
            "human_labeled_comment": "/**\n * @notice Mints a specified number of shares for a receiver by depositing the equivalent amount of assets.\n *\n * Steps:\n * 1. Calculate the maximum number of shares that can be minted for the receiver using `maxMint`.\n * 2. If the requested number of shares exceeds the maximum allowed, revert with an error indicating the limit is exceeded.\n * 3. Calculate the equivalent amount of assets required to mint the specified shares using `previewMint`.\n * 4. Deposit the calculated assets and mint the shares for the receiver using `_deposit`.\n * 5. Return the amount of assets deposited.\n */"
        },
        {
            "identifier": "_tryGetAssetDecimals",
            "parameters": "IERC20 asset_",
            "modifiers": "view",
            "return": "returns (bool ok, uint8 assetDecimals)",
            "body": "function _tryGetAssetDecimals(IERC20 asset_) private view returns (bool ok, uint8 assetDecimals) {\n        (bool success, bytes memory encodedDecimals) = address(asset_).staticcall(\n            abi.encodeCall(IERC20Metadata.decimals, ())\n        );\n        if (success && encodedDecimals.length >= 32) {\n            uint256 returnedDecimals = abi.decode(encodedDecimals, (uint256));\n            if (returnedDecimals <= type(uint8).max) {\n                return (true, uint8(returnedDecimals));\n            }\n        }\n        return (false, 0);\n    }",
            "start": "86",
            "end": "97",
            "class": "ERC4626",
            "signature": "returns (bool ok, uint8 assetDecimals) _tryGetAssetDecimalsIERC20 asset_",
            "full_signature": "function _tryGetAssetDecimals(IERC20 asset_) private  view returns (bool ok, uint8 assetDecimals)",
            "class_method_signature": "ERC4626._tryGetAssetDecimalsIERC20 asset_",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function decimals() public virtual override returns (uint8)', 'function decimals() external  override returns (uint8)', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function asset() external  view returns (address assetTokenAddress)', 'uint8 public  decimals', 'function decimals() external  view returns (uint8)', 'function decimals() public virtual view returns (uint8)'}",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve the decimals of an ERC20 token.\n *\n * Steps:\n * 1. Perform a static call to the `decimals` function of the ERC20 token.\n * 2. Check if the call was successful and if the returned data is at least 32 bytes long.\n * 3. Decode the returned data into a uint256.\n * 4. If the decoded value is within the range of a uint8, return `true` and the decoded value.\n * 5. If the call fails or the decoded value is out of range, return `false` and `0`.\n */"
        },
        {
            "identifier": "ERC4626ExceededMaxRedeem",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ERC4626ExceededMaxRedeem(address owner, uint256 shares, uint256 max);",
            "start": "72",
            "end": "72",
            "class": "ERC4626",
            "signature": " ERC4626ExceededMaxRedeem",
            "full_signature": "function ERC4626ExceededMaxRedeem()",
            "class_method_signature": "ERC4626.ERC4626ExceededMaxRedeem",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function add(int256 a, int256 b) internal  pure returns (int256)'}",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the maximum redeemable shares for an owner has been exceeded.\n * @param owner The address of the owner attempting to redeem shares.\n * @param shares The number of shares attempted to be redeemed.\n * @param max The maximum number of shares allowed to be redeemed.\n */"
        },
        {
            "identifier": "_deposit",
            "parameters": "address caller, address receiver, uint256 assets, uint256 shares",
            "modifiers": "",
            "return": "",
            "body": "function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual {\n        // If _asset is ERC-777, `transferFrom` can trigger a reentrancy BEFORE the transfer happens through the\n        // `tokensToSend` hook. On the other hand, the `tokenReceived` hook, that is triggered after the transfer,\n        // calls the vault, which is assumed not malicious.\n        //\n        // Conclusion: we need to do the transfer before we mint so that any reentrancy would happen before the\n        // assets are transferred and before the shares are minted, which is a valid state.\n        // slither-disable-next-line reentrancy-no-eth\n        SafeERC20.safeTransferFrom(_asset, caller, address(this), assets);\n        _mint(receiver, shares);\n\n        emit Deposit(caller, receiver, assets, shares);\n    }",
            "start": "239",
            "end": "251",
            "class": "ERC4626",
            "signature": " _depositaddress caller, address receiver, uint256 assets, uint256 shares",
            "full_signature": "function _deposit(address caller, address receiver, uint256 assets, uint256 shares) internal virtual",
            "class_method_signature": "ERC4626._depositaddress caller, address receiver, uint256 assets, uint256 shares",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function min(int256 a, int256 b) internal  pure returns (int256)', 'function transferFrom(address from, address to, uint256 value) public virtual  returns (bool)', 'function transferFrom(address from, address to, uint256 amount) external   returns (bool)', 'function transferFrom(address src, address dst, uint wad) public virtual  returns (bool)', 'function min(uint256 a, uint256 b) internal  pure returns (uint256)', 'function transfer(address to, uint256 value) external   returns (bool)', 'function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal', 'function transfer(address to, uint256 value) public virtual  returns (bool)', 'function add(uint x, uint y) internal  pure returns (uint z)', 'function mint(uint256 shares, address receiver) external   returns (uint256 assets)', 'function _mint(address account, uint256 value) internal', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function transfer(address to, uint256 amount) external   returns (bool)', 'function transfer(address to, uint256 amount) public virtual  returns (bool)', 'function transferFrom(address from, address to, uint256 amount) public virtual  returns (bool)', 'function asset() external  view returns (address assetTokenAddress)', 'function mint(address to, uint256 value) public virtual', 'function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool)', 'function transferFrom(address from, address to, uint256 value) external   returns (bool)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function _mint(address account, uint256 amount) internal virtual', 'function _mint(address to, uint256 amount) internal virtual', 'function deposit(uint256 assets, address receiver) external   returns (uint256 shares)', 'function transferFrom(address sender, address recipient, uint256 amount) external   returns (bool)', 'function transfer(address to, uint256 amount) public virtual override returns (bool)', 'function transfer(address dst, uint wad) public virtual  returns (bool)', 'function Transfer()', 'function Deposit()', 'function transferFrom(address sender, address recipient, uint256 amount) external virtual override returns (bool)', 'function safeTransfer(IERC20 token, address to, uint256 value) internal', 'function mint(address usr, uint wad) public virtual', 'function transfer(address recipient, uint256 amount) external virtual override returns (bool)', 'function transfer(address recipient, uint256 amount) external   returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Internal function to handle the deposit of assets and minting of shares.\n *\n * Steps:\n * 1. Transfer assets from the caller to the contract using `safeTransferFrom` to prevent reentrancy attacks.\n * 2. Mint shares to the receiver.\n * 3. Emit a `Deposit` event with the caller, receiver, assets, and shares as parameters.\n *\n * @dev This function is designed to handle potential reentrancy attacks by ensuring the transfer happens before minting.\n *      This ensures that any reentrancy would occur before the assets are transferred and shares are minted, maintaining a valid state.\n *\n * @param caller The address initiating the deposit.\n * @param receiver The address receiving the shares.\n * @param assets The amount of assets being deposited.\n * @param shares The amount of shares being minted.\n */"
        },
        {
            "identifier": "withdraw",
            "parameters": "uint256 assets, address receiver, address owner",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function withdraw(uint256 assets, address receiver, address owner) public virtual returns (uint256) {\n        uint256 maxAssets = maxWithdraw(owner);\n        if (assets > maxAssets) {\n            revert ERC4626ExceededMaxWithdraw(owner, assets, maxAssets);\n        }\n\n        uint256 shares = previewWithdraw(assets);\n        _withdraw(_msgSender(), receiver, owner, assets, shares);\n\n        return shares;\n    }",
            "start": "197",
            "end": "207",
            "class": "ERC4626",
            "signature": "returns (uint256) withdrawuint256 assets, address receiver, address owner",
            "full_signature": "function withdraw(uint256 assets, address receiver, address owner) public virtual  returns (uint256)",
            "class_method_signature": "ERC4626.withdrawuint256 assets, address receiver, address owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function maxWithdraw(address owner) external  view returns (uint256 maxAssets)', 'function add(uint x, uint y) internal  pure returns (uint z)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function previewWithdraw(uint256 assets) external  view returns (uint256 shares)', 'function max(int256 a, int256 b) internal  pure returns (int256)', 'function add(uint256 a, uint256 b) internal  pure returns (uint256)', 'function Withdraw()', 'function add(int256 a, int256 b) internal  pure returns (int256)', 'function asset() external  view returns (address assetTokenAddress)', 'function withdraw(uint256 assets, address receiver, address owner) external   returns (uint256 shares)'}",
            "human_labeled_comment": "/**\n * @notice Withdraws a specified amount of assets from the contract and transfers them to the receiver.\n *\n * Steps:\n * 1. Retrieve the maximum amount of assets that can be withdrawn by the owner.\n * 2. If the requested assets exceed the maximum allowed, revert with an error indicating the limit is exceeded.\n * 3. Calculate the equivalent number of shares for the requested assets using `previewWithdraw`.\n * 4. Execute the withdrawal by calling the internal `_withdraw` function, transferring assets to the receiver and burning the corresponding shares.\n * 5. Return the number of shares burned during the withdrawal.\n *\n * @param assets The amount of assets to withdraw.\n * @param receiver The address to receive the withdrawn assets.\n * @param owner The address of the owner whose assets are being withdrawn.\n * @return The number of shares burned during the withdrawal.\n */"
        },
        {
            "identifier": "convertToShares",
            "parameters": "uint256 assets",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function convertToShares(uint256 assets) public view virtual returns (uint256) {\n        return _convertToShares(assets, Math.Rounding.Floor);\n    }",
            "start": "121",
            "end": "123",
            "class": "ERC4626",
            "signature": "returns (uint256) convertToSharesuint256 assets",
            "full_signature": "function convertToShares(uint256 assets) public virtual view returns (uint256)",
            "class_method_signature": "ERC4626.convertToSharesuint256 assets",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function asset() external  view returns (address assetTokenAddress)', 'function convertToShares(uint256 assets) external  view returns (uint256 shares)'}",
            "human_labeled_comment": "/**\n * @notice Converts a given amount of assets into the equivalent number of shares.\n * @dev This function is a virtual view function that internally calls `_convertToShares` with the provided assets and a rounding mode of `Math.Rounding.Floor`.\n * @param assets The amount of assets to be converted into shares.\n * @return The equivalent number of shares for the given assets.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/proxy/Clones.sol": [
        {
            "identifier": "CloneArgumentsTooLong",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error CloneArgumentsTooLong();",
            "start": "21",
            "end": "21",
            "class": "Clones",
            "signature": " CloneArgumentsTooLong",
            "full_signature": "function CloneArgumentsTooLong()",
            "class_method_signature": "Clones.CloneArgumentsTooLong",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Error indicating that the arguments provided for cloning are too long.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/Ethernaut.sol": [
        {
            "identifier": "submitFailure",
            "parameters": "address instance, address level, address player",
            "modifiers": "",
            "return": "",
            "body": "function submitFailure(address instance, address level, address player) external;",
            "start": "12",
            "end": "12",
            "class": "IStatistics",
            "signature": " submitFailureaddress instance, address level, address player",
            "full_signature": "function submitFailure(address instance, address level, address player) external",
            "class_method_signature": "IStatistics.submitFailureaddress instance, address level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"./levels/base/Level.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Submits a failure for a specific level instance and player.\n * @param instance The address of the level instance.\n * @param level The address of the level contract.\n * @param player The address of the player who failed the level.\n */"
        },
        {
            "identifier": "submitSuccess",
            "parameters": "address instance, address level, address player",
            "modifiers": "",
            "return": "",
            "body": "function submitSuccess(address instance, address level, address player) external;",
            "start": "14",
            "end": "14",
            "class": "IStatistics",
            "signature": " submitSuccessaddress instance, address level, address player",
            "full_signature": "function submitSuccess(address instance, address level, address player) external",
            "class_method_signature": "IStatistics.submitSuccessaddress instance, address level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"./levels/base/Level.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Submits a successfully completed level instance.\n * @param instance The address of the level instance to be submitted.\n * @param level The address of the level contract.\n * @param player The address of the player who completed the level.\n */"
        },
        {
            "identifier": "createNewInstance",
            "parameters": "address instance, address level, address player",
            "modifiers": "",
            "return": "",
            "body": "function createNewInstance(address instance, address level, address player) external;",
            "start": "10",
            "end": "10",
            "class": "IStatistics",
            "signature": " createNewInstanceaddress instance, address level, address player",
            "full_signature": "function createNewInstance(address instance, address level, address player) external",
            "class_method_signature": "IStatistics.createNewInstanceaddress instance, address level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"./levels/base/Level.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Creates a new instance of a level for a player.\n *\n * @param instance The address of the new instance to be created.\n * @param level The address of the level for which the instance is being created.\n * @param player The address of the player for whom the instance is being created.\n */"
        },
        {
            "identifier": "saveNewLevel",
            "parameters": "address level",
            "modifiers": "",
            "return": "",
            "body": "function saveNewLevel(address level) external;",
            "start": "8",
            "end": "8",
            "class": "IStatistics",
            "signature": " saveNewLeveladdress level",
            "full_signature": "function saveNewLevel(address level) external",
            "class_method_signature": "IStatistics.saveNewLeveladdress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"./levels/base/Level.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "a new level address to the contract.\n * @param level The address of the new level to be saved.\n * @dev This function is external, meaning it can only be called from outside the contract.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/metrics/Statistics.sol": [
        {
            "identifier": "playerExists",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => bool)",
            "body": "mapping(address => bool) private playerExists;",
            "start": "36",
            "end": "36",
            "class": "Statistics",
            "signature": "mapping(address => bool) playerExists",
            "full_signature": "mapping(address => bool) private  playerExists",
            "class_method_signature": "Statistics.playerExists",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping to track whether a player exists.\n * @dev The mapping stores a boolean value for each address, indicating whether the player exists or not.\n */"
        },
        {
            "identifier": "getTotalNoOfFailedSubmissionsByPlayer",
            "parameters": "address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfFailedSubmissionsByPlayer(address player)\n        public\n        view\n        playerExistsCheck(player)\n        returns (uint256)\n    {\n        return globalNoOfFailedSubmissionsByPlayer[player];\n    }",
            "start": "164",
            "end": "171",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfFailedSubmissionsByPlayeraddress player",
            "full_signature": "function getTotalNoOfFailedSubmissionsByPlayer(address player) public  playerExistsCheck(player) returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfFailedSubmissionsByPlayeraddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the total number of failed submissions by a specific player.\n * \n * @param player The address of the player whose failed submissions are to be queried.\n * @return uint256 The total number of failed submissions by the player.\n * \n * Requirements:\n * - The player must exist (enforced by the `playerExistsCheck` modifier).\n */"
        },
        {
            "identifier": "globalNoOfFailedSubmissions",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private globalNoOfFailedSubmissions;",
            "start": "12",
            "end": "12",
            "class": "Statistics",
            "signature": "uint256 globalNoOfFailedSubmissions",
            "full_signature": "uint256 private  globalNoOfFailedSubmissions",
            "class_method_signature": "Statistics.globalNoOfFailedSubmissions",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable that tracks the total number of failed submissions globally.\n */"
        },
        {
            "identifier": "getSubmissionsForLevelByPlayer",
            "parameters": "address player, address level, uint256 index",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (uint256)",
            "body": "function getSubmissionsForLevelByPlayer(address player, address level, uint256 index)\n        public\n        view\n        playerExistsCheck(player)\n        levelExistsCheck(level)\n        returns (uint256)\n    {\n        require(playerStats[player][level].timeSubmitted.length >= index, \"Index outbounded\");\n        return playerStats[player][level].timeSubmitted[index];\n    }",
            "start": "218",
            "end": "227",
            "class": "Statistics",
            "signature": "returns (uint256) getSubmissionsForLevelByPlayeraddress player, address level, uint256 index",
            "full_signature": "function getSubmissionsForLevelByPlayer(address player, address level, uint256 index) public  levelExistsCheck(level) returns (uint256)",
            "class_method_signature": "Statistics.getSubmissionsForLevelByPlayeraddress player, address level, uint256 index",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the submission time for a specific level by a player at a given index.\n *\n * @param player The address of the player.\n * @param level The address of the level.\n * @param index The index of the submission time to retrieve.\n *\n * @return The submission time at the specified index.\n *\n * Requirements:\n * - The player must exist (checked by `playerExistsCheck` modifier).\n * - The level must exist (checked by `levelExistsCheck` modifier).\n * - The index must be within the bounds of the submission times array.\n *\n * Reverts:\n * - If the index is out of bounds, reverts with \"Index outbounded\".\n */"
        },
        {
            "identifier": "submitFailure",
            "parameters": "address instance, address level, address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "",
            "body": "function submitFailure(address instance, address level, address player)\n        external\n        onlyEthernaut\n        levelExistsCheck(level)\n        playerExistsCheck(player)\n    {\n        require(playerStats[player][level].instance != address(0), \"Instance for the level is not created\");\n        require(playerStats[player][level].instance == instance, \"Submitted instance is not the created one\");\n        require(playerStats[player][level].isCompleted == false, \"Level already completed\");\n        playerStats[player][level].timeSubmitted.push(block.timestamp);\n        levelStats[level].noOfSubmissions_Failed++;\n        globalNoOfFailedSubmissions++;\n        globalNoOfFailedSubmissionsByPlayer[player]++;\n    }",
            "start": "122",
            "end": "135",
            "class": "Statistics",
            "signature": " submitFailureaddress instance, address level, address player",
            "full_signature": "function submitFailure(address instance, address level, address player) external  playerExistsCheck(player)",
            "class_method_signature": "Statistics.submitFailureaddress instance, address level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Submits a failure for a level instance.\n *\n * Requirements:\n * 1. Only the Ethernaut contract can call this function.\n * 2. The level must exist.\n * 3. The player must exist.\n *\n * Steps:\n * 1. Ensure that an instance for the level has been created for the player.\n * 2. Ensure that the submitted instance matches the created instance.\n * 3. Ensure that the level has not already been completed.\n *\n * 4. Record the submission timestamp for the player's level instance.\n * 5. Increment the number of failed submissions for the level.\n * 6. Increment the global number of failed submissions.\n * 7. Increment the global number of failed submissions for the player.\n */"
        },
        {
            "identifier": "levelExists",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => bool)",
            "body": "mapping(address => bool) private levelExists;",
            "start": "37",
            "end": "37",
            "class": "Statistics",
            "signature": "mapping(address => bool) levelExists",
            "full_signature": "mapping(address => bool) private  levelExists",
            "class_method_signature": "Statistics.levelExists",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that tracks whether a level exists for a given address.\n * @dev The mapping stores a boolean value for each address, indicating whether the level exists.\n */"
        },
        {
            "identifier": "getTotalNoOfLevelInstancesCompletedByPlayer",
            "parameters": "address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfLevelInstancesCompletedByPlayer(address player)\n        public\n        view\n        playerExistsCheck(player)\n        returns (uint256)\n    {\n        return globalNoOfInstancesCompletedByPlayer[player];\n    }",
            "start": "154",
            "end": "161",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfLevelInstancesCompletedByPlayeraddress player",
            "full_signature": "function getTotalNoOfLevelInstancesCompletedByPlayer(address player) public  playerExistsCheck(player) returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfLevelInstancesCompletedByPlayeraddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the total number of level instances completed by a specific player.\n *\n * @param player The address of the player whose completed instances are being queried.\n * @return uint256 The total number of level instances completed by the player.\n *\n * Requirements:\n * - The player must exist (enforced by the `playerExistsCheck` modifier).\n */"
        },
        {
            "identifier": "getTotalNoOfLevelInstancesCompleted",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfLevelInstancesCompleted() public view returns (uint256) {\n        return globalNoOfInstancesCompleted;\n    }",
            "start": "263",
            "end": "265",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfLevelInstancesCompleted",
            "full_signature": "function getTotalNoOfLevelInstancesCompleted() public  view returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfLevelInstancesCompleted",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the total number of level instances that have been completed globally.\n *\n * @return uint256 The total number of completed level instances.\n */"
        },
        {
            "identifier": "getNoOfCompletedSubmissionsForLevel",
            "parameters": "address level",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (uint256)",
            "body": "function getNoOfCompletedSubmissionsForLevel(address level) public view levelExistsCheck(level) returns (uint256) {\n        return levelStats[level].noOfInstancesSubmitted_Success;\n    }",
            "start": "283",
            "end": "285",
            "class": "Statistics",
            "signature": "returns (uint256) getNoOfCompletedSubmissionsForLeveladdress level",
            "full_signature": "function getNoOfCompletedSubmissionsForLevel(address level) public  levelExistsCheck(level) returns (uint256)",
            "class_method_signature": "Statistics.getNoOfCompletedSubmissionsForLeveladdress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the number of successful submissions for a specific level.\n * @param level The address of the level to query.\n * @return uint256 The number of successful submissions for the specified level.\n * @dev This function includes a modifier `levelExistsCheck` to ensure the level exists before querying.\n */"
        },
        {
            "identifier": "doesPlayerExist",
            "parameters": "address player",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function doesPlayerExist(address player) public view returns (bool) {\n        return playerExists[player];\n    }",
            "start": "292",
            "end": "294",
            "class": "Statistics",
            "signature": "returns (bool) doesPlayerExistaddress player",
            "full_signature": "function doesPlayerExist(address player) public  view returns (bool)",
            "class_method_signature": "Statistics.doesPlayerExistaddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a player exists in the system.\n *\n * @param player The address of the player to check.\n * @return bool Returns true if the player exists, otherwise false.\n */"
        },
        {
            "identifier": "players",
            "parameters": "",
            "modifiers": "",
            "return": "address[]",
            "body": "address[] public players;",
            "start": "8",
            "end": "8",
            "class": "Statistics",
            "signature": "address[] players",
            "full_signature": "address[] public  players",
            "class_method_signature": "Statistics.players",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public array of addresses representing the players.\n */"
        },
        {
            "identifier": "levelDoesntExistCheck",
            "parameters": "address level",
            "modifiers": "",
            "return": "",
            "body": "modifier levelDoesntExistCheck(address level) {\n        require(!doesLevelExist(level), \"Level already exists\");\n        _;\n    }",
            "start": "49",
            "end": "52",
            "class": "Statistics",
            "signature": " levelDoesntExistCheckaddress level",
            "full_signature": "function levelDoesntExistCheck(address level)",
            "class_method_signature": "Statistics.levelDoesntExistCheckaddress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to check if a level does not already exist.\n * @param level The address of the level to check.\n * @dev Reverts with the message \"Level already exists\" if the level exists.\n */"
        },
        {
            "identifier": "getTotalNoOfEthernautLevels",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfEthernautLevels() public view returns (uint256) {\n        return levels.length;\n    }",
            "start": "296",
            "end": "298",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfEthernautLevels",
            "full_signature": "function getTotalNoOfEthernautLevels() public  view returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfEthernautLevels",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the total number of Ethernaut levels available.\n *\n * @return uint256 The total number of levels stored in the `levels` array.\n */"
        },
        {
            "identifier": "globalNoOfInstancesCompleted",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private globalNoOfInstancesCompleted;",
            "start": "11",
            "end": "11",
            "class": "Statistics",
            "signature": "uint256 globalNoOfInstancesCompleted",
            "full_signature": "uint256 private  globalNoOfInstancesCompleted",
            "class_method_signature": "Statistics.globalNoOfInstancesCompleted",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable to track the total number of instances completed globally.\n */"
        },
        {
            "identifier": "getTotalNoOfLevelsCompletedByPlayer",
            "parameters": "address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfLevelsCompletedByPlayer(address player)\n        public\n        view\n        playerExistsCheck(player)\n        returns (uint256)\n    {\n        return globalNoOfLevelsCompletedByPlayer[player];\n    }",
            "start": "173",
            "end": "180",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfLevelsCompletedByPlayeraddress player",
            "full_signature": "function getTotalNoOfLevelsCompletedByPlayer(address player) public  playerExistsCheck(player) returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfLevelsCompletedByPlayeraddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the total number of levels completed by a specific player.\n *\n * @param player The address of the player whose completed levels are to be queried.\n * @return uint256 The total number of levels completed by the player.\n *\n * Requirements:\n * - The player must exist (checked by the `playerExistsCheck` modifier).\n */"
        },
        {
            "identifier": "onlyEthernaut",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyEthernaut() {\n        require(msg.sender == ethernaut, \"Only Ethernaut can call this function\");\n        _;\n    }",
            "start": "59",
            "end": "62",
            "class": "Statistics",
            "signature": " onlyEthernaut",
            "full_signature": "function onlyEthernaut()",
            "class_method_signature": "Statistics.onlyEthernaut",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to restrict function access to the Ethernaut contract only.\n * \n * Requirements:\n * - The caller must be the Ethernaut contract.\n * \n * Reverts:\n * - If the caller is not the Ethernaut contract, reverts with the message \"Only Ethernaut can call this function\".\n */"
        },
        {
            "identifier": "getTotalNoOfLevelInstancesCreated",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfLevelInstancesCreated() public view returns (uint256) {\n        return globalNoOfInstancesCreated;\n    }",
            "start": "259",
            "end": "261",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfLevelInstancesCreated",
            "full_signature": "function getTotalNoOfLevelInstancesCreated() public  view returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfLevelInstancesCreated",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the total number of level instances created.\n *\n * @return uint256 The total number of level instances created.\n */"
        },
        {
            "identifier": "levelExistsCheck",
            "parameters": "address level",
            "modifiers": "",
            "return": "",
            "body": "modifier levelExistsCheck(address level) {\n        require(doesLevelExist(level), \"Level doesn't exist\");\n        _;\n    }",
            "start": "44",
            "end": "47",
            "class": "Statistics",
            "signature": " levelExistsCheckaddress level",
            "full_signature": "function levelExistsCheck(address level)",
            "class_method_signature": "Statistics.levelExistsCheckaddress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to check if a level exists before proceeding.\n * \n * Steps:\n * 1. Require that the level exists by calling `doesLevelExist(level)`.\n * 2. If the level does not exist, revert with the message \"Level doesn't exist\".\n * 3. If the level exists, continue with the execution of the function.\n */"
        },
        {
            "identifier": "levelFirstCompletionTime",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => mapping(address => uint256))",
            "body": "mapping(address => mapping(address => uint256)) private levelFirstCompletionTime;",
            "start": "34",
            "end": "34",
            "class": "Statistics",
            "signature": "mapping(address => mapping(address => uint256)) levelFirstCompletionTime",
            "full_signature": "mapping(address => mapping(address => uint256)) private  levelFirstCompletionTime",
            "class_method_signature": "Statistics.levelFirstCompletionTime",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores the first completion time of a level for a user.\n * \n * Structure:\n * - The outer mapping key is the user's address.\n * - The inner mapping key is the level's address.\n * - The value is the timestamp (uint256) when the user first completed the level.\n */"
        },
        {
            "identifier": "doesLevelExist",
            "parameters": "address level",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function doesLevelExist(address level) public view returns (bool) {\n        return levelExists[level];\n    }",
            "start": "288",
            "end": "290",
            "class": "Statistics",
            "signature": "returns (bool) doesLevelExistaddress level",
            "full_signature": "function doesLevelExist(address level) public  view returns (bool)",
            "class_method_signature": "Statistics.doesLevelExistaddress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a specific level exists in the system.\n * @param level The address of the level to check.\n * @return bool Returns true if the level exists, otherwise false.\n */"
        },
        {
            "identifier": "playerStats",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => mapping(address => LevelInstance))",
            "body": "mapping(address => mapping(address => LevelInstance)) private playerStats;",
            "start": "35",
            "end": "35",
            "class": "Statistics",
            "signature": "mapping(address => mapping(address => LevelInstance)) playerStats",
            "full_signature": "mapping(address => mapping(address => LevelInstance)) private  playerStats",
            "class_method_signature": "Statistics.playerStats",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores level instance data for each player.\n * \n * Structure:\n * - The outer mapping uses the player's address as the key.\n * - The inner mapping uses the level's address as the key.\n * - The value is a LevelInstance struct, which likely contains information about the player's progress or status in that level.\n */"
        },
        {
            "identifier": "getNoOfFailedSubmissionsForLevel",
            "parameters": "address level",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (uint256)",
            "body": "function getNoOfFailedSubmissionsForLevel(address level) public view levelExistsCheck(level) returns (uint256) {\n        return levelStats[level].noOfSubmissions_Failed;\n    }",
            "start": "275",
            "end": "277",
            "class": "Statistics",
            "signature": "returns (uint256) getNoOfFailedSubmissionsForLeveladdress level",
            "full_signature": "function getNoOfFailedSubmissionsForLevel(address level) public  levelExistsCheck(level) returns (uint256)",
            "class_method_signature": "Statistics.getNoOfFailedSubmissionsForLeveladdress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the number of failed submissions for a specific level.\n * @param level The address of the level to query.\n * @return uint256 The number of failed submissions for the specified level.\n * @dev This function includes a modifier `levelExistsCheck` to ensure the level exists before querying.\n */"
        },
        {
            "identifier": "getTotalNoOfFailuresForLevelAndPlayer",
            "parameters": "address level, address player",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfFailuresForLevelAndPlayer(address level, address player)\n        public\n        view\n        playerExistsCheck(player)\n        levelExistsCheck(level)\n        returns (uint256)\n    {\n        return playerStats[player][level].instance != address(0) ? playerStats[player][level].timeSubmitted.length : 0;\n    }",
            "start": "183",
            "end": "191",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfFailuresForLevelAndPlayeraddress level, address player",
            "full_signature": "function getTotalNoOfFailuresForLevelAndPlayer(address level, address player) public  levelExistsCheck(level) returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfFailuresForLevelAndPlayeraddress level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the total number of failures for a specific level and player.\n *\n * Requirements:\n * - The player must exist (checked by `playerExistsCheck` modifier).\n * - The level must exist (checked by `levelExistsCheck` modifier).\n *\n * @param level The address of the level to check.\n * @param player The address of the player to check.\n * @return The total number of failures for the specified level and player. \n *         If the player has not attempted the level, returns 0.\n */"
        },
        {
            "identifier": "levelFirstInstanceCreationTime",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => mapping(address => uint256))",
            "body": "mapping(address => mapping(address => uint256)) private levelFirstInstanceCreationTime;",
            "start": "33",
            "end": "33",
            "class": "Statistics",
            "signature": "mapping(address => mapping(address => uint256)) levelFirstInstanceCreationTime",
            "full_signature": "mapping(address => mapping(address => uint256)) private  levelFirstInstanceCreationTime",
            "class_method_signature": "Statistics.levelFirstInstanceCreationTime",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores the first instance creation time for each user and level.\n * @dev The mapping is structured as `levelFirstInstanceCreationTime[user][level]`, where:\n * - `user` is the address of the user.\n * - `level` is the address of the level.\n * - The value is a `uint256` representing the timestamp of the first instance creation.\n */"
        },
        {
            "identifier": "globalNoOfInstancesCreated",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private globalNoOfInstancesCreated;",
            "start": "10",
            "end": "10",
            "class": "Statistics",
            "signature": "uint256 globalNoOfInstancesCreated",
            "full_signature": "uint256 private  globalNoOfInstancesCreated",
            "class_method_signature": "Statistics.globalNoOfInstancesCreated",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable that tracks the total number of instances created.\n * @dev This variable is used to store the count of instances created globally.\n */"
        },
        {
            "identifier": "globalNoOfInstancesCompletedByPlayer",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) private globalNoOfInstancesCompletedByPlayer;",
            "start": "30",
            "end": "30",
            "class": "Statistics",
            "signature": "mapping(address => uint256) globalNoOfInstancesCompletedByPlayer",
            "full_signature": "mapping(address => uint256) private  globalNoOfInstancesCompletedByPlayer",
            "class_method_signature": "Statistics.globalNoOfInstancesCompletedByPlayer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores the number of level instances completed by each player.\n * @dev The key is the player's address, and the value is the count of completed instances.\n */"
        },
        {
            "identifier": "levelStats",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => Level)",
            "body": "mapping(address => Level) private levelStats;",
            "start": "32",
            "end": "32",
            "class": "Statistics",
            "signature": "mapping(address => Level) levelStats",
            "full_signature": "mapping(address => Level) private  levelStats",
            "class_method_signature": "Statistics.levelStats",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores the level statistics for each address.\n * @dev The key is an address, and the value is a `Level` struct representing the stats for that address.\n */"
        },
        {
            "identifier": "getNoOfInstancesForLevel",
            "parameters": "address level",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (uint256)",
            "body": "function getNoOfInstancesForLevel(address level) public view levelExistsCheck(level) returns (uint256) {\n        return levelStats[level].noOfInstancesCreated;\n    }",
            "start": "279",
            "end": "281",
            "class": "Statistics",
            "signature": "returns (uint256) getNoOfInstancesForLeveladdress level",
            "full_signature": "function getNoOfInstancesForLevel(address level) public  levelExistsCheck(level) returns (uint256)",
            "class_method_signature": "Statistics.getNoOfInstancesForLeveladdress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the number of instances created for a specific level.\n * @param level The address of the level to query.\n * @return uint256 The number of instances created for the specified level.\n * @dev This function includes a modifier `levelExistsCheck` to ensure the level exists before querying.\n */"
        },
        {
            "identifier": "updateAverageTimeTakenToCompleteLevelsByPlayer",
            "parameters": "address player, address level, uint256 totalNoOfLevelsCompletedByPlayer",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function updateAverageTimeTakenToCompleteLevelsByPlayer(\n        address player,\n        address level,\n        uint256 totalNoOfLevelsCompletedByPlayer\n    ) private returns (uint256) {\n        uint256 lastAverageTime = averageTimeTakenToCompleteLevels[player];\n        uint256 newAverageTimeTakenToCompleteLevels;\n        uint256 timeTakenForThisSuccessfulSubmission;\n        timeTakenForThisSuccessfulSubmission =\n            levelFirstCompletionTime[player][level] - levelFirstInstanceCreationTime[player][level];\n        //now, set the average time value in the mapping via evaluating its current value;\n        if (averageTimeTakenToCompleteLevels[player] == 0) {\n            averageTimeTakenToCompleteLevels[player] = timeTakenForThisSuccessfulSubmission;\n        } else {\n            newAverageTimeTakenToCompleteLevels = (\n                (lastAverageTime * (totalNoOfLevelsCompletedByPlayer - 1)) + timeTakenForThisSuccessfulSubmission\n            ) / totalNoOfLevelsCompletedByPlayer;\n            averageTimeTakenToCompleteLevels[player] = newAverageTimeTakenToCompleteLevels;\n        }\n        return newAverageTimeTakenToCompleteLevels;\n    }",
            "start": "236",
            "end": "256",
            "class": "Statistics",
            "signature": "returns (uint256) updateAverageTimeTakenToCompleteLevelsByPlayeraddress player, address level, uint256 totalNoOfLevelsCompletedByPlayer",
            "full_signature": "function updateAverageTimeTakenToCompleteLevelsByPlayer(address player, address level, uint256 totalNoOfLevelsCompletedByPlayer) private   returns (uint256)",
            "class_method_signature": "Statistics.updateAverageTimeTakenToCompleteLevelsByPlayeraddress player, address level, uint256 totalNoOfLevelsCompletedByPlayer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Updates the average time taken by a player to complete levels.\n *\n * Steps:\n * 1. Retrieve the last average time taken by the player to complete levels.\n * 2. Calculate the time taken for the current successful submission by subtracting the level's first instance creation time from the level's first completion time.\n * 3. If the player has no previous average time recorded, set the current time taken as the average.\n * 4. Otherwise, calculate the new average time by taking into account the previous average and the current time taken.\n * 5. Update the average time taken by the player in the mapping.\n * 6. Return the new average time taken to complete levels.\n */"
        },
        {
            "identifier": "isLevelCompleted",
            "parameters": "address player, address level",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (bool)",
            "body": "function isLevelCompleted(address player, address level)\n        public\n        view\n        playerExistsCheck(player)\n        levelExistsCheck(level)\n        returns (bool)\n    {\n        return playerStats[player][level].isCompleted;\n    }",
            "start": "194",
            "end": "202",
            "class": "Statistics",
            "signature": "returns (bool) isLevelCompletedaddress player, address level",
            "full_signature": "function isLevelCompleted(address player, address level) public  levelExistsCheck(level) returns (bool)",
            "class_method_signature": "Statistics.isLevelCompletedaddress player, address level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a specific level has been completed by a player.\n *\n * @param player The address of the player to check.\n * @param level The address of the level to check.\n *\n * @return bool Returns true if the level has been completed by the player, otherwise false.\n *\n * Modifiers:\n * - `playerExistsCheck`: Ensures the player exists.\n * - `levelExistsCheck`: Ensures the level exists.\n */"
        },
        {
            "identifier": "averageTimeTakenToCompleteLevels",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) private averageTimeTakenToCompleteLevels;",
            "start": "38",
            "end": "38",
            "class": "Statistics",
            "signature": "mapping(address => uint256) averageTimeTakenToCompleteLevels",
            "full_signature": "mapping(address => uint256) private  averageTimeTakenToCompleteLevels",
            "class_method_signature": "Statistics.averageTimeTakenToCompleteLevels",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores the average time taken by each address to complete levels.\n * @dev The key is the address of the user, and the value is the average time taken (in seconds) to complete levels.\n */"
        },
        {
            "identifier": "levels",
            "parameters": "",
            "modifiers": "",
            "return": "address[]",
            "body": "address[] public levels;",
            "start": "9",
            "end": "9",
            "class": "Statistics",
            "signature": "address[] levels",
            "full_signature": "address[] public  levels",
            "class_method_signature": "Statistics.levels",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public array that stores the addresses of levels.\n */"
        },
        {
            "identifier": "playerExistsCheck",
            "parameters": "address player",
            "modifiers": "",
            "return": "",
            "body": "modifier playerExistsCheck(address player) {\n        require(doesPlayerExist(player), \"Player doesn't exist\");\n        _;\n    }",
            "start": "54",
            "end": "57",
            "class": "Statistics",
            "signature": " playerExistsCheckaddress player",
            "full_signature": "function playerExistsCheck(address player)",
            "class_method_signature": "Statistics.playerExistsCheckaddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to check if a player exists.\n * @dev Reverts with the message \"Player doesn't exist\" if the player does not exist.\n * @param player The address of the player to check.\n */"
        },
        {
            "identifier": "playerScoreProfile",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "event playerScoreProfile(\n        address indexed player, uint256 indexed averageCompletionTime, uint256 indexed globalLevelsCompleted\n    );",
            "start": "40",
            "end": "42",
            "class": "Statistics",
            "signature": " playerScoreProfile",
            "full_signature": "function playerScoreProfile()",
            "class_method_signature": "Statistics.playerScoreProfile",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Emits an event that logs a player's score profile, including their address, average completion time, and the total number of levels completed globally.\n *\n * @param player The address of the player.\n * @param averageCompletionTime The average time taken by the player to complete levels.\n * @param globalLevelsCompleted The total number of levels completed by all players globally.\n */"
        },
        {
            "identifier": "__gap",
            "parameters": "",
            "modifiers": "",
            "return": "uint256[44]",
            "body": "uint256[44] private __gap;",
            "start": "309",
            "end": "309",
            "class": "Statistics",
            "signature": "uint256[44] __gap",
            "full_signature": "uint256[44] private  __gap",
            "class_method_signature": "Statistics.__gap",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private array of 44 uint256 values used for storage gap in upgradeable contracts.\n * This is typically used in proxy patterns to reserve storage slots for future upgrades.\n */"
        },
        {
            "identifier": "getTotalNoOfPlayers",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfPlayers() public view returns (uint256) {\n        return players.length;\n    }",
            "start": "271",
            "end": "273",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfPlayers",
            "full_signature": "function getTotalNoOfPlayers() public  view returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfPlayers",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the total number of players currently registered in the system.\n *\n * @return uint256 The total number of players.\n */"
        },
        {
            "identifier": "globalNoOfFailedSubmissionsByPlayer",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) private globalNoOfFailedSubmissionsByPlayer;",
            "start": "31",
            "end": "31",
            "class": "Statistics",
            "signature": "mapping(address => uint256) globalNoOfFailedSubmissionsByPlayer",
            "full_signature": "mapping(address => uint256) private  globalNoOfFailedSubmissionsByPlayer",
            "class_method_signature": "Statistics.globalNoOfFailedSubmissionsByPlayer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that tracks the number of failed submissions by each player.\n * @dev The key is the player's address, and the value is the count of failed submissions.\n */"
        },
        {
            "identifier": "getTotalNoOfLevelInstancesCreatedByPlayer",
            "parameters": "address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfLevelInstancesCreatedByPlayer(address player)\n        public\n        view\n        playerExistsCheck(player)\n        returns (uint256)\n    {\n        return globalNoOfInstancesCreatedByPlayer[player];\n    }",
            "start": "144",
            "end": "151",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfLevelInstancesCreatedByPlayeraddress player",
            "full_signature": "function getTotalNoOfLevelInstancesCreatedByPlayer(address player) public  playerExistsCheck(player) returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfLevelInstancesCreatedByPlayeraddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the total number of level instances created by a specific player.\n *\n * @param player The address of the player whose level instances are being queried.\n * @return uint256 The total number of level instances created by the player.\n *\n * Requirements:\n * - The player must exist (checked by the `playerExistsCheck` modifier).\n */"
        },
        {
            "identifier": "getTotalNoOfFailedSubmissions",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getTotalNoOfFailedSubmissions() public view returns (uint256) {\n        return globalNoOfFailedSubmissions;\n    }",
            "start": "267",
            "end": "269",
            "class": "Statistics",
            "signature": "returns (uint256) getTotalNoOfFailedSubmissions",
            "full_signature": "function getTotalNoOfFailedSubmissions() public  view returns (uint256)",
            "class_method_signature": "Statistics.getTotalNoOfFailedSubmissions",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the total number of failed submissions.\n * @return uint256 The total number of failed submissions stored in `globalNoOfFailedSubmissions`.\n */"
        },
        {
            "identifier": "globalNoOfLevelsCompletedByPlayer",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) private globalNoOfLevelsCompletedByPlayer;",
            "start": "28",
            "end": "28",
            "class": "Statistics",
            "signature": "mapping(address => uint256) globalNoOfLevelsCompletedByPlayer",
            "full_signature": "mapping(address => uint256) private  globalNoOfLevelsCompletedByPlayer",
            "class_method_signature": "Statistics.globalNoOfLevelsCompletedByPlayer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that stores the number of levels completed by each player.\n * @dev The key is the player's address, and the value is the number of levels they have completed.\n */"
        },
        {
            "identifier": "LevelInstance",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct LevelInstance {\n        address instance;\n        bool isCompleted;\n        uint256 timeCreated;\n        uint256 timeCompleted;\n        uint256[] timeSubmitted;\n    }",
            "start": "14",
            "end": "20",
            "class": "Statistics",
            "signature": " LevelInstance",
            "full_signature": "function LevelInstance()",
            "class_method_signature": "Statistics.LevelInstance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a structure to store information about a level instance.\n * \n * Fields:\n * - instance: The address of the level instance.\n * - isCompleted: A boolean indicating whether the level instance has been completed.\n * - timeCreated: The timestamp when the level instance was created.\n * - timeCompleted: The timestamp when the level instance was marked as completed.\n * - timeSubmitted: An array of timestamps representing each submission attempt of the level instance.\n */"
        },
        {
            "identifier": "getPercentageOfLevelsCompleted",
            "parameters": "address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "returns (uint256)",
            "body": "function getPercentageOfLevelsCompleted(address player) public view playerExistsCheck(player) returns (uint256) {\n        // Changed from 100 to 1e18 otherwise when levels.length > 100 this will round to 0 always\n        return (getTotalNoOfLevelsCompletedByPlayer(player) * 1e18) / levels.length;\n    }",
            "start": "230",
            "end": "233",
            "class": "Statistics",
            "signature": "returns (uint256) getPercentageOfLevelsCompletedaddress player",
            "full_signature": "function getPercentageOfLevelsCompleted(address player) public  playerExistsCheck(player) returns (uint256)",
            "class_method_signature": "Statistics.getPercentageOfLevelsCompletedaddress player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the percentage of levels completed by a player.\n * \n * Steps:\n * 1. Checks if the player exists using the `playerExistsCheck` modifier.\n * 2. Multiplies the total number of levels completed by the player by 1e18 to avoid rounding errors.\n * 3. Divides the result by the total number of levels to get the percentage.\n * 4. Returns the calculated percentage.\n */"
        },
        {
            "identifier": "globalNoOfInstancesCreatedByPlayer",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) private globalNoOfInstancesCreatedByPlayer;",
            "start": "29",
            "end": "29",
            "class": "Statistics",
            "signature": "mapping(address => uint256) globalNoOfInstancesCreatedByPlayer",
            "full_signature": "mapping(address => uint256) private  globalNoOfInstancesCreatedByPlayer",
            "class_method_signature": "Statistics.globalNoOfInstancesCreatedByPlayer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private mapping that tracks the number of instances created by each player.\n * @dev The key is the player's address, and the value is the number of instances created by that player.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/attacks/CoinFlipAttack.sol": [
        {
            "identifier": "FACTOR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;",
            "start": "8",
            "end": "8",
            "class": "CoinFlipAttack",
            "signature": "uint256 FACTOR",
            "full_signature": "uint256   FACTOR",
            "class_method_signature": "CoinFlipAttack.FACTOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"../levels/CoinFlip.sol\";"
            ],
            "context": "{'uint256   FACTOR'}",
            "human_labeled_comment": "/**\n * @notice A constant representing a large integer value, likely used for mathematical operations or as a divisor/multiplier in calculations.\n * The value is 2^255, which is a common value in cryptographic or large-number computations.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/attacks/GatekeeperTwoAttack.sol": [
        {
            "identifier": "enter",
            "parameters": "bytes8 _gateKey",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function enter(bytes8 _gateKey) external returns (bool);",
            "start": "6",
            "end": "6",
            "class": "GatekeeperTwoInterface",
            "signature": "returns (bool) enterbytes8 _gateKey",
            "full_signature": "function enter(bytes8 _gateKey) external   returns (bool)",
            "class_method_signature": "GatekeeperTwoInterface.enterbytes8 _gateKey",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Allows an external caller to attempt to enter a gate using a provided key.  \n * @param _gateKey The key required to enter the gate, represented as a bytes8 value.  \n * @return A boolean indicating whether the entry attempt was successful.  \n */  "
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Dex.sol": [
        {
            "identifier": "addLiquidity",
            "parameters": "address token_address, uint256 amount",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function addLiquidity(address token_address, uint256 amount) public onlyOwner {\n        IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n    }",
            "start": "19",
            "end": "21",
            "class": "Dex",
            "signature": " addLiquidityaddress token_address, uint256 amount",
            "full_signature": "function addLiquidity(address token_address, uint256 amount) public  onlyOwner",
            "class_method_signature": "Dex.addLiquidityaddress token_address, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Adds liquidity by transferring tokens from the caller to the contract.\n * \n * Steps:\n * 1. Transfers the specified amount of tokens from the caller to the contract.\n * \n * Requirements:\n * - The caller must be the owner of the contract.\n * - The token address must be valid.\n * - The amount must be greater than zero.\n */"
        },
        {
            "identifier": "balanceOf",
            "parameters": "address token, address account",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function balanceOf(address token, address account) public view returns (uint256) {\n        return IERC20(token).balanceOf(account);\n    }",
            "start": "41",
            "end": "43",
            "class": "Dex",
            "signature": "returns (uint256) balanceOfaddress token, address account",
            "full_signature": "function balanceOf(address token, address account) public  view returns (uint256)",
            "class_method_signature": "Dex.balanceOfaddress token, address account",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the token balance of a specified account for a given ERC20 token.\n *\n * @param token The address of the ERC20 token contract.\n * @param account The address of the account to query the balance for.\n * @return uint256 The token balance of the specified account.\n */"
        },
        {
            "identifier": "getSwapPrice",
            "parameters": "address from, address to, uint256 amount",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getSwapPrice(address from, address to, uint256 amount) public view returns (uint256) {\n        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));\n    }",
            "start": "32",
            "end": "34",
            "class": "Dex",
            "signature": "returns (uint256) getSwapPriceaddress from, address to, uint256 amount",
            "full_signature": "function getSwapPrice(address from, address to, uint256 amount) public  view returns (uint256)",
            "class_method_signature": "Dex.getSwapPriceaddress from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the swap price between two tokens based on their balances in the contract.\n *\n * @param from The address of the token to swap from.\n * @param to The address of the token to swap to.\n * @param amount The amount of the `from` token to calculate the swap price for.\n *\n * @return The calculated swap price in terms of the `to` token.\n *\n * Formula:\n * Swap Price = (amount * balance of `to` token in contract) / balance of `from` token in contract\n */"
        },
        {
            "identifier": "setTokens",
            "parameters": "address _token1, address _token2",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function setTokens(address _token1, address _token2) public onlyOwner {\n        token1 = _token1;\n        token2 = _token2;\n    }",
            "start": "14",
            "end": "17",
            "class": "Dex",
            "signature": " setTokensaddress _token1, address _token2",
            "full_signature": "function setTokens(address _token1, address _token2) public  onlyOwner",
            "class_method_signature": "Dex.setTokensaddress _token1, address _token2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sets the addresses of two tokens.\n * @dev This function can only be called by the owner.\n * @param _token1 The address of the first token.\n * @param _token2 The address of the second token.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/GatekeeperOne.sol": [
        {
            "identifier": "enter",
            "parameters": "bytes8 _gateKey",
            "modifiers": "gateThree(_gateKey)",
            "return": "returns (bool)",
            "body": "function enter(bytes8 _gateKey) public gateOne gateTwo gateThree(_gateKey) returns (bool) {\n        entrant = tx.origin;\n        return true;\n    }",
            "start": "24",
            "end": "27",
            "class": "GatekeeperOne",
            "signature": "returns (bool) enterbytes8 _gateKey",
            "full_signature": "function enter(bytes8 _gateKey) public  gateThree(_gateKey) returns (bool)",
            "class_method_signature": "GatekeeperOne.enterbytes8 _gateKey",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Function to enter through a gate by passing a gate key.\n * @dev The function is protected by three modifiers: gateOne, gateTwo, and gateThree.\n * @param _gateKey The key required to pass through the gate.\n * @return bool Returns true if the function executes successfully.\n *\n * Steps:\n * 1. Set the entrant to the transaction origin (tx.origin).\n * 2. Return true to indicate successful execution.\n */"
        },
        {
            "identifier": "gateOne",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier gateOne() {\n        require(msg.sender != tx.origin);\n        _;\n    }",
            "start": "7",
            "end": "10",
            "class": "GatekeeperOne",
            "signature": " gateOne",
            "full_signature": "function gateOne()",
            "class_method_signature": "GatekeeperOne.gateOne",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that ensures the caller is not the transaction origin.\n * \n * This modifier is used to enforce that the function can only be called by a contract,\n * not directly by an externally owned account (EOA).\n * \n * Steps:\n * 1. Check that the `msg.sender` is not equal to `tx.origin`.\n * 2. If the condition is met, proceed with the function execution.\n */"
        },
        {
            "identifier": "entrant",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public entrant;",
            "start": "5",
            "end": "5",
            "class": "GatekeeperOne",
            "signature": "address entrant",
            "full_signature": "address public  entrant",
            "class_method_signature": "GatekeeperOne.entrant",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores the address of the entrant.\n */"
        },
        {
            "identifier": "gateTwo",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier gateTwo() {\n        require(gasleft() % 8191 == 0);\n        _;\n    }",
            "start": "12",
            "end": "15",
            "class": "GatekeeperOne",
            "signature": " gateTwo",
            "full_signature": "function gateTwo()",
            "class_method_signature": "GatekeeperOne.gateTwo",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that ensures the remaining gas is a multiple of 8191.\n * \n * Steps:\n * 1. Checks if the remaining gas (`gasleft()`) modulo 8191 equals 0.\n * 2. If the condition is met, the function proceeds; otherwise, it reverts.\n */"
        },
        {
            "identifier": "gateThree",
            "parameters": "bytes8 _gateKey",
            "modifiers": "",
            "return": "",
            "body": "modifier gateThree(bytes8 _gateKey) {\n        require(uint32(uint64(_gateKey)) == uint16(uint64(_gateKey)), \"GatekeeperOne: invalid gateThree part one\");\n        require(uint32(uint64(_gateKey)) != uint64(_gateKey), \"GatekeeperOne: invalid gateThree part two\");\n        require(uint32(uint64(_gateKey)) == uint16(uint160(tx.origin)), \"GatekeeperOne: invalid gateThree part three\");\n        _;\n    }",
            "start": "17",
            "end": "22",
            "class": "GatekeeperOne",
            "signature": " gateThreebytes8 _gateKey",
            "full_signature": "function gateThree(bytes8 _gateKey)",
            "class_method_signature": "GatekeeperOne.gateThreebytes8 _gateKey",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that enforces three specific conditions for passing through a gate.\n *\n * Conditions:\n * 1. The lower 32 bits of the `_gateKey` must equal the lower 16 bits of the `_gateKey`.\n * 2. The lower 32 bits of the `_gateKey` must not equal the full 64 bits of the `_gateKey`.\n * 3. The lower 32 bits of the `_gateKey` must equal the lower 16 bits of the transaction origin address.\n *\n * If any of these conditions are not met, the function will revert with an appropriate error message.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/CoinFlipFactory.sol": [
        {
            "identifier": "createInstance",
            "parameters": "address _player",
            "modifiers": "override",
            "return": "returns (address)",
            "body": "function createInstance(address _player) public payable override returns (address) {\n        _player;\n        return address(new CoinFlip());\n    }",
            "start": "9",
            "end": "12",
            "class": "CoinFlipFactory",
            "signature": "returns (address) createInstanceaddress _player",
            "full_signature": "function createInstance(address _player) public  override returns (address)",
            "class_method_signature": "CoinFlipFactory.createInstanceaddress _player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"./base/Level.sol\";",
                "import \"./CoinFlip.sol\";"
            ],
            "context": "{'function createInstance(address _player) public virtual payable returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Creates a new instance of the CoinFlip contract and returns its address.\n * \n * Steps:\n * 1. Accepts a player address as a parameter (unused in the function).\n * 2. Deploys a new CoinFlip contract.\n * 3. Returns the address of the newly deployed CoinFlip instance.\n */"
        },
        {
            "identifier": "validateInstance",
            "parameters": "address payable _instance, address",
            "modifiers": "override",
            "return": "returns (bool)",
            "body": "function validateInstance(address payable _instance, address) public view override returns (bool) {\n        CoinFlip instance = CoinFlip(_instance);\n        return instance.consecutiveWins() >= 10;\n    }",
            "start": "14",
            "end": "17",
            "class": "CoinFlipFactory",
            "signature": "returns (bool) validateInstanceaddress payable _instance, address",
            "full_signature": "function validateInstance(address payable _instance, address) public  override returns (bool)",
            "class_method_signature": "CoinFlipFactory.validateInstanceaddress payable _instance, address",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"./base/Level.sol\";",
                "import \"./CoinFlip.sol\";"
            ],
            "context": "{'function validateInstance(address payable _instance, address _player) public virtual  returns (bool)', 'uint256 public  consecutiveWins'}",
            "human_labeled_comment": "/**\n * @notice Validates if a CoinFlip instance has achieved 10 or more consecutive wins.\n *\n * Steps:\n * 1. Cast the provided instance address to a CoinFlip contract.\n * 2. Check if the consecutive wins count is greater than or equal to 10.\n * 3. Return the result of the validation.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/DexTwo.sol": [
        {
            "identifier": "getSwapAmount",
            "parameters": "address from, address to, uint256 amount",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getSwapAmount(address from, address to, uint256 amount) public view returns (uint256) {\n        return ((amount * IERC20(to).balanceOf(address(this))) / IERC20(from).balanceOf(address(this)));\n    }",
            "start": "31",
            "end": "33",
            "class": "DexTwo",
            "signature": "returns (uint256) getSwapAmountaddress from, address to, uint256 amount",
            "full_signature": "function getSwapAmount(address from, address to, uint256 amount) public  view returns (uint256)",
            "class_method_signature": "DexTwo.getSwapAmountaddress from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the swap amount based on the balance of tokens in the contract.\n *\n * @param from The address of the token to swap from.\n * @param to The address of the token to swap to.\n * @param amount The amount of tokens to swap.\n *\n * @return The calculated swap amount, derived from the ratio of the balances of the two tokens in the contract.\n */"
        },
        {
            "identifier": "setTokens",
            "parameters": "address _token1, address _token2",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function setTokens(address _token1, address _token2) public onlyOwner {\n        token1 = _token1;\n        token2 = _token2;\n    }",
            "start": "14",
            "end": "17",
            "class": "DexTwo",
            "signature": " setTokensaddress _token1, address _token2",
            "full_signature": "function setTokens(address _token1, address _token2) public  onlyOwner",
            "class_method_signature": "DexTwo.setTokensaddress _token1, address _token2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sets the addresses of two tokens.\n * @dev This function can only be called by the owner.\n * @param _token1 The address of the first token.\n * @param _token2 The address of the second token.\n */"
        },
        {
            "identifier": "approve",
            "parameters": "address spender, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function approve(address spender, uint256 amount) public {\n        SwappableTokenTwo(token1).approve(msg.sender, spender, amount);\n        SwappableTokenTwo(token2).approve(msg.sender, spender, amount);\n    }",
            "start": "35",
            "end": "38",
            "class": "DexTwo",
            "signature": " approveaddress spender, uint256 amount",
            "full_signature": "function approve(address spender, uint256 amount) public",
            "class_method_signature": "DexTwo.approveaddress spender, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Approves a spender to spend a specified amount of tokens on behalf of the caller.\n *\n * Steps:\n * 1. Calls the `approve` function on `token1` to approve the spender for the specified amount.\n * 2. Calls the `approve` function on `token2` to approve the spender for the specified amount.\n *\n * @param spender The address of the spender to be approved.\n * @param amount The amount of tokens the spender is allowed to spend.\n */"
        },
        {
            "identifier": "add_liquidity",
            "parameters": "address token_address, uint256 amount",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function add_liquidity(address token_address, uint256 amount) public onlyOwner {\n        IERC20(token_address).transferFrom(msg.sender, address(this), amount);\n    }",
            "start": "19",
            "end": "21",
            "class": "DexTwo",
            "signature": " add_liquidityaddress token_address, uint256 amount",
            "full_signature": "function add_liquidity(address token_address, uint256 amount) public  onlyOwner",
            "class_method_signature": "DexTwo.add_liquidityaddress token_address, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Adds liquidity by transferring tokens from the caller to the contract.\n * \n * Steps:\n * 1. The function is restricted to the contract owner using the `onlyOwner` modifier.\n * 2. Transfers the specified `amount` of tokens from the caller (`msg.sender`) to the contract.\n * 3. The token address is specified by `token_address`.\n */"
        },
        {
            "identifier": "balanceOf",
            "parameters": "address token, address account",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function balanceOf(address token, address account) public view returns (uint256) {\n        return IERC20(token).balanceOf(account);\n    }",
            "start": "40",
            "end": "42",
            "class": "DexTwo",
            "signature": "returns (uint256) balanceOfaddress token, address account",
            "full_signature": "function balanceOf(address token, address account) public  view returns (uint256)",
            "class_method_signature": "DexTwo.balanceOfaddress token, address account",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the token balance of a specified account for a given ERC20 token.\n * \n * @param token The address of the ERC20 token contract.\n * @param account The address of the account to query the balance for.\n * @return uint256 The token balance of the specified account.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Reentrance.sol": [
        {
            "identifier": "balanceOf",
            "parameters": "address _who",
            "modifiers": "view",
            "return": "returns (uint256 balance)",
            "body": "function balanceOf(address _who) public view returns (uint256 balance) {\n        return balances[_who];\n    }",
            "start": "15",
            "end": "17",
            "class": "Reentrance",
            "signature": "returns (uint256 balance) balanceOfaddress _who",
            "full_signature": "function balanceOf(address _who) public  view returns (uint256 balance)",
            "class_method_signature": "Reentrance.balanceOfaddress _who",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.12;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the balance of a specified address.\n * \n * @param _who The address for which the balance is being queried.\n * @return balance The balance of the specified address.\n */"
        },
        {
            "identifier": "withdraw",
            "parameters": "uint256 _amount",
            "modifiers": "",
            "return": "",
            "body": "function withdraw(uint256 _amount) public {\n        if (balances[msg.sender] >= _amount) {\n            (bool result,) = msg.sender.call{value: _amount}(\"\");\n            if (result) {\n                _amount;\n            }\n            balances[msg.sender] -= _amount;\n        }\n    }",
            "start": "19",
            "end": "27",
            "class": "Reentrance",
            "signature": " withdrawuint256 _amount",
            "full_signature": "function withdraw(uint256 _amount) public",
            "class_method_signature": "Reentrance.withdrawuint256 _amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.12;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Allows a user to withdraw a specified amount of funds from their balance.\n *\n * Steps:\n * 1. Check if the user's balance is sufficient to cover the requested withdrawal amount.\n * 2. If sufficient, attempt to transfer the specified amount to the user's address.\n * 3. If the transfer is successful, deduct the withdrawn amount from the user's balance.\n * 4. If the transfer fails, the balance remains unchanged.\n */"
        },
        {
            "identifier": "balances",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) public balances;",
            "start": "9",
            "end": "9",
            "class": "Reentrance",
            "signature": "mapping(address => uint256) balances",
            "full_signature": "mapping(address => uint256) public  balances",
            "class_method_signature": "Reentrance.balances",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.12;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public mapping that associates addresses with their corresponding balances.\n * @dev The key is an address, and the value is a uint256 representing the balance.\n */"
        },
        {
            "identifier": "donate",
            "parameters": "address _to",
            "modifiers": "payable",
            "return": "",
            "body": "function donate(address _to) public payable {\n        balances[_to] = balances[_to].add(msg.value);\n    }",
            "start": "11",
            "end": "13",
            "class": "Reentrance",
            "signature": " donateaddress _to",
            "full_signature": "function donate(address _to) public  payable",
            "class_method_signature": "Reentrance.donateaddress _to",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.12;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Allows a user to donate Ether to a specified address.\n * \n * @param _to The address that will receive the donated Ether.\n * \n * Steps:\n * 1. The function is payable, meaning it can receive Ether.\n * 2. The donated Ether (msg.value) is added to the balance of the specified address (_to).\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Instance.sol": [
        {
            "identifier": "theMethodName",
            "parameters": "",
            "modifiers": "",
            "return": "string",
            "body": "string public theMethodName = \"The method name is method7123949.\";",
            "start": "7",
            "end": "7",
            "class": "Instance",
            "signature": "string theMethodName",
            "full_signature": "string public  theMethodName",
            "class_method_signature": "Instance.theMethodName",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public string variable that stores the method name as \"The method name is method7123949.\"\n */"
        },
        {
            "identifier": "infoNum",
            "parameters": "",
            "modifiers": "",
            "return": "uint8",
            "body": "uint8 public infoNum = 42;",
            "start": "6",
            "end": "6",
            "class": "Instance",
            "signature": "uint8 infoNum",
            "full_signature": "uint8 public  infoNum",
            "class_method_signature": "Instance.infoNum",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `infoNum` of type `uint8` initialized to 42.\n */"
        },
        {
            "identifier": "cleared",
            "parameters": "",
            "modifiers": "",
            "return": "bool",
            "body": "bool private cleared = false;",
            "start": "8",
            "end": "8",
            "class": "Instance",
            "signature": "bool cleared",
            "full_signature": "bool private  cleared",
            "class_method_signature": "Instance.cleared",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private boolean variable `cleared` initialized to `false`.\n */"
        },
        {
            "identifier": "info",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function info() public pure returns (string memory) {\n        return \"You will find what you need in info1().\";\n    }",
            "start": "15",
            "end": "17",
            "class": "Instance",
            "signature": "returns (string memory) info",
            "full_signature": "function info() public  pure returns (string memory)",
            "class_method_signature": "Instance.info",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns a string message directing the user to another function for more information.\n * @return A string message indicating that the required information can be found in `info1()`.\n */"
        },
        {
            "identifier": "info1",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function info1() public pure returns (string memory) {\n        return 'Try info2(), but with \"hello\" as a parameter.';\n    }",
            "start": "19",
            "end": "21",
            "class": "Instance",
            "signature": "returns (string memory) info1",
            "full_signature": "function info1() public  pure returns (string memory)",
            "class_method_signature": "Instance.info1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns a string instructing the user to call `info2()` with the parameter \"hello\".\n *\n * @return A string message suggesting to call `info2()` with \"hello\" as the parameter.\n */"
        },
        {
            "identifier": "info2",
            "parameters": "string memory param",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function info2(string memory param) public pure returns (string memory) {\n        if (keccak256(abi.encodePacked(param)) == keccak256(abi.encodePacked(\"hello\"))) {\n            return \"The property infoNum holds the number of the next info method to call.\";\n        }\n        return \"Wrong parameter.\";\n    }",
            "start": "23",
            "end": "28",
            "class": "Instance",
            "signature": "returns (string memory) info2string memory param",
            "full_signature": "function info2(string memory param) public  pure returns (string memory)",
            "class_method_signature": "Instance.info2string memory param",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns a specific message based on the input parameter.\n *\n * Steps:\n * 1. Checks if the input parameter is \"hello\" by comparing the keccak256 hash of the encoded parameter.\n * 2. If the parameter is \"hello\", returns a message indicating that the property infoNum holds the number of the next info method to call.\n * 3. If the parameter is not \"hello\", returns \"Wrong parameter\".\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/DoubleEntryPoint.sol": [
        {
            "identifier": "delegateTransfer",
            "parameters": "address to, uint256 value, address origSender",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);",
            "start": "8",
            "end": "8",
            "class": "DelegateERC20",
            "signature": "returns (bool) delegateTransferaddress to, uint256 value, address origSender",
            "full_signature": "function delegateTransfer(address to, uint256 value, address origSender) external   returns (bool)",
            "class_method_signature": "DelegateERC20.delegateTransferaddress to, uint256 value, address origSender",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Delegates a transfer operation to another address.\n * \n * @param to The address to which the transfer is delegated.\n * @param value The amount of tokens or value to be transferred.\n * @param origSender The original sender of the transfer request.\n * @return A boolean indicating whether the transfer was successful.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/CoinFlip.sol": [
        {
            "identifier": "FACTOR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 FACTOR = 57896044618658097711785492504343953926634992332820282019728792003956564819968;",
            "start": "7",
            "end": "7",
            "class": "CoinFlip",
            "signature": "uint256 FACTOR",
            "full_signature": "uint256   FACTOR",
            "class_method_signature": "CoinFlip.FACTOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a large integer value used in calculations.\n * The value is 2^255, which is a common constant in cryptographic or mathematical operations.\n */"
        },
        {
            "identifier": "consecutiveWins",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public consecutiveWins;",
            "start": "5",
            "end": "5",
            "class": "CoinFlip",
            "signature": "uint256 consecutiveWins",
            "full_signature": "uint256 public  consecutiveWins",
            "class_method_signature": "CoinFlip.consecutiveWins",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that tracks the number of consecutive wins.\n */"
        },
        {
            "identifier": "lastHash",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 lastHash;",
            "start": "6",
            "end": "6",
            "class": "CoinFlip",
            "signature": "uint256 lastHash",
            "full_signature": "uint256   lastHash",
            "class_method_signature": "CoinFlip.lastHash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A state variable to store the last hash value.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/HigherOrder.sol": [
        {
            "identifier": "commander",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public commander;",
            "start": "5",
            "end": "5",
            "class": "HigherOrder",
            "signature": "address commander",
            "full_signature": "address public  commander",
            "class_method_signature": "HigherOrder.commander",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity 0.6.12;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores the address of the commander.\n */"
        },
        {
            "identifier": "treasury",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public treasury;",
            "start": "7",
            "end": "7",
            "class": "HigherOrder",
            "signature": "uint256 treasury",
            "full_signature": "uint256 public  treasury",
            "class_method_signature": "HigherOrder.treasury",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity 0.6.12;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable representing the treasury balance.\n * @dev This variable stores the amount of funds in the treasury.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Preservation.sol": [
        {
            "identifier": "timeZone1Library",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public timeZone1Library;",
            "start": "6",
            "end": "6",
            "class": "Preservation",
            "signature": "address timeZone1Library",
            "full_signature": "address public  timeZone1Library",
            "class_method_signature": "Preservation.timeZone1Library",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Public state variable that stores the address of the timeZone1Library.\n */"
        },
        {
            "identifier": "storedTime",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 storedTime;",
            "start": "9",
            "end": "9",
            "class": "Preservation",
            "signature": "uint256 storedTime",
            "full_signature": "uint256   storedTime",
            "class_method_signature": "Preservation.storedTime",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A state variable to store a timestamp or time-related value.\n */"
        },
        {
            "identifier": "setSecondTime",
            "parameters": "uint256 _timeStamp",
            "modifiers": "",
            "return": "",
            "body": "function setSecondTime(uint256 _timeStamp) public {\n        timeZone2Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));\n    }",
            "start": "25",
            "end": "27",
            "class": "Preservation",
            "signature": " setSecondTimeuint256 _timeStamp",
            "full_signature": "function setSecondTime(uint256 _timeStamp) public",
            "class_method_signature": "Preservation.setSecondTimeuint256 _timeStamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sets the timestamp for the second time zone by delegating the call to `timeZone2Library`.\n *\n * Steps:\n * 1. Delegates a call to `timeZone2Library` with the encoded function signature and the provided `_timeStamp`.\n * 2. The call is made using `delegatecall`, which executes the code in the context of the calling contract.\n */"
        },
        {
            "identifier": "setTimeSignature",
            "parameters": "",
            "modifiers": "",
            "return": "bytes4",
            "body": "bytes4 constant setTimeSignature = bytes4(keccak256(\"setTime(uint256)\"));",
            "start": "11",
            "end": "11",
            "class": "Preservation",
            "signature": "bytes4 setTimeSignature",
            "full_signature": "bytes4  constant setTimeSignature",
            "class_method_signature": "Preservation.setTimeSignature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant variable that stores the function signature for the `setTime(uint256)` function.\n * The signature is derived by hashing the function name and its parameter types using keccak256.\n */"
        },
        {
            "identifier": "timeZone2Library",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public timeZone2Library;",
            "start": "7",
            "end": "7",
            "class": "Preservation",
            "signature": "address timeZone2Library",
            "full_signature": "address public  timeZone2Library",
            "class_method_signature": "Preservation.timeZone2Library",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Public state variable that stores the address of the timeZone2Library.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Impersonator.sol": [
        {
            "identifier": "deployNewLock",
            "parameters": "bytes memory signature",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function deployNewLock(bytes memory signature) public onlyOwner {\n        // Deploy a new lock\n        ECLocker newLock = new ECLocker(++lockCounter, signature);\n        lockers.push(newLock);\n        emit NewLock(address(newLock), lockCounter, block.timestamp, signature);\n    }",
            "start": "17",
            "end": "22",
            "class": "Impersonator",
            "signature": " deployNewLockbytes memory signature",
            "full_signature": "function deployNewLock(bytes memory signature) public  onlyOwner",
            "class_method_signature": "Impersonator.deployNewLockbytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Deploys a new ECLocker instance with a unique ID and a provided signature.\n * \n * Steps:\n * 1. Increment the lock counter to generate a unique ID for the new lock.\n * 2. Deploy a new ECLocker instance with the incremented lock counter and the provided signature.\n * 3. Add the newly deployed lock to the `lockers` array.\n * 4. Emit a `NewLock` event with the address of the new lock, the lock counter, the current block timestamp, and the signature.\n *\n * @param signature The signature to be associated with the new lock.\n */"
        },
        {
            "identifier": "NewLock",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "event NewLock(address indexed lockAddress, uint256 lockId, uint256 timestamp, bytes signature);",
            "start": "11",
            "end": "11",
            "class": "Impersonator",
            "signature": " NewLock",
            "full_signature": "function NewLock()",
            "class_method_signature": "Impersonator.NewLock",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Emits an event when a new lock is created.\n * @param lockAddress The address of the newly created lock.\n * @param lockId The unique identifier for the lock.\n * @param timestamp The timestamp when the lock was created.\n * @param signature The signature associated with the lock creation.\n */"
        },
        {
            "identifier": "lockCounter",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public lockCounter;",
            "start": "8",
            "end": "8",
            "class": "Impersonator",
            "signature": "uint256 lockCounter",
            "full_signature": "uint256 public  lockCounter",
            "class_method_signature": "Impersonator.lockCounter",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable to track the number of locks.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Denial.sol": [
        {
            "identifier": "timeLastWithdrawn",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 timeLastWithdrawn;",
            "start": "7",
            "end": "7",
            "class": "Denial",
            "signature": "uint256 timeLastWithdrawn",
            "full_signature": "uint256   timeLastWithdrawn",
            "class_method_signature": "Denial.timeLastWithdrawn",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A state variable to store the timestamp of the last withdrawal.\n */"
        },
        {
            "identifier": "partner",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public partner;",
            "start": "5",
            "end": "5",
            "class": "Denial",
            "signature": "address partner",
            "full_signature": "address public  partner",
            "class_method_signature": "Denial.partner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores the address of a partner.\n */"
        },
        {
            "identifier": "contractBalance",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function contractBalance() public view returns (uint256) {\n        return address(this).balance;\n    }",
            "start": "30",
            "end": "32",
            "class": "Denial",
            "signature": "returns (uint256) contractBalance",
            "full_signature": "function contractBalance() public  view returns (uint256)",
            "class_method_signature": "Denial.contractBalance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the current balance of the contract.\n *\n * @return The balance of the contract in wei.\n */"
        },
        {
            "identifier": "withdrawPartnerBalances",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) withdrawPartnerBalances;",
            "start": "8",
            "end": "8",
            "class": "Denial",
            "signature": "mapping(address => uint256) withdrawPartnerBalances",
            "full_signature": "mapping(address => uint256)   withdrawPartnerBalances",
            "class_method_signature": "Denial.withdrawPartnerBalances",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A mapping that stores the withdrawal balances for partners.\n * @dev The key is the partner's address, and the value is the corresponding balance.\n */"
        },
        {
            "identifier": "withdraw",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "function withdraw() public {\n        uint256 amountToSend = address(this).balance / 100;\n        // perform a call without checking return\n        // The recipient can revert, the owner will still get their share\n        partner.call{value: amountToSend}(\"\");\n        payable(owner).transfer(amountToSend);\n        // keep track of last withdrawal time\n        timeLastWithdrawn = block.timestamp;\n        withdrawPartnerBalances[partner] += amountToSend;\n    }",
            "start": "15",
            "end": "24",
            "class": "Denial",
            "signature": " withdraw",
            "full_signature": "function withdraw() public",
            "class_method_signature": "Denial.withdraw",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Withdraws funds from the contract, distributing them between the partner and the owner.\n *\n * Steps:\n * 1. Calculate the amount to send as 1% of the contract's balance.\n * 2. Send the calculated amount to the partner using a low-level call without checking the return value.\n *   - Note: The recipient can revert the transaction, but the owner will still receive their share.\n * 3. Transfer the same calculated amount to the owner.\n * 4. Update the last withdrawal time to the current block timestamp.\n * 5. Increment the partner's withdrawal balance by the amount sent.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Telephone.sol": [
        {
            "identifier": "changeOwner",
            "parameters": "address _owner",
            "modifiers": "",
            "return": "",
            "body": "function changeOwner(address _owner) public {\n        if (tx.origin != msg.sender) {\n            owner = _owner;\n        }\n    }",
            "start": "11",
            "end": "15",
            "class": "Telephone",
            "signature": " changeOwneraddress _owner",
            "full_signature": "function changeOwner(address _owner) public",
            "class_method_signature": "Telephone.changeOwneraddress _owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Changes the owner of the contract.\n * \n * Steps:\n * 1. Checks if the transaction origin is not the same as the message sender.\n * 2. If true, updates the owner to the provided address `_owner`.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/AlienCodex.sol": [
        {
            "identifier": "contacted",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier contacted() {\n        assert(contact);\n        _;\n    }",
            "start": "10",
            "end": "13",
            "class": "AlienCodex",
            "signature": " contacted",
            "full_signature": "function contacted()",
            "class_method_signature": "AlienCodex.contacted",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.5.0;"
            ],
            "import_directive": [
                "import \"../helpers/Ownable-05.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that ensures the `contact` condition is true before executing the function.\n * \n * Steps:\n * 1. Assert that the `contact` variable is true.\n * 2. Continue with the execution of the function if the assertion passes.\n */"
        },
        {
            "identifier": "codex",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32[]",
            "body": "bytes32[] public codex;",
            "start": "8",
            "end": "8",
            "class": "AlienCodex",
            "signature": "bytes32[] codex",
            "full_signature": "bytes32[] public  codex",
            "class_method_signature": "AlienCodex.codex",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.5.0;"
            ],
            "import_directive": [
                "import \"../helpers/Ownable-05.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public array of bytes32 to store data.\n * This array can be accessed and modified by any external or internal function.\n */"
        },
        {
            "identifier": "contact",
            "parameters": "",
            "modifiers": "",
            "return": "bool",
            "body": "bool public contact;",
            "start": "7",
            "end": "7",
            "class": "AlienCodex",
            "signature": "bool contact",
            "full_signature": "bool public  contact",
            "class_method_signature": "AlienCodex.contact",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.5.0;"
            ],
            "import_directive": [
                "import \"../helpers/Ownable-05.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `contact` of type `bool`.\n * This variable can be accessed externally to check or modify the contact status.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Delegation.sol": [
        {
            "identifier": "",
            "parameters": "address _delegateAddress",
            "modifiers": "",
            "return": "",
            "body": "constructor(address _delegateAddress) {\n        delegate = Delegate(_delegateAddress);\n        owner = msg.sender;\n    }",
            "start": "20",
            "end": "23",
            "class": "Delegation",
            "signature": " address _delegateAddress",
            "full_signature": "constructor (address _delegateAddress)",
            "class_method_signature": "Delegation.address _delegateAddress",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Constructor that initializes the contract with a delegate address and sets the owner to the message sender.\n * \n * @param _delegateAddress The address of the delegate contract to be used.\n */"
        },
        {
            "identifier": "owner",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public owner;",
            "start": "17",
            "end": "17",
            "class": "Delegation",
            "signature": "address owner",
            "full_signature": "address public  owner",
            "class_method_signature": "Delegation.owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores the address of the owner.\n */"
        },
        {
            "identifier": "delegate",
            "parameters": "",
            "modifiers": "",
            "return": "Delegate",
            "body": "Delegate delegate;",
            "start": "18",
            "end": "18",
            "class": "Delegation",
            "signature": "Delegate delegate",
            "full_signature": "Delegate   delegate",
            "class_method_signature": "Delegation.delegate",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Declares a variable `delegate` of type `Delegate`.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/GatekeeperThree.sol": [
        {
            "identifier": "password",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private password = block.timestamp;",
            "start": "7",
            "end": "7",
            "class": "SimpleTrick",
            "signature": "uint256 password",
            "full_signature": "uint256 private  password",
            "class_method_signature": "SimpleTrick.password",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable `password` initialized with the current block timestamp.\n */"
        },
        {
            "identifier": "target",
            "parameters": "",
            "modifiers": "",
            "return": "GatekeeperThree",
            "body": "GatekeeperThree public target;",
            "start": "5",
            "end": "5",
            "class": "SimpleTrick",
            "signature": "GatekeeperThree target",
            "full_signature": "GatekeeperThree public  target",
            "class_method_signature": "SimpleTrick.target",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Public state variable that holds an instance of the GatekeeperThree contract.\n */"
        },
        {
            "identifier": "checkPassword",
            "parameters": "uint256 _password",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function checkPassword(uint256 _password) public returns (bool) {\n        if (_password == password) {\n            return true;\n        }\n        password = block.timestamp;\n        return false;\n    }",
            "start": "13",
            "end": "19",
            "class": "SimpleTrick",
            "signature": "returns (bool) checkPassworduint256 _password",
            "full_signature": "function checkPassword(uint256 _password) public   returns (bool)",
            "class_method_signature": "SimpleTrick.checkPassworduint256 _password",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the provided password matches the stored password.\n * \n * Steps:\n * 1. If the provided password matches the stored password, return `true`.\n * 2. If the provided password does not match, update the stored password to the current block timestamp.\n * 3. Return `false`.\n */"
        },
        {
            "identifier": "trickInit",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "function trickInit() public {\n        trick = address(this);\n    }",
            "start": "21",
            "end": "23",
            "class": "SimpleTrick",
            "signature": " trickInit",
            "full_signature": "function trickInit() public",
            "class_method_signature": "SimpleTrick.trickInit",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Initializes the `trick` variable with the address of the current contract.\n *\n * Steps:\n * 1. Assign the address of the current contract (`address(this)`) to the `trick` variable.\n */"
        },
        {
            "identifier": "trickyTrick",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "function trickyTrick() public {\n        if (address(this) == msg.sender && address(this) != trick) {\n            target.getAllowance(password);\n        }\n    }",
            "start": "25",
            "end": "29",
            "class": "SimpleTrick",
            "signature": " trickyTrick",
            "full_signature": "function trickyTrick() public",
            "class_method_signature": "SimpleTrick.trickyTrick",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A function that performs a specific trick based on conditions.\n *\n * Steps:\n * 1. Check if the contract address is the same as the caller (msg.sender) and if the contract address is not equal to the `trick` address.\n * 2. If the conditions are met, call the `getAllowance` function on the `target` contract with the `password` as an argument.\n */"
        },
        {
            "identifier": "trick",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public trick;",
            "start": "6",
            "end": "6",
            "class": "SimpleTrick",
            "signature": "address trick",
            "full_signature": "address public  trick",
            "class_method_signature": "SimpleTrick.trick",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `trick` that stores an Ethereum address.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Privacy.sol": [
        {
            "identifier": "denomination",
            "parameters": "",
            "modifiers": "",
            "return": "uint8",
            "body": "uint8 private denomination = 255;",
            "start": "8",
            "end": "8",
            "class": "Privacy",
            "signature": "uint8 denomination",
            "full_signature": "uint8 private  denomination",
            "class_method_signature": "Privacy.denomination",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable `denomination` of type `uint8` initialized to 255.\n */"
        },
        {
            "identifier": "locked",
            "parameters": "",
            "modifiers": "",
            "return": "bool",
            "body": "bool public locked = true;",
            "start": "5",
            "end": "5",
            "class": "Privacy",
            "signature": "bool locked",
            "full_signature": "bool public  locked",
            "class_method_signature": "Privacy.locked",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `locked` initialized to `true`.\n */"
        },
        {
            "identifier": "flattening",
            "parameters": "",
            "modifiers": "",
            "return": "uint8",
            "body": "uint8 private flattening = 10;",
            "start": "7",
            "end": "7",
            "class": "Privacy",
            "signature": "uint8 flattening",
            "full_signature": "uint8 private  flattening",
            "class_method_signature": "Privacy.flattening",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable `flattening` of type `uint8` initialized to 10.\n */"
        },
        {
            "identifier": "ID",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public ID = block.timestamp;",
            "start": "6",
            "end": "6",
            "class": "Privacy",
            "signature": "uint256 ID",
            "full_signature": "uint256 public  ID",
            "class_method_signature": "Privacy.ID",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `ID` initialized with the current block's timestamp.\n * This variable is used to store a unique identifier based on the time of deployment or transaction execution.\n */"
        },
        {
            "identifier": "awkwardness",
            "parameters": "",
            "modifiers": "",
            "return": "uint16",
            "body": "uint16 private awkwardness = uint16(block.timestamp);",
            "start": "9",
            "end": "9",
            "class": "Privacy",
            "signature": "uint16 awkwardness",
            "full_signature": "uint16 private  awkwardness",
            "class_method_signature": "Privacy.awkwardness",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private state variable `awkwardness` initialized with the current block timestamp cast to a uint16.\n * This may lead to potential overflow or unexpected behavior due to the limited range of uint16.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Fallback.sol": [
        {
            "identifier": "contributions",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) public contributions;",
            "start": "5",
            "end": "5",
            "class": "Fallback",
            "signature": "mapping(address => uint256) contributions",
            "full_signature": "mapping(address => uint256) public  contributions",
            "class_method_signature": "Fallback.contributions",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public mapping that stores the contributions of addresses.\n * @dev Maps an address to a uint256 value representing the contribution amount.\n */"
        },
        {
            "identifier": "onlyOwner",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }",
            "start": "13",
            "end": "16",
            "class": "Fallback",
            "signature": " onlyOwner",
            "full_signature": "function onlyOwner()",
            "class_method_signature": "Fallback.onlyOwner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts access to the owner of the contract.\n * \n * Steps:\n * 1. Checks if the caller is the owner.\n * 2. If not, reverts with the message \"caller is not the owner\".\n * 3. If the caller is the owner, proceeds with the function execution.\n */"
        },
        {
            "identifier": "getContribution",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function getContribution() public view returns (uint256) {\n        return contributions[msg.sender];\n    }",
            "start": "26",
            "end": "28",
            "class": "Fallback",
            "signature": "returns (uint256) getContribution",
            "full_signature": "function getContribution() public  view returns (uint256)",
            "class_method_signature": "Fallback.getContribution",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the contribution amount of the caller.\n *\n * @return The contribution amount of the caller.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Shop.sol": [
        {
            "identifier": "price",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function price() external view returns (uint256);",
            "start": "5",
            "end": "5",
            "class": "Buyer",
            "signature": "returns (uint256) price",
            "full_signature": "function price() external  view returns (uint256)",
            "class_method_signature": "Buyer.price",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the current price as a uint256 value.\n * @dev This function is external and view-only, meaning it does not modify the state and can be called from outside the contract.\n * @return uint256 The current price.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/GoodSamaritan.sol": [
        {
            "identifier": "wallet",
            "parameters": "",
            "modifiers": "",
            "return": "Wallet",
            "body": "Wallet public wallet;",
            "start": "7",
            "end": "7",
            "class": "GoodSamaritan",
            "signature": "Wallet wallet",
            "full_signature": "Wallet public  wallet",
            "class_method_signature": "GoodSamaritan.wallet",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity >=0.8.0 <0.9.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/utils/Address.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Declares a public state variable `wallet` of type `Wallet`.\n * This variable can be accessed externally and is used to store an instance of the `Wallet` contract.\n */"
        },
        {
            "identifier": "coin",
            "parameters": "",
            "modifiers": "",
            "return": "Coin",
            "body": "Coin public coin;",
            "start": "8",
            "end": "8",
            "class": "GoodSamaritan",
            "signature": "Coin coin",
            "full_signature": "Coin public  coin",
            "class_method_signature": "GoodSamaritan.coin",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity >=0.8.0 <0.9.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/utils/Address.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Declares a public state variable `coin` of type `Coin`.\n * This variable can be accessed externally and is used to store an instance of the `Coin` contract.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/PuzzleWallet.sol": [
        {
            "identifier": "pendingAdmin",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public pendingAdmin;",
            "start": "8",
            "end": "8",
            "class": "PuzzleProxy",
            "signature": "address pendingAdmin",
            "full_signature": "address public  pendingAdmin",
            "class_method_signature": "PuzzleProxy.pendingAdmin",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;",
                "pragma experimental ABIEncoderV2;"
            ],
            "import_directive": [
                "import \"../helpers/UpgradeableProxy-08.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores the address of the pending admin.\n * The pending admin is an address that is proposed to become the new admin but has not yet been confirmed.\n */"
        },
        {
            "identifier": "approveNewAdmin",
            "parameters": "address _expectedAdmin",
            "modifiers": "onlyAdmin",
            "return": "",
            "body": "function approveNewAdmin(address _expectedAdmin) external onlyAdmin {\n        require(pendingAdmin == _expectedAdmin, \"Expected new admin by the current admin is not the pending admin\");\n        admin = pendingAdmin;\n    }",
            "start": "26",
            "end": "29",
            "class": "PuzzleProxy",
            "signature": " approveNewAdminaddress _expectedAdmin",
            "full_signature": "function approveNewAdmin(address _expectedAdmin) external  onlyAdmin",
            "class_method_signature": "PuzzleProxy.approveNewAdminaddress _expectedAdmin",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;",
                "pragma experimental ABIEncoderV2;"
            ],
            "import_directive": [
                "import \"../helpers/UpgradeableProxy-08.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Approves a new admin address if it matches the pending admin.\n * @dev This function can only be called by the current admin.\n * @param _expectedAdmin The address of the expected new admin.\n * Requirements:\n * - The `_expectedAdmin` must match the `pendingAdmin`.\n * Effects:\n * - Updates the `admin` to the `pendingAdmin`.\n * Reverts:\n * - If `_expectedAdmin` does not match `pendingAdmin`, reverts with the message \"Expected new admin by the current admin is not the pending admin\".\n */"
        },
        {
            "identifier": "admin",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address public admin;",
            "start": "9",
            "end": "9",
            "class": "PuzzleProxy",
            "signature": "address admin",
            "full_signature": "address public  admin",
            "class_method_signature": "PuzzleProxy.admin",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;",
                "pragma experimental ABIEncoderV2;"
            ],
            "import_directive": [
                "import \"../helpers/UpgradeableProxy-08.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores the address of the admin.\n */"
        },
        {
            "identifier": "upgradeTo",
            "parameters": "address _newImplementation",
            "modifiers": "onlyAdmin",
            "return": "",
            "body": "function upgradeTo(address _newImplementation) external onlyAdmin {\n        _upgradeTo(_newImplementation);\n    }",
            "start": "31",
            "end": "33",
            "class": "PuzzleProxy",
            "signature": " upgradeToaddress _newImplementation",
            "full_signature": "function upgradeTo(address _newImplementation) external  onlyAdmin",
            "class_method_signature": "PuzzleProxy.upgradeToaddress _newImplementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;",
                "pragma experimental ABIEncoderV2;"
            ],
            "import_directive": [
                "import \"../helpers/UpgradeableProxy-08.sol\";"
            ],
            "context": "{'function _upgradeTo(address newImplementation) internal'}",
            "human_labeled_comment": "/**\n * @notice Upgrades the contract to a new implementation address.\n * @dev This function can only be called by the admin.\n * @param _newImplementation The address of the new implementation to upgrade to.\n */"
        },
        {
            "identifier": "onlyAdmin",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyAdmin() {\n        require(msg.sender == admin, \"Caller is not the admin\");\n        _;\n    }",
            "start": "17",
            "end": "20",
            "class": "PuzzleProxy",
            "signature": " onlyAdmin",
            "full_signature": "function onlyAdmin()",
            "class_method_signature": "PuzzleProxy.onlyAdmin",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;",
                "pragma experimental ABIEncoderV2;"
            ],
            "import_directive": [
                "import \"../helpers/UpgradeableProxy-08.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts access to the admin.\n * \n * Steps:\n * 1. Checks if the caller is the admin.\n * 2. If not, reverts with the message \"Caller is not the admin\".\n * 3. If the caller is the admin, proceeds with the function execution.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Recovery.sol": [
        {
            "identifier": "generateToken",
            "parameters": "string memory _name, uint256 _initialSupply",
            "modifiers": "",
            "return": "",
            "body": "function generateToken(string memory _name, uint256 _initialSupply) public {\n        new SimpleToken(_name, msg.sender, _initialSupply);\n    }",
            "start": "6",
            "end": "8",
            "class": "Recovery",
            "signature": " generateTokenstring memory _name, uint256 _initialSupply",
            "full_signature": "function generateToken(string memory _name, uint256 _initialSupply) public",
            "class_method_signature": "Recovery.generateTokenstring memory _name, uint256 _initialSupply",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Generates a new SimpleToken with the specified name and initial supply.\n *\n * Steps:\n * 1. Deploys a new SimpleToken contract with the provided `_name`, the caller's address as the owner, and `_initialSupply` as the initial token supply.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Vault.sol": [
        {
            "identifier": "locked",
            "parameters": "",
            "modifiers": "",
            "return": "bool",
            "body": "bool public locked;",
            "start": "5",
            "end": "5",
            "class": "Vault",
            "signature": "bool locked",
            "full_signature": "bool public  locked",
            "class_method_signature": "Vault.locked",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `locked` of type `bool`.\n * This variable can be accessed externally to check the locked status.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/King.sol": [
        {
            "identifier": "prize",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public prize;",
            "start": "6",
            "end": "6",
            "class": "King",
            "signature": "uint256 prize",
            "full_signature": "uint256 public  prize",
            "class_method_signature": "King.prize",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable `prize` of type `uint256`.\n * This variable can be accessed externally to retrieve the value of `prize`.\n */"
        },
        {
            "identifier": "king",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address king;",
            "start": "5",
            "end": "5",
            "class": "King",
            "signature": "address king",
            "full_signature": "address   king",
            "class_method_signature": "King.king",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A state variable to store the address of the current king.\n */"
        },
        {
            "identifier": "_king",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (address)",
            "body": "function _king() public view returns (address) {\n        return king;\n    }",
            "start": "22",
            "end": "24",
            "class": "King",
            "signature": "returns (address) _king",
            "full_signature": "function _king() public  view returns (address)",
            "class_method_signature": "King._king",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the current king address.\n * @return The address of the current king.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Elevator.sol": [
        {
            "identifier": "isLastFloor",
            "parameters": "uint256",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function isLastFloor(uint256) external returns (bool);",
            "start": "5",
            "end": "5",
            "class": "Building",
            "signature": "returns (bool) isLastFlooruint256",
            "full_signature": "function isLastFloor(uint256) external   returns (bool)",
            "class_method_signature": "Building.isLastFlooruint256",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the given floor is the last floor.\n * @param uint256 The floor number to check.\n * @return bool Returns true if the floor is the last floor, otherwise false.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/NaughtCoin.sol": [
        {
            "identifier": "timeLock",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public timeLock = block.timestamp + 10 * 365 days;",
            "start": "10",
            "end": "10",
            "class": "NaughtCoin",
            "signature": "uint256 timeLock",
            "full_signature": "uint256 public  timeLock",
            "class_method_signature": "NaughtCoin.timeLock",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that sets a time lock 10 years from the current block timestamp.\n * The time lock is calculated by adding 10 years (in seconds) to the current block timestamp.\n */"
        },
        {
            "identifier": "transfer",
            "parameters": "address _to, uint256 _value",
            "modifiers": "lockTokens",
            "return": "returns (bool)",
            "body": "function transfer(address _to, uint256 _value) public override lockTokens returns (bool) {\n        super.transfer(_to, _value);\n    }",
            "start": "23",
            "end": "25",
            "class": "NaughtCoin",
            "signature": "returns (bool) transferaddress _to, uint256 _value",
            "full_signature": "function transfer(address _to, uint256 _value) public  lockTokens returns (bool)",
            "class_method_signature": "NaughtCoin.transferaddress _to, uint256 _value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Transfers tokens from the caller's address to the specified address.\n * @dev Overrides the `transfer` function from the parent contract and applies the `lockTokens` modifier.\n * @param _to The address to which tokens will be transferred.\n * @param _value The amount of tokens to transfer.\n * @return A boolean indicating whether the transfer was successful.\n */"
        },
        {
            "identifier": "INITIAL_SUPPLY",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public INITIAL_SUPPLY;",
            "start": "11",
            "end": "11",
            "class": "NaughtCoin",
            "signature": "uint256 INITIAL_SUPPLY",
            "full_signature": "uint256 public  INITIAL_SUPPLY",
            "class_method_signature": "NaughtCoin.INITIAL_SUPPLY",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable representing the initial supply of a token or asset.\n * This variable is of type uint256 and can be accessed by any external or internal caller.\n */"
        },
        {
            "identifier": "lockTokens",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier lockTokens() {\n        if (msg.sender == player) {\n            require(block.timestamp > timeLock);\n            _;\n        } else {\n            _;\n        }\n    }",
            "start": "28",
            "end": "35",
            "class": "NaughtCoin",
            "signature": " lockTokens",
            "full_signature": "function lockTokens()",
            "class_method_signature": "NaughtCoin.lockTokens",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts token operations based on the sender and a time lock.\n *\n * Behavior:\n * - If the sender is the player, it enforces that the current block timestamp is greater than the `timeLock`.\n * - If the sender is not the player, it allows the function to proceed without any restrictions.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Motorbike.sol": [
        {
            "identifier": "_getAddressSlot",
            "parameters": "bytes32 slot",
            "modifiers": "pure",
            "return": "returns (AddressSlot storage r)",
            "body": "function _getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r_slot := slot\n        }\n    }",
            "start": "44",
            "end": "48",
            "class": "Motorbike",
            "signature": "returns (AddressSlot storage r) _getAddressSlotbytes32 slot",
            "full_signature": "function _getAddressSlot(bytes32 slot) internal  pure returns (AddressSlot storage r)",
            "class_method_signature": "Motorbike._getAddressSlotbytes32 slot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity <0.7.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/utils/Address.sol\";",
                "import \"openzeppelin-contracts-06/proxy/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the storage slot for an address based on the provided slot identifier.\n *\n * @param slot The bytes32 identifier for the storage slot.\n * @return r The AddressSlot storage reference corresponding to the provided slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided slot to the storage reference.\n */"
        },
        {
            "identifier": "AddressSlot",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct AddressSlot {\n        address value;\n    }",
            "start": "12",
            "end": "14",
            "class": "Motorbike",
            "signature": " AddressSlot",
            "full_signature": "function AddressSlot()",
            "class_method_signature": "Motorbike.AddressSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity <0.7.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/utils/Address.sol\";",
                "import \"openzeppelin-contracts-06/proxy/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A struct representing a storage slot for an address value.\n * @dev This struct is used to store a single address value in a storage slot.\n */"
        },
        {
            "identifier": "_delegate",
            "parameters": "address implementation",
            "modifiers": "",
            "return": "",
            "body": "function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }",
            "start": "25",
            "end": "35",
            "class": "Motorbike",
            "signature": " _delegateaddress implementation",
            "full_signature": "function _delegate(address implementation) internal virtual",
            "class_method_signature": "Motorbike._delegateaddress implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity <0.7.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/utils/Address.sol\";",
                "import \"openzeppelin-contracts-06/proxy/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Delegates the current call to an implementation address.\n *\n * Steps:\n * 1. Copies the calldata to memory.\n * 2. Performs a delegatecall to the implementation address with the copied calldata.\n * 3. Copies the returned data to memory.\n * 4. Checks the result of the delegatecall:\n *    - If the result is 0, reverts with the returned data.\n *    - Otherwise, returns the returned data.\n *\n * @dev This function uses inline assembly to perform low-level operations.\n * @param implementation The address of the contract to delegate the call to.\n */"
        },
        {
            "identifier": "_IMPLEMENTATION_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
            "start": "10",
            "end": "10",
            "class": "Motorbike",
            "signature": "bytes32 _IMPLEMENTATION_SLOT",
            "full_signature": "bytes32 internal constant _IMPLEMENTATION_SLOT",
            "class_method_signature": "Motorbike._IMPLEMENTATION_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity <0.7.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/utils/Address.sol\";",
                "import \"openzeppelin-contracts-06/proxy/Initializable.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant `_IMPLEMENTATION_SLOT` with a specific bytes32 value.\n * This slot is typically used in proxy patterns to store the address of the implementation contract.\n * The value `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` is a standard slot for the implementation address in EIP-1967.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Switch.sol": [
        {
            "identifier": "offSelector",
            "parameters": "",
            "modifiers": "",
            "return": "bytes4",
            "body": "bytes4 public offSelector = bytes4(keccak256(\"turnSwitchOff()\"));",
            "start": "6",
            "end": "6",
            "class": "Switch",
            "signature": "bytes4 offSelector",
            "full_signature": "bytes4 public  offSelector",
            "class_method_signature": "Switch.offSelector",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public variable `offSelector` that stores the function selector for the `turnSwitchOff()` function.\n * The selector is computed using `keccak256` to hash the function signature and then taking the first 4 bytes.\n */"
        },
        {
            "identifier": "onlyThis",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyThis() {\n        require(msg.sender == address(this), \"Only the contract can call this\");\n        _;\n    }",
            "start": "8",
            "end": "11",
            "class": "Switch",
            "signature": " onlyThis",
            "full_signature": "function onlyThis()",
            "class_method_signature": "Switch.onlyThis",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts access to the contract itself.\n * \n * Requirements:\n * - The caller must be the contract itself.\n * \n * Reverts:\n * - If the caller is not the contract, with the message \"Only the contract can call this\".\n */"
        },
        {
            "identifier": "onlyOff",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyOff() {\n        // we use a complex data type to put in memory\n        bytes32[1] memory selector;\n        // check that the calldata at position 68 (location of _data)\n        assembly {\n            calldatacopy(selector, 68, 4) // grab function selector from calldata\n        }\n        require(selector[0] == offSelector, \"Can only call the turnOffSwitch function\");\n        _;\n    }",
            "start": "13",
            "end": "22",
            "class": "Switch",
            "signature": " onlyOff",
            "full_signature": "function onlyOff()",
            "class_method_signature": "Switch.onlyOff",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts access to only the `turnOffSwitch` function.\n *\n * Steps:\n * 1. Declare a memory array `selector` to store the function selector.\n * 2. Use assembly to copy the function selector from calldata at position 68.\n * 3. Require that the copied selector matches the `offSelector`.\n * 4. If the condition is met, allow the function to proceed; otherwise, revert with an error message.\n */"
        },
        {
            "identifier": "turnSwitchOn",
            "parameters": "",
            "modifiers": "onlyThis",
            "return": "",
            "body": "function turnSwitchOn() public onlyThis {\n        switchOn = true;\n    }",
            "start": "29",
            "end": "31",
            "class": "Switch",
            "signature": " turnSwitchOn",
            "full_signature": "function turnSwitchOn() public  onlyThis",
            "class_method_signature": "Switch.turnSwitchOn",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Turns the switch on.\n * @dev This function can only be called by the contract itself (using `onlyThis` modifier).\n * It sets the `switchOn` state variable to `true`.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Token.sol": [
        {
            "identifier": "balanceOf",
            "parameters": "address _owner",
            "modifiers": "view",
            "return": "returns (uint256 balance)",
            "body": "function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }",
            "start": "19",
            "end": "21",
            "class": "Token",
            "signature": "returns (uint256 balance) balanceOfaddress _owner",
            "full_signature": "function balanceOf(address _owner) public  view returns (uint256 balance)",
            "class_method_signature": "Token.balanceOfaddress _owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the token balance of a specified address.\n *\n * @param _owner The address of the account whose balance is being queried.\n * @return balance The token balance of the specified address.\n */"
        },
        {
            "identifier": "balances",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) balances;",
            "start": "5",
            "end": "5",
            "class": "Token",
            "signature": "mapping(address => uint256) balances",
            "full_signature": "mapping(address => uint256)   balances",
            "class_method_signature": "Token.balances",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A mapping that stores the balance of each address.\n * @dev The key is an address, and the value is the corresponding balance (uint256).\n */"
        },
        {
            "identifier": "totalSupply",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public totalSupply;",
            "start": "6",
            "end": "6",
            "class": "Token",
            "signature": "uint256 totalSupply",
            "full_signature": "uint256 public  totalSupply",
            "class_method_signature": "Token.totalSupply",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable representing the total supply of tokens or assets.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/MagicAnimalCarousel.sol": [
        {
            "identifier": "encodeAnimalName",
            "parameters": "string calldata animalName",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function encodeAnimalName(string calldata animalName) public pure returns (uint256) {\n        require(bytes(animalName).length <= 12, AnimalNameTooLong());\n        return uint256(bytes32(abi.encodePacked(animalName)) >> 160);\n    }",
            "start": "46",
            "end": "49",
            "class": "MagicAnimalCarousel",
            "signature": "returns (uint256) encodeAnimalNamestring calldata animalName",
            "full_signature": "function encodeAnimalName(string calldata animalName) public  pure returns (uint256)",
            "class_method_signature": "MagicAnimalCarousel.encodeAnimalNamestring calldata animalName",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Encodes a given animal name into a uint256 value.\n *\n * Steps:\n * 1. Checks if the length of the animal name is 12 characters or less.\n *    - Reverts with `AnimalNameTooLong` error if the name exceeds 12 characters.\n * 2. Packs the animal name into bytes32 using `abi.encodePacked`.\n * 3. Shifts the packed bytes32 value right by 160 bits.\n * 4. Converts the result to a uint256 and returns it.\n */"
        },
        {
            "identifier": "NEXT_ID_MASK",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 constant NEXT_ID_MASK = uint256(type(uint16).max) << 160;",
            "start": "7",
            "end": "7",
            "class": "MagicAnimalCarousel",
            "signature": "uint256 NEXT_ID_MASK",
            "full_signature": "uint256  constant NEXT_ID_MASK",
            "class_method_signature": "MagicAnimalCarousel.NEXT_ID_MASK",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask used to extract or manipulate the next ID in a 256-bit value.\n * The mask is created by shifting the maximum value of a uint16 (2^16 - 1) left by 160 bits.\n * This is typically used in scenarios where IDs are packed into higher bits of a larger data structure.\n */"
        },
        {
            "identifier": "OWNER_MASK",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 constant OWNER_MASK = uint256(type(uint160).max);",
            "start": "8",
            "end": "8",
            "class": "MagicAnimalCarousel",
            "signature": "uint256 OWNER_MASK",
            "full_signature": "uint256  constant OWNER_MASK",
            "class_method_signature": "MagicAnimalCarousel.OWNER_MASK",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask for the owner address.\n * @dev The mask is derived from the maximum value of a uint160, which is used to represent Ethereum addresses.\n */"
        },
        {
            "identifier": "AnimalNameTooLong",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error AnimalNameTooLong();",
            "start": "13",
            "end": "13",
            "class": "MagicAnimalCarousel",
            "signature": " AnimalNameTooLong",
            "full_signature": "function AnimalNameTooLong()",
            "class_method_signature": "MagicAnimalCarousel.AnimalNameTooLong",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the provided animal name exceeds the allowed length.\n */"
        },
        {
            "identifier": "ANIMAL_MASK",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 constant ANIMAL_MASK = uint256(type(uint80).max) << 160 + 16;",
            "start": "6",
            "end": "6",
            "class": "MagicAnimalCarousel",
            "signature": "uint256 ANIMAL_MASK",
            "full_signature": "uint256  constant ANIMAL_MASK",
            "class_method_signature": "MagicAnimalCarousel.ANIMAL_MASK",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask for animal-related data.\n * \n * The mask is created by shifting the maximum value of a uint80 (80-bit unsigned integer) \n * left by 160 + 16 bits, effectively creating a mask that can be used to extract or manipulate \n * specific bits in a 256-bit value related to animal data.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Stake.sol": [
        {
            "identifier": "UserStake",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) public UserStake;",
            "start": "6",
            "end": "6",
            "class": "Stake",
            "signature": "mapping(address => uint256) UserStake",
            "full_signature": "mapping(address => uint256) public  UserStake",
            "class_method_signature": "Stake.UserStake",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public mapping that stores the stake amount (uint256) for each user address.\n * The key is the user's address, and the value is the amount of stake they have.\n */"
        },
        {
            "identifier": "Stakers",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => bool)",
            "body": "mapping(address => bool) public Stakers;",
            "start": "7",
            "end": "7",
            "class": "Stake",
            "signature": "mapping(address => bool) Stakers",
            "full_signature": "mapping(address => bool) public  Stakers",
            "class_method_signature": "Stake.Stakers",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public mapping that associates addresses with a boolean value.\n * @dev This mapping can be used to track whether an address is a staker or not.\n *      The key is an address, and the value is a boolean indicating staker status.\n */"
        },
        {
            "identifier": "StakeETH",
            "parameters": "",
            "modifiers": "payable",
            "return": "",
            "body": "function StakeETH() public payable {\n        require(msg.value > 0.001 ether, \"Don't be cheap\");\n        totalStaked += msg.value;\n        UserStake[msg.sender] += msg.value;\n        Stakers[msg.sender] = true;\n    }",
            "start": "15",
            "end": "20",
            "class": "Stake",
            "signature": " StakeETH",
            "full_signature": "function StakeETH() public  payable",
            "class_method_signature": "Stake.StakeETH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Allows users to stake ETH in the contract.\n *\n * Requirements:\n * - The amount of ETH sent must be greater than 0.001 ether.\n *\n * Effects:\n * - Increases the total staked amount by the sent value.\n * - Updates the staked amount for the sender in the UserStake mapping.\n * - Marks the sender as a staker in the Stakers mapping.\n */"
        },
        {
            "identifier": "bytesToUint",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function bytesToUint(bytes memory data) internal pure returns (uint256) {\n        require(data.length >= 32, \"Data length must be at least 32 bytes\");\n        uint256 result;\n        assembly {\n            result := mload(add(data, 0x20))\n        }\n        return result;\n    }",
            "start": "39",
            "end": "46",
            "class": "Stake",
            "signature": "returns (uint256) bytesToUintbytes memory data",
            "full_signature": "function bytesToUint(bytes memory data) internal  pure returns (uint256)",
            "class_method_signature": "Stake.bytesToUintbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a bytes array to a uint256 value.\n *\n * Steps:\n * 1. Require that the input data length is at least 32 bytes.\n * 2. Use inline assembly to load the first 32 bytes of the data into a uint256 variable.\n * 3. Return the resulting uint256 value.\n *\n * @param data The bytes array to be converted.\n * @return result The uint256 value derived from the bytes array.\n */"
        },
        {
            "identifier": "totalStaked",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 public totalStaked;",
            "start": "5",
            "end": "5",
            "class": "Stake",
            "signature": "uint256 totalStaked",
            "full_signature": "uint256 public  totalStaked",
            "class_method_signature": "Stake.totalStaked",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that tracks the total amount of staked tokens.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Fallout.sol": [
        {
            "identifier": "collectAllocations",
            "parameters": "",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function collectAllocations() public onlyOwner {\n        msg.sender.transfer(address(this).balance);\n    }",
            "start": "32",
            "end": "34",
            "class": "Fallout",
            "signature": " collectAllocations",
            "full_signature": "function collectAllocations() public  onlyOwner",
            "class_method_signature": "Fallout.collectAllocations",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Allows the owner to collect all allocated funds from the contract.\n *\n * Steps:\n * 1. Checks that the caller is the owner (via the `onlyOwner` modifier).\n * 2. Transfers the entire contract balance to the owner's address.\n */"
        },
        {
            "identifier": "allocate",
            "parameters": "",
            "modifiers": "payable",
            "return": "",
            "body": "function allocate() public payable {\n        allocations[msg.sender] = allocations[msg.sender].add(msg.value);\n    }",
            "start": "23",
            "end": "25",
            "class": "Fallout",
            "signature": " allocate",
            "full_signature": "function allocate() public  payable",
            "class_method_signature": "Fallout.allocate",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Allocates funds to the caller's address.\n *\n * Steps:\n * 1. Adds the sent value (msg.value) to the caller's (msg.sender) allocation balance.\n */"
        },
        {
            "identifier": "onlyOwner",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyOwner() {\n        require(msg.sender == owner, \"caller is not the owner\");\n        _;\n    }",
            "start": "18",
            "end": "21",
            "class": "Fallout",
            "signature": " onlyOwner",
            "full_signature": "function onlyOwner()",
            "class_method_signature": "Fallout.onlyOwner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts access to the owner of the contract.\n * \n * Steps:\n * 1. Checks if the caller is the owner.\n * 2. If not, reverts with the message \"caller is not the owner\".\n * 3. If the caller is the owner, proceeds with the function execution.\n */"
        },
        {
            "identifier": "sendAllocation",
            "parameters": "address payable allocator",
            "modifiers": "",
            "return": "",
            "body": "function sendAllocation(address payable allocator) public {\n        require(allocations[allocator] > 0);\n        allocator.transfer(allocations[allocator]);\n    }",
            "start": "27",
            "end": "30",
            "class": "Fallout",
            "signature": " sendAllocationaddress payable allocator",
            "full_signature": "function sendAllocation(address payable allocator) public",
            "class_method_signature": "Fallout.sendAllocationaddress payable allocator",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sends the allocated amount to the specified allocator.\n *\n * Steps:\n * 1. Checks if the allocator has a positive allocation.\n * 2. Transfers the allocated amount to the allocator's address.\n */"
        },
        {
            "identifier": "owner",
            "parameters": "",
            "modifiers": "",
            "return": "address payable",
            "body": "address payable public owner;",
            "start": "10",
            "end": "10",
            "class": "Fallout",
            "signature": "address payable owner",
            "full_signature": "address payable public  owner",
            "class_method_signature": "Fallout.owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable representing the owner of the contract.\n * @dev The owner is stored as a payable address, allowing it to receive Ether.\n */"
        },
        {
            "identifier": "allocations",
            "parameters": "",
            "modifiers": "",
            "return": "mapping(address => uint256)",
            "body": "mapping(address => uint256) allocations;",
            "start": "9",
            "end": "9",
            "class": "Fallout",
            "signature": "mapping(address => uint256) allocations",
            "full_signature": "mapping(address => uint256)   allocations",
            "class_method_signature": "Fallout.allocations",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A mapping that stores allocations (uint256 values) associated with addresses.\n * @dev The key is an address, and the value is a uint256 representing the allocation for that address.\n */"
        },
        {
            "identifier": "allocatorBalance",
            "parameters": "address allocator",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function allocatorBalance(address allocator) public view returns (uint256) {\n        return allocations[allocator];\n    }",
            "start": "36",
            "end": "38",
            "class": "Fallout",
            "signature": "returns (uint256) allocatorBalanceaddress allocator",
            "full_signature": "function allocatorBalance(address allocator) public  view returns (uint256)",
            "class_method_signature": "Fallout.allocatorBalanceaddress allocator",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the balance allocated to a specific allocator.\n * \n * @param allocator The address of the allocator whose balance is being queried.\n * @return uint256 The balance allocated to the specified allocator.\n */"
        }
    ],
    "/root/uniswap-solidity-hooks-template/lib/uniswap-solidity-hooks-template/test/utils/EasyPosm.sol": [
        {
            "identifier": "increaseLiquidity",
            "parameters": "IPositionManager posm, uint256 tokenId, uint256 liquidityToAdd, uint256 amount0Max, uint256 amount1Max, uint256 deadline, bytes memory hookData",
            "modifiers": "",
            "return": "returns (BalanceDelta delta)",
            "body": "function increaseLiquidity(\n        IPositionManager posm,\n        uint256 tokenId,\n        uint256 liquidityToAdd,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        uint256 deadline,\n        bytes memory hookData\n    ) internal returns (BalanceDelta delta) {\n        (Currency currency0, Currency currency1) = getCurrencies(posm, tokenId);\n\n        bytes[] memory params = new bytes[](3);\n        params[0] = abi.encode(tokenId, liquidityToAdd, amount0Max, amount1Max, hookData);\n        params[1] = abi.encode(currency0);\n        params[2] = abi.encode(currency1);\n\n        uint256 balance0Before = currency0.balanceOf(address(this));\n        uint256 balance1Before = currency1.balanceOf(address(this));\n\n        uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;\n        posm.modifyLiquidities{value: valueToPass}(\n            abi.encode(\n                abi.encodePacked(\n                    uint8(Actions.INCREASE_LIQUIDITY), uint8(Actions.CLOSE_CURRENCY), uint8(Actions.CLOSE_CURRENCY)\n                ),\n                params\n            ),\n            deadline\n        );\n\n        delta = toBalanceDelta(\n            (currency0.balanceOf(address(this)).toInt256() - balance0Before.toInt256()).toInt128(),\n            (currency1.balanceOf(address(this)).toInt256() - balance1Before.toInt256()).toInt128()\n        );\n    }",
            "start": "67",
            "end": "101",
            "class": "EasyPosm",
            "signature": "returns (BalanceDelta delta) increaseLiquidityIPositionManager posm, uint256 tokenId, uint256 liquidityToAdd, uint256 amount0Max, uint256 amount1Max, uint256 deadline, bytes memory hookData",
            "full_signature": "function increaseLiquidity(IPositionManager posm, uint256 tokenId, uint256 liquidityToAdd, uint256 amount0Max, uint256 amount1Max, uint256 deadline, bytes memory hookData) internal   returns (BalanceDelta delta)",
            "class_method_signature": "EasyPosm.increaseLiquidityIPositionManager posm, uint256 tokenId, uint256 liquidityToAdd, uint256 amount0Max, uint256 amount1Max, uint256 deadline, bytes memory hookData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Increases liquidity for a given position in a PositionManager.\n *\n * Steps:\n * 1. Retrieve the currencies (currency0 and currency1) associated with the given tokenId from the PositionManager.\n * 2. Prepare parameters for the liquidity increase operation, including tokenId, liquidityToAdd, amount0Max, amount1Max, and hookData.\n * 3. Record the current balances of currency0 and currency1 before the operation.\n * 4. Determine the value to pass (if any) based on whether currency0 is the zero address.\n * 5. Call the `modifyLiquidities` function on the PositionManager with the prepared parameters and deadline.\n * 6. Calculate the balance delta by comparing the current balances of currency0 and currency1 after the operation.\n * 7. Return the calculated balance delta.\n */"
        },
        {
            "identifier": "decreaseLiquidity",
            "parameters": "IPositionManager posm, uint256 tokenId, uint256 liquidityToRemove, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "modifiers": "",
            "return": "returns (BalanceDelta delta)",
            "body": "function decreaseLiquidity(\n        IPositionManager posm,\n        uint256 tokenId,\n        uint256 liquidityToRemove,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address recipient,\n        uint256 deadline,\n        bytes memory hookData\n    ) internal returns (BalanceDelta delta) {\n        (Currency currency0, Currency currency1) = getCurrencies(posm, tokenId);\n\n        bytes[] memory params = new bytes[](2);\n        params[0] = abi.encode(tokenId, liquidityToRemove, amount0Min, amount1Min, hookData);\n        params[1] = abi.encode(currency0, currency1, recipient);\n\n        uint256 balance0Before = currency0.balanceOf(address(this));\n        uint256 balance1Before = currency1.balanceOf(address(this));\n\n        posm.modifyLiquidities(\n            abi.encode(abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR)), params), deadline\n        );\n\n        delta = toBalanceDelta(\n            (currency0.balanceOf(address(this)) - balance0Before).toInt128(),\n            (currency1.balanceOf(address(this)) - balance1Before).toInt128()\n        );\n    }",
            "start": "103",
            "end": "130",
            "class": "EasyPosm",
            "signature": "returns (BalanceDelta delta) decreaseLiquidityIPositionManager posm, uint256 tokenId, uint256 liquidityToRemove, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "full_signature": "function decreaseLiquidity(IPositionManager posm, uint256 tokenId, uint256 liquidityToRemove, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData) internal   returns (BalanceDelta delta)",
            "class_method_signature": "EasyPosm.decreaseLiquidityIPositionManager posm, uint256 tokenId, uint256 liquidityToRemove, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Decreases liquidity for a given position in a Uniswap V3 pool.\n *\n * Steps:\n * 1. Retrieve the currencies (token0 and token1) associated with the position using the tokenId.\n * 2. Prepare parameters for the liquidity decrease operation, including:\n *    - tokenId: The ID of the position.\n *    - liquidityToRemove: The amount of liquidity to remove.\n *    - amount0Min: The minimum amount of token0 to receive.\n *    - amount1Min: The minimum amount of token1 to receive.\n *    - hookData: Additional data for the liquidity modification.\n * 3. Encode the recipient address and the currencies into the parameters.\n * 4. Record the balances of token0 and token1 before the liquidity decrease.\n * 5. Call the `modifyLiquidities` function on the PositionManager with the encoded parameters and deadline.\n * 6. Calculate the balance changes for token0 and token1 after the liquidity decrease.\n * 7. Return the balance delta as a `BalanceDelta` struct.\n */"
        },
        {
            "identifier": "burn",
            "parameters": "IPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "modifiers": "",
            "return": "returns (BalanceDelta delta)",
            "body": "function burn(\n        IPositionManager posm,\n        uint256 tokenId,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address recipient,\n        uint256 deadline,\n        bytes memory hookData\n    ) internal returns (BalanceDelta delta) {\n        (Currency currency0, Currency currency1) = getCurrencies(posm, tokenId);\n\n        bytes[] memory params = new bytes[](2);\n        params[0] = abi.encode(tokenId, 0, amount0Min, amount1Min, hookData);\n        params[1] = abi.encode(currency0, currency1, recipient);\n\n        uint256 balance0Before = currency0.balanceOf(recipient);\n        uint256 balance1Before = currency1.balanceOf(recipient);\n\n        posm.modifyLiquidities(\n            abi.encode(abi.encodePacked(uint8(Actions.BURN_POSITION), uint8(Actions.TAKE_PAIR)), params), deadline\n        );\n\n        delta = toBalanceDelta(\n            (currency0.balanceOf(recipient) - balance0Before).toInt128(),\n            (currency1.balanceOf(recipient) - balance1Before).toInt128()\n        );\n    }",
            "start": "161",
            "end": "187",
            "class": "EasyPosm",
            "signature": "returns (BalanceDelta delta) burnIPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "full_signature": "function burn(IPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData) internal   returns (BalanceDelta delta)",
            "class_method_signature": "EasyPosm.burnIPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Burns a liquidity position and returns the balance delta for the recipient.\n *\n * Steps:\n * 1. Retrieve the currencies (currency0 and currency1) associated with the given tokenId from the PositionManager.\n * 2. Prepare parameters for the burn operation, including tokenId, minimum amounts (amount0Min, amount1Min), recipient address, and hook data.\n * 3. Record the recipient's balance of currency0 and currency1 before the burn operation.\n * 4. Call the PositionManager's `modifyLiquidities` function with the encoded burn and take pair actions, along with the deadline.\n * 5. Calculate the balance delta by comparing the recipient's balances before and after the burn operation.\n * 6. Return the balance delta as a `BalanceDelta` struct.\n */"
        },
        {
            "identifier": "mint",
            "parameters": "IPositionManager posm, PoolKey memory poolKey, int24 tickLower, int24 tickUpper, uint256 liquidity, uint256 amount0Max, uint256 amount1Max, address recipient, uint256 deadline, bytes memory hookData",
            "modifiers": "",
            "return": "returns (uint256 tokenId, BalanceDelta delta)",
            "body": "function mint(\n        IPositionManager posm,\n        PoolKey memory poolKey,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 liquidity,\n        uint256 amount0Max,\n        uint256 amount1Max,\n        address recipient,\n        uint256 deadline,\n        bytes memory hookData\n    ) internal returns (uint256 tokenId, BalanceDelta delta) {\n        (Currency currency0, Currency currency1) = (poolKey.currency0, poolKey.currency1);\n\n        MintData memory mintData = MintData({\n            balance0Before: currency0.balanceOf(address(this)),\n            balance1Before: currency1.balanceOf(address(this)),\n            params: new bytes[](2)\n        });\n        mintData.params[0] =\n            abi.encode(poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, recipient, hookData);\n        mintData.params[1] = abi.encode(currency0, currency1);\n\n        // Mint Liquidity\n        tokenId = posm.nextTokenId();\n        uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;\n        posm.modifyLiquidities{value: valueToPass}(\n            abi.encode(abi.encodePacked(uint8(Actions.MINT_POSITION), uint8(Actions.SETTLE_PAIR)), mintData.params),\n            deadline\n        );\n\n        delta = toBalanceDelta(\n            -(mintData.balance0Before - currency0.balanceOf(address(this))).toInt128(),\n            -(mintData.balance1Before - currency1.balanceOf(address(this))).toInt128()\n        );\n    }",
            "start": "30",
            "end": "65",
            "class": "EasyPosm",
            "signature": "returns (uint256 tokenId, BalanceDelta delta) mintIPositionManager posm, PoolKey memory poolKey, int24 tickLower, int24 tickUpper, uint256 liquidity, uint256 amount0Max, uint256 amount1Max, address recipient, uint256 deadline, bytes memory hookData",
            "full_signature": "function mint(IPositionManager posm, PoolKey memory poolKey, int24 tickLower, int24 tickUpper, uint256 liquidity, uint256 amount0Max, uint256 amount1Max, address recipient, uint256 deadline, bytes memory hookData) internal   returns (uint256 tokenId, BalanceDelta delta)",
            "class_method_signature": "EasyPosm.mintIPositionManager posm, PoolKey memory poolKey, int24 tickLower, int24 tickUpper, uint256 liquidity, uint256 amount0Max, uint256 amount1Max, address recipient, uint256 deadline, bytes memory hookData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Mints a new liquidity position in a pool.\n *\n * Steps:\n * 1. Extract the currencies (currency0 and currency1) from the provided poolKey.\n * 2. Create a MintData struct to store the balances of the currencies before minting and the parameters for the mint operation.\n * 3. Encode the minting parameters (poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, recipient, hookData) into the first parameter of the MintData struct.\n * 4. Encode the currencies (currency0 and currency1) into the second parameter of the MintData struct.\n *\n * 5. Mint liquidity by calling the modifyLiquidities function on the PositionManager (posm).\n * 6. Pass the encoded parameters and the deadline to the modifyLiquidities function.\n * 7. If currency0 is the zero address, pass amount0Max as the value; otherwise, pass 0.\n *\n * 8. Calculate the balance delta by comparing the balances of currency0 and currency1 before and after the mint operation.\n * 9. Return the tokenId of the newly minted position and the calculated balance delta.\n */"
        },
        {
            "identifier": "getCurrencies",
            "parameters": "IPositionManager posm, uint256 tokenId",
            "modifiers": "view",
            "return": "returns (Currency currency0, Currency currency1)",
            "body": "function getCurrencies(IPositionManager posm, uint256 tokenId)\n        internal\n        view\n        returns (Currency currency0, Currency currency1)\n    {\n        (PoolKey memory key,) = posm.getPoolAndPositionInfo(tokenId);\n        return (key.currency0, key.currency1);\n    }",
            "start": "189",
            "end": "196",
            "class": "EasyPosm",
            "signature": "returns (Currency currency0, Currency currency1) getCurrenciesIPositionManager posm, uint256 tokenId",
            "full_signature": "function getCurrencies(IPositionManager posm, uint256 tokenId) internal  view returns (Currency currency0, Currency currency1)",
            "class_method_signature": "EasyPosm.getCurrenciesIPositionManager posm, uint256 tokenId",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the currencies associated with a specific token ID in a position manager.\n *\n * Steps:\n * 1. Call `getPoolAndPositionInfo` on the position manager to retrieve the pool key and position info for the given token ID.\n * 2. Extract and return the two currencies (`currency0` and `currency1`) from the pool key.\n */"
        },
        {
            "identifier": "collect",
            "parameters": "IPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "modifiers": "",
            "return": "returns (BalanceDelta delta)",
            "body": "function collect(\n        IPositionManager posm,\n        uint256 tokenId,\n        uint256 amount0Min,\n        uint256 amount1Min,\n        address recipient,\n        uint256 deadline,\n        bytes memory hookData\n    ) internal returns (BalanceDelta delta) {\n        (Currency currency0, Currency currency1) = getCurrencies(posm, tokenId);\n\n        bytes[] memory params = new bytes[](2);\n        // collecting fees is achieved by decreasing liquidity with 0 liquidity removed\n        params[0] = abi.encode(tokenId, 0, amount0Min, amount1Min, hookData);\n        params[1] = abi.encode(currency0, currency1, recipient);\n\n        uint256 balance0Before = currency0.balanceOf(recipient);\n        uint256 balance1Before = currency1.balanceOf(recipient);\n\n        posm.modifyLiquidities(\n            abi.encode(abi.encodePacked(uint8(Actions.DECREASE_LIQUIDITY), uint8(Actions.TAKE_PAIR)), params), deadline\n        );\n\n        delta = toBalanceDelta(\n            (currency0.balanceOf(recipient) - balance0Before).toInt128(),\n            (currency1.balanceOf(recipient) - balance1Before).toInt128()\n        );\n    }",
            "start": "132",
            "end": "159",
            "class": "EasyPosm",
            "signature": "returns (BalanceDelta delta) collectIPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "full_signature": "function collect(IPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData) internal   returns (BalanceDelta delta)",
            "class_method_signature": "EasyPosm.collectIPositionManager posm, uint256 tokenId, uint256 amount0Min, uint256 amount1Min, address recipient, uint256 deadline, bytes memory hookData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Collects fees from a liquidity position by decreasing liquidity with 0 liquidity removed.\n *\n * @param posm The position manager contract.\n * @param tokenId The ID of the token representing the liquidity position.\n * @param amount0Min The minimum amount of token0 to collect.\n * @param amount1Min The minimum amount of token1 to collect.\n * @param recipient The address to receive the collected fees.\n * @param deadline The deadline for the transaction to be executed.\n * @param hookData Additional data for the hook.\n *\n * Steps:\n * 1. Retrieve the currencies (token0 and token1) associated with the position.\n * 2. Prepare parameters for the modifyLiquidities call:\n *    - Decrease liquidity with 0 liquidity removed to collect fees.\n *    - Specify the recipient for the collected fees.\n * 3. Record the recipient's balances before the operation.\n * 4. Call modifyLiquidities on the position manager with the prepared parameters.\n * 5. Calculate the balance delta (change in balances) for both tokens.\n * 6. Return the balance delta.\n */"
        },
        {
            "identifier": "MintData",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct MintData {\n        uint256 balance0Before;\n        uint256 balance1Before;\n        bytes[] params;\n    }",
            "start": "22",
            "end": "26",
            "class": "EasyPosm",
            "signature": " MintData",
            "full_signature": "function MintData()",
            "class_method_signature": "EasyPosm.MintData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.21;"
            ],
            "import_directive": [
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BalanceDelta, toBalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {IPositionManager} from \"v4-periphery/src/interfaces/IPositionManager.sol\";",
                "import {Actions} from \"v4-periphery/src/libraries/Actions.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";",
                "import {PositionInfo, PositionInfoLibrary} from \"v4-periphery/src/libraries/PositionInfoLibrary.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct `MintData` to store data related to a mint operation.\n * \n * Fields:\n * - `balance0Before`: The balance of token0 before the mint operation.\n * - `balance1Before`: The balance of token1 before the mint operation.\n * - `params`: An array of bytes to store additional parameters for the mint operation.\n */"
        }
    ],
    "/root/uniswap-solidity-hooks-template/lib/uniswap-solidity-hooks-template/test/custom-accounting/ExampleHook.sol": [
        {
            "identifier": "beforeSwap",
            "parameters": "address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata",
            "modifiers": "onlyPoolManager",
            "return": "returns (bytes4, BeforeSwapDelta, uint24)",
            "body": "function beforeSwap(\n        address, /* sender **/\n        PoolKey calldata key,\n        IPoolManager.SwapParams calldata params,\n        bytes calldata /* hookData **/\n    ) external override onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n        (Currency inputCurrency, Currency outputCurrency, uint256 amount) = _getInputOutputAndAmount(key, params);\n\n        // this \"custom curve\" is a line, 1-1\n        // take the full input amount, and give the full output amount\n        manager.take(inputCurrency, address(this), amount);\n\n        outputCurrency.settle(manager, address(this), amount, false);\n\n        // return -amountSpecified as specified to no-op the concentrated liquidity swap\n        BeforeSwapDelta hookDelta = toBeforeSwapDelta(int128(-params.amountSpecified), int128(params.amountSpecified));\n        return (IHooks.beforeSwap.selector, hookDelta, 0);\n    }",
            "start": "30",
            "end": "47",
            "class": "ExampleHook",
            "signature": "returns (bytes4, BeforeSwapDelta, uint24) beforeSwapaddress, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata",
            "full_signature": "function beforeSwap(address, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata) external  onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24)",
            "class_method_signature": "ExampleHook.beforeSwapaddress, PoolKey calldata key, IPoolManager.SwapParams calldata params, bytes calldata",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";",
                "import {CurrencySettler} from \"v4-core/test/utils/CurrencySettler.sol\";",
                "import {BaseTestHooks} from \"v4-core/src/test/BaseTestHooks.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Executes logic before a swap operation in a pool.\n *\n * Steps:\n * 1. Retrieves the input currency, output currency, and amount from the pool key and swap parameters.\n * 2. Takes the full input amount from the sender and settles the output amount to the sender.\n * 3. Constructs a `BeforeSwapDelta` object to represent the swap delta, effectively no-op'ing the concentrated liquidity swap.\n * 4. Returns the selector for the `beforeSwap` hook, the calculated delta, and a zero value for the fee tier.\n *\n * @param key The pool key containing details about the pool.\n * @param params The swap parameters including the amount and other swap details.\n * @return The selector for the `beforeSwap` hook, the calculated swap delta, and a zero value for the fee tier.\n */"
        },
        {
            "identifier": "",
            "parameters": "IPoolManager _manager",
            "modifiers": "",
            "return": "",
            "body": "constructor(IPoolManager _manager) {\n        manager = _manager;\n    }",
            "start": "21",
            "end": "23",
            "class": "ExampleHook",
            "signature": " IPoolManager _manager",
            "full_signature": "constructor (IPoolManager _manager)",
            "class_method_signature": "ExampleHook.IPoolManager _manager",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";",
                "import {CurrencySettler} from \"v4-core/test/utils/CurrencySettler.sol\";",
                "import {BaseTestHooks} from \"v4-core/src/test/BaseTestHooks.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with a specified PoolManager instance.\n * @param _manager The address of the PoolManager contract to be set as the manager.\n */"
        },
        {
            "identifier": "onlyPoolManager",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyPoolManager() {\n        require(msg.sender == address(manager));\n        _;\n    }",
            "start": "25",
            "end": "28",
            "class": "ExampleHook",
            "signature": " onlyPoolManager",
            "full_signature": "function onlyPoolManager()",
            "class_method_signature": "ExampleHook.onlyPoolManager",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";",
                "import {CurrencySettler} from \"v4-core/test/utils/CurrencySettler.sol\";",
                "import {BaseTestHooks} from \"v4-core/src/test/BaseTestHooks.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to restrict access to only the pool manager.\n * \n * Steps:\n * 1. Check if the caller is the pool manager.\n * 2. If true, proceed with the function execution.\n * 3. If false, revert the transaction.\n */"
        },
        {
            "identifier": "manager",
            "parameters": "",
            "modifiers": "",
            "return": "IPoolManager",
            "body": "IPoolManager immutable manager;",
            "start": "19",
            "end": "19",
            "class": "ExampleHook",
            "signature": "IPoolManager manager",
            "full_signature": "IPoolManager   manager",
            "class_method_signature": "ExampleHook.manager",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";",
                "import {CurrencySettler} from \"v4-core/test/utils/CurrencySettler.sol\";",
                "import {BaseTestHooks} from \"v4-core/src/test/BaseTestHooks.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Declares an immutable variable `manager` of type `IPoolManager`.\n * This variable is set during contract deployment and cannot be modified afterward.\n */"
        },
        {
            "identifier": "_getInputOutputAndAmount",
            "parameters": "PoolKey calldata key, IPoolManager.SwapParams calldata params",
            "modifiers": "pure",
            "return": "returns (Currency input, Currency output, uint256 amount)",
            "body": "function _getInputOutputAndAmount(PoolKey calldata key, IPoolManager.SwapParams calldata params)\n        internal\n        pure\n        returns (Currency input, Currency output, uint256 amount)\n    {\n        (input, output) = params.zeroForOne ? (key.currency0, key.currency1) : (key.currency1, key.currency0);\n\n        amount = params.amountSpecified < 0 ? uint256(-params.amountSpecified) : uint256(params.amountSpecified);\n    }",
            "start": "49",
            "end": "57",
            "class": "ExampleHook",
            "signature": "returns (Currency input, Currency output, uint256 amount) _getInputOutputAndAmountPoolKey calldata key, IPoolManager.SwapParams calldata params",
            "full_signature": "function _getInputOutputAndAmount(PoolKey calldata key, IPoolManager.SwapParams calldata params) internal  pure returns (Currency input, Currency output, uint256 amount)",
            "class_method_signature": "ExampleHook._getInputOutputAndAmountPoolKey calldata key, IPoolManager.SwapParams calldata params",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IHooks} from \"v4-core/src/interfaces/IHooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {BeforeSwapDelta, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";",
                "import {CurrencySettler} from \"v4-core/test/utils/CurrencySettler.sol\";",
                "import {BaseTestHooks} from \"v4-core/src/test/BaseTestHooks.sol\";",
                "import {Currency} from \"v4-core/src/types/Currency.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Determines the input currency, output currency, and the absolute amount for a swap operation.\n *\n * Steps:\n * 1. Determine the input and output currencies based on the `zeroForOne` flag in the swap parameters.\n *   - If `zeroForOne` is true, input is `key.currency0` and output is `key.currency1`.\n *   - If `zeroForOne` is false, input is `key.currency1` and output is `key.currency0`.\n *\n * 2. Calculate the absolute amount for the swap:\n *   - If `amountSpecified` is negative, convert it to a positive value.\n *   - If `amountSpecified` is positive, use it as is.\n *\n * @param key The pool key containing the currency pair.\n * @param params The swap parameters including the `zeroForOne` flag and `amountSpecified`.\n * @return input The input currency for the swap.\n * @return output The output currency for the swap.\n * @return amount The absolute amount for the swap.\n */"
        }
    ],
    "/root/uniswap-solidity-hooks-template/lib/uniswap-solidity-hooks-template/src/Counter.sol": [
        {
            "identifier": "getAmountOutFromExactInput",
            "parameters": "uint256 amountIn, address input, address output, bool zeroForOne",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function getAmountOutFromExactInput(uint256 amountIn, address input, address output, bool zeroForOne)\n        external\n        returns (uint256);",
            "start": "21",
            "end": "23",
            "class": "IUniswapCurve",
            "signature": "returns (uint256) getAmountOutFromExactInputuint256 amountIn, address input, address output, bool zeroForOne",
            "full_signature": "function getAmountOutFromExactInput(uint256 amountIn, address input, address output, bool zeroForOne) external   returns (uint256)",
            "class_method_signature": "IUniswapCurve.getAmountOutFromExactInputuint256 amountIn, address input, address output, bool zeroForOne",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": [
                "import {BaseHook} from \"v4-periphery/src/base/hooks/BaseHook.sol\";",
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {PoolId, PoolIdLibrary} from \"v4-core/src/types/PoolId.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the amount of output tokens received for a given exact input amount.\n * \n * @param amountIn The exact amount of input tokens to swap.\n * @param input The address of the input token.\n * @param output The address of the output token.\n * @param zeroForOne A boolean flag indicating the direction of the swap (true for token0 to token1, false for token1 to token0).\n * \n * @return uint256 The amount of output tokens received from the swap.\n */"
        },
        {
            "identifier": "getAmountInForExactOutput",
            "parameters": "uint256 amountOut, address input, address output, bool zeroForOne",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function getAmountInForExactOutput(uint256 amountOut, address input, address output, bool zeroForOne)\n        external\n        returns (uint256);",
            "start": "17",
            "end": "19",
            "class": "IUniswapCurve",
            "signature": "returns (uint256) getAmountInForExactOutputuint256 amountOut, address input, address output, bool zeroForOne",
            "full_signature": "function getAmountInForExactOutput(uint256 amountOut, address input, address output, bool zeroForOne) external   returns (uint256)",
            "class_method_signature": "IUniswapCurve.getAmountInForExactOutputuint256 amountOut, address input, address output, bool zeroForOne",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": [
                "import {BaseHook} from \"v4-periphery/src/base/hooks/BaseHook.sol\";",
                "import {Hooks} from \"v4-core/src/libraries/Hooks.sol\";",
                "import {IPoolManager} from \"v4-core/src/interfaces/IPoolManager.sol\";",
                "import {PoolKey} from \"v4-core/src/types/PoolKey.sol\";",
                "import {PoolId, PoolIdLibrary} from \"v4-core/src/types/PoolId.sol\";",
                "import {BalanceDelta} from \"v4-core/src/types/BalanceDelta.sol\";",
                "import {BeforeSwapDelta, BeforeSwapDeltaLibrary, toBeforeSwapDelta} from \"v4-core/src/types/BeforeSwapDelta.sol\";",
                "import {Currency, CurrencyLibrary} from \"v4-core/src/types/Currency.sol\";",
                "import {SafeCast} from \"v4-core/src/libraries/SafeCast.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the required input amount to receive an exact output amount in a token swap.\n *\n * @param amountOut The desired output amount of the swap.\n * @param input The address of the input token.\n * @param output The address of the output token.\n * @param zeroForOne A boolean flag indicating the direction of the swap:\n *                   - true: Token0 to Token1\n *                   - false: Token1 to Token0\n *\n * @return The required input amount to achieve the exact output amount.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/test/internal/StringHelper.sol": [
        {
            "identifier": "join",
            "parameters": "string[] memory arr",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function join(string[] memory arr) internal pure returns (string memory) {\n        string memory result;\n        for (uint i = 0; i < arr.length; i++) {\n            result = string.concat(result, arr[i]);\n            if (i < arr.length - 1) {\n                result = string.concat(result, \" \");\n            }\n        }\n        return result;\n    }",
            "start": "8",
            "end": "17",
            "class": "StringHelper",
            "signature": "returns (string memory) joinstring[] memory arr",
            "full_signature": "function join(string[] memory arr) internal  pure returns (string memory)",
            "class_method_signature": "StringHelper.joinstring[] memory arr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Concatenates an array of strings into a single string, separated by spaces.\n *\n * Steps:\n * 1. Initialize an empty string `result`.\n * 2. Iterate through each element in the input array `arr`.\n * 3. Concatenate the current element to `result`.\n * 4. If the current element is not the last one, append a space to `result`.\n * 5. Return the concatenated string `result`.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/LegacyUpgrades.sol": [
        {
            "identifier": "validateUpgrade",
            "parameters": "string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "",
            "body": "function validateUpgrade(string memory contractName, Options memory opts) internal {\n        Core.validateUpgrade(contractName, opts);\n    }",
            "start": "165",
            "end": "167",
            "class": "Upgrades",
            "signature": " validateUpgradestring memory contractName, Options memory opts",
            "full_signature": "function validateUpgrade(string memory contractName, Options memory opts) internal",
            "class_method_signature": "Upgrades.validateUpgradestring memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function validateUpgrade(string memory contractName, Options memory opts) internal'}",
            "human_labeled_comment": "/**\n * @notice Validates the upgrade of a contract by calling the `validateUpgrade` function from the `Core` contract.\n *\n * @param contractName The name of the contract to be upgraded.\n * @param opts The options for the upgrade, passed as a struct of type `Options`.\n */"
        },
        {
            "identifier": "prepareUpgrade",
            "parameters": "string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function prepareUpgrade(string memory contractName, Options memory opts) internal returns (address) {\n        return Core.prepareUpgrade(contractName, opts);\n    }",
            "start": "181",
            "end": "183",
            "class": "Upgrades",
            "signature": "returns (address) prepareUpgradestring memory contractName, Options memory opts",
            "full_signature": "function prepareUpgrade(string memory contractName, Options memory opts) internal   returns (address)",
            "class_method_signature": "Upgrades.prepareUpgradestring memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function prepareUpgrade(string memory contractName, Options memory opts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Prepares an upgrade for a specified contract.\n *\n * @param contractName The name of the contract to be upgraded.\n * @param opts The options for the upgrade process.\n * @return The address of the prepared upgrade.\n *\n * Steps:\n * 1. Calls the `prepareUpgrade` function from the `Core` contract.\n * 2. Returns the address of the prepared upgrade.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/internal/Utils.sol": [
        {
            "identifier": "_split",
            "parameters": "strings.slice memory inputSlice, strings.slice memory delimSlice",
            "modifiers": "pure",
            "return": "returns (string[] memory)",
            "body": "function _split(\n        strings.slice memory inputSlice,\n        strings.slice memory delimSlice\n    ) private pure returns (string[] memory) {\n        string[] memory parts = new string[](inputSlice.count(delimSlice) + 1);\n        for (uint i = 0; i < parts.length; i++) {\n            parts[i] = inputSlice.split(delimSlice).toString();\n        }\n        return parts;\n    }",
            "start": "148",
            "end": "157",
            "class": "Utils",
            "signature": "returns (string[] memory) _splitstrings.slice memory inputSlice, strings.slice memory delimSlice",
            "full_signature": "function _split(strings.slice memory inputSlice, strings.slice memory delimSlice) private  pure returns (string[] memory)",
            "class_method_signature": "Utils._splitstrings.slice memory inputSlice, strings.slice memory delimSlice",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function split(string calldata input, string calldata delimiter) external  pure returns (string[] memory outputs)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)'}",
            "human_labeled_comment": "/**\n * @notice Splits a string slice into an array of strings based on a delimiter slice.\n *\n * Steps:\n * 1. Calculate the number of parts by counting occurrences of the delimiter in the input slice.\n * 2. Initialize an array of strings with the calculated number of parts.\n * 3. Iterate through the array and split the input slice using the delimiter.\n * 4. Convert each split slice to a string and store it in the array.\n * 5. Return the array of split strings.\n */"
        },
        {
            "identifier": "runAsBashCommand",
            "parameters": "string[] memory inputs",
            "modifiers": "",
            "return": "returns (Vm.FfiResult memory)",
            "body": "function runAsBashCommand(string[] memory inputs) internal returns (Vm.FfiResult memory) {\n        Vm vm = Vm(CHEATCODE_ADDRESS);\n        string memory defaultBashPath = \"bash\";\n        string memory bashPath = vm.envOr(\"OPENZEPPELIN_BASH_PATH\", defaultBashPath);\n\n        string[] memory bashCommand = toBashCommand(inputs, bashPath);\n        Vm.FfiResult memory result = vm.tryFfi(bashCommand);\n        if (result.exitCode != 0 && result.stdout.length == 0 && result.stderr.length == 0) {\n            // On Windows, using the bash executable from WSL leads to a non-zero exit code and no output\n            revert(\n                string(\n                    abi.encodePacked(\n                        'Failed to run bash command with \"',\n                        bashCommand[0],\n                        '\". If you are using Windows, set the OPENZEPPELIN_BASH_PATH environment variable to the fully qualified path of the bash executable. For example, if you are using Git for Windows, add the following line in the .env file of your project (using forward slashes):\\nOPENZEPPELIN_BASH_PATH=\"C:/Program Files/Git/bin/bash\"'\n                    )\n                )\n            );\n        } else {\n            return result;\n        }\n    }",
            "start": "236",
            "end": "257",
            "class": "Utils",
            "signature": "returns (Vm.FfiResult memory) runAsBashCommandstring[] memory inputs",
            "full_signature": "function runAsBashCommand(string[] memory inputs) internal   returns (Vm.FfiResult memory)",
            "class_method_signature": "Utils.runAsBashCommandstring[] memory inputs",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue) external  view returns (bytes32[] memory value)', 'function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue) external  view returns (bool[] memory value)', 'function envOr(string calldata name, bool defaultValue) external  view returns (bool value)', 'function envOr(string calldata name, string calldata defaultValue) external  view returns (string memory value)', 'function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue) external  view returns (bytes[] memory value)', 'function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue) external  view returns (int256[] memory value)', 'function envOr(string calldata name, string calldata delim, string[] calldata defaultValue) external  view returns (string[] memory value)', 'function envOr(string calldata name, uint256 defaultValue) external  view returns (uint256 value)', 'function envOr(string calldata name, string calldata delim, address[] calldata defaultValue) external  view returns (address[] memory value)', 'function envOr(string calldata name, int256 defaultValue) external  view returns (int256 value)', 'function envOr(string calldata name, bytes calldata defaultValue) external  view returns (bytes memory value)', 'function envOr(string calldata name, address defaultValue) external  view returns (address value)', 'function envOr(string calldata name, bytes32 defaultValue) external  view returns (bytes32 value)', 'function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue) external  view returns (uint256[] memory value)', 'function FfiResult()', 'function tryFfi(string[] calldata commandInput) external   returns (FfiResult memory result)'}",
            "human_labeled_comment": "/**\n * @notice Executes a bash command using the provided inputs.\n *\n * Steps:\n * 1. Initialize a Vm instance using the cheatcode address.\n * 2. Retrieve the default bash path or use the one specified in the environment variable OPENZEPPELIN_BASH_PATH.\n * 3. Convert the inputs into a bash command using the retrieved bash path.\n * 4. Attempt to execute the bash command using the Vm instance.\n * 5. If the command fails with a non-zero exit code and no output (stdout or stderr), revert with an error message.\n *    - This is particularly relevant for Windows users using WSL, where the bash executable might not be correctly configured.\n *    - The error message provides guidance on setting the OPENZEPPELIN_BASH_PATH environment variable.\n * 6. If the command executes successfully, return the result.\n */"
        },
        {
            "identifier": "CHEATCODE_ADDRESS",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address constant CHEATCODE_ADDRESS = 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D;",
            "start": "35",
            "end": "35",
            "class": "Utils",
            "signature": "address CHEATCODE_ADDRESS",
            "full_signature": "address  constant CHEATCODE_ADDRESS",
            "class_method_signature": "Utils.CHEATCODE_ADDRESS",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice A constant address representing the cheatcode address used for testing purposes.\n * This address is typically used in conjunction with tools like Foundry for debugging and testing smart contracts.\n */"
        },
        {
            "identifier": "_toFileName",
            "parameters": "string memory contractName",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function _toFileName(string memory contractName) private pure returns (string memory) {\n        strings.slice memory name = contractName.toSlice();\n        if (name.endsWith(\".sol\".toSlice())) {\n            return name.toString();\n        } else if (name.count(\":\".toSlice()) == 1) {\n            return name.split(\":\".toSlice()).toString();\n        } else {\n            if (name.endsWith(\".json\".toSlice())) {\n                string[] memory parts = _split(name, \"/\".toSlice());\n                if (parts.length > 1) {\n                    return parts[parts.length - 2];\n                }\n            }\n\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Contract name \",\n                        contractName,\n                        \" must be in the format MyContract.sol:MyContract or MyContract.sol or out/MyContract.sol/MyContract.json\"\n                    )\n                )\n            );\n        }\n    }",
            "start": "159",
            "end": "183",
            "class": "Utils",
            "signature": "returns (string memory) _toFileNamestring memory contractName",
            "full_signature": "function _toFileName(string memory contractName) private  pure returns (string memory)",
            "class_method_signature": "Utils._toFileNamestring memory contractName",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function split(string calldata input, string calldata delimiter) external  pure returns (string[] memory outputs)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)'}",
            "human_labeled_comment": "/**\n * @notice Converts a contract name string into a valid file name format.\n *\n * Steps:\n * 1. Convert the contract name into a slice for manipulation.\n * 2. Check if the contract name ends with \".sol\". If so, return it as is.\n * 3. If the contract name contains a single colon \":\", split the string at the colon and return the first part.\n * 4. If the contract name ends with \".json\":\n *    a. Split the string by \"/\" to handle paths.\n *    b. If the resulting parts array has more than one element, return the second-to-last part.\n * 5. If none of the above conditions are met, revert with an error message indicating the required format.\n *\n * @param contractName The input contract name string to be converted.\n * @return string The formatted file name.\n * @dev Reverts if the contract name does not match the expected formats.\n */"
        },
        {
            "identifier": "_toShortName",
            "parameters": "string memory contractName",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function _toShortName(string memory contractName) private pure returns (string memory) {\n        strings.slice memory name = contractName.toSlice();\n        if (name.endsWith(\".sol\".toSlice())) {\n            return name.until(\".sol\".toSlice()).toString();\n        } else if (name.count(\":\".toSlice()) == 1) {\n            name.split(\":\".toSlice());\n            return name.split(\":\".toSlice()).toString();\n        } else if (name.endsWith(\".json\".toSlice())) {\n            string[] memory parts = _split(name, \"/\".toSlice());\n            string memory jsonName = parts[parts.length - 1];\n            return jsonName.toSlice().until(\".json\".toSlice()).toString();\n        } else {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Contract name \",\n                        contractName,\n                        \" must be in the format MyContract.sol:MyContract or MyContract.sol or out/MyContract.sol/MyContract.json\"\n                    )\n                )\n            );\n        }\n    }",
            "start": "185",
            "end": "207",
            "class": "Utils",
            "signature": "returns (string memory) _toShortNamestring memory contractName",
            "full_signature": "function _toShortName(string memory contractName) private  pure returns (string memory)",
            "class_method_signature": "Utils._toShortNamestring memory contractName",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function split(string calldata input, string calldata delimiter) external  pure returns (string[] memory outputs)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)'}",
            "human_labeled_comment": "/**\n * @notice Converts a contract name string into a short name by removing file extensions and paths.\n *\n * Steps:\n * 1. Convert the input contract name into a slice for manipulation.\n * 2. If the name ends with \".sol\", remove the \".sol\" extension and return the remaining string.\n * 3. If the name contains a single \":\", split the string at the \":\" and return the second part.\n * 4. If the name ends with \".json\", split the string at \"/\" to isolate the file name, then remove the \".json\" extension and return the remaining string.\n * 5. If the name does not match any of the expected formats, revert with an error message indicating the required format.\n *\n * @param contractName The full contract name string to be shortened.\n * @return The shortened contract name.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/internal/DefenderDeploy.sol": [
        {
            "identifier": "_parseLine",
            "parameters": "string memory expectedPrefix, string memory stdout, bool required",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function _parseLine(\n        string memory expectedPrefix,\n        string memory stdout,\n        bool required\n    ) private pure returns (string memory) {\n        strings.slice memory delim = expectedPrefix.toSlice();\n        if (stdout.toSlice().contains(delim)) {\n            strings.slice memory slice = stdout.toSlice().copy().find(delim).beyond(delim);\n            // Remove any following lines\n            if (slice.contains(\"\\n\".toSlice())) {\n                slice = slice.split(\"\\n\".toSlice());\n            }\n            return slice.toString();\n        } else if (required) {\n            revert(\n                string(abi.encodePacked(\"Failed to find line with prefix '\", expectedPrefix, \"' in output: \", stdout))\n            );\n        } else {\n            return \"\";\n        }\n    }",
            "start": "225",
            "end": "245",
            "class": "DefenderDeploy",
            "signature": "returns (string memory) _parseLinestring memory expectedPrefix, string memory stdout, bool required",
            "full_signature": "function _parseLine(string memory expectedPrefix, string memory stdout, bool required) private  pure returns (string memory)",
            "class_method_signature": "DefenderDeploy._parseLinestring memory expectedPrefix, string memory stdout, bool required",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function split(string calldata input, string calldata delimiter) external  pure returns (string[] memory outputs)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) internal  pure returns (string memory)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)'}",
            "human_labeled_comment": "/**\n * @notice Parses a line from a given string output based on an expected prefix.\n *\n * Steps:\n * 1. Convert the expected prefix into a slice for comparison.\n * 2. Check if the output string contains the expected prefix.\n * 3. If the prefix is found:\n *    - Extract the substring beyond the prefix.\n *    - Remove any following lines by splitting at the newline character.\n *    - Return the extracted substring.\n * 4. If the prefix is not found and the line is required:\n *    - Revert with an error message indicating the prefix was not found.\n * 5. If the prefix is not found and the line is not required:\n *    - Return an empty string.\n *\n * @param expectedPrefix The prefix to search for in the output string.\n * @param stdout The output string to parse.\n * @param required Whether the line with the prefix is mandatory.\n * @return The parsed line or an empty string if not required.\n */"
        },
        {
            "identifier": "_toLicenseType",
            "parameters": "ContractInfo memory contractInfo",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function _toLicenseType(ContractInfo memory contractInfo) private pure returns (string memory) {\n        strings.slice memory id = contractInfo.license.toSlice();\n        if (id.equals(\"UNLICENSED\".toSlice())) {\n            return \"None\";\n        } else if (id.equals(\"Unlicense\".toSlice())) {\n            return \"Unlicense\";\n        } else if (id.equals(\"MIT\".toSlice())) {\n            return \"MIT\";\n        } else if (id.equals(\"GPL-2.0-only\".toSlice()) || id.equals(\"GPL-2.0-or-later\".toSlice())) {\n            return \"GNU GPLv2\";\n        } else if (id.equals(\"GPL-3.0-only\".toSlice()) || id.equals(\"GPL-3.0-or-later\".toSlice())) {\n            return \"GNU GPLv3\";\n        } else if (id.equals(\"LGPL-2.1-only\".toSlice()) || id.equals(\"LGPL-2.1-or-later\".toSlice())) {\n            return \"GNU LGPLv2.1\";\n        } else if (id.equals(\"LGPL-3.0-only\".toSlice()) || id.equals(\"LGPL-3.0-or-later\".toSlice())) {\n            return \"GNU LGPLv3\";\n        } else if (id.equals(\"BSD-2-Clause\".toSlice())) {\n            return \"BSD-2-Clause\";\n        } else if (id.equals(\"BSD-3-Clause\".toSlice())) {\n            return \"BSD-3-Clause\";\n        } else if (id.equals(\"MPL-2.0\".toSlice())) {\n            return \"MPL-2.0\";\n        } else if (id.equals(\"OSL-3.0\".toSlice())) {\n            return \"OSL-3.0\";\n        } else if (id.equals(\"Apache-2.0\".toSlice())) {\n            return \"Apache-2.0\";\n        } else if (id.equals(\"AGPL-3.0-only\".toSlice()) || id.equals(\"AGPL-3.0-or-later\".toSlice())) {\n            return \"GNU AGPLv3\";\n        } else if (id.equals(\"BUSL-1.1\".toSlice())) {\n            return \"BSL 1.1\";\n        } else {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"SPDX license identifier \",\n                        contractInfo.license,\n                        \" in \",\n                        contractInfo.contractPath,\n                        \" does not look like a supported license for block explorer verification. Use the `licenseType` option to specify a license type, or set the `skipLicenseType` option to `true` to skip.\"\n                    )\n                )\n            );\n        }\n    }",
            "start": "134",
            "end": "177",
            "class": "DefenderDeploy",
            "signature": "returns (string memory) _toLicenseTypeContractInfo memory contractInfo",
            "full_signature": "function _toLicenseType(ContractInfo memory contractInfo) private  pure returns (string memory)",
            "class_method_signature": "DefenderDeploy._toLicenseTypeContractInfo memory contractInfo",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function skip(bool skipTest) external', 'function equal(string memory a, string memory b) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Converts a given SPDX license identifier into a standardized license type.\n *\n * @param contractInfo A struct containing the license identifier and contract path.\n * @return string memory The standardized license type corresponding to the SPDX identifier.\n *\n * Steps:\n * 1. Convert the license identifier into a slice for comparison.\n * 2. Compare the license identifier against known SPDX identifiers.\n * 3. Return the corresponding standardized license type.\n * 4. If the license identifier is not recognized, revert with an error message indicating the unsupported license.\n */"
        },
        {
            "identifier": "getApprovalProcess",
            "parameters": "string memory command",
            "modifiers": "",
            "return": "returns (ApprovalProcessResponse memory)",
            "body": "function getApprovalProcess(string memory command) internal returns (ApprovalProcessResponse memory) {\n        string[] memory inputs = buildGetApprovalProcessCommand(command);\n\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (result.exitCode != 0) {\n            revert(string(abi.encodePacked(\"Failed to get approval process: \", string(result.stderr))));\n        }\n\n        return parseApprovalProcessResponse(stdout);\n    }",
            "start": "291",
            "end": "302",
            "class": "DefenderDeploy",
            "signature": "returns (ApprovalProcessResponse memory) getApprovalProcessstring memory command",
            "full_signature": "function getApprovalProcess(string memory command) internal   returns (ApprovalProcessResponse memory)",
            "class_method_signature": "DefenderDeploy.getApprovalProcessstring memory command",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function FfiResult()', 'function runAsBashCommand(string[] memory inputs) internal   returns (Vm.FfiResult memory)'}",
            "human_labeled_comment": "/**\n * @notice Retrieves the approval process for a given command by executing a bash command and parsing the output.\n *\n * Steps:\n * 1. Build the command inputs required to fetch the approval process.\n * 2. Execute the command as a bash command using the `Utils.runAsBashCommand` function.\n * 3. Retrieve the standard output from the command execution.\n *\n * 4. Check if the command execution was successful by verifying the exit code.\n * 5. If the exit code is non-zero, revert with an error message containing the standard error output.\n *\n * 6. Parse the standard output to create an `ApprovalProcessResponse` object.\n * 7. Return the parsed `ApprovalProcessResponse`.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/internal/Core.sol": [
        {
            "identifier": "getImplementationAddress",
            "parameters": "address proxy",
            "modifiers": "view",
            "return": "returns (address)",
            "body": "function getImplementationAddress(address proxy) internal view returns (address) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        bytes32 implSlot = vm.load(proxy, IMPLEMENTATION_SLOT);\n        return address(uint160(uint256(implSlot)));\n    }",
            "start": "249",
            "end": "254",
            "class": "Core",
            "signature": "returns (address) getImplementationAddressaddress proxy",
            "full_signature": "function getImplementationAddress(address proxy) internal  view returns (address)",
            "class_method_signature": "Core.getImplementationAddressaddress proxy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function getImplementation() internal  view returns (address)', 'address  constant CHEATCODE_ADDRESS', 'VmSafe private constant vm', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'bytes32 internal constant IMPLEMENTATION_SLOT', 'function load(address target, bytes32 slot) external  view returns (bytes32 data)'}",
            "human_labeled_comment": "/**\n * @notice Retrieves the implementation address of a proxy contract.\n *\n * Steps:\n * 1. Initialize a Vm instance using the cheatcode address.\n * 2. Load the implementation slot from the proxy contract.\n * 3. Convert the slot data to an address and return it.\n */"
        },
        {
            "identifier": "upgradeProxyTo",
            "parameters": "address proxy, address newImpl, bytes memory data",
            "modifiers": "",
            "return": "",
            "body": "function upgradeProxyTo(address proxy, address newImpl, bytes memory data) internal {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        bytes32 adminSlot = vm.load(proxy, ADMIN_SLOT);\n        if (adminSlot == bytes32(0)) {\n            string memory upgradeInterfaceVersion = getUpgradeInterfaceVersion(proxy);\n            if (upgradeInterfaceVersion.toSlice().equals(\"5.0.0\".toSlice()) || data.length > 0) {\n                IUpgradeableProxy(proxy).upgradeToAndCall(newImpl, data);\n            } else {\n                IUpgradeableProxy(proxy).upgradeTo(newImpl);\n            }\n        } else {\n            address admin = address(uint160(uint256(adminSlot)));\n            string memory upgradeInterfaceVersion = getUpgradeInterfaceVersion(admin);\n            if (upgradeInterfaceVersion.toSlice().equals(\"5.0.0\".toSlice()) || data.length > 0) {\n                IProxyAdmin(admin).upgradeAndCall(proxy, newImpl, data);\n            } else {\n                IProxyAdmin(admin).upgrade(proxy, newImpl);\n            }\n        }\n    }",
            "start": "71",
            "end": "91",
            "class": "Core",
            "signature": " upgradeProxyToaddress proxy, address newImpl, bytes memory data",
            "full_signature": "function upgradeProxyTo(address proxy, address newImpl, bytes memory data) internal",
            "class_method_signature": "Core.upgradeProxyToaddress proxy, address newImpl, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgradeTo(address) external', 'function upgrade(address, address) external', 'function upgradeToAndCall(address, bytes memory) external  payable', 'address  constant CHEATCODE_ADDRESS', 'VmSafe private constant vm', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'bytes32 internal constant ADMIN_SLOT', 'function load(address target, bytes32 slot) external  view returns (bytes32 data)', 'function upgradeToAndCall(address newImplementation, bytes memory data) internal', 'function upgradeAndCall(address, address, bytes memory) external  payable'}",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation address.\n *\n * Steps:\n * 1. Initialize the Vm utility to interact with the cheatcode address.\n * 2. Load the admin slot from the proxy contract.\n *\n * 3. If the admin slot is empty (no admin):\n *    - Retrieve the upgrade interface version of the proxy.\n *    - If the version is \"5.0.0\" or additional data is provided, call `upgradeToAndCall` on the proxy.\n *    - Otherwise, call `upgradeTo` on the proxy.\n *\n * 4. If the admin slot is not empty (admin exists):\n *    - Retrieve the admin address from the admin slot.\n *    - Retrieve the upgrade interface version of the admin.\n *    - If the version is \"5.0.0\" or additional data is provided, call `upgradeAndCall` on the admin.\n *    - Otherwise, call `upgrade` on the admin.\n */"
        },
        {
            "identifier": "upgradeProxy",
            "parameters": "address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller",
            "modifiers": "tryPrank(tryCaller)",
            "return": "",
            "body": "function upgradeProxy(\n        address proxy,\n        string memory contractName,\n        bytes memory data,\n        Options memory opts,\n        address tryCaller\n    ) internal tryPrank(tryCaller) {\n        upgradeProxy(proxy, contractName, data, opts);\n    }",
            "start": "54",
            "end": "62",
            "class": "Core",
            "signature": " upgradeProxyaddress proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller",
            "full_signature": "function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)",
            "class_method_signature": "Core.upgradeProxyaddress proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param contractName The name of the new contract implementation.\n * @param data Additional data to be passed during the upgrade process.\n * @param opts Options for the upgrade process.\n * @param tryCaller The address to impersonate during the upgrade process.\n *\n * Steps:\n * 1. Attempt to impersonate the specified caller (`tryCaller`).\n * 2. Call the internal `upgradeProxy` function with the provided parameters.\n */"
        },
        {
            "identifier": "deployImplementation",
            "parameters": "string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function deployImplementation(string memory contractName, Options memory opts) internal returns (address) {\n        validateImplementation(contractName, opts);\n        return deploy(contractName, opts.constructorData, opts);\n    }",
            "start": "196",
            "end": "199",
            "class": "Core",
            "signature": "returns (address) deployImplementationstring memory contractName, Options memory opts",
            "full_signature": "function deployImplementation(string memory contractName, Options memory opts) internal   returns (address)",
            "class_method_signature": "Core.deployImplementationstring memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Deploys a contract implementation based on the provided contract name and options.\n *\n * Steps:\n * 1. Validate the implementation using the provided contract name and options.\n * 2. Deploy the contract using the contract name, constructor data, and options.\n * 3. Return the address of the deployed contract.\n */"
        },
        {
            "identifier": "_validate",
            "parameters": "string memory contractName, Options memory opts, bool requireReference",
            "modifiers": "",
            "return": "",
            "body": "function _validate(string memory contractName, Options memory opts, bool requireReference) private {\n        if (opts.unsafeSkipAllChecks) {\n            return;\n        }\n\n        string[] memory inputs = buildValidateCommand(contractName, opts, requireReference);\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        // CLI validate command uses exit code to indicate if the validation passed or failed.\n        // As an extra precaution, we also check stdout for \"SUCCESS\" to ensure it actually ran.\n        if (result.exitCode == 0 && stdout.toSlice().contains(\"SUCCESS\".toSlice())) {\n            return;\n        } else if (result.stderr.length > 0) {\n            // Validations failed to run\n            revert(string(abi.encodePacked(\"Failed to run upgrade safety validation: \", string(result.stderr))));\n        } else {\n            // Validations ran but some contracts were not upgrade safe\n            revert(string(abi.encodePacked(\"Upgrade safety validation failed:\\n\", stdout)));\n        }\n    }",
            "start": "338",
            "end": "358",
            "class": "Core",
            "signature": " _validatestring memory contractName, Options memory opts, bool requireReference",
            "full_signature": "function _validate(string memory contractName, Options memory opts, bool requireReference) private",
            "class_method_signature": "Core._validatestring memory contractName, Options memory opts, bool requireReference",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function FfiResult()', 'function runAsBashCommand(string[] memory inputs) internal   returns (Vm.FfiResult memory)'}",
            "human_labeled_comment": "/**\n * @notice Validates the upgrade safety of a contract.\n *\n * Steps:\n * 1. If `unsafeSkipAllChecks` is true, skip all validation checks and return immediately.\n * 2. Build the validation command using the contract name, options, and whether a reference is required.\n * 3. Execute the validation command as a bash command and capture the result.\n * 4. Convert the command's stdout to a string.\n *\n * 5. Check if the command exited successfully (exit code 0) and if the stdout contains \"SUCCESS\".\n * 6. If both conditions are met, the validation is successful, and the function returns.\n *\n * 7. If the command failed to run (stderr is not empty), revert with an error message indicating the failure.\n * 8. If the command ran but the validation failed (stdout does not contain \"SUCCESS\"), revert with the validation failure details.\n */"
        },
        {
            "identifier": "_deployFromBytecode",
            "parameters": "bytes memory bytecode",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function _deployFromBytecode(bytes memory bytecode) private returns (address) {\n        address addr;\n        assembly {\n            addr := create(0, add(bytecode, 32), mload(bytecode))\n        }\n        return addr;\n    }",
            "start": "457",
            "end": "463",
            "class": "Core",
            "signature": "returns (address) _deployFromBytecodebytes memory bytecode",
            "full_signature": "function _deployFromBytecode(bytes memory bytecode) private   returns (address)",
            "class_method_signature": "Core._deployFromBytecodebytes memory bytecode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function load(address target, bytes32 slot) external  view returns (bytes32 data)', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Deploys a contract from the provided bytecode.\n *\n * Steps:\n * 1. Declare a variable `addr` to store the deployed contract address.\n * 2. Use inline assembly to create a new contract:\n *    - `create(0, add(bytecode, 32), mload(bytecode))`:\n *      - `0`: No value is sent with the deployment.\n *      - `add(bytecode, 32)`: Points to the start of the bytecode (skipping the length prefix).\n *      - `mload(bytecode)`: Loads the length of the bytecode.\n * 3. Return the deployed contract address.\n */"
        },
        {
            "identifier": "BEACON_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private constant BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;",
            "start": "301",
            "end": "301",
            "class": "Core",
            "signature": "bytes32 BEACON_SLOT",
            "full_signature": "bytes32 private constant BEACON_SLOT",
            "class_method_signature": "Core.BEACON_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'bytes32 internal constant BEACON_SLOT'}",
            "human_labeled_comment": "/**\n * @notice Defines a private constant `BEACON_SLOT` with a fixed value.\n * The value represents a specific storage slot used for beacon-related data.\n */"
        },
        {
            "identifier": "upgradeProxyTo",
            "parameters": "address proxy, address newImpl, bytes memory data, address tryCaller",
            "modifiers": "tryPrank(tryCaller)",
            "return": "",
            "body": "function upgradeProxyTo(\n        address proxy,\n        address newImpl,\n        bytes memory data,\n        address tryCaller\n    ) internal tryPrank(tryCaller) {\n        upgradeProxyTo(proxy, newImpl, data);\n    }",
            "start": "106",
            "end": "113",
            "class": "Core",
            "signature": " upgradeProxyToaddress proxy, address newImpl, bytes memory data, address tryCaller",
            "full_signature": "function upgradeProxyTo(address proxy, address newImpl, bytes memory data, address tryCaller) internal  tryPrank(tryCaller)",
            "class_method_signature": "Core.upgradeProxyToaddress proxy, address newImpl, bytes memory data, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param newImpl The address of the new implementation contract.\n * @param data Additional data to be passed during the upgrade process.\n * @param tryCaller The address of the caller attempting the upgrade.\n *\n * Steps:\n * 1. Attempt to impersonate the specified caller (`tryCaller`).\n * 2. Call the internal `upgradeProxyTo` function with the provided proxy, new implementation, and data.\n */"
        },
        {
            "identifier": "ADMIN_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private constant ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;",
            "start": "295",
            "end": "295",
            "class": "Core",
            "signature": "bytes32 ADMIN_SLOT",
            "full_signature": "bytes32 private constant ADMIN_SLOT",
            "class_method_signature": "Core.ADMIN_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'bytes32 internal constant ADMIN_SLOT'}",
            "human_labeled_comment": "/**\n * @notice A private constant variable that stores the keccak-256 hash of the admin slot.\n * This is typically used in proxy patterns or upgradeable contracts to store the admin address.\n * The value is derived from the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1.\n */"
        },
        {
            "identifier": "IMPLEMENTATION_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
            "start": "289",
            "end": "289",
            "class": "Core",
            "signature": "bytes32 IMPLEMENTATION_SLOT",
            "full_signature": "bytes32 private constant IMPLEMENTATION_SLOT",
            "class_method_signature": "Core.IMPLEMENTATION_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'bytes32 internal constant IMPLEMENTATION_SLOT'}",
            "human_labeled_comment": "/**\n * @notice A private constant representing the storage slot for the implementation address in a proxy contract.\n * This slot is defined by the EIP-1967 standard for proxy contracts.\n */"
        },
        {
            "identifier": "upgradeBeacon",
            "parameters": "address beacon, string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "",
            "body": "function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal {\n        address newImpl = prepareUpgrade(contractName, opts);\n        upgradeBeaconTo(beacon, newImpl);\n    }",
            "start": "124",
            "end": "127",
            "class": "Core",
            "signature": " upgradeBeaconaddress beacon, string memory contractName, Options memory opts",
            "full_signature": "function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal",
            "class_method_signature": "Core.upgradeBeaconaddress beacon, string memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades a beacon to a new implementation.\n *\n * Steps:\n * 1. Prepare the upgrade by retrieving the new implementation address for the given contract name and options.\n * 2. Upgrade the beacon to the new implementation address.\n */"
        },
        {
            "identifier": "upgradeBeacon",
            "parameters": "address beacon, string memory contractName, Options memory opts, address tryCaller",
            "modifiers": "tryPrank(tryCaller)",
            "return": "",
            "body": "function upgradeBeacon(\n        address beacon,\n        string memory contractName,\n        Options memory opts,\n        address tryCaller\n    ) internal tryPrank(tryCaller) {\n        upgradeBeacon(beacon, contractName, opts);\n    }",
            "start": "144",
            "end": "151",
            "class": "Core",
            "signature": " upgradeBeaconaddress beacon, string memory contractName, Options memory opts, address tryCaller",
            "full_signature": "function upgradeBeacon(address beacon, string memory contractName, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)",
            "class_method_signature": "Core.upgradeBeaconaddress beacon, string memory contractName, Options memory opts, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades a beacon contract with a new implementation.\n *\n * @param beacon The address of the beacon contract to upgrade.\n * @param contractName The name of the contract to upgrade to.\n * @param opts Options for the upgrade process.\n * @param tryCaller The address to impersonate during the upgrade (if provided).\n *\n * Steps:\n * 1. Attempt to impersonate the provided `tryCaller` address (if not zero).\n * 2. Call the internal `upgradeBeacon` function with the provided parameters.\n */"
        },
        {
            "identifier": "upgradeProxy",
            "parameters": "address proxy, string memory contractName, bytes memory data, Options memory opts",
            "modifiers": "",
            "return": "",
            "body": "function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal {\n        address newImpl = prepareUpgrade(contractName, opts);\n        upgradeProxyTo(proxy, newImpl, data);\n    }",
            "start": "33",
            "end": "36",
            "class": "Core",
            "signature": " upgradeProxyaddress proxy, string memory contractName, bytes memory data, Options memory opts",
            "full_signature": "function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal",
            "class_method_signature": "Core.upgradeProxyaddress proxy, string memory contractName, bytes memory data, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation.\n *\n * Steps:\n * 1. Prepare the upgrade by retrieving the new implementation address for the given contract name and options.\n * 2. Upgrade the proxy to the new implementation using the provided data.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param contractName The name of the contract to be used for the upgrade.\n * @param data Additional data to be passed during the upgrade process.\n * @param opts Options for the upgrade process.\n */"
        },
        {
            "identifier": "getBeaconAddress",
            "parameters": "address proxy",
            "modifiers": "view",
            "return": "returns (address)",
            "body": "function getBeaconAddress(address proxy) internal view returns (address) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        bytes32 beaconSlot = vm.load(proxy, BEACON_SLOT);\n        return address(uint160(uint256(beaconSlot)));\n    }",
            "start": "262",
            "end": "267",
            "class": "Core",
            "signature": "returns (address) getBeaconAddressaddress proxy",
            "full_signature": "function getBeaconAddress(address proxy) internal  view returns (address)",
            "class_method_signature": "Core.getBeaconAddressaddress proxy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function getBeacon() internal  view returns (address)', 'address  constant CHEATCODE_ADDRESS', 'VmSafe private constant vm', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function load(address target, bytes32 slot) external  view returns (bytes32 data)', 'bytes32 internal constant BEACON_SLOT'}",
            "human_labeled_comment": "/**\n * @notice Retrieves the beacon address associated with a given proxy contract.\n *\n * Steps:\n * 1. Initialize the Vm instance using the cheatcode address.\n * 2. Load the beacon slot data from the proxy contract.\n * 3. Convert the beacon slot data to an address and return it.\n */"
        },
        {
            "identifier": "tryPrank",
            "parameters": "address deployer",
            "modifiers": "",
            "return": "",
            "body": "modifier tryPrank(address deployer) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        try vm.startPrank(deployer) {\n            _;\n            vm.stopPrank();\n        } catch {\n            _;\n        }\n    }",
            "start": "274",
            "end": "283",
            "class": "Core",
            "signature": " tryPrankaddress deployer",
            "full_signature": "function tryPrank(address deployer)",
            "class_method_signature": "Core.tryPrankaddress deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function startPrank(address msgSender) external', 'function stopPrank() external', 'function startPrank(address msgSender, address txOrigin) external', 'address  constant CHEATCODE_ADDRESS', 'VmSafe private constant vm', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice A modifier that attempts to impersonate a given address (`deployer`) during the execution of the function.\n * \n * Steps:\n * 1. Create a `Vm` instance using the cheatcode address.\n * 2. Attempt to start impersonating the `deployer` address.\n * 3. Execute the function body (`_`).\n * 4. Stop impersonating the `deployer` address after the function execution.\n * 5. If the impersonation fails, execute the function body (`_`) without impersonation.\n */"
        },
        {
            "identifier": "getAdminAddress",
            "parameters": "address proxy",
            "modifiers": "view",
            "return": "returns (address)",
            "body": "function getAdminAddress(address proxy) internal view returns (address) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        bytes32 adminSlot = vm.load(proxy, ADMIN_SLOT);\n        return address(uint160(uint256(adminSlot)));\n    }",
            "start": "236",
            "end": "241",
            "class": "Core",
            "signature": "returns (address) getAdminAddressaddress proxy",
            "full_signature": "function getAdminAddress(address proxy) internal  view returns (address)",
            "class_method_signature": "Core.getAdminAddressaddress proxy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'address  constant CHEATCODE_ADDRESS', 'VmSafe private constant vm', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function getAdmin() internal  view returns (address)', 'bytes32 internal constant ADMIN_SLOT', 'function load(address target, bytes32 slot) external  view returns (bytes32 data)'}",
            "human_labeled_comment": "/**\n * @notice Retrieves the admin address for a given proxy contract.\n *\n * Steps:\n * 1. Initialize the Vm instance using the cheatcode address.\n * 2. Load the value stored in the admin slot of the proxy contract.\n * 3. Convert the loaded value to an address and return it.\n */"
        },
        {
            "identifier": "upgradeBeaconTo",
            "parameters": "address beacon, address newImpl",
            "modifiers": "",
            "return": "",
            "body": "function upgradeBeaconTo(address beacon, address newImpl) internal {\n        IUpgradeableBeacon(beacon).upgradeTo(newImpl);\n    }",
            "start": "159",
            "end": "161",
            "class": "Core",
            "signature": " upgradeBeaconToaddress beacon, address newImpl",
            "full_signature": "function upgradeBeaconTo(address beacon, address newImpl) internal",
            "class_method_signature": "Core.upgradeBeaconToaddress beacon, address newImpl",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgradeTo(address) external', 'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades the implementation of a beacon contract to a new address.\n *\n * Steps:\n * 1. Calls the `upgradeTo` function on the specified beacon contract, passing the new implementation address.\n * 2. This function is internal, meaning it can only be called within the contract or derived contracts.\n */"
        },
        {
            "identifier": "deploy",
            "parameters": "string memory contractName, bytes memory constructorData, Options memory opts",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function deploy(\n        string memory contractName,\n        bytes memory constructorData,\n        Options memory opts\n    ) internal returns (address) {\n        if (opts.defender.useDefenderDeploy) {\n            return DefenderDeploy.deploy(contractName, constructorData, opts.defender);\n        } else {\n            return _deploy(contractName, constructorData);\n        }\n    }",
            "start": "426",
            "end": "436",
            "class": "Core",
            "signature": "returns (address) deploystring memory contractName, bytes memory constructorData, Options memory opts",
            "full_signature": "function deploy(string memory contractName, bytes memory constructorData, Options memory opts) internal   returns (address)",
            "class_method_signature": "Core.deploystring memory contractName, bytes memory constructorData, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Deploys a contract with the given name, constructor data, and deployment options.\n *\n * Steps:\n * 1. Check if the deployment should use DefenderDeploy based on the provided options.\n * 2. If DefenderDeploy is enabled, call the DefenderDeploy.deploy function with the contract name, constructor data, and Defender options.\n * 3. If DefenderDeploy is not enabled, call the internal _deploy function with the contract name and constructor data.\n * 4. Return the address of the deployed contract.\n */"
        },
        {
            "identifier": "upgradeBeaconTo",
            "parameters": "address beacon, address newImpl, address tryCaller",
            "modifiers": "tryPrank(tryCaller)",
            "return": "",
            "body": "function upgradeBeaconTo(address beacon, address newImpl, address tryCaller) internal tryPrank(tryCaller) {\n        upgradeBeaconTo(beacon, newImpl);\n    }",
            "start": "175",
            "end": "177",
            "class": "Core",
            "signature": " upgradeBeaconToaddress beacon, address newImpl, address tryCaller",
            "full_signature": "function upgradeBeaconTo(address beacon, address newImpl, address tryCaller) internal  tryPrank(tryCaller)",
            "class_method_signature": "Core.upgradeBeaconToaddress beacon, address newImpl, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function upgrade(address, address) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)'}",
            "human_labeled_comment": "/**\n * @notice Upgrades the implementation of a beacon to a new implementation address.\n * \n * Steps:\n * 1. Attempt to impersonate the specified caller (`tryCaller`).\n * 2. Call the internal `upgradeBeaconTo` function to upgrade the beacon's implementation to `newImpl`.\n */"
        },
        {
            "identifier": "validateImplementation",
            "parameters": "string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "",
            "body": "function validateImplementation(string memory contractName, Options memory opts) internal {\n        _validate(contractName, opts, false);\n    }",
            "start": "185",
            "end": "187",
            "class": "Core",
            "signature": " validateImplementationstring memory contractName, Options memory opts",
            "full_signature": "function validateImplementation(string memory contractName, Options memory opts) internal",
            "class_method_signature": "Core.validateImplementationstring memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Validates the implementation of a contract by calling the internal `_validate` function.\n * \n * @param contractName The name of the contract to validate.\n * @param opts The options to pass to the validation function.\n */"
        },
        {
            "identifier": "prepareUpgrade",
            "parameters": "string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function prepareUpgrade(string memory contractName, Options memory opts) internal returns (address) {\n        validateUpgrade(contractName, opts);\n        return deploy(contractName, opts.constructorData, opts);\n    }",
            "start": "225",
            "end": "228",
            "class": "Core",
            "signature": "returns (address) prepareUpgradestring memory contractName, Options memory opts",
            "full_signature": "function prepareUpgrade(string memory contractName, Options memory opts) internal   returns (address)",
            "class_method_signature": "Core.prepareUpgradestring memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Prepares a contract for upgrade by validating the upgrade and deploying the new contract.\n *\n * Steps:\n * 1. Validate the upgrade by checking the contract name and options.\n * 2. Deploy the new contract using the provided constructor data and options.\n * 3. Return the address of the newly deployed contract.\n */"
        },
        {
            "identifier": "validateUpgrade",
            "parameters": "string memory contractName, Options memory opts",
            "modifiers": "",
            "return": "",
            "body": "function validateUpgrade(string memory contractName, Options memory opts) internal {\n        _validate(contractName, opts, true);\n    }",
            "start": "209",
            "end": "211",
            "class": "Core",
            "signature": " validateUpgradestring memory contractName, Options memory opts",
            "full_signature": "function validateUpgrade(string memory contractName, Options memory opts) internal",
            "class_method_signature": "Core.validateUpgradestring memory contractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Validates the upgrade process for a given contract.\n *\n * @param contractName The name of the contract to be upgraded.\n * @param opts The options for the upgrade process.\n *\n * Internally calls `_validate` with the provided contract name, options, and a boolean flag set to true.\n */"
        },
        {
            "identifier": "_deploy",
            "parameters": "string memory contractName, bytes memory constructorData",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function _deploy(string memory contractName, bytes memory constructorData) private returns (address) {\n        bytes memory creationCode = Vm(Utils.CHEATCODE_ADDRESS).getCode(contractName);\n        address deployedAddress = _deployFromBytecode(abi.encodePacked(creationCode, constructorData));\n        if (deployedAddress == address(0)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Failed to deploy contract \",\n                        contractName,\n                        ' using constructor data \"',\n                        string(constructorData),\n                        '\"'\n                    )\n                )\n            );\n        }\n        return deployedAddress;\n    }",
            "start": "438",
            "end": "455",
            "class": "Core",
            "signature": "returns (address) _deploystring memory contractName, bytes memory constructorData",
            "full_signature": "function _deploy(string memory contractName, bytes memory constructorData) private   returns (address)",
            "class_method_signature": "Core._deploystring memory contractName, bytes memory constructorData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function getCode(string calldata artifactPath) external  view returns (bytes memory creationBytecode)', 'address  constant CHEATCODE_ADDRESS', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)'}",
            "human_labeled_comment": "/**\n * @notice Deploys a contract using the provided contract name and constructor data.\n *\n * Steps:\n * 1. Retrieve the creation code for the contract using the contract name.\n * 2. Deploy the contract using the creation code and constructor data.\n * 3. If the deployment fails (returns address(0)), revert with an error message indicating the failure.\n * 4. Return the address of the deployed contract.\n */"
        }
    ],
    "/root/Account2/lib/Account2/src/Account2.sol": [
        {
            "identifier": "transfer",
            "parameters": "address to, uint256 amount",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function transfer(address to, uint256 amount) external returns (bool);",
            "start": "9",
            "end": "9",
            "class": "IERC20",
            "signature": "returns (bool) transferaddress to, uint256 amount",
            "full_signature": "function transfer(address to, uint256 amount) external   returns (bool)",
            "class_method_signature": "IERC20.transferaddress to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.15;"
            ],
            "import_directive": [
                "import \"solmate/auth/Owned.sol\";",
                "import \"solmate/auth/Auth.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Transfers a specified amount of tokens to a specified address.\n * @param to The address to which the tokens will be transferred.\n * @param amount The amount of tokens to transfer.\n * @return A boolean indicating whether the transfer was successful.\n */"
        },
        {
            "identifier": "balanceOf",
            "parameters": "address account",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function balanceOf(address account) external view returns (uint256);",
            "start": "8",
            "end": "8",
            "class": "IERC20",
            "signature": "returns (uint256) balanceOfaddress account",
            "full_signature": "function balanceOf(address account) external  view returns (uint256)",
            "class_method_signature": "IERC20.balanceOfaddress account",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.15;"
            ],
            "import_directive": [
                "import \"solmate/auth/Owned.sol\";",
                "import \"solmate/auth/Auth.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "ves the token balance of a specified account.\n * @param account The address of the account to query the balance for.\n * @return uint256 The token balance of the specified account.\n */"
        }
    ],
    "/root/Account2/lib/Account2/src/Greeter.sol": [
        {
            "identifier": "greeting",
            "parameters": "",
            "modifiers": "",
            "return": "string",
            "body": "string public greeting;",
            "start": "8",
            "end": "8",
            "class": "Greeter",
            "signature": "string greeting",
            "full_signature": "string public  greeting",
            "class_method_signature": "Greeter.greeting",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.15;"
            ],
            "import_directive": [
                "import { ERC20 } from \"solmate/tokens/ERC20.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A public state variable that stores a greeting message as a string.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DateTimeLib.sol": [
        {
            "identifier": "_totalMonths",
            "parameters": "uint256 numYears, uint256 numMonths",
            "modifiers": "pure",
            "return": "returns (uint256 total)",
            "body": "function _totalMonths(uint256 numYears, uint256 numMonths)\n        private\n        pure\n        returns (uint256 total)\n    {\n        unchecked {\n            total = numYears * 12 + numMonths;\n        }\n    }",
            "start": "476",
            "end": "484",
            "class": "DateTimeLib",
            "signature": "returns (uint256 total) _totalMonthsuint256 numYears, uint256 numMonths",
            "full_signature": "function _totalMonths(uint256 numYears, uint256 numMonths) private  pure returns (uint256 total)",
            "class_method_signature": "DateTimeLib._totalMonthsuint256 numYears, uint256 numMonths",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the total number of months based on the given number of years and months.\n * @dev This function is private and pure, meaning it does not modify the state and can only be called internally.\n * @param numYears The number of years to convert into months.\n * @param numMonths The additional months to add to the total.\n * @return total The total number of months calculated as (numYears * 12) + numMonths.\n * @dev The calculation is performed in an unchecked block to avoid overflow checks, assuming the inputs are valid.\n */"
        },
        {
            "identifier": "OCT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant OCT = 10;",
            "start": "46",
            "end": "46",
            "class": "DateTimeLib",
            "signature": "uint256 OCT",
            "full_signature": "uint256 internal constant OCT",
            "class_method_signature": "DateTimeLib.OCT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant variable representing the value 10.\n * @dev This constant is used for internal calculations or configurations within the contract.\n */"
        },
        {
            "identifier": "JAN",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant JAN = 1;",
            "start": "37",
            "end": "37",
            "class": "DateTimeLib",
            "signature": "uint256 JAN",
            "full_signature": "uint256 internal constant JAN",
            "class_method_signature": "DateTimeLib.JAN",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the month of January, assigned the value 1.\n */"
        },
        {
            "identifier": "TUE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant TUE = 2;",
            "start": "28",
            "end": "28",
            "class": "DateTimeLib",
            "signature": "uint256 TUE",
            "full_signature": "uint256 internal constant TUE",
            "class_method_signature": "DateTimeLib.TUE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines an internal constant `TUE` with a value of 2.\n * This constant is likely used to represent a specific state or identifier within the contract.\n */"
        },
        {
            "identifier": "APR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant APR = 4;",
            "start": "40",
            "end": "40",
            "class": "DateTimeLib",
            "signature": "uint256 APR",
            "full_signature": "uint256 internal constant APR",
            "class_method_signature": "DateTimeLib.APR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the Annual Percentage Rate (APR) as a uint256 value.\n * The APR is set to 4.\n */"
        },
        {
            "identifier": "DEC",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant DEC = 12;",
            "start": "48",
            "end": "48",
            "class": "DateTimeLib",
            "signature": "uint256 DEC",
            "full_signature": "uint256 internal constant DEC",
            "class_method_signature": "DateTimeLib.DEC",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice An internal constant representing a decimal value of 12.\n */"
        },
        {
            "identifier": "MAR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant MAR = 3;",
            "start": "39",
            "end": "39",
            "class": "DateTimeLib",
            "signature": "uint256 MAR",
            "full_signature": "uint256 internal constant MAR",
            "class_method_signature": "DateTimeLib.MAR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant variable representing the value 3.\n */"
        },
        {
            "identifier": "JUL",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant JUL = 7;",
            "start": "43",
            "end": "43",
            "class": "DateTimeLib",
            "signature": "uint256 JUL",
            "full_signature": "uint256 internal constant JUL",
            "class_method_signature": "DateTimeLib.JUL",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant variable representing the month of July, assigned the value 7.\n */"
        },
        {
            "identifier": "_sub",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (uint256 c)",
            "body": "function _sub(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a - b;\n        }\n    }",
            "start": "494",
            "end": "498",
            "class": "DateTimeLib",
            "signature": "returns (uint256 c) _subuint256 a, uint256 b",
            "full_signature": "function _sub(uint256 a, uint256 b) private  pure returns (uint256 c)",
            "class_method_signature": "DateTimeLib._subuint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function to subtract two unsigned integers.\n * @dev Uses unchecked block to prevent overflow checks, assuming the caller ensures `a >= b`.\n * @param a The minuend (the number from which another number is to be subtracted).\n * @param b The subtrahend (the number to be subtracted).\n * @return c The result of the subtraction.\n */"
        },
        {
            "identifier": "THU",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant THU = 4;",
            "start": "30",
            "end": "30",
            "class": "DateTimeLib",
            "signature": "uint256 THU",
            "full_signature": "uint256 internal constant THU",
            "class_method_signature": "DateTimeLib.THU",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice An internal constant variable `THU` with a value of 4.\n */"
        },
        {
            "identifier": "FEB",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant FEB = 2;",
            "start": "38",
            "end": "38",
            "class": "DateTimeLib",
            "signature": "uint256 FEB",
            "full_signature": "uint256 internal constant FEB",
            "class_method_signature": "DateTimeLib.FEB",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the month of February, assigned the value 2.\n */"
        },
        {
            "identifier": "JUN",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant JUN = 6;",
            "start": "42",
            "end": "42",
            "class": "DateTimeLib",
            "signature": "uint256 JUN",
            "full_signature": "uint256 internal constant JUN",
            "class_method_signature": "DateTimeLib.JUN",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the month of June, assigned the value 6.\n */"
        },
        {
            "identifier": "MAY",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant MAY = 5;",
            "start": "41",
            "end": "41",
            "class": "DateTimeLib",
            "signature": "uint256 MAY",
            "full_signature": "uint256 internal constant MAY",
            "class_method_signature": "DateTimeLib.MAY",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant variable representing the month of May, assigned the value 5.\n */"
        },
        {
            "identifier": "NOV",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant NOV = 11;",
            "start": "47",
            "end": "47",
            "class": "DateTimeLib",
            "signature": "uint256 NOV",
            "full_signature": "uint256 internal constant NOV",
            "class_method_signature": "DateTimeLib.NOV",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant variable `NOV` with a value of 11.\n * This variable is internal and cannot be accessed outside the contract.\n */"
        },
        {
            "identifier": "AUG",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant AUG = 8;",
            "start": "44",
            "end": "44",
            "class": "DateTimeLib",
            "signature": "uint256 AUG",
            "full_signature": "uint256 internal constant AUG",
            "class_method_signature": "DateTimeLib.AUG",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines an internal constant `AUG` with a value of 8.\n * This constant is likely used for specific calculations or logic within the contract.\n */"
        },
        {
            "identifier": "_offsetted",
            "parameters": "uint256 year, uint256 month, uint256 day, uint256 timestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp)\n        private\n        pure\n        returns (uint256 result)\n    {\n        uint256 dm = daysInMonth(year, month);\n        if (day >= dm) {\n            day = dm;\n        }\n        result = dateToEpochDay(year, month, day) * 86400 + (timestamp % 86400);\n    }",
            "start": "501",
            "end": "511",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) _offsetteduint256 year, uint256 month, uint256 day, uint256 timestamp",
            "full_signature": "function _offsetted(uint256 year, uint256 month, uint256 day, uint256 timestamp) private  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib._offsetteduint256 year, uint256 month, uint256 day, uint256 timestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the timestamp for a given date and time, adjusted for the number of days in the month.\n *\n * Steps:\n * 1. Determine the number of days in the specified month and year.\n * 2. If the provided day exceeds the number of days in the month, set the day to the last day of the month.\n * 3. Convert the adjusted date to an epoch day (number of days since the Unix epoch).\n * 4. Multiply the epoch day by 86400 (seconds in a day) and add the remainder of the timestamp divided by 86400.\n * 5. Return the resulting timestamp.\n */"
        },
        {
            "identifier": "_add",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (uint256 c)",
            "body": "function _add(uint256 a, uint256 b) private pure returns (uint256 c) {\n        unchecked {\n            c = a + b;\n        }\n    }",
            "start": "487",
            "end": "491",
            "class": "DateTimeLib",
            "signature": "returns (uint256 c) _adduint256 a, uint256 b",
            "full_signature": "function _add(uint256 a, uint256 b) private  pure returns (uint256 c)",
            "class_method_signature": "DateTimeLib._adduint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function to add two unsigned integers.\n * @dev Uses unchecked block to prevent overflow checks, assuming the caller ensures valid inputs.\n * @param a The first unsigned integer.\n * @param b The second unsigned integer.\n * @return c The sum of `a` and `b`.\n */"
        },
        {
            "identifier": "SEP",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant SEP = 9;",
            "start": "45",
            "end": "45",
            "class": "DateTimeLib",
            "signature": "uint256 SEP",
            "full_signature": "uint256 internal constant SEP",
            "class_method_signature": "DateTimeLib.SEP",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines an internal constant `SEP` with a value of 9.\n * This constant is likely used as a separator or identifier in the contract logic.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ERC1967Factory.sol": [
        {
            "identifier": "initCodeHash",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function initCodeHash() public view returns (bytes32 result) {\n        bytes32 m = _initCode();\n        assembly {\n            result := keccak256(add(m, 0x13), 0x88)\n        }\n    }",
            "start": "261",
            "end": "266",
            "class": "ERC1967Factory",
            "signature": "returns (bytes32 result) initCodeHash",
            "full_signature": "function initCodeHash() public  view returns (bytes32 result)",
            "class_method_signature": "ERC1967Factory.initCodeHash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the keccak256 hash of the initialization code.\n *\n * Steps:\n * 1. Retrieve the initialization code from the contract.\n * 2. Use inline assembly to compute the keccak256 hash of the code.\n * 3. Return the computed hash.\n */"
        },
        {
            "identifier": "_DEPLOYMENT_FAILED_ERROR_SELECTOR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _DEPLOYMENT_FAILED_ERROR_SELECTOR = 0x30116425;",
            "start": "28",
            "end": "28",
            "class": "ERC1967Factory",
            "signature": "uint256 _DEPLOYMENT_FAILED_ERROR_SELECTOR",
            "full_signature": "uint256 internal constant _DEPLOYMENT_FAILED_ERROR_SELECTOR",
            "class_method_signature": "ERC1967Factory._DEPLOYMENT_FAILED_ERROR_SELECTOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the error selector for deployment failure.\n * This selector is used to identify errors related to failed contract deployments.\n */"
        },
        {
            "identifier": "DeploymentFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error DeploymentFailed();",
            "start": "16",
            "end": "16",
            "class": "ERC1967Factory",
            "signature": " DeploymentFailed",
            "full_signature": "function DeploymentFailed()",
            "class_method_signature": "ERC1967Factory.DeploymentFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a deployment operation has failed.\n */"
        },
        {
            "identifier": "_UPGRADE_FAILED_ERROR_SELECTOR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _UPGRADE_FAILED_ERROR_SELECTOR = 0x55299b49;",
            "start": "31",
            "end": "31",
            "class": "ERC1967Factory",
            "signature": "uint256 _UPGRADE_FAILED_ERROR_SELECTOR",
            "full_signature": "uint256 internal constant _UPGRADE_FAILED_ERROR_SELECTOR",
            "class_method_signature": "ERC1967Factory._UPGRADE_FAILED_ERROR_SELECTOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the error selector for a failed upgrade.\n * This selector is used to identify specific errors related to upgrade failures in the contract.\n */"
        },
        {
            "identifier": "_UNAUTHORIZED_ERROR_SELECTOR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _UNAUTHORIZED_ERROR_SELECTOR = 0x82b42900;",
            "start": "25",
            "end": "25",
            "class": "ERC1967Factory",
            "signature": "uint256 _UNAUTHORIZED_ERROR_SELECTOR",
            "full_signature": "uint256 internal constant _UNAUTHORIZED_ERROR_SELECTOR",
            "class_method_signature": "ERC1967Factory._UNAUTHORIZED_ERROR_SELECTOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the error selector for unauthorized access.\n * This selector is used to identify specific errors related to unauthorized actions in the contract.\n */"
        },
        {
            "identifier": "_deploy",
            "parameters": "address implementation, address admin, bytes32 salt, bool useSalt, bytes calldata data",
            "modifiers": "",
            "return": "returns (address proxy)",
            "body": "function _deploy(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bool useSalt,\n        bytes calldata data\n    ) internal returns (address proxy) {\n        bytes32 m = _initCode();\n        assembly {\n            // Create the proxy.\n            switch useSalt\n            case 0 { proxy := create(0, add(m, 0x13), 0x88) }\n            default { proxy := create2(0, add(m, 0x13), 0x88, salt) }\n            // Revert if the creation fails.\n            if iszero(proxy) {\n                mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n\n            // Set up the calldata to set the implementation of the proxy.\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try setting the implementation on the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `DeploymentFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _DEPLOYMENT_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n\n            // Emit the {Deployed} event.\n            log4(0, 0, _DEPLOYED_EVENT_SIGNATURE, proxy, implementation, admin)\n        }\n    }",
            "start": "198",
            "end": "239",
            "class": "ERC1967Factory",
            "signature": "returns (address proxy) _deployaddress implementation, address admin, bytes32 salt, bool useSalt, bytes calldata data",
            "full_signature": "function _deploy(address implementation, address admin, bytes32 salt, bool useSalt, bytes calldata data) internal   returns (address proxy)",
            "class_method_signature": "ERC1967Factory._deployaddress implementation, address admin, bytes32 salt, bool useSalt, bytes calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Deploys a proxy contract using either `create` or `create2` depending on the `useSalt` flag.\n *\n * Steps:\n * 1. Retrieve the initialization code for the proxy.\n * 2. Use assembly to create the proxy:\n *    - If `useSalt` is false, use `create` to deploy the proxy.\n *    - If `useSalt` is true, use `create2` with the provided `salt` to deploy the proxy.\n * 3. Revert if the proxy creation fails.\n *\n * 4. Set up the calldata to configure the proxy's implementation:\n *    - Store the implementation address and the implementation slot in memory.\n *    - Copy the provided `data` into memory for the proxy initialization.\n * 5. Call the proxy to set the implementation and revert if the call fails:\n *    - If no returndata is available, revert with the `DeploymentFailed` error.\n *    - Otherwise, bubble up the returned error.\n *\n * 6. Store the admin address for the proxy in storage.\n * 7. Emit the `Deployed` event with the proxy, implementation, and admin addresses.\n */"
        },
        {
            "identifier": "_initCode",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bytes32 m)",
            "body": "function _initCode() internal view returns (bytes32 m) {\n        assembly {\n            /**\n             * -------------------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                                   |\n             * -------------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic        | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize   | r                   |                                 |\n             * 3d         | RETURNDATASIZE  | 0 r                 |                                 |\n             * 81         | DUP2            | r 0 r               |                                 |\n             * 60 offset  | PUSH1 offset    | o r 0 r             |                                 |\n             * 3d         | RETURNDATASIZE  | 0 o r 0 r           |                                 |\n             * 39         | CODECOPY        | 0 r                 | [0..runSize): runtime code      |\n             * f3         | RETURN          |                     | [0..runSize): runtime code      |\n             * -------------------------------------------------------------------------------------|\n             * RUNTIME (127 bytes)                                                                  |\n             * -------------------------------------------------------------------------------------|\n             * Opcode      | Mnemonic       | Stack               | Memory                          |\n             * -------------------------------------------------------------------------------------|\n             *                                                                                      |\n             * ::: keep some values in stack :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0                   |                                 |\n             * 3d          | RETURNDATASIZE | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: check if caller is factory ::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 33          | CALLER         | c 0 0               |                                 |\n             * 73 factory  | PUSH20 factory | f c 0 0             |                                 |\n             * 14          | EQ             | isf 0 0             |                                 |\n             * 60 0x57     | PUSH1 0x57     | dest isf 0 0        |                                 |\n             * 57          | JUMPI          | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             |                                 |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 cds 0 0         |                                 |\n             * 37          | CALLDATACOPY   | 0 0                 | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 0 0             | [0..calldatasize): calldata     |\n             * 3d          | RETURNDATASIZE | 0 cds 0 0           | [0..calldatasize): calldata     |\n             * 7f slot     | PUSH32 slot    | s 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 54          | SLOAD          | i 0 cds 0 0         | [0..calldatasize): calldata     |\n             * 5a          | GAS            | g i 0 cds 0 0       | [0..calldatasize): calldata     |\n             * f4          | DELEGATECALL   | succ                | [0..calldatasize): calldata     |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..calldatasize): calldata     |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..calldatasize): calldata     |\n             * 80          | DUP1           | 0 0 rds succ        | [0..calldatasize): calldata     |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       |                     | [0..returndatasize): returndata |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * f3          | RETURN         |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: set new implementation (caller is factory) ::::::::::::::::::::::::::::::::::::: |\n             * 5b          | JUMPDEST       | 0 0                 |                                 |\n             * 3d          | RETURNDATASIZE | 0 0 0               |                                 |\n             * 35          | CALLDATALOAD   | impl 0 0            |                                 |\n             * 60 0x20     | PUSH1 0x20     | w impl 0 0          |                                 |\n             * 35          | CALLDATALOAD   | slot impl 0 0       |                                 |\n             * 55          | SSTORE         | 0 0                 |                                 |\n             *                                                                                      |\n             * ::: no extra calldata, return :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x40     | PUSH1 0x40     | 2w 0 0              |                                 |\n             * 80          | DUP1           | 2w 2w 0 0           |                                 |\n             * 36          | CALLDATASIZE   | cds 2w 2w 0 0       |                                 |\n             * 11          | GT             | gt 2w 0 0           |                                 |\n             * 15          | ISZERO         | lte 2w 0 0          |                                 |\n             * 60 0x52     | PUSH1 0x52     | dest lte 2w 0 0     |                                 |\n             * 57          | JUMPI          | 2w 0 0              |                                 |\n             *                                                                                      |\n             * ::: copy extra calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36          | CALLDATASIZE   | cds 2w 0 0          |                                 |\n             * 03          | SUB            | t 0 0               |                                 |\n             * 80          | DUP1           | t t 0 0             |                                 |\n             * 60 0x40     | PUSH1 0x40     | 2w t t 0 0          |                                 |\n             * 3d          | RETURNDATASIZE | 0 2w t t 0 0        |                                 |\n             * 37          | CALLDATACOPY   | t 0 0               | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | 0 t 0 0             | [0..t): extra calldata          |\n             * 3d          | RETURNDATASIZE | 0 0 t 0 0           | [0..t): extra calldata          |\n             * 35          | CALLDATALOAD   | i 0 t 0 0           | [0..t): extra calldata          |\n             * 5a          | GAS            | g i 0 t 0 0         | [0..t): extra calldata          |\n             * f4          | DELEGATECALL   | succ                | [0..t): extra calldata          |\n             *                                                                                      |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds succ            | [0..t): extra calldata          |\n             * 60 0x00     | PUSH1 0x00     | 0 rds succ          | [0..t): extra calldata          |\n             * 80          | DUP1           | 0 0 rds succ        | [0..t): extra calldata          |\n             * 3e          | RETURNDATACOPY | succ                | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52     | PUSH1 0x52     | dest succ           | [0..returndatasize): returndata |\n             * 57          | JUMPI          |                     | [0..returndatasize): returndata |\n             *                                                                                      |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d          | RETURNDATASIZE | rds                 | [0..returndatasize): returndata |\n             * 60 0x00     | PUSH1 0x00     | 0 rds               | [0..returndatasize): returndata |\n             * fd          | REVERT         |                     | [0..returndatasize): returndata |\n             * -------------------------------------------------------------------------------------+\n             */\n            m := mload(0x40)\n            // forgefmt: disable-start\n            switch shr(112, address())\n            case 0 {\n                // If the factory's address has six or more leading zero bytes.\n                mstore(add(m, 0x75), 0x604c573d6000fd) // 7\n                mstore(add(m, 0x6e), 0x3d3560203555604080361115604c5736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x4e), 0x3735a920a3ca505d382bbc545af43d6000803e604c573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x2e), 0x14605157363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x0e), address()) // 14\n                mstore(m, 0x60793d8160093d39f33d3d336d) // 9 + 4\n            }\n            default {\n                mstore(add(m, 0x7b), 0x6052573d6000fd) // 7\n                mstore(add(m, 0x74), 0x3d356020355560408036111560525736038060403d373d3d355af43d6000803e) // 32\n                mstore(add(m, 0x54), 0x3735a920a3ca505d382bbc545af43d6000803e6052573d6000fd5b3d6000f35b) // 32\n                mstore(add(m, 0x34), 0x14605757363d3d37363d7f360894a13ba1a3210667c828492db98dca3e2076cc) // 32\n                mstore(add(m, 0x14), address()) // 20\n                mstore(m, 0x607f3d8160093d39f33d3d3373) // 9 + 4\n            }\n            // forgefmt: disable-end\n        }\n    }",
            "start": "269",
            "end": "406",
            "class": "ERC1967Factory",
            "signature": "returns (bytes32 m) _initCode",
            "full_signature": "function _initCode() internal  view returns (bytes32 m)",
            "class_method_signature": "ERC1967Factory._initCode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "al function to initialize the contract's runtime code.\n *\n * This function uses inline assembly to generate and return the runtime code for the contract.\n * The runtime code is responsible for handling delegate calls and managing the contract's state.\n *\n * Steps:\n * 1. Load the free memory pointer into `m`.\n * 2. Use inline assembly to generate the runtime code based on the contract's address.\n * 3. Depending on the number of leading zero bytes in the factory's address, different runtime code is generated.\n * 4. The runtime code includes:\n *    - Creation code to deploy the contract.\n *    - Runtime code to handle delegate calls, check the caller, copy calldata, and manage state.\n *    - Logic to handle successful and failed delegate calls, including reverting or returning data.\n *    - Logic to set a new implementation if the caller is the factory.\n * 5. The generated runtime code is stored in memory and returned as a `bytes32` value.\n *\n * The function is designed to be gas-efficient and ensures that the contract behaves correctly when deployed.\n */"
        },
        {
            "identifier": "_SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR = 0x2f634836;",
            "start": "34",
            "end": "34",
            "class": "ERC1967Factory",
            "signature": "uint256 _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR",
            "full_signature": "uint256 internal constant _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR",
            "class_method_signature": "ERC1967Factory._SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the error selector for when the salt does not start with the caller.\n * @dev This constant is used to identify specific errors in the contract, particularly when the salt value does not meet the expected criteria.\n */"
        },
        {
            "identifier": "_emptyData",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes calldata data)",
            "body": "function _emptyData() internal pure returns (bytes calldata data) {\n        assembly {\n            data.length := 0\n        }\n    }",
            "start": "413",
            "end": "417",
            "class": "ERC1967Factory",
            "signature": "returns (bytes calldata data) _emptyData",
            "full_signature": "function _emptyData() internal  pure returns (bytes calldata data)",
            "class_method_signature": "ERC1967Factory._emptyData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function that returns an empty bytes calldata.\n * \n * Steps:\n * 1. Use inline assembly to set the length of the returned data to 0.\n * 2. Return the empty bytes calldata.\n */"
        },
        {
            "identifier": "_UPGRADED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _UPGRADED_EVENT_SIGNATURE =\n        0x5d611f318680d00598bb735d61bacf0c514c6b50e1e5ad30040a4df2b12791c7;",
            "start": "54",
            "end": "55",
            "class": "ERC1967Factory",
            "signature": "uint256 _UPGRADED_EVENT_SIGNATURE",
            "full_signature": "uint256 internal constant _UPGRADED_EVENT_SIGNATURE",
            "class_method_signature": "ERC1967Factory._UPGRADED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the event signature for an upgrade event.\n * \n * The value is a keccak256 hash of the event signature, which is used to identify\n * the event in the logs.\n */"
        },
        {
            "identifier": "UpgradeFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error UpgradeFailed();",
            "start": "19",
            "end": "19",
            "class": "ERC1967Factory",
            "signature": " UpgradeFailed",
            "full_signature": "function UpgradeFailed()",
            "class_method_signature": "ERC1967Factory.UpgradeFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that an upgrade operation has failed.\n */"
        },
        {
            "identifier": "_ADMIN_CHANGED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _ADMIN_CHANGED_EVENT_SIGNATURE =\n        0x7e644d79422f17c01e4894b5f4f588d331ebfa28653d42ae832dc59e38c9798f;",
            "start": "50",
            "end": "51",
            "class": "ERC1967Factory",
            "signature": "uint256 _ADMIN_CHANGED_EVENT_SIGNATURE",
            "full_signature": "uint256 internal constant _ADMIN_CHANGED_EVENT_SIGNATURE",
            "class_method_signature": "ERC1967Factory._ADMIN_CHANGED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the event signature for the \"AdminChanged\" event.\n * This signature is used to identify and filter events related to admin changes.\n */"
        },
        {
            "identifier": "_IMPLEMENTATION_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;",
            "start": "69",
            "end": "70",
            "class": "ERC1967Factory",
            "signature": "uint256 _IMPLEMENTATION_SLOT",
            "full_signature": "uint256 internal constant _IMPLEMENTATION_SLOT",
            "class_method_signature": "ERC1967Factory._IMPLEMENTATION_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant internal variable `_IMPLEMENTATION_SLOT` with a specific slot value.\n * This slot is typically used in proxy patterns to store the address of the implementation contract.\n * The value `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc` is a standard slot for the implementation address in EIP-1967.\n */"
        },
        {
            "identifier": "_DEPLOYED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _DEPLOYED_EVENT_SIGNATURE =\n        0xc95935a66d15e0da5e412aca0ad27ae891d20b2fb91cf3994b6a3bf2b8178082;",
            "start": "58",
            "end": "59",
            "class": "ERC1967Factory",
            "signature": "uint256 _DEPLOYED_EVENT_SIGNATURE",
            "full_signature": "uint256 internal constant _DEPLOYED_EVENT_SIGNATURE",
            "class_method_signature": "ERC1967Factory._DEPLOYED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the signature of the deployed event.\n * This is used to identify the event emitted when a contract is deployed.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/UUPSUpgradeable.sol": [
        {
            "identifier": "_authorizeUpgrade",
            "parameters": "address newImplementation",
            "modifiers": "",
            "return": "",
            "body": "function _authorizeUpgrade(address newImplementation) internal virtual;",
            "start": "61",
            "end": "61",
            "class": "UUPSUpgradeable",
            "signature": " _authorizeUpgradeaddress newImplementation",
            "full_signature": "function _authorizeUpgrade(address newImplementation) internal virtual",
            "class_method_signature": "UUPSUpgradeable._authorizeUpgradeaddress newImplementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "al function to authorize an upgrade to a new implementation.\n * @dev This function is virtual and should be overridden by derived contracts to provide specific authorization logic.\n * @param newImplementation The address of the new implementation contract to which the upgrade is being authorized.\n */"
        },
        {
            "identifier": "onlyProxy",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyProxy() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // To enable use cases with an immutable default implementation in the bytecode,\n            // (see: ERC6551Proxy), we don't require that the proxy address must match the\n            // value stored in the implementation slot, which may not be initialized.\n            if eq(s, address()) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }",
            "start": "114",
            "end": "127",
            "class": "UUPSUpgradeable",
            "signature": " onlyProxy",
            "full_signature": "function onlyProxy()",
            "class_method_signature": "UUPSUpgradeable.onlyProxy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to ensure that the function is only callable by the proxy contract.\n *\n * Steps:\n * 1. Retrieve the current contract's address (`__self`).\n * 2. Use inline assembly to check if the current contract's address matches the proxy address.\n * 3. If the addresses do not match, revert with an `UnauthorizedCallContext` error.\n * 4. If the addresses match, allow the function to proceed.\n */"
        },
        {
            "identifier": "__self",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private immutable __self = uint256(uint160(address(this)));",
            "start": "30",
            "end": "30",
            "class": "UUPSUpgradeable",
            "signature": "uint256 __self",
            "full_signature": "uint256 private  __self",
            "class_method_signature": "UUPSUpgradeable.__self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Stores the current contract's address as an immutable uint256 value.\n * This is done by converting the address to a uint160 and then to a uint256.\n * The value is immutable, meaning it cannot be changed after deployment.\n */"
        },
        {
            "identifier": "_UPGRADED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;",
            "start": "40",
            "end": "41",
            "class": "UUPSUpgradeable",
            "signature": "uint256 _UPGRADED_EVENT_SIGNATURE",
            "full_signature": "uint256 private constant _UPGRADED_EVENT_SIGNATURE",
            "class_method_signature": "UUPSUpgradeable._UPGRADED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant variable that stores the event signature for an upgrade event.\n * The event signature is a keccak256 hash of the event name and its parameters.\n * In this case, the event signature corresponds to an upgrade event.\n */"
        },
        {
            "identifier": "notDelegated",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier notDelegated() {\n        uint256 s = __self;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(eq(s, address())) {\n                mstore(0x00, 0x9f03a026) // `UnauthorizedCallContext()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }",
            "start": "131",
            "end": "141",
            "class": "UUPSUpgradeable",
            "signature": " notDelegated",
            "full_signature": "function notDelegated()",
            "class_method_signature": "UUPSUpgradeable.notDelegated",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to ensure the function is not called in a delegated context.\n *\n * Steps:\n * 1. Store the current contract's address in a variable.\n * 2. Use inline assembly to check if the current address matches the contract's address.\n * 3. If the addresses do not match, revert with the error `UnauthorizedCallContext()`.\n * 4. If the addresses match, continue with the function execution.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/Multicallable.sol": [
        {
            "identifier": "_multicall",
            "parameters": "bytes[] calldata data",
            "modifiers": "",
            "return": "returns (bytes32 results)",
            "body": "function _multicall(bytes[] calldata data) internal virtual returns (bytes32 results) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            results := mload(0x40)\n            mstore(results, 0x20)\n            mstore(add(0x20, results), data.length)\n            let c := add(0x40, results)\n            let s := c\n            let end := shl(5, data.length)\n            calldatacopy(c, data.offset, end)\n            end := add(c, end)\n            let m := end\n            if data.length {\n                for {} 1 {} {\n                    let o := add(data.offset, mload(c))\n                    calldatacopy(m, add(o, 0x20), calldataload(o))\n                    // forgefmt: disable-next-item\n                    if iszero(delegatecall(gas(), address(), m, calldataload(o), codesize(), 0x00)) {\n                        // Bubble up the revert if the delegatecall reverts.\n                        returndatacopy(results, 0x00, returndatasize())\n                        revert(results, returndatasize())\n                    }\n                    mstore(c, sub(m, s))\n                    c := add(0x20, c)\n                    // Append the `returndatasize()`, and the return data.\n                    mstore(m, returndatasize())\n                    let b := add(m, 0x20)\n                    returndatacopy(b, 0x00, returndatasize())\n                    // Advance `m` by `returndatasize() + 0x20`,\n                    // rounded up to the next multiple of 32.\n                    m := and(add(add(b, returndatasize()), 0x1f), 0xffffffffffffffe0)\n                    mstore(add(b, returndatasize()), 0) // Zeroize the slot after the returndata.\n                    if iszero(lt(c, end)) { break }\n                }\n            }\n            mstore(0x40, m) // Allocate memory.\n            results := or(shl(64, m), results) // Pack the bytes length into `results`.\n        }\n    }",
            "start": "42",
            "end": "80",
            "class": "Multicallable",
            "signature": "returns (bytes32 results) _multicallbytes[] calldata data",
            "full_signature": "function _multicall(bytes[] calldata data) internal virtual  returns (bytes32 results)",
            "class_method_signature": "Multicallable._multicallbytes[] calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Executes multiple function calls in a single transaction using delegatecall.\n * @dev This function is marked as internal and virtual, allowing it to be overridden by derived contracts.\n * \n * Steps:\n * 1. Allocate memory for the results and store the length of the data array.\n * 2. Copy the calldata into memory for processing.\n * 3. Iterate over each function call in the data array:\n *    a. Load the function call data from calldata.\n *    b. Execute the function call using delegatecall.\n *    c. If the delegatecall fails, revert with the returned data.\n *    d. Store the return data and its size in memory.\n *    e. Advance the memory pointer to prepare for the next function call.\n * 4. Allocate memory for the final results and pack the length of the results into the return value.\n * \n * @param data An array of encoded function calls to be executed.\n * @return results The packed results of the function calls, including their lengths.\n */"
        },
        {
            "identifier": "_multicallResultsToBytesArray",
            "parameters": "bytes32 results",
            "modifiers": "pure",
            "return": "returns (bytes[] memory decoded)",
            "body": "function _multicallResultsToBytesArray(bytes32 results)\n        internal\n        pure\n        virtual\n        returns (bytes[] memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            decoded := mload(0x40)\n            let c := and(0xffffffffffffffff, results) // Extract the offset.\n            mstore(decoded, mload(add(c, 0x20))) // Store the length.\n            let o := add(decoded, 0x20) // Start of elements in `decoded`.\n            let end := add(o, shl(5, mload(decoded)))\n            mstore(0x40, end) // Allocate memory.\n            let s := add(c, 0x40) // Start of elements in `results`.\n            let d := sub(s, o) // Difference between input and output pointers.\n            for {} iszero(eq(o, end)) { o := add(o, 0x20) } { mstore(o, add(mload(add(d, o)), s)) }\n        }\n    }",
            "start": "84",
            "end": "102",
            "class": "Multicallable",
            "signature": "returns (bytes[] memory decoded) _multicallResultsToBytesArraybytes32 results",
            "full_signature": "function _multicallResultsToBytesArray(bytes32 results) internal virtual pure returns (bytes[] memory decoded)",
            "class_method_signature": "Multicallable._multicallResultsToBytesArraybytes32 results",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a `bytes32` result from a multicall into a `bytes[]` array.\n *\n * Steps:\n * 1. Allocate memory for the decoded array.\n * 2. Extract the offset from the `results` parameter.\n * 3. Store the length of the decoded array.\n * 4. Calculate the start and end pointers for the decoded array.\n * 5. Allocate memory for the decoded array elements.\n * 6. Calculate the start pointer for the `results` elements.\n * 7. Compute the difference between the input and output pointers.\n * 8. Loop through the elements, copying them from `results` to the decoded array.\n *\n * @param results The `bytes32` input containing the multicall results.\n * @return decoded The decoded `bytes[]` array.\n */"
        },
        {
            "identifier": "_multicallDirectReturn",
            "parameters": "bytes32 results",
            "modifiers": "pure",
            "return": "",
            "body": "function _multicallDirectReturn(bytes32 results) internal pure virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            return(and(0xffffffffffffffff, results), shr(64, results))\n        }\n    }",
            "start": "106",
            "end": "111",
            "class": "Multicallable",
            "signature": " _multicallDirectReturnbytes32 results",
            "full_signature": "function _multicallDirectReturn(bytes32 results) internal virtual pure",
            "class_method_signature": "Multicallable._multicallDirectReturnbytes32 results",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to handle multicall with direct return values.\n * \n * Steps:\n * 1. Uses inline assembly to perform low-level operations.\n * 2. Extracts the lower 64 bits of the `results` parameter and returns them.\n * 3. Shifts the `results` parameter right by 64 bits and returns the upper 64 bits.\n * \n * @param results A bytes32 value containing the data to be split and returned.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibMap.sol": [
        {
            "identifier": "_rawMod",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function _rawMod(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }",
            "start": "303",
            "end": "308",
            "class": "LibMap",
            "signature": "returns (uint256 z) _rawModuint256 x, uint256 y",
            "full_signature": "function _rawMod(uint256 x, uint256 y) private  pure returns (uint256 z)",
            "class_method_signature": "LibMap._rawModuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that performs a raw modulo operation on two unsigned integers.\n * \n * @param x The dividend.\n * @param y The divisor.\n * @return z The remainder of the division of `x` by `y`.\n * \n * @dev Uses inline assembly to perform the modulo operation directly, ensuring memory safety.\n */"
        },
        {
            "identifier": "_rawDiv",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function _rawDiv(uint256 x, uint256 y) private pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }",
            "start": "295",
            "end": "300",
            "class": "LibMap",
            "signature": "returns (uint256 z) _rawDivuint256 x, uint256 y",
            "full_signature": "function _rawDiv(uint256 x, uint256 y) private  pure returns (uint256 z)",
            "class_method_signature": "LibMap._rawDivuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a raw division operation on two unsigned integers using inline assembly.\n * @dev This function uses Solidity's inline assembly to perform the division, which is memory-safe.\n * @param x The dividend.\n * @param y The divisor.\n * @return z The result of the division (x / y).\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/SSTORE2.sol": [
        {
            "identifier": "CREATE3_PROXY_INITCODE_HASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant CREATE3_PROXY_INITCODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;",
            "start": "20",
            "end": "21",
            "class": "SSTORE2",
            "signature": "bytes32 CREATE3_PROXY_INITCODE_HASH",
            "full_signature": "bytes32 internal constant CREATE3_PROXY_INITCODE_HASH",
            "class_method_signature": "SSTORE2.CREATE3_PROXY_INITCODE_HASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the keccak256 hash of the CREATE3 proxy initialization code.\n * This hash is used to uniquely identify the initialization code for CREATE3 proxy contracts.\n */"
        },
        {
            "identifier": "initCodeHash",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHash(bytes memory data) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xfffe))\n            mstore(data, add(0x61000180600a3d393df300, shl(0x40, n)))\n            hash := keccak256(add(data, 0x15), add(n, 0xb))\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "start": "132",
            "end": "142",
            "class": "SSTORE2",
            "signature": "returns (bytes32 hash) initCodeHashbytes memory data",
            "full_signature": "function initCodeHash(bytes memory data) internal  pure returns (bytes32 hash)",
            "class_method_signature": "SSTORE2.initCodeHashbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Computes the keccak256 hash of the given bytecode data with a specific prefix.\n * \n * Steps:\n * 1. Load the length of the data into `n`.\n * 2. Perform an out-of-gas revert if `n + 1` exceeds 2 bytes.\n * 3. Prepend a specific prefix to the data in memory.\n * 4. Compute the keccak256 hash of the modified data.\n * 5. Restore the original length of the data in memory.\n * \n * @param data The bytecode data to compute the hash for.\n * @return hash The computed keccak256 hash of the modified data.\n */"
        },
        {
            "identifier": "_CREATE3_PROXY_INITCODE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _CREATE3_PROXY_INITCODE = 0x67363d3d37363d34f03d5260086018f3;",
            "start": "16",
            "end": "16",
            "class": "SSTORE2",
            "signature": "uint256 _CREATE3_PROXY_INITCODE",
            "full_signature": "uint256 private constant _CREATE3_PROXY_INITCODE",
            "class_method_signature": "SSTORE2._CREATE3_PROXY_INITCODE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the initialization code for a CREATE3 proxy.\n * This is typically used in low-level contract creation patterns to deploy contracts at deterministic addresses.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/CREATE3.sol": [
        {
            "identifier": "_PROXY_INITCODE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _PROXY_INITCODE = 0x67363d3d37363d34f03d5260086018f3;",
            "start": "45",
            "end": "45",
            "class": "CREATE3",
            "signature": "uint256 _PROXY_INITCODE",
            "full_signature": "uint256 private constant _PROXY_INITCODE",
            "class_method_signature": "CREATE3._PROXY_INITCODE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the initialization code for a proxy contract.\n * The value is a hardcoded byte sequence used during the deployment of proxy contracts.\n */"
        },
        {
            "identifier": "PROXY_INITCODE_HASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant PROXY_INITCODE_HASH =\n        0x21c35dbe1b344a2488cf3321d6ce542f8e9f305544ff09e4993a62319a497c1f;",
            "start": "49",
            "end": "50",
            "class": "CREATE3",
            "signature": "bytes32 PROXY_INITCODE_HASH",
            "full_signature": "bytes32 internal constant PROXY_INITCODE_HASH",
            "class_method_signature": "CREATE3.PROXY_INITCODE_HASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the keccak256 hash of the proxy initialization code.\n * This is typically used in proxy patterns to ensure the correct initialization code is used when deploying proxy contracts.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DeploylessPredeployQueryer.sol": [
        {
            "identifier": "ReturnedAddressMismatch",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ReturnedAddressMismatch();",
            "start": "27",
            "end": "27",
            "class": "DeploylessPredeployQueryer",
            "signature": " ReturnedAddressMismatch",
            "full_signature": "function ReturnedAddressMismatch()",
            "class_method_signature": "DeploylessPredeployQueryer.ReturnedAddressMismatch",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the returned address does not match the expected address.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibBytes.sol": [
        {
            "identifier": "BytesStorage",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct BytesStorage {\n        bytes32 _spacer;\n    }",
            "start": "14",
            "end": "16",
            "class": "LibBytes",
            "signature": " BytesStorage",
            "full_signature": "function BytesStorage()",
            "class_method_signature": "LibBytes.BytesStorage",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A struct representing a storage container for bytes data.\n * @dev The struct includes a single field `_spacer` of type `bytes32`, which can be used as a placeholder or spacer in storage.\n */"
        },
        {
            "identifier": "replace",
            "parameters": "bytes memory subject, bytes memory needle, bytes memory replacement",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function replace(bytes memory subject, bytes memory needle, bytes memory replacement)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let needleLen := mload(needle)\n            let replacementLen := mload(replacement)\n            let d := sub(result, subject) // Memory difference.\n            let i := add(subject, 0x20) // Subject bytes pointer.\n            mstore(0x00, add(i, mload(subject))) // End of subject.\n            if iszero(gt(needleLen, mload(subject))) {\n                let subjectSearchEnd := add(sub(mload(0x00), needleLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(needleLen, 0x20)) { h := keccak256(add(needle, 0x20), needleLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(needleLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `needleLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, needleLen), h)) {\n                                mstore(add(i, d), t)\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        // Copy the `replacement` one word at a time.\n                        for { let j := 0 } 1 {} {\n                            mstore(add(add(i, d), j), mload(add(add(replacement, 0x20), j)))\n                            j := add(j, 0x20)\n                            if iszero(lt(j, replacementLen)) { break }\n                        }\n                        d := sub(add(d, replacementLen), needleLen)\n                        if needleLen {\n                            i := add(i, needleLen)\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    mstore(add(i, d), t)\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n            }\n            let end := mload(0x00)\n            let n := add(sub(d, add(result, 0x20)), end)\n            // Copy the rest of the bytes one word at a time.\n            for {} lt(i, end) { i := add(i, 0x20) } { mstore(add(i, d), mload(i)) }\n            let o := add(i, d)\n            mstore(o, 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "131",
            "end": "188",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) replacebytes memory subject, bytes memory needle, bytes memory replacement",
            "full_signature": "function replace(bytes memory subject, bytes memory needle, bytes memory replacement) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibBytes.replacebytes memory subject, bytes memory needle, bytes memory replacement",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Replaces occurrences of `needle` in `subject` with `replacement` in a memory-safe manner.\n *\n * Steps:\n * 1. Allocate memory for the result.\n * 2. Calculate the length of `needle` and `replacement`.\n * 3. Compute the memory difference between `result` and `subject`.\n * 4. Initialize pointers for iterating through `subject`.\n * 5. Store the end of `subject` in memory.\n *\n * 6. If `needle` is not longer than `subject`, proceed with the replacement logic.\n * 7. Calculate the end of the search range within `subject`.\n * 8. Compute the hash of `needle` if its length is 32 bytes or more.\n * 9. Load the first word of `needle` for comparison.\n *\n * 10. Iterate through `subject` to find matches with `needle`.\n * 11. If a match is found, copy `replacement` into the result.\n * 12. Adjust the memory difference and continue searching.\n * 13. If no match is found, copy the current byte from `subject` to the result.\n *\n * 14. After processing, copy the remaining bytes of `subject` to the result.\n * 15. Zeroize the slot after the result and allocate memory.\n * 16. Store the length of the result.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "bytes memory subject, bytes memory needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function indexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0) // Initialize to `NOT_FOUND`.\n            for { let subjectLen := mload(subject) } 1 {} {\n                if iszero(mload(needle)) {\n                    result := from\n                    if iszero(gt(from, subjectLen)) { break }\n                    result := subjectLen\n                    break\n                }\n                let needleLen := mload(needle)\n                let subjectStart := add(subject, 0x20)\n\n                subject := add(subjectStart, from)\n                let end := add(sub(add(subjectStart, subjectLen), needleLen), 1)\n                let m := shl(3, sub(0x20, and(needleLen, 0x1f)))\n                let s := mload(add(needle, 0x20))\n\n                if iszero(and(lt(subject, end), lt(from, subjectLen))) { break }\n\n                if iszero(lt(needleLen, 0x20)) {\n                    for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                        if iszero(shr(m, xor(mload(subject), s))) {\n                            if eq(keccak256(subject, needleLen), h) {\n                                result := sub(subject, subjectStart)\n                                break\n                            }\n                        }\n                        subject := add(subject, 1)\n                        if iszero(lt(subject, end)) { break }\n                    }\n                    break\n                }\n                for {} 1 {} {\n                    if iszero(shr(m, xor(mload(subject), s))) {\n                        result := sub(subject, subjectStart)\n                        break\n                    }\n                    subject := add(subject, 1)\n                    if iszero(lt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }",
            "start": "193",
            "end": "242",
            "class": "LibBytes",
            "signature": "returns (uint256 result) indexOfbytes memory subject, bytes memory needle, uint256 from",
            "full_signature": "function indexOf(bytes memory subject, bytes memory needle, uint256 from) internal  pure returns (uint256 result)",
            "class_method_signature": "LibBytes.indexOfbytes memory subject, bytes memory needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Finds the index of a `needle` byte sequence within a `subject` byte sequence, starting from a specified `from` index.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation. It returns the index of the first occurrence of `needle` in `subject` starting from `from`. If `needle` is not found, it returns `NOT_FOUND` (initialized as `not(0)`).\n *\n * Steps:\n * 1. Initialize `result` to `NOT_FOUND`.\n * 2. Check if `needle` is empty. If so, return `from` if it is within bounds, otherwise return the length of `subject`.\n * 3. Calculate the length of `needle` and the starting position of `subject`.\n * 4. Adjust `subject` to start from the `from` index.\n * 5. Calculate the end position for the search.\n * 6. Use bitwise operations to prepare for comparison.\n * 7. If `needle` is 32 bytes or longer, use `keccak256` for efficient comparison.\n * 8. Iterate through `subject` to find a match for `needle`.\n * 9. If a match is found, return the index of the match.\n * 10. If no match is found, return `NOT_FOUND`.\n */"
        },
        {
            "identifier": "startsWith",
            "parameters": "bytes memory subject, bytes memory needle",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function startsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            // Just using keccak256 directly is actually cheaper.\n            let t := eq(keccak256(add(subject, 0x20), n), keccak256(add(needle, 0x20), n))\n            result := lt(gt(n, mload(subject)), t)\n        }\n    }",
            "start": "305",
            "end": "317",
            "class": "LibBytes",
            "signature": "returns (bool result) startsWithbytes memory subject, bytes memory needle",
            "full_signature": "function startsWith(bytes memory subject, bytes memory needle) internal  pure returns (bool result)",
            "class_method_signature": "LibBytes.startsWithbytes memory subject, bytes memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a byte array (`subject`) starts with another byte array (`needle`).\n *\n * Steps:\n * 1. Load the length of the `needle` byte array.\n * 2. Compare the keccak256 hash of the first `n` bytes of `subject` with the keccak256 hash of `needle`.\n * 3. Return `true` if the `needle` is a prefix of `subject`, otherwise return `false`.\n *\n * @dev This function uses low-level assembly for efficient byte array comparison.\n * @param subject The byte array to check.\n * @param needle The byte array to compare as a prefix.\n * @return result `true` if `subject` starts with `needle`, otherwise `false`.\n */"
        },
        {
            "identifier": "concat",
            "parameters": "bytes memory a, bytes memory b",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function concat(bytes memory a, bytes memory b) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let w := not(0x1f)\n            let aLen := mload(a)\n            // Copy `a` one word at a time, backwards.\n            for { let o := and(add(aLen, 0x20), w) } 1 {} {\n                mstore(add(result, o), mload(add(a, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let bLen := mload(b)\n            let output := add(result, aLen)\n            // Copy `b` one word at a time, backwards.\n            for { let o := and(add(bLen, 0x20), w) } 1 {} {\n                mstore(add(output, o), mload(add(b, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            let totalLen := add(aLen, bLen)\n            let last := add(add(result, 0x20), totalLen)\n            mstore(last, 0) // Zeroize the slot after the bytes.\n            mstore(result, totalLen) // Store the length.\n            mstore(0x40, add(last, 0x20)) // Allocate memory.\n        }\n    }",
            "start": "561",
            "end": "587",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) concatbytes memory a, bytes memory b",
            "full_signature": "function concat(bytes memory a, bytes memory b) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibBytes.concatbytes memory a, bytes memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Concatenates two byte arrays `a` and `b` into a single byte array.\n * @dev Uses low-level assembly for efficient memory manipulation.\n *\n * Steps:\n * 1. Load the free memory pointer to determine where to store the result.\n * 2. Calculate the length of `a` and copy its contents word by word into the result.\n * 3. Calculate the length of `b` and copy its contents word by word into the result, starting after `a`.\n * 4. Calculate the total length of the concatenated result.\n * 5. Zeroize the memory slot after the concatenated result to ensure proper memory alignment.\n * 6. Store the total length of the result in the first word of the result.\n * 7. Update the free memory pointer to allocate memory for the result.\n *\n * @param a The first byte array to concatenate.\n * @param b The second byte array to concatenate.\n * @return result The concatenated byte array.\n */"
        },
        {
            "identifier": "set",
            "parameters": "BytesStorage storage $, bytes memory s",
            "modifiers": "",
            "return": "",
            "body": "function set(BytesStorage storage $, bytes memory s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let packed := or(0xff, shl(8, n))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(n, 0xfe)) {\n                    i := 0x1f\n                    packed := or(n, shl(8, mload(add(s, i))))\n                    if iszero(gt(n, i)) { break }\n                }\n                let o := add(s, 0x20)\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), mload(add(o, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }",
            "start": "30",
            "end": "52",
            "class": "LibBytes",
            "signature": " setBytesStorage storage $, bytes memory s",
            "full_signature": "function set(BytesStorage storage $, bytes memory s) internal",
            "class_method_signature": "LibBytes.setBytesStorage storage $, bytes memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sets the bytes data in the storage slot.\n *\n * Steps:\n * 1. Load the length of the bytes data `s` into `n`.\n * 2. Pack the length `n` with a prefix `0xff` and store it in `packed`.\n *\n * 3. If the length `n` is less than or equal to `0xfe`:\n *    - Set `i` to `0x1f`.\n *    - Pack the first 32 bytes of `s` with the length `n` and store it in `packed`.\n *    - If the length `n` is less than or equal to `i`, break the loop.\n *\n * 4. Otherwise:\n *    - Calculate the offset `o` as `s + 0x20`.\n *    - Store the storage slot address in memory at `0x00`.\n *    - Calculate the storage pointer `p` using `keccak256(0x00, 0x20)`.\n *    - Store the bytes data in the storage slot in chunks of 32 bytes.\n *    - Increment `i` by 32 bytes until all data is stored.\n *\n * 5. Store the packed data in the storage slot.\n */"
        },
        {
            "identifier": "split",
            "parameters": "bytes memory subject, bytes memory delimiter",
            "modifiers": "pure",
            "return": "returns (bytes[] memory result)",
            "body": "function split(bytes memory subject, bytes memory delimiter)\n        internal\n        pure\n        returns (bytes[] memory result)\n    {\n        uint256[] memory indices = indicesOf(subject, delimiter);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let indexPtr := add(indices, 0x20)\n            let indicesEnd := add(indexPtr, shl(5, add(mload(indices), 1)))\n            mstore(add(indicesEnd, w), mload(subject))\n            mstore(indices, add(mload(indices), 1))\n            for { let prevIndex := 0 } 1 {} {\n                let index := mload(indexPtr)\n                mstore(indexPtr, 0x60)\n                if iszero(eq(index, prevIndex)) {\n                    let element := mload(0x40)\n                    let l := sub(index, prevIndex)\n                    mstore(element, l) // Store the length of the element.\n                    // Copy the `subject` one word at a time, backwards.\n                    for { let o := and(add(l, 0x1f), w) } 1 {} {\n                        mstore(add(element, o), mload(add(add(subject, prevIndex), o)))\n                        o := add(o, w) // `sub(o, 0x20)`.\n                        if iszero(o) { break }\n                    }\n                    mstore(add(add(element, 0x20), l), 0) // Zeroize the slot after the bytes.\n                    // Allocate memory for the length and the bytes, rounded up to a multiple of 32.\n                    mstore(0x40, add(element, and(add(l, 0x3f), w)))\n                    mstore(indexPtr, element) // Store the `element` into the array.\n                }\n                prevIndex := add(index, mload(delimiter))\n                indexPtr := add(indexPtr, 0x20)\n                if iszero(lt(indexPtr, indicesEnd)) { break }\n            }\n            result := indices\n            if iszero(mload(delimiter)) {\n                result := add(indices, 0x20)\n                mstore(result, sub(mload(indices), 2))\n            }\n        }\n    }",
            "start": "516",
            "end": "557",
            "class": "LibBytes",
            "signature": "returns (bytes[] memory result) splitbytes memory subject, bytes memory delimiter",
            "full_signature": "function split(bytes memory subject, bytes memory delimiter) internal  pure returns (bytes[] memory result)",
            "class_method_signature": "LibBytes.splitbytes memory subject, bytes memory delimiter",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Splits a byte array (`subject`) into multiple byte arrays using a delimiter (`delimiter`).\n * @dev This function uses low-level assembly to efficiently split the byte array.\n *\n * Steps:\n * 1. Find all indices of the delimiter in the subject byte array.\n * 2. Use assembly to:\n *    - Prepare pointers and memory for processing.\n *    - Iterate through the indices to split the subject into sub-arrays.\n *    - Store each sub-array in memory and manage memory allocation.\n *    - Handle edge cases where the delimiter is empty.\n * 3. Return the resulting array of byte arrays.\n *\n * @param subject The byte array to be split.\n * @param delimiter The byte array used as the delimiter for splitting.\n * @return result An array of byte arrays resulting from the split operation.\n */"
        },
        {
            "identifier": "eq",
            "parameters": "bytes memory a, bytes memory b",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function eq(bytes memory a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }",
            "start": "590",
            "end": "595",
            "class": "LibBytes",
            "signature": "returns (bool result) eqbytes memory a, bytes memory b",
            "full_signature": "function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)",
            "class_method_signature": "LibBytes.eqbytes memory a, bytes memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Compares two byte arrays for equality.\n *\n * Steps:\n * 1. Uses inline assembly to compute the Keccak-256 hash of both byte arrays.\n * 2. Compares the hashes to determine if the byte arrays are equal.\n * 3. Returns `true` if the hashes match, otherwise `false`.\n */"
        },
        {
            "identifier": "endsWith",
            "parameters": "bytes memory subject, bytes memory needle",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function endsWith(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(needle)\n            let notInRange := gt(n, mload(subject))\n            // `subject + 0x20 + max(subject.length - needle.length, 0)`.\n            let t := add(add(subject, 0x20), mul(iszero(notInRange), sub(mload(subject), n)))\n            // Just using keccak256 directly is actually cheaper.\n            result := gt(eq(keccak256(t, n), keccak256(add(needle, 0x20), n)), notInRange)\n        }\n    }",
            "start": "320",
            "end": "334",
            "class": "LibBytes",
            "signature": "returns (bool result) endsWithbytes memory subject, bytes memory needle",
            "full_signature": "function endsWith(bytes memory subject, bytes memory needle) internal  pure returns (bool result)",
            "class_method_signature": "LibBytes.endsWithbytes memory subject, bytes memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a byte array (`subject`) ends with another byte array (`needle`).\n *\n * Steps:\n * 1. Load the length of the `needle` byte array.\n * 2. Check if the `needle` length is greater than the `subject` length.\n * 3. Calculate the starting position in `subject` to compare with `needle`.\n * 4. Use keccak256 to hash the relevant parts of `subject` and `needle`.\n * 5. Compare the hashes and return `true` if they match and `needle` is not longer than `subject`.\n *\n * @param subject The byte array to check.\n * @param needle The byte array to compare against the end of `subject`.\n * @return result `true` if `subject` ends with `needle`, otherwise `false`.\n */"
        },
        {
            "identifier": "setCalldata",
            "parameters": "BytesStorage storage $, bytes calldata s",
            "modifiers": "",
            "return": "",
            "body": "function setCalldata(BytesStorage storage $, bytes calldata s) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := or(0xff, shl(8, s.length))\n            for { let i := 0 } 1 {} {\n                if iszero(gt(s.length, 0xfe)) {\n                    i := 0x1f\n                    packed := or(s.length, shl(8, shr(8, calldataload(s.offset))))\n                    if iszero(gt(s.length, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    sstore(add(p, shr(5, i)), calldataload(add(s.offset, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, s.length)) { break }\n                }\n                break\n            }\n            sstore($.slot, packed)\n        }\n    }",
            "start": "55",
            "end": "75",
            "class": "LibBytes",
            "signature": " setCalldataBytesStorage storage $, bytes calldata s",
            "full_signature": "function setCalldata(BytesStorage storage $, bytes calldata s) internal",
            "class_method_signature": "LibBytes.setCalldataBytesStorage storage $, bytes calldata s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sets the calldata for a BytesStorage struct.\n *\n * @dev This function uses low-level assembly to efficiently store the calldata.\n * It handles the storage of the length and the actual data in a packed format.\n *\n * Steps:\n * 1. Pack the length of the calldata with a specific mask (0xff).\n * 2. If the length is less than or equal to 0xfe, store the length and the first 32 bytes of the calldata.\n * 3. If the length is greater than 0xfe, store the data in chunks of 32 bytes using the storage slot.\n * 4. Store the packed length and data in the storage slot.\n */"
        },
        {
            "identifier": "isEmpty",
            "parameters": "BytesStorage storage $",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function isEmpty(BytesStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }",
            "start": "83",
            "end": "85",
            "class": "LibBytes",
            "signature": "returns (bool) isEmptyBytesStorage storage $",
            "full_signature": "function isEmpty(BytesStorage storage $) internal  view returns (bool)",
            "class_method_signature": "LibBytes.isEmptyBytesStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the BytesStorage is empty.\n * @dev The function checks the first byte of the storage spacer to determine if it is empty.\n * @param $ The BytesStorage instance to check.\n * @return bool Returns true if the BytesStorage is empty, otherwise false.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "bytes memory subject, bytes memory needle",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function indexOf(bytes memory subject, bytes memory needle) internal pure returns (uint256) {\n        return indexOf(subject, needle, 0);\n    }",
            "start": "247",
            "end": "249",
            "class": "LibBytes",
            "signature": "returns (uint256) indexOfbytes memory subject, bytes memory needle",
            "full_signature": "function indexOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256)",
            "class_method_signature": "LibBytes.indexOfbytes memory subject, bytes memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Finds the index of the first occurrence of `needle` in `subject`.\n * @dev This is an internal pure function that searches for the `needle` byte array within the `subject` byte array.\n * @param subject The byte array to search within.\n * @param needle The byte array to search for.\n * @return The index of the first occurrence of `needle` in `subject`. If not found, returns 0.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "BytesStorage storage $",
            "modifiers": "",
            "return": "",
            "body": "function clear(BytesStorage storage $) internal {\n        delete $._spacer;\n    }",
            "start": "78",
            "end": "80",
            "class": "LibBytes",
            "signature": " clearBytesStorage storage $",
            "full_signature": "function clear(BytesStorage storage $) internal",
            "class_method_signature": "LibBytes.clearBytesStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Clears the storage of the BytesStorage struct by deleting the `_spacer` field.  \n *  \n * @param $ The BytesStorage struct whose `_spacer` field will be deleted.  \n */  "
        },
        {
            "identifier": "indicesOf",
            "parameters": "bytes memory subject, bytes memory needle",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function indicesOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let searchLen := mload(needle)\n            if iszero(gt(searchLen, mload(subject))) {\n                result := mload(0x40)\n                let i := add(subject, 0x20)\n                let o := add(result, 0x20)\n                let subjectSearchEnd := add(sub(add(i, mload(subject)), searchLen), 1)\n                let h := 0 // The hash of `needle`.\n                if iszero(lt(searchLen, 0x20)) { h := keccak256(add(needle, 0x20), searchLen) }\n                let s := mload(add(needle, 0x20))\n                for { let m := shl(3, sub(0x20, and(searchLen, 0x1f))) } 1 {} {\n                    let t := mload(i)\n                    // Whether the first `searchLen % 32` bytes of `subject` and `needle` matches.\n                    if iszero(shr(m, xor(t, s))) {\n                        if h {\n                            if iszero(eq(keccak256(i, searchLen), h)) {\n                                i := add(i, 1)\n                                if iszero(lt(i, subjectSearchEnd)) { break }\n                                continue\n                            }\n                        }\n                        mstore(o, sub(i, add(subject, 0x20))) // Append to `result`.\n                        o := add(o, 0x20)\n                        i := add(i, searchLen) // Advance `i` by `searchLen`.\n                        if searchLen {\n                            if iszero(lt(i, subjectSearchEnd)) { break }\n                            continue\n                        }\n                    }\n                    i := add(i, 1)\n                    if iszero(lt(i, subjectSearchEnd)) { break }\n                }\n                mstore(result, shr(5, sub(o, add(result, 0x20)))) // Store the length of `result`.\n                // Allocate memory for result.\n                // We allocate one more word, so this array can be recycled for {split}.\n                mstore(0x40, add(o, 0x20))\n            }\n        }\n    }",
            "start": "469",
            "end": "513",
            "class": "LibBytes",
            "signature": "returns (uint256[] memory result) indicesOfbytes memory subject, bytes memory needle",
            "full_signature": "function indicesOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "LibBytes.indicesOfbytes memory subject, bytes memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Finds the indices of all occurrences of `needle` within `subject`.\n * @dev This function uses low-level assembly for efficient memory manipulation.\n *\n * Steps:\n * 1. Load the length of `needle` and check if it is greater than the length of `subject`.\n * 2. If `needle` is not longer than `subject`, prepare memory for the result.\n * 3. Initialize pointers for `subject`, `result`, and the end of the search range.\n * 4. Compute the hash of `needle` if its length is 32 bytes or more.\n * 5. Iterate through `subject` to find matches with `needle`:\n *    - Compare the first `searchLen % 32` bytes of `subject` and `needle`.\n *    - If a match is found, append the index to `result`.\n *    - Advance the pointer by `searchLen` if a match is found.\n * 6. Store the length of `result` and allocate memory for the result array.\n * 7. Return the array of indices.\n */"
        },
        {
            "identifier": "NOT_FOUND",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant NOT_FOUND = type(uint256).max;",
            "start": "23",
            "end": "23",
            "class": "LibBytes",
            "signature": "uint256 NOT_FOUND",
            "full_signature": "uint256 internal constant NOT_FOUND",
            "class_method_signature": "LibBytes.NOT_FOUND",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the maximum value of a uint256, used to indicate a \"not found\" state.\n */"
        },
        {
            "identifier": "eqs",
            "parameters": "bytes memory a, bytes32 b",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function eqs(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }",
            "start": "598",
            "end": "613",
            "class": "LibBytes",
            "signature": "returns (bool result) eqsbytes memory a, bytes32 b",
            "full_signature": "function eqs(bytes memory a, bytes32 b) internal  pure returns (bool result)",
            "class_method_signature": "LibBytes.eqsbytes memory a, bytes32 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Compares a bytes array with a bytes32 value for equality.\n * @dev This function uses low-level assembly to perform the comparison efficiently.\n * \n * Steps:\n * 1. Compute a mask `m` to handle padding and alignment.\n * 2. Calculate `x` to determine the effective length of `b`.\n * 3. Use bitwise operations to compare the lengths and contents of `a` and `b`.\n * 4. Return `true` if the bytes array `a` matches the bytes32 value `b`, otherwise `false`.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "bytes memory subject, bytes memory needle",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lastIndexOf(bytes memory subject, bytes memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(subject, needle, type(uint256).max);\n    }",
            "start": "291",
            "end": "297",
            "class": "LibBytes",
            "signature": "returns (uint256) lastIndexOfbytes memory subject, bytes memory needle",
            "full_signature": "function lastIndexOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256)",
            "class_method_signature": "LibBytes.lastIndexOfbytes memory subject, bytes memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a `needle` byte sequence within a `subject` byte sequence.\n * @dev This function is a helper that calls the overloaded `lastIndexOf` function with the maximum possible index.\n * @param subject The byte sequence to search within.\n * @param needle The byte sequence to search for.\n * @return The last index of `needle` in `subject`, or `type(uint256).max` if not found.\n */"
        },
        {
            "identifier": "contains",
            "parameters": "bytes memory subject, bytes memory needle",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function contains(bytes memory subject, bytes memory needle) internal pure returns (bool) {\n        return indexOf(subject, needle) != NOT_FOUND;\n    }",
            "start": "300",
            "end": "302",
            "class": "LibBytes",
            "signature": "returns (bool) containsbytes memory subject, bytes memory needle",
            "full_signature": "function contains(bytes memory subject, bytes memory needle) internal  pure returns (bool)",
            "class_method_signature": "LibBytes.containsbytes memory subject, bytes memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a byte array (`needle`) is contained within another byte array (`subject`).\n * @param subject The byte array to search within.\n * @param needle The byte array to search for.\n * @return bool Returns `true` if `needle` is found within `subject`, otherwise `false`.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "bytes memory subject, bytes memory needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := not(0) // Initialize to `NOT_FOUND`.\n                let needleLen := mload(needle)\n                if gt(needleLen, mload(subject)) { break }\n                let w := result\n\n                let fromMax := sub(mload(subject), needleLen)\n                if iszero(gt(fromMax, from)) { from := fromMax }\n\n                let end := add(add(subject, 0x20), w)\n                subject := add(add(subject, 0x20), from)\n                if iszero(gt(subject, end)) { break }\n                // As this function is not too often used,\n                // we shall simply use keccak256 for smaller bytecode size.\n                for { let h := keccak256(add(needle, 0x20), needleLen) } 1 {} {\n                    if eq(keccak256(subject, needleLen), h) {\n                        result := sub(subject, add(end, 1))\n                        break\n                    }\n                    subject := add(subject, w) // `sub(subject, 1)`.\n                    if iszero(gt(subject, end)) { break }\n                }\n                break\n            }\n        }\n    }",
            "start": "254",
            "end": "286",
            "class": "LibBytes",
            "signature": "returns (uint256 result) lastIndexOfbytes memory subject, bytes memory needle, uint256 from",
            "full_signature": "function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from) internal  pure returns (uint256 result)",
            "class_method_signature": "LibBytes.lastIndexOfbytes memory subject, bytes memory needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a byte sequence (`needle`) within another byte sequence (`subject`), starting from a specified position (`from`).\n * \n * Steps:\n * 1. Initialize `result` to `NOT_FOUND` (represented by `not(0)`).\n * 2. Check if the length of `needle` is greater than the length of `subject`. If true, break and return `NOT_FOUND`.\n * 3. Calculate the maximum starting position (`fromMax`) to ensure the search does not exceed the bounds of `subject`.\n * 4. Adjust `from` to `fromMax` if `from` exceeds `fromMax`.\n * 5. Calculate the end position for the search.\n * 6. Use a loop to search for `needle` within `subject`:\n *    - Compute the hash of `needle` using `keccak256`.\n *    - Compare the hash of the current `subject` slice with the hash of `needle`.\n *    - If a match is found, update `result` to the current position and break.\n *    - Move the search window backward by one byte.\n *    - If the search window exceeds the bounds, break.\n * 7. Return the last index of `needle` within `subject` or `NOT_FOUND` if not found.\n */"
        },
        {
            "identifier": "get",
            "parameters": "BytesStorage storage $",
            "modifiers": "view",
            "return": "returns (bytes memory result)",
            "body": "function get(BytesStorage storage $) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let packed := sload($.slot)\n            let n := shr(8, packed)\n            for { let i := 0 } 1 {} {\n                if iszero(eq(or(packed, 0xff), packed)) {\n                    mstore(o, packed)\n                    n := and(0xff, packed)\n                    i := 0x1f\n                    if iszero(gt(n, i)) { break }\n                }\n                mstore(0x00, $.slot)\n                for { let p := keccak256(0x00, 0x20) } 1 {} {\n                    mstore(add(o, i), sload(add(p, shr(5, i))))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, n)) { break }\n                }\n                break\n            }\n            mstore(result, n) // Store the length of the memory.\n            mstore(add(o, n), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(o, n), 0x20)) // Allocate memory.\n        }\n    }",
            "start": "98",
            "end": "124",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) getBytesStorage storage $",
            "full_signature": "function get(BytesStorage storage $) internal  view returns (bytes memory result)",
            "class_method_signature": "LibBytes.getBytesStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the bytes stored in the `BytesStorage` struct.\n * @dev This function uses low-level assembly to efficiently read and return the stored bytes.\n *\n * Steps:\n * 1. Allocate memory for the result.\n * 2. Load the packed data from storage.\n * 3. Determine the length of the stored bytes.\n * 4. Iterate through the stored data, copying it into the allocated memory.\n * 5. Store the length of the bytes in memory.\n * 6. Zeroize the slot after the bytes to ensure no leftover data.\n * 7. Update the free memory pointer to allocate memory for the result.\n *\n * @param $ The `BytesStorage` struct containing the bytes to retrieve.\n * @return result The retrieved bytes stored in memory.\n */"
        },
        {
            "identifier": "repeat",
            "parameters": "bytes memory subject, uint256 times",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function repeat(bytes memory subject, uint256 times)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(or(iszero(times), iszero(l))) {\n                result := mload(0x40)\n                subject := add(subject, 0x20)\n                let o := add(result, 0x20)\n                for {} 1 {} {\n                    // Copy the `subject` one word at a time.\n                    for { let j := 0 } 1 {} {\n                        mstore(add(o, j), mload(add(subject, j)))\n                        j := add(j, 0x20)\n                        if iszero(lt(j, l)) { break }\n                    }\n                    o := add(o, l)\n                    times := sub(times, 1)\n                    if iszero(times) { break }\n                }\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            }\n        }\n    }",
            "start": "337",
            "end": "365",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) repeatbytes memory subject, uint256 times",
            "full_signature": "function repeat(bytes memory subject, uint256 times) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibBytes.repeatbytes memory subject, uint256 times",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Repeats the given `subject` bytes `times` number of times.\n * @dev This function uses low-level assembly to efficiently repeat the bytes.\n *\n * Steps:\n * 1. Load the length of the `subject` bytes.\n * 2. Check if either `times` or the length of `subject` is zero. If so, return an empty result.\n * 3. Allocate memory for the result.\n * 4. Adjust the `subject` pointer to skip the length prefix.\n * 5. Initialize the output pointer.\n * 6. Loop to copy the `subject` bytes `times` number of times:\n *    - Copy the `subject` bytes one word (32 bytes) at a time.\n *    - Update the output pointer after each copy.\n *    - Decrement `times` and break the loop if `times` reaches zero.\n * 7. Zeroize the slot after the bytes to ensure memory safety.\n * 8. Update the free memory pointer to allocate memory correctly.\n * 9. Store the length of the result in the first word of the result.\n *\n * @param subject The bytes to be repeated.\n * @param times The number of times to repeat the `subject`.\n * @return result The repeated bytes.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/MetadataReaderLib.sol": [
        {
            "identifier": "STRING_LIMIT_DEFAULT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant STRING_LIMIT_DEFAULT = 1000;",
            "start": "16",
            "end": "16",
            "class": "MetadataReaderLib",
            "signature": "uint256 STRING_LIMIT_DEFAULT",
            "full_signature": "uint256 internal constant STRING_LIMIT_DEFAULT",
            "class_method_signature": "MetadataReaderLib.STRING_LIMIT_DEFAULT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the default string length limit, set to 1000.\n */"
        },
        {
            "identifier": "_uint",
            "parameters": "address target, bytes32 ptr, uint256 gasStipend",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function _uint(address target, bytes32 ptr, uint256 gasStipend)\n        private\n        view\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                mul(\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x20, 0x20)\n                    )\n                )\n        }\n    }",
            "start": "188",
            "end": "204",
            "class": "MetadataReaderLib",
            "signature": "returns (uint256 result) _uintaddress target, bytes32 ptr, uint256 gasStipend",
            "full_signature": "function _uint(address target, bytes32 ptr, uint256 gasStipend) private  view returns (uint256 result)",
            "class_method_signature": "MetadataReaderLib._uintaddress target, bytes32 ptr, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private view function that performs a low-level static call to a target address and returns a uint256 result.\n *\n * @param target The address of the contract to call.\n * @param ptr The pointer to the memory location where the call data is stored.\n * @param gasStipend The amount of gas to stipend for the call.\n *\n * @return result The uint256 result of the static call.\n *\n * Steps:\n * 1. Perform a low-level static call to the target address using the provided gas stipend.\n * 2. Ensure that the call returns at least 32 bytes of data.\n * 3. Multiply the result by the value stored at memory location 0x20.\n * 4. Return the final result.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and gas optimization.\n */"
        },
        {
            "identifier": "_ptr",
            "parameters": "uint256 s",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function _ptr(uint256 s) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Layout the calldata in the scratch space for temporary usage.\n            mstore(0x04, s) // Store the function selector.\n            mstore(result, 4) // Store the length.\n        }\n    }",
            "start": "207",
            "end": "214",
            "class": "MetadataReaderLib",
            "signature": "returns (bytes32 result) _ptruint256 s",
            "full_signature": "function _ptr(uint256 s) private  pure returns (bytes32 result)",
            "class_method_signature": "MetadataReaderLib._ptruint256 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that manipulates memory to store a function selector and length.\n * \n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Store the provided uint256 value `s` at memory offset 0x04.\n * 3. Store the length (4 bytes) in the `result` variable.\n * \n * @param s The uint256 value to be stored in memory.\n * @return result A bytes32 value representing the length stored in memory.\n */"
        },
        {
            "identifier": "GAS_STIPEND_NO_GRIEF",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;",
            "start": "13",
            "end": "13",
            "class": "MetadataReaderLib",
            "signature": "uint256 GAS_STIPEND_NO_GRIEF",
            "full_signature": "uint256 internal constant GAS_STIPEND_NO_GRIEF",
            "class_method_signature": "MetadataReaderLib.GAS_STIPEND_NO_GRIEF",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the gas stipend to prevent griefing attacks.\n * This value is used to ensure that a minimum amount of gas is provided for certain operations.\n */"
        },
        {
            "identifier": "_ptr",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function _ptr(bytes memory data) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := data\n        }\n    }",
            "start": "217",
            "end": "222",
            "class": "MetadataReaderLib",
            "signature": "returns (bytes32 result) _ptrbytes memory data",
            "full_signature": "function _ptr(bytes memory data) private  pure returns (bytes32 result)",
            "class_method_signature": "MetadataReaderLib._ptrbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that returns the starting memory pointer of a bytes array.\n * \n * Steps:\n * 1. Use inline assembly to retrieve the memory pointer of the input `data` bytes array.\n * 2. Return the pointer as a `bytes32` value.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/MinHeapLib.sol": [
        {
            "identifier": "_set",
            "parameters": "Heap storage heap, uint256 value, uint256 maxLength, uint256 mode",
            "modifiers": "",
            "return": "returns (uint256 status, uint256 popped)",
            "body": "function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(heap.slot)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20) // Array storage slot offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is not full.\n                    if iszero(eq(n, maxLength)) {\n                        status := 1\n                        pos := n\n                        // Increment and update the length.\n                        sstore(heap.slot, add(pos, 1))\n                        childPos := sOffset\n                        break\n                    }\n                    let r := sload(sOffset)\n                    if iszero(lt(r, value)) { break }\n                    status := 3\n                    childPos := 1\n                    popped := r\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        sstore(heap.slot, n)\n                        // Set the `value` to the last item.\n                        value := sload(add(sOffset, n))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := sload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    sstore(heap.slot, add(pos, 1))\n                    childPos := sOffset\n                    break\n                }\n                // Mode: `pushPop`.\n                popped := value\n                if iszero(n) { break }\n                let r := sload(sOffset)\n                if iszero(lt(r, value)) { break }\n                popped := r\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := sload(add(sOffset, childPos))\n                let rightPos := add(childPos, 1)\n                let right := sload(add(sOffset, rightPos))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    right := child\n                    rightPos := childPos\n                }\n                sstore(add(sOffset, pos), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := sload(add(sOffset, parentPos))\n                if iszero(lt(value, parent)) { break }\n                sstore(add(sOffset, pos), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if add(childPos, 1) { sstore(add(sOffset, pos), value) }\n        }\n    }",
            "start": "348",
            "end": "441",
            "class": "MinHeapLib",
            "signature": "returns (uint256 status, uint256 popped) _setHeap storage heap, uint256 value, uint256 maxLength, uint256 mode",
            "full_signature": "function _set(Heap storage heap, uint256 value, uint256 maxLength, uint256 mode) private   returns (uint256 status, uint256 popped)",
            "class_method_signature": "MinHeapLib._setHeap storage heap, uint256 value, uint256 maxLength, uint256 mode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to manage heap operations such as enqueue, pop, replace, push, and pushPop.\n * \n * @param heap The heap storage reference.\n * @param value The value to be inserted or compared.\n * @param maxLength The maximum allowed length of the heap.\n * @param mode The operation mode:\n *              - 0: Enqueue (adds value to the heap if space is available).\n *              - 1: Pop (removes and returns the root value).\n *              - 2: Replace (replaces the root value with the given value).\n *              - 3: Push (adds value to the heap, ignoring maxLength).\n *              - 4: PushPop (adds value and immediately pops the smallest value).\n *\n * @return status The status of the operation:\n *              - 1: Successfully enqueued.\n *              - 3: Replaced the root value.\n *              - Other: Operation-specific status.\n * @return popped The value removed from the heap during pop or replace operations.\n *\n * Steps:\n * 1. Load the current length of the heap.\n * 2. Calculate the storage slot offset for the heap array.\n * 3. Perform operations based on the specified mode:\n *    - Enqueue: Add value if space is available, otherwise replace the smallest value.\n *    - Pop: Remove and return the root value.\n *    - Replace: Replace the root value with the given value.\n *    - Push: Add value to the heap, ignoring maxLength.\n *    - PushPop: Add value and immediately pop the smallest value.\n * 4. Perform sift-up and sift-down operations to maintain heap properties.\n * 5. Update the heap storage with the new value and return the operation status and popped value.\n */"
        },
        {
            "identifier": "bumpFreeMemoryPointer",
            "parameters": "",
            "modifiers": "pure",
            "return": "",
            "body": "function bumpFreeMemoryPointer() internal pure {\n        uint256 zero;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, zero)\n            mstore(0x40, add(m, 0x20))\n        }\n    }",
            "start": "332",
            "end": "340",
            "class": "MinHeapLib",
            "signature": " bumpFreeMemoryPointer",
            "full_signature": "function bumpFreeMemoryPointer() internal  pure",
            "class_method_signature": "MinHeapLib.bumpFreeMemoryPointer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Bumps the free memory pointer to allocate memory in Solidity.\n *\n * Steps:\n * 1. Declare a variable `zero` initialized to 0.\n * 2. Use inline assembly to:\n *    a. Load the current free memory pointer (0x40).\n *    b. Store the value of `zero` at the memory location pointed to by the free memory pointer.\n *    c. Update the free memory pointer by adding 0x20 (32 bytes) to the current memory location.\n *\n * This ensures that the free memory pointer is moved forward, preventing memory corruption.\n */"
        },
        {
            "identifier": "_set",
            "parameters": "MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode",
            "modifiers": "pure",
            "return": "returns (uint256 status, uint256 popped)",
            "body": "function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode)\n        private\n        pure\n        returns (uint256 status, uint256 popped)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let data := mload(heap)\n            let n := mload(data)\n            // Allocation / reallocation.\n            for {\n                let cap := not(mload(sub(data, 0x20)))\n                let prime := 204053801631428327883786711931463459222251954273621\n                cap := mul(iszero(mod(cap, prime)), div(cap, prime))\n            } iszero(lt(n, cap)) {} {\n                let newCap := add(add(cap, cap), shl(5, iszero(cap)))\n                if iszero(or(cap, iszero(n))) {\n                    for { cap := n } iszero(gt(newCap, n)) {} { newCap := add(newCap, newCap) }\n                }\n                mstore(mload(0x40), not(mul(newCap, prime))) // Update `heap.capacity`.\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                if cap {\n                    let w := not(0x1f)\n                    for { let i := shl(5, cap) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n                mstore(heap, m) // Update `heap.data`.\n                data := m\n                break\n            }\n            let sOffset := add(data, 0x20) // Array memory offset.\n            let pos := 0\n            let childPos := not(0)\n            // Operations are ordered from most likely usage to least likely usage.\n            for {} 1 {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            } {\n                // Mode: `enqueue`.\n                if iszero(mode) {\n                    if iszero(maxLength) { continue }\n                    // If queue is not full.\n                    if iszero(eq(n, maxLength)) {\n                        status := 1\n                        pos := n\n                        // Increment and update the length.\n                        mstore(data, add(pos, 1))\n                        childPos := 0xff0000000000000000\n                        break\n                    }\n                    if iszero(lt(mload(sOffset), value)) { break }\n                    status := 3\n                    childPos := 1\n                    popped := mload(sOffset)\n                    break\n                }\n                if iszero(gt(mode, 2)) {\n                    if iszero(n) { continue }\n                    // Mode: `pop`.\n                    if eq(mode, 2) {\n                        // Decrement and update the length.\n                        n := sub(n, 1)\n                        mstore(data, n)\n                        // Set the `value` to the last item.\n                        value := mload(add(sOffset, shl(5, n)))\n                        popped := value\n                        if iszero(n) { break }\n                    }\n                    // Mode: `replace`.\n                    popped := mload(sOffset)\n                    childPos := 1\n                    break\n                }\n                // Mode: `push`.\n                if eq(mode, 3) {\n                    // Increment and update the length.\n                    pos := n\n                    mstore(data, add(pos, 1))\n                    childPos := 0xff0000000000000000\n                    break\n                }\n                // Mode: `pushPop`.\n                if iszero(mul(n, lt(mload(sOffset), value))) {\n                    popped := value\n                    break\n                }\n                popped := mload(sOffset)\n                childPos := 1\n                break\n            }\n            // Siftup.\n            for {} lt(childPos, n) {} {\n                let child := mload(add(sOffset, shl(5, childPos)))\n                let rightPos := add(childPos, 1)\n                let right := mload(add(sOffset, shl(5, rightPos)))\n                if iszero(gt(lt(rightPos, n), lt(child, right))) {\n                    mstore(add(sOffset, shl(5, pos)), child)\n                    pos := childPos\n                    childPos := add(shl(1, pos), 1)\n                    continue\n                }\n                mstore(add(sOffset, shl(5, pos)), right)\n                pos := rightPos\n                childPos := add(shl(1, pos), 1)\n            }\n            // Siftdown.\n            for {} pos {} {\n                let parentPos := shr(1, sub(pos, 1))\n                let parent := mload(add(sOffset, shl(5, parentPos)))\n                if iszero(lt(value, parent)) { break }\n                mstore(add(sOffset, shl(5, pos)), parent)\n                pos := parentPos\n            }\n            // If `childPos` has been changed from `not(0)`.\n            if iszero(shr(128, childPos)) { mstore(add(sOffset, shl(5, pos)), value) }\n        }\n    }",
            "start": "445",
            "end": "566",
            "class": "MinHeapLib",
            "signature": "returns (uint256 status, uint256 popped) _setMemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode",
            "full_signature": "function _set(MemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode) private  pure returns (uint256 status, uint256 popped)",
            "class_method_signature": "MinHeapLib._setMemHeap memory heap, uint256 value, uint256 maxLength, uint256 mode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to manage operations on a memory heap, including enqueue, pop, replace, push, and pushPop.\n *\n * @param heap The memory heap structure to operate on.\n * @param value The value to be inserted or used in operations.\n * @param maxLength The maximum allowed length of the heap.\n * @param mode The operation mode:\n *             0: Enqueue\n *             1: Pop\n *             2: Replace\n *             3: Push\n *             4: PushPop\n *\n * @return status The status of the operation:\n *                1: Success (enqueue or push)\n *                3: Success with a popped value (replace or pushPop)\n * @return popped The value popped from the heap during replace or pushPop operations.\n *\n * Steps:\n * 1. Perform memory allocation or reallocation if necessary.\n * 2. Handle operations based on the mode:\n *    - Enqueue: Insert a value if the heap is not full.\n *    - Pop: Remove and return the top value.\n *    - Replace: Replace the top value with a new value.\n *    - Push: Insert a value at the end of the heap.\n *    - PushPop: Insert a value and pop the top value if the heap is full.\n * 3. Perform siftup and siftdown operations to maintain heap properties.\n * 4. Return the operation status and any popped value.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/SafeCastLib.sol": [
        {
            "identifier": "_revertOverflow",
            "parameters": "",
            "modifiers": "pure",
            "return": "",
            "body": "function _revertOverflow() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Store the function selector of `Overflow()`.\n            mstore(0x00, 0x35278d12)\n            // Revert with (offset, size).\n            revert(0x1c, 0x04)\n        }\n    }",
            "start": "568",
            "end": "576",
            "class": "SafeCastLib",
            "signature": " _revertOverflow",
            "full_signature": "function _revertOverflow() private  pure",
            "class_method_signature": "SafeCastLib._revertOverflow",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that reverts with an overflow error.\n *\n * Steps:\n * 1. Use inline assembly to store the function selector of `Overflow()` at memory location 0x00.\n * 2. Revert the transaction with the stored function selector, indicating an overflow error.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ECDSA.sol": [
        {
            "identifier": "_HALF_N_PLUS_1",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _HALF_N_PLUS_1 =\n        0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a1;",
            "start": "35",
            "end": "36",
            "class": "ECDSA",
            "signature": "uint256 _HALF_N_PLUS_1",
            "full_signature": "uint256 private constant _HALF_N_PLUS_1",
            "class_method_signature": "ECDSA._HALF_N_PLUS_1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a specific 256-bit value.\n * This value is likely used for cryptographic or mathematical operations.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EnumerableSetLib.sol": [
        {
            "identifier": "_toBytes32Set",
            "parameters": "Uint256Set storage s",
            "modifiers": "pure",
            "return": "returns (Bytes32Set storage c)",
            "body": "function _toBytes32Set(Uint256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }",
            "start": "701",
            "end": "706",
            "class": "EnumerableSetLib",
            "signature": "returns (Bytes32Set storage c) _toBytes32SetUint256Set storage s",
            "full_signature": "function _toBytes32Set(Uint256Set storage s) private  pure returns (Bytes32Set storage c)",
            "class_method_signature": "EnumerableSetLib._toBytes32SetUint256Set storage s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a Uint256Set storage reference to a Bytes32Set storage reference.\n * @dev This function uses inline assembly to directly assign the storage slot of the input set to the output set.\n * @param s The Uint256Set storage reference to be converted.\n * @return c The Bytes32Set storage reference with the same storage slot as the input set.\n */"
        },
        {
            "identifier": "_toBytes32Set",
            "parameters": "Int256Set storage s",
            "modifiers": "pure",
            "return": "returns (Bytes32Set storage c)",
            "body": "function _toBytes32Set(Int256Set storage s) private pure returns (Bytes32Set storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c.slot := s.slot\n        }\n    }",
            "start": "709",
            "end": "714",
            "class": "EnumerableSetLib",
            "signature": "returns (Bytes32Set storage c) _toBytes32SetInt256Set storage s",
            "full_signature": "function _toBytes32Set(Int256Set storage s) private  pure returns (Bytes32Set storage c)",
            "class_method_signature": "EnumerableSetLib._toBytes32SetInt256Set storage s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an Int256Set storage reference to a Bytes32Set storage reference.\n * \n * @dev This function uses inline assembly to directly assign the storage slot of the input set to the output set.\n * \n * @param s The Int256Set storage reference to be converted.\n * @return c The resulting Bytes32Set storage reference.\n */"
        },
        {
            "identifier": "_toInts",
            "parameters": "bytes32[] memory a",
            "modifiers": "pure",
            "return": "returns (int256[] memory c)",
            "body": "function _toInts(bytes32[] memory a) private pure returns (int256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }",
            "start": "725",
            "end": "730",
            "class": "EnumerableSetLib",
            "signature": "returns (int256[] memory c) _toIntsbytes32[] memory a",
            "full_signature": "function _toInts(bytes32[] memory a) private  pure returns (int256[] memory c)",
            "class_method_signature": "EnumerableSetLib._toIntsbytes32[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of `bytes32` to an array of `int256` using low-level assembly.\n * \n * @param a The input array of `bytes32` values.\n * @return c The resulting array of `int256` values.\n * \n * @dev This function uses inline assembly to directly reinterpret the memory layout of the input array.\n *      It assumes that the memory layout of `bytes32[]` is compatible with `int256[]`.\n */"
        },
        {
            "identifier": "_ENUMERABLE_ADDRESS_SET_SLOT_SEED",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _ENUMERABLE_ADDRESS_SET_SLOT_SEED = 0x978aab92;",
            "start": "46",
            "end": "46",
            "class": "EnumerableSetLib",
            "signature": "uint256 _ENUMERABLE_ADDRESS_SET_SLOT_SEED",
            "full_signature": "uint256 private constant _ENUMERABLE_ADDRESS_SET_SLOT_SEED",
            "class_method_signature": "EnumerableSetLib._ENUMERABLE_ADDRESS_SET_SLOT_SEED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the slot seed for an enumerable address set.\n * This value is used to calculate storage slots in a deterministic way, typically for\n * managing sets of addresses in a contract.\n */"
        },
        {
            "identifier": "_rootSlot",
            "parameters": "Bytes32Set storage s",
            "modifiers": "pure",
            "return": "returns (bytes32 r)",
            "body": "function _rootSlot(Bytes32Set storage s) private pure returns (bytes32 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _ENUMERABLE_WORD_SET_SLOT_SEED)\n            mstore(0x00, s.slot)\n            r := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "691",
            "end": "698",
            "class": "EnumerableSetLib",
            "signature": "returns (bytes32 r) _rootSlotBytes32Set storage s",
            "full_signature": "function _rootSlot(Bytes32Set storage s) private  pure returns (bytes32 r)",
            "class_method_signature": "EnumerableSetLib._rootSlotBytes32Set storage s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Computes the root slot for a given Bytes32Set storage.\n * \n * Steps:\n * 1. Store the predefined seed value `_ENUMERABLE_WORD_SET_SLOT_SEED` at memory offset 0x04.\n * 2. Store the slot of the Bytes32Set storage `s` at memory offset 0x00.\n * 3. Compute the keccak256 hash of the memory range from 0x00 to 0x24.\n * 4. Return the computed hash as the root slot.\n *\n * @dev This function is marked as `private` and `pure`, meaning it does not modify state and is only callable within the contract.\n */"
        },
        {
            "identifier": "_ENUMERABLE_WORD_SET_SLOT_SEED",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _ENUMERABLE_WORD_SET_SLOT_SEED = 0x18fb5864;",
            "start": "60",
            "end": "60",
            "class": "EnumerableSetLib",
            "signature": "uint256 _ENUMERABLE_WORD_SET_SLOT_SEED",
            "full_signature": "uint256 private constant _ENUMERABLE_WORD_SET_SLOT_SEED",
            "class_method_signature": "EnumerableSetLib._ENUMERABLE_WORD_SET_SLOT_SEED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the slot seed for an enumerable word set.\n * This is typically used in low-level storage manipulation or for generating unique storage slots.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibTransient.sol": [
        {
            "identifier": "_compat",
            "parameters": "TUint256 storage ptr",
            "modifiers": "pure",
            "return": "returns (TUint256 storage c)",
            "body": "function _compat(TUint256 storage ptr) private pure returns (TUint256 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "698",
            "end": "705",
            "class": "LibTransient",
            "signature": "returns (TUint256 storage c) _compatTUint256 storage ptr",
            "full_signature": "function _compat(TUint256 storage ptr) private  pure returns (TUint256 storage c)",
            "class_method_signature": "LibTransient._compatTUint256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a TUint256 storage pointer to a compatible format using inline assembly.\n * \n * Steps:\n * 1. Store the transient compatibility slot seed at memory offset 0x04.\n * 2. Store the slot of the input pointer at memory offset 0x00.\n * 3. Compute the keccak256 hash of the memory range 0x00 to 0x24.\n * 4. Assign the resulting hash as the slot for the compatible storage pointer.\n *\n * @param ptr The TUint256 storage pointer to be converted.\n * @return c The compatible TUint256 storage pointer.\n */"
        },
        {
            "identifier": "_compat",
            "parameters": "TBytes storage ptr",
            "modifiers": "pure",
            "return": "returns (TBytes storage c)",
            "body": "function _compat(TBytes storage ptr) private pure returns (TBytes storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "748",
            "end": "755",
            "class": "LibTransient",
            "signature": "returns (TBytes storage c) _compatTBytes storage ptr",
            "full_signature": "function _compat(TBytes storage ptr) private  pure returns (TBytes storage c)",
            "class_method_signature": "LibTransient._compatTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private function that converts a TBytes storage pointer to a compatible format.\n * \n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Store the _LIB_TRANSIENT_COMPAT_SLOT_SEED value at memory offset 0x04.\n * 3. Store the slot of the input TBytes storage pointer at memory offset 0x00.\n * 4. Compute the keccak256 hash of the memory range from 0x00 to 0x24.\n * 5. Assign the resulting hash to the slot of the output TBytes storage pointer.\n */"
        },
        {
            "identifier": "_compat",
            "parameters": "TAddress storage ptr",
            "modifiers": "pure",
            "return": "returns (TAddress storage c)",
            "body": "function _compat(TAddress storage ptr) private pure returns (TAddress storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "728",
            "end": "735",
            "class": "LibTransient",
            "signature": "returns (TAddress storage c) _compatTAddress storage ptr",
            "full_signature": "function _compat(TAddress storage ptr) private  pure returns (TAddress storage c)",
            "class_method_signature": "LibTransient._compatTAddress storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a given `TAddress` storage pointer into a compatible format.\n * \n * Steps:\n * 1. Uses inline assembly to perform the conversion.\n * 2. Stores the `_LIB_TRANSIENT_COMPAT_SLOT_SEED` value at memory offset 0x04.\n * 3. Stores the slot of the input pointer `ptr` at memory offset 0x00.\n * 4. Computes the keccak256 hash of the memory range 0x00 to 0x24.\n * 5. Assigns the resulting hash to the slot of the output pointer `c`.\n *\n * @dev This function is marked as `private pure` and uses assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "_compat",
            "parameters": "TBytes32 storage ptr",
            "modifiers": "pure",
            "return": "returns (TBytes32 storage c)",
            "body": "function _compat(TBytes32 storage ptr) private pure returns (TBytes32 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "718",
            "end": "725",
            "class": "LibTransient",
            "signature": "returns (TBytes32 storage c) _compatTBytes32 storage ptr",
            "full_signature": "function _compat(TBytes32 storage ptr) private  pure returns (TBytes32 storage c)",
            "class_method_signature": "LibTransient._compatTBytes32 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a TBytes32 storage pointer to a compatible storage pointer.\n * \n * Steps:\n * 1. Store the _LIB_TRANSIENT_COMPAT_SLOT_SEED value at memory location 0x04.\n * 2. Store the slot of the input pointer at memory location 0x00.\n * 3. Compute the keccak256 hash of the memory range 0x00 to 0x24.\n * 4. Assign the computed hash to the slot of the output pointer.\n * \n * @dev This function uses inline assembly for memory-safe operations.\n * @param ptr The input TBytes32 storage pointer.\n * @return c The compatible TBytes32 storage pointer.\n */"
        },
        {
            "identifier": "_LIB_TRANSIENT_COMPAT_SLOT_SEED",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _LIB_TRANSIENT_COMPAT_SLOT_SEED = 0x5a0b45f2;",
            "start": "52",
            "end": "52",
            "class": "LibTransient",
            "signature": "uint256 _LIB_TRANSIENT_COMPAT_SLOT_SEED",
            "full_signature": "uint256 private constant _LIB_TRANSIENT_COMPAT_SLOT_SEED",
            "class_method_signature": "LibTransient._LIB_TRANSIENT_COMPAT_SLOT_SEED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the seed for the transient compatibility slot.\n * This is used for internal storage or compatibility purposes within the contract.\n */"
        },
        {
            "identifier": "_compat",
            "parameters": "TInt256 storage ptr",
            "modifiers": "pure",
            "return": "returns (TInt256 storage c)",
            "body": "function _compat(TInt256 storage ptr) private pure returns (TInt256 storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "708",
            "end": "715",
            "class": "LibTransient",
            "signature": "returns (TInt256 storage c) _compatTInt256 storage ptr",
            "full_signature": "function _compat(TInt256 storage ptr) private  pure returns (TInt256 storage c)",
            "class_method_signature": "LibTransient._compatTInt256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private function that ensures compatibility for a TInt256 storage pointer.\n * \n * Steps:\n * 1. Use inline assembly to perform memory-safe operations.\n * 2. Store the `_LIB_TRANSIENT_COMPAT_SLOT_SEED` value at memory offset 0x04.\n * 3. Store the slot of the provided `ptr` at memory offset 0x00.\n * 4. Compute the keccak256 hash of the memory range 0x00 to 0x24.\n * 5. Assign the resulting hash to the slot of the returned `c` storage pointer.\n */"
        },
        {
            "identifier": "_compat",
            "parameters": "TBool storage ptr",
            "modifiers": "pure",
            "return": "returns (TBool storage c)",
            "body": "function _compat(TBool storage ptr) private pure returns (TBool storage c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x04, _LIB_TRANSIENT_COMPAT_SLOT_SEED)\n            mstore(0x00, ptr.slot)\n            c.slot := keccak256(0x00, 0x24)\n        }\n    }",
            "start": "738",
            "end": "745",
            "class": "LibTransient",
            "signature": "returns (TBool storage c) _compatTBool storage ptr",
            "full_signature": "function _compat(TBool storage ptr) private  pure returns (TBool storage c)",
            "class_method_signature": "LibTransient._compatTBool storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that computes the storage slot for a transient compatibility check.\n *\n * Steps:\n * 1. Store the transient compatibility slot seed at memory offset 0x04.\n * 2. Store the slot of the provided `ptr` at memory offset 0x00.\n * 3. Compute the keccak256 hash of the memory range [0x00, 0x24) to determine the storage slot for the compatibility check.\n * 4. Assign the computed slot to the return variable `c`.\n *\n * @dev This function uses inline assembly for low-level memory manipulation.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/JSONParserLib.sol": [
        {
            "identifier": "_BITMASK_TYPE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITMASK_TYPE = 7;",
            "start": "63",
            "end": "63",
            "class": "JSONParserLib",
            "signature": "uint256 _BITMASK_TYPE",
            "full_signature": "uint256 private constant _BITMASK_TYPE",
            "class_method_signature": "JSONParserLib._BITMASK_TYPE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a bitmask for type-related operations.\n * The value is set to 7, which corresponds to the binary `0111`.\n * This bitmask can be used to extract or manipulate specific bits in a uint256 value.\n */"
        },
        {
            "identifier": "_CHILDREN_INITED",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _CHILDREN_INITED = 1 << 5;",
            "start": "66",
            "end": "66",
            "class": "JSONParserLib",
            "signature": "uint256 _CHILDREN_INITED",
            "full_signature": "uint256 private constant _CHILDREN_INITED",
            "class_method_signature": "JSONParserLib._CHILDREN_INITED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a bitmask for the initialization state of children.\n * The value is set to `1 << 5`, which is equivalent to 32 in decimal.\n * This constant is likely used to track or check the initialization status of child components or elements.\n */"
        },
        {
            "identifier": "_query",
            "parameters": "bytes32 input, uint256 mode",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function _query(bytes32 input, uint256 mode) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            function skipWhitespace(pIn_, end_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(and(shr(chr(_pOut), 0x100002600), 1)) { leave } // Not in ' \\n\\r\\t'.\n                }\n            }\n\n            function setP(packed_, bitpos_, p_) -> _packed {\n                // Perform an out-of-gas revert if `p_` exceeds `_BITMASK_POINTER`.\n                returndatacopy(returndatasize(), returndatasize(), gt(p_, _BITMASK_POINTER))\n                _packed := or(and(not(shl(bitpos_, _BITMASK_POINTER)), packed_), shl(bitpos_, p_))\n            }\n\n            function getP(packed_, bitpos_) -> _p {\n                _p := and(_BITMASK_POINTER, shr(bitpos_, packed_))\n            }\n\n            function mallocItem(s_, packed_, pStart_, pCurr_, type_) -> _item {\n                _item := mload(0x40)\n                // forgefmt: disable-next-item\n                packed_ := setP(setP(packed_, _BITPOS_VALUE, sub(pStart_, add(s_, 0x20))),\n                    _BITPOS_VALUE_LENGTH, sub(pCurr_, pStart_))\n                mstore(_item, or(packed_, type_))\n                mstore(0x40, add(_item, 0x20)) // Allocate memory.\n            }\n\n            function parseValue(s_, sibling_, pIn_, end_) -> _item, _pOut {\n                let packed_ := setP(mload(0x00), _BITPOS_SIBLING_OR_PARENT, sibling_)\n                _pOut := skipWhitespace(pIn_, end_)\n                if iszero(lt(_pOut, end_)) { leave }\n                for { let c_ := chr(_pOut) } 1 {} {\n                    // If starts with '\"'.\n                    if eq(c_, 34) {\n                        let pStart_ := _pOut\n                        _pOut := parseStringSub(s_, packed_, _pOut, end_)\n                        _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_STRING)\n                        break\n                    }\n                    // If starts with '['.\n                    if eq(c_, 91) {\n                        _item, _pOut := parseArray(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with '{'.\n                    if eq(c_, 123) {\n                        _item, _pOut := parseObject(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    // If starts with any in '0123456789-'.\n                    if and(shr(c_, shl(45, 0x1ff9)), 1) {\n                        _item, _pOut := parseNumber(s_, packed_, _pOut, end_)\n                        break\n                    }\n                    if iszero(gt(add(_pOut, 4), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(224, mload(_pOut))\n                        // 'true' in hex format.\n                        if eq(w_, 0x74727565) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                        // 'null' in hex format.\n                        if eq(w_, 0x6e756c6c) {\n                            _pOut := add(_pOut, 4)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_NULL)\n                            break\n                        }\n                    }\n                    if iszero(gt(add(_pOut, 5), end_)) {\n                        let pStart_ := _pOut\n                        let w_ := shr(216, mload(_pOut))\n                        // 'false' in hex format.\n                        if eq(w_, 0x66616c7365) {\n                            _pOut := add(_pOut, 5)\n                            _item := mallocItem(s_, packed_, pStart_, _pOut, TYPE_BOOLEAN)\n                            break\n                        }\n                    }\n                    fail()\n                    break\n                }\n                _pOut := skipWhitespace(_pOut, end_)\n            }\n\n            function parseArray(s_, packed_, pIn_, end_) -> _item, _pOut {\n                let j_ := 0\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 93) { break } // ']'.\n                    }\n                    _item, _pOut := parseValue(s_, _item, _pOut, end_)\n                    if _item {\n                        // forgefmt: disable-next-item\n                        mstore(_item, setP(or(_PARENT_IS_ARRAY, mload(_item)),\n                            _BITPOS_KEY, j_))\n                        j_ := add(j_, 1)\n                        let c_ := chr(_pOut)\n                        if eq(c_, 93) { break } // ']'.\n                        if eq(c_, 44) { continue } // ','.\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_ARRAY)\n            }\n\n            function parseObject(s_, packed_, pIn_, end_) -> _item, _pOut {\n                for { _pOut := add(pIn_, 1) } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(_pOut, end_)) { fail() }\n                    if iszero(_item) {\n                        _pOut := skipWhitespace(_pOut, end_)\n                        if eq(chr(_pOut), 125) { break } // '}'.\n                    }\n                    _pOut := skipWhitespace(_pOut, end_)\n                    let pKeyStart_ := _pOut\n                    let pKeyEnd_ := parseStringSub(s_, _item, _pOut, end_)\n                    _pOut := skipWhitespace(pKeyEnd_, end_)\n                    // If ':'.\n                    if eq(chr(_pOut), 58) {\n                        _item, _pOut := parseValue(s_, _item, add(_pOut, 1), end_)\n                        if _item {\n                            // forgefmt: disable-next-item\n                            mstore(_item, setP(setP(or(_PARENT_IS_OBJECT, mload(_item)),\n                                _BITPOS_KEY_LENGTH, sub(pKeyEnd_, pKeyStart_)),\n                                    _BITPOS_KEY, sub(pKeyStart_, add(s_, 0x20))))\n                            let c_ := chr(_pOut)\n                            if eq(c_, 125) { break } // '}'.\n                            if eq(c_, 44) { continue } // ','.\n                        }\n                    }\n                    _pOut := end_\n                }\n                _pOut := add(_pOut, 1)\n                packed_ := setP(packed_, _BITPOS_CHILD, _item)\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_OBJECT)\n            }\n\n            function checkStringU(p_, o_) {\n                // If not in '0123456789abcdefABCDEF', revert.\n                if iszero(and(shr(sub(chr(add(p_, o_)), 48), 0x7e0000007e03ff), 1)) { fail() }\n                if iszero(eq(o_, 5)) { checkStringU(p_, add(o_, 1)) }\n            }\n\n            function parseStringSub(s_, packed_, pIn_, end_) -> _pOut {\n                if iszero(lt(pIn_, end_)) { fail() }\n                for { _pOut := add(pIn_, 1) } 1 {} {\n                    let c_ := chr(_pOut)\n                    if eq(c_, 34) { break } // '\"'.\n                    // Not '\\'.\n                    if iszero(eq(c_, 92)) {\n                        _pOut := add(_pOut, 1)\n                        continue\n                    }\n                    c_ := chr(add(_pOut, 1))\n                    // '\"', '\\', '//', 'b', 'f', 'n', 'r', 't'.\n                    if and(shr(sub(c_, 34), 0x510110400000000002001), 1) {\n                        _pOut := add(_pOut, 2)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(c_, 117) {\n                        checkStringU(_pOut, 2)\n                        _pOut := add(_pOut, 6)\n                        continue\n                    }\n                    _pOut := end_\n                    break\n                }\n                if iszero(lt(_pOut, end_)) { fail() }\n                _pOut := add(_pOut, 1)\n            }\n\n            function skip0To9s(pIn_, end_, atLeastOne_) -> _pOut {\n                for { _pOut := pIn_ } 1 { _pOut := add(_pOut, 1) } {\n                    if iszero(lt(sub(chr(_pOut), 48), 10)) { break } // Not '0'..'9'.\n                }\n                if and(atLeastOne_, eq(pIn_, _pOut)) { fail() }\n            }\n\n            function parseNumber(s_, packed_, pIn_, end_) -> _item, _pOut {\n                _pOut := pIn_\n                if eq(chr(_pOut), 45) { _pOut := add(_pOut, 1) } // '-'.\n                if iszero(lt(sub(chr(_pOut), 48), 10)) { fail() } // Not '0'..'9'.\n                let c_ := chr(_pOut)\n                _pOut := add(_pOut, 1)\n                if iszero(eq(c_, 48)) { _pOut := skip0To9s(_pOut, end_, 0) } // Not '0'.\n                if eq(chr(_pOut), 46) { _pOut := skip0To9s(add(_pOut, 1), end_, 1) } // '.'.\n                let t_ := mload(_pOut)\n                // 'E', 'e'.\n                if eq(or(0x20, byte(0, t_)), 101) {\n                    // forgefmt: disable-next-item\n                    _pOut := skip0To9s(add(byte(sub(byte(1, t_), 14), 0x010001), // '+', '-'.\n                        add(_pOut, 1)), end_, 1)\n                }\n                _item := mallocItem(s_, packed_, pIn_, _pOut, TYPE_NUMBER)\n            }\n\n            function copyStr(s_, offset_, len_) -> _sCopy {\n                _sCopy := mload(0x40)\n                s_ := add(s_, offset_)\n                let w_ := not(0x1f)\n                for { let i_ := and(add(len_, 0x1f), w_) } 1 {} {\n                    mstore(add(_sCopy, i_), mload(add(s_, i_)))\n                    i_ := add(i_, w_) // `sub(i_, 0x20)`.\n                    if iszero(i_) { break }\n                }\n                mstore(_sCopy, len_) // Copy the length.\n                mstore(add(add(_sCopy, 0x20), len_), 0) // Zeroize the last slot.\n                mstore(0x40, add(add(_sCopy, 0x40), len_)) // Allocate memory.\n            }\n\n            function value(item_) -> _value {\n                let packed_ := mload(item_)\n                _value := getP(packed_, _BITPOS_VALUE) // The offset in the string.\n                if iszero(and(_VALUE_INITED, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _value := copyStr(s_, _value, getP(packed_, _BITPOS_VALUE_LENGTH))\n                    packed_ := setP(packed_, _BITPOS_VALUE, _value)\n                    mstore(s_, or(_VALUE_INITED, packed_))\n                }\n            }\n\n            function children(item_) -> _arr {\n                _arr := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                for {} iszero(gt(and(_BITMASK_TYPE, packed_), TYPE_OBJECT)) {} {\n                    if or(iszero(packed_), iszero(item_)) { break }\n                    if and(packed_, _CHILDREN_INITED) {\n                        _arr := getP(packed_, _BITPOS_CHILD)\n                        break\n                    }\n                    _arr := mload(0x40)\n                    let o_ := add(_arr, 0x20)\n                    for { let h_ := getP(packed_, _BITPOS_CHILD) } h_ {} {\n                        mstore(o_, h_)\n                        let q_ := mload(h_)\n                        let y_ := getP(q_, _BITPOS_SIBLING_OR_PARENT)\n                        mstore(h_, setP(q_, _BITPOS_SIBLING_OR_PARENT, item_))\n                        h_ := y_\n                        o_ := add(o_, 0x20)\n                    }\n                    let w_ := not(0x1f)\n                    let n_ := add(w_, sub(o_, _arr))\n                    mstore(_arr, shr(5, n_))\n                    mstore(0x40, o_) // Allocate memory.\n                    packed_ := setP(packed_, _BITPOS_CHILD, _arr)\n                    mstore(item_, or(_CHILDREN_INITED, packed_))\n                    // Reverse the array.\n                    if iszero(lt(n_, 0x40)) {\n                        let lo_ := add(_arr, 0x20)\n                        let hi_ := add(_arr, n_)\n                        for {} 1 {} {\n                            let temp_ := mload(lo_)\n                            mstore(lo_, mload(hi_))\n                            mstore(hi_, temp_)\n                            hi_ := add(hi_, w_)\n                            lo_ := add(lo_, 0x20)\n                            if iszero(lt(lo_, hi_)) { break }\n                        }\n                    }\n                    break\n                }\n            }\n\n            function getStr(item_, bitpos_, bitposLength_, bitmaskInited_) -> _result {\n                _result := 0x60 // Initialize to the zero pointer.\n                let packed_ := mload(item_)\n                if or(iszero(item_), iszero(packed_)) { leave }\n                _result := getP(packed_, bitpos_)\n                if iszero(and(bitmaskInited_, packed_)) {\n                    let s_ := getP(packed_, _BITPOS_STRING)\n                    _result := copyStr(s_, _result, getP(packed_, bitposLength_))\n                    mstore(item_, or(bitmaskInited_, setP(packed_, bitpos_, _result)))\n                }\n            }\n\n            switch mode\n            // Get value.\n            case 0 { result := getStr(input, _BITPOS_VALUE, _BITPOS_VALUE_LENGTH, _VALUE_INITED) }\n            // Get key.\n            case 1 { result := getStr(input, _BITPOS_KEY, _BITPOS_KEY_LENGTH, _KEY_INITED) }\n            // Get children.\n            case 3 { result := children(input) }\n            // Parse.\n            default {\n                let p := add(input, 0x20)\n                let e := add(p, mload(input))\n                if iszero(eq(p, e)) {\n                    let c := chr(e)\n                    mstore8(e, 34) // Place a '\"' at the end to speed up parsing.\n                    // The `34 << 248` makes `mallocItem` preserve '\"' at the end.\n                    mstore(0x00, setP(shl(248, 34), _BITPOS_STRING, input))\n                    result, p := parseValue(input, 0, p, e)\n                    mstore8(e, c) // Restore the original char at the end.\n                }\n                if or(lt(p, e), iszero(result)) { fail() }\n            }\n        }\n    }",
            "start": "485",
            "end": "798",
            "class": "JSONParserLib",
            "signature": "returns (bytes32 result) _querybytes32 input, uint256 mode",
            "full_signature": "function _query(bytes32 input, uint256 mode) private  pure returns (bytes32 result)",
            "class_method_signature": "JSONParserLib._querybytes32 input, uint256 mode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "ate function `_query` that processes a bytes32 input based on the specified mode.\n *\n * Modes:\n * 0: Retrieves the value associated with the input.\n * 1: Retrieves the key associated with the input.\n * 3: Retrieves the children associated with the input.\n * Default: Parses the input as a JSON-like structure and returns the parsed result.\n *\n * The function uses low-level assembly for efficient memory manipulation and parsing.\n * It includes helper functions for parsing strings, arrays, objects, and numbers.\n * The function also handles memory allocation and error handling.\n *\n * Key Helper Functions:\n * - `fail()`: Reverts the transaction with a custom error message.\n * - `chr(p_)`: Retrieves the byte at a specific memory position.\n * - `skipWhitespace(pIn_, end_)`: Skips whitespace characters in the input.\n * - `setP(packed_, bitpos_, p_)`: Sets a pointer in a packed memory slot.\n * - `getP(packed_, bitpos_)`: Retrieves a pointer from a packed memory slot.\n * - `mallocItem(s_, packed_, pStart_, pCurr_, type_)`: Allocates memory for an item.\n * - `parseValue(s_, sibling_, pIn_, end_)`: Parses a value from the input.\n * - `parseArray(s_, packed_, pIn_, end_)`: Parses an array from the input.\n * - `parseObject(s_, packed_, pIn_, end_)`: Parses an object from the input.\n * - `checkStringU(p_, o_)`: Validates Unicode characters in a string.\n * - `parseStringSub(s_, packed_, pIn_, end_)`: Parses a substring.\n * - `skip0To9s(pIn_, end_, atLeastOne_)`: Skips numeric characters.\n * - `parseNumber(s_, packed_, pIn_, end_)`: Parses a number.\n * - `copyStr(s_, offset_, len_)`: Copies a string to a new memory location.\n * - `value(item_)`: Retrieves the value of an item.\n * - `children(item_)`: Retrieves the children of an item.\n * - `getStr(item_, bitpos_, bitposLength_, bitmaskInited_)`: Retrieves a string from an item.\n *\n * The function performs extensive memory manipulation and error checking to ensure\n * safe and efficient parsing of the input data.\n */"
        },
        {
            "identifier": "_toInput",
            "parameters": "Item memory input",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function _toInput(Item memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }",
            "start": "809",
            "end": "814",
            "class": "JSONParserLib",
            "signature": "returns (bytes32 result) _toInputItem memory input",
            "full_signature": "function _toInput(Item memory input) private  pure returns (bytes32 result)",
            "class_method_signature": "JSONParserLib._toInputItem memory input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an `Item` struct into a `bytes32` value.\n * @dev Uses inline assembly to directly convert the memory representation of the `Item` struct into a `bytes32` value.\n * @param input The `Item` struct to be converted.\n * @return result The resulting `bytes32` value.\n */"
        },
        {
            "identifier": "_BITPOS_STRING",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_STRING = 32 * 7 - 8;",
            "start": "55",
            "end": "55",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_STRING",
            "full_signature": "uint256 private constant _BITPOS_STRING",
            "class_method_signature": "JSONParserLib._BITPOS_STRING",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "tant representing the bit position for string data storage.\n * \n * This constant is calculated as `32 * 7 - 8`, which is used to determine the specific bit position\n * where string data is stored in a packed storage layout.\n */"
        },
        {
            "identifier": "_BITPOS_VALUE_LENGTH",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_VALUE_LENGTH = 32 * 4 - 8;",
            "start": "58",
            "end": "58",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_VALUE_LENGTH",
            "full_signature": "uint256 private constant _BITPOS_VALUE_LENGTH",
            "class_method_signature": "JSONParserLib._BITPOS_VALUE_LENGTH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the bit position for the length of a value.\n * The value is calculated as (32 * 4) - 8, which is 120.\n * This constant is likely used for bit manipulation or storage optimization.\n */"
        },
        {
            "identifier": "TYPE_UNDEFINED",
            "parameters": "",
            "modifiers": "",
            "return": "uint8",
            "body": "uint8 internal constant TYPE_UNDEFINED = 0;",
            "start": "23",
            "end": "23",
            "class": "JSONParserLib",
            "signature": "uint8 TYPE_UNDEFINED",
            "full_signature": "uint8 internal constant TYPE_UNDEFINED",
            "class_method_signature": "JSONParserLib.TYPE_UNDEFINED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing an undefined type, initialized to 0.\n */"
        },
        {
            "identifier": "_BITMASK_POINTER",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITMASK_POINTER = 0xffffffff;",
            "start": "62",
            "end": "62",
            "class": "JSONParserLib",
            "signature": "uint256 _BITMASK_POINTER",
            "full_signature": "uint256 private constant _BITMASK_POINTER",
            "class_method_signature": "JSONParserLib._BITMASK_POINTER",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a bitmask for a pointer.\n * The value is set to 0xffffffff, which is a 32-bit mask.\n */"
        },
        {
            "identifier": "_PARENT_IS_OBJECT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _PARENT_IS_OBJECT = 1 << 7;",
            "start": "68",
            "end": "68",
            "class": "JSONParserLib",
            "signature": "uint256 _PARENT_IS_OBJECT",
            "full_signature": "uint256 private constant _PARENT_IS_OBJECT",
            "class_method_signature": "JSONParserLib._PARENT_IS_OBJECT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a flag where the parent is an object.\n *         The value is set as 1 shifted left by 7 bits (i.e., 128 in decimal).\n */"
        },
        {
            "identifier": "_VALUE_INITED",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _VALUE_INITED = 1 << 4;",
            "start": "65",
            "end": "65",
            "class": "JSONParserLib",
            "signature": "uint256 _VALUE_INITED",
            "full_signature": "uint256 private constant _VALUE_INITED",
            "class_method_signature": "JSONParserLib._VALUE_INITED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a bitmask value initialized to 1 shifted left by 4 bits.\n * This is typically used for bitwise operations or to represent a specific state or flag.\n */"
        },
        {
            "identifier": "_PARENT_IS_ARRAY",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _PARENT_IS_ARRAY = 1 << 6;",
            "start": "67",
            "end": "67",
            "class": "JSONParserLib",
            "signature": "uint256 _PARENT_IS_ARRAY",
            "full_signature": "uint256 private constant _PARENT_IS_ARRAY",
            "class_method_signature": "JSONParserLib._PARENT_IS_ARRAY",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a flag for whether the parent is an array.\n *         The value is set as a bitmask with the 6th bit (1 << 6) enabled.\n */"
        },
        {
            "identifier": "_BITPOS_KEY_LENGTH",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_KEY_LENGTH = 32 * 6 - 8;",
            "start": "56",
            "end": "56",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_KEY_LENGTH",
            "full_signature": "uint256 private constant _BITPOS_KEY_LENGTH",
            "class_method_signature": "JSONParserLib._BITPOS_KEY_LENGTH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the bit position for the key length.\n * The value is calculated as (32 * 6) - 8, which results in 184.\n * This constant is used to determine the position of the key length within a bit field.\n */"
        },
        {
            "identifier": "_BITPOS_KEY",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_KEY = 32 * 5 - 8;",
            "start": "57",
            "end": "57",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_KEY",
            "full_signature": "uint256 private constant _BITPOS_KEY",
            "class_method_signature": "JSONParserLib._BITPOS_KEY",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant `_BITPOS_KEY` which represents the bit position of a key.\n * The value is calculated as `(32 * 5) - 8`, which results in 152.\n * This constant is likely used for bitwise operations or to define a specific position in a data structure.\n */"
        },
        {
            "identifier": "_BITPOS_VALUE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_VALUE = 32 * 3 - 8;",
            "start": "59",
            "end": "59",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_VALUE",
            "full_signature": "uint256 private constant _BITPOS_VALUE",
            "class_method_signature": "JSONParserLib._BITPOS_VALUE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the bit position for a specific value.\n * The value is calculated as (32 * 3 - 8), which is used for bitwise operations.\n */"
        },
        {
            "identifier": "_toInput",
            "parameters": "string memory input",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function _toInput(string memory input) private pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := input\n        }\n    }",
            "start": "801",
            "end": "806",
            "class": "JSONParserLib",
            "signature": "returns (bytes32 result) _toInputstring memory input",
            "full_signature": "function _toInput(string memory input) private  pure returns (bytes32 result)",
            "class_method_signature": "JSONParserLib._toInputstring memory input",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a string input into a bytes32 value.\n * @dev This function uses inline assembly to directly convert the string memory pointer to a bytes32 value.\n * @param input The string to be converted.\n * @return result The bytes32 representation of the input string.\n */"
        },
        {
            "identifier": "_KEY_INITED",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _KEY_INITED = 1 << 3;",
            "start": "64",
            "end": "64",
            "class": "JSONParserLib",
            "signature": "uint256 _KEY_INITED",
            "full_signature": "uint256 private constant _KEY_INITED",
            "class_method_signature": "JSONParserLib._KEY_INITED",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing a bitmask for initialization status.\n * The value is set as `1 << 3`, which corresponds to the binary value `00001000`.\n * This constant is likely used to check or set a specific bit in a bitmask or flag system.\n */"
        },
        {
            "identifier": "_BITPOS_CHILD",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_CHILD = 32 * 2 - 8;",
            "start": "60",
            "end": "60",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_CHILD",
            "full_signature": "uint256 private constant _BITPOS_CHILD",
            "class_method_signature": "JSONParserLib._BITPOS_CHILD",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "s a constant `_BITPOS_CHILD` which represents a specific bit position.\n * The value is calculated as `(32 * 2) - 8`, resulting in 56.\n * This constant is likely used for bitwise operations or to represent a specific position in a bitmask.\n */"
        },
        {
            "identifier": "_BITPOS_SIBLING_OR_PARENT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _BITPOS_SIBLING_OR_PARENT = 32 * 1 - 8;",
            "start": "61",
            "end": "61",
            "class": "JSONParserLib",
            "signature": "uint256 _BITPOS_SIBLING_OR_PARENT",
            "full_signature": "uint256 private constant _BITPOS_SIBLING_OR_PARENT",
            "class_method_signature": "JSONParserLib._BITPOS_SIBLING_OR_PARENT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the bit position for sibling or parent in a 32-byte word.\n *         The value is calculated as (32 * 1) - 8, which results in 24.\n *         This is typically used in bitwise operations to manipulate or extract specific bits.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibSort.sol": [
        {
            "identifier": "_toUints",
            "parameters": "bytes32[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory casted)",
            "body": "function _toUints(bytes32[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "start": "608",
            "end": "613",
            "class": "LibSort",
            "signature": "returns (uint256[] memory casted) _toUintsbytes32[] memory a",
            "full_signature": "function _toUints(bytes32[] memory a) private  pure returns (uint256[] memory casted)",
            "class_method_signature": "LibSort._toUintsbytes32[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of `bytes32` to an array of `uint256`.\n *\n * @param a The input array of `bytes32` values.\n * @return casted The resulting array of `uint256` values.\n *\n * @dev This function uses low-level assembly to perform the conversion efficiently.\n */"
        },
        {
            "identifier": "_toInts",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (int256[] memory casted)",
            "body": "function _toInts(uint256[] memory a) private pure returns (int256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "start": "616",
            "end": "621",
            "class": "LibSort",
            "signature": "returns (int256[] memory casted) _toIntsuint256[] memory a",
            "full_signature": "function _toInts(uint256[] memory a) private  pure returns (int256[] memory casted)",
            "class_method_signature": "LibSort._toIntsuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of `uint256` to an array of `int256` using low-level assembly.\n * \n * @param a The input array of `uint256` values.\n * @return casted The resulting array of `int256` values.\n * \n * @dev This function uses inline assembly to perform the conversion, which is memory-safe.\n */"
        },
        {
            "identifier": "_toUints",
            "parameters": "address[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory casted)",
            "body": "function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }",
            "start": "597",
            "end": "605",
            "class": "LibSort",
            "signature": "returns (uint256[] memory casted) _toUintsaddress[] memory a",
            "full_signature": "function _toUints(address[] memory a) private  pure returns (uint256[] memory casted)",
            "class_method_signature": "LibSort._toUintsaddress[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of addresses to an array of uint256.\n * @dev This function uses inline assembly to directly cast the address array to a uint256 array.\n *      Since Solidity ensures that the upper 96 bits of an address are zeroed when stored in memory,\n *      the addresses can be safely treated as uint256 values without additional manipulation.\n * @param a The input array of addresses to be converted.\n * @return casted The resulting array of uint256 values.\n */"
        },
        {
            "identifier": "_toBytes32s",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory casted)",
            "body": "function _toBytes32s(uint256[] memory a) private pure returns (bytes32[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "start": "632",
            "end": "637",
            "class": "LibSort",
            "signature": "returns (bytes32[] memory casted) _toBytes32suint256[] memory a",
            "full_signature": "function _toBytes32s(uint256[] memory a) private  pure returns (bytes32[] memory casted)",
            "class_method_signature": "LibSort._toBytes32suint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of uint256 values to an array of bytes32 values.\n * @dev This function uses inline assembly to perform the conversion efficiently.\n * @param a The input array of uint256 values.\n * @return casted The resulting array of bytes32 values.\n */"
        },
        {
            "identifier": "_toUints",
            "parameters": "int256[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory casted)",
            "body": "function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "start": "589",
            "end": "594",
            "class": "LibSort",
            "signature": "returns (uint256[] memory casted) _toUintsint256[] memory a",
            "full_signature": "function _toUints(int256[] memory a) private  pure returns (uint256[] memory casted)",
            "class_method_signature": "LibSort._toUintsint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of int256 to an array of uint256.\n * @dev Uses inline assembly to perform the conversion.\n * @param a The input array of int256 values.\n * @return casted The resulting array of uint256 values.\n */"
        },
        {
            "identifier": "_toAddresses",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (address[] memory casted)",
            "body": "function _toAddresses(uint256[] memory a) private pure returns (address[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "start": "624",
            "end": "629",
            "class": "LibSort",
            "signature": "returns (address[] memory casted) _toAddressesuint256[] memory a",
            "full_signature": "function _toAddresses(uint256[] memory a) private  pure returns (address[] memory casted)",
            "class_method_signature": "LibSort._toAddressesuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of uint256 values to an array of addresses.\n * @dev This function uses inline assembly to perform the conversion.\n * @param a The input array of uint256 values.\n * @return casted The resulting array of addresses.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DynamicArrayLib.sol": [
        {
            "identifier": "asBytes32Array",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory result)",
            "body": "function asBytes32Array(uint256[] memory a) internal pure returns (bytes32[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "162",
            "end": "167",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32[] memory result) asBytes32Arrayuint256[] memory a",
            "full_signature": "function asBytes32Array(uint256[] memory a) internal  pure returns (bytes32[] memory result)",
            "class_method_signature": "DynamicArrayLib.asBytes32Arrayuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of uint256 to an array of bytes32.\n * @dev This function uses inline assembly to directly reinterpret the memory layout of the input array.\n * @param a The input array of uint256 values.\n * @return result The resulting array of bytes32 values.\n */"
        },
        {
            "identifier": "popBool",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function popBool(DynamicArray memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "start": "658",
            "end": "666",
            "class": "DynamicArrayLib",
            "signature": "returns (bool result) popBoolDynamicArray memory a",
            "full_signature": "function popBool(DynamicArray memory a) internal  pure returns (bool result)",
            "class_method_signature": "DynamicArrayLib.popBoolDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Pops the last boolean element from a DynamicArray.\n *\n * Steps:\n * 1. Load the base pointer of the array.\n * 2. Load the current length of the array.\n * 3. Retrieve the last element by calculating its memory address.\n * 4. Decrement the array length by 1, ensuring it does not underflow.\n * 5. Return the popped boolean element.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n * @param a The DynamicArray from which to pop the last boolean element.\n * @return result The popped boolean element.\n */"
        },
        {
            "identifier": "toUint256Array",
            "parameters": "bool[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function toUint256Array(bool[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "178",
            "end": "183",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) toUint256Arraybool[] memory a",
            "full_signature": "function toUint256Array(bool[] memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.toUint256Arraybool[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a boolean array to a uint256 array.\n *\n * @param a The boolean array to be converted.\n * @return result The resulting uint256 array.\n *\n * @dev This function uses inline assembly to directly cast the boolean array to a uint256 array.\n *      The memory layout of boolean and uint256 arrays is compatible, allowing this direct conversion.\n */"
        },
        {
            "identifier": "_deallocate",
            "parameters": "DynamicArray memory result",
            "modifiers": "pure",
            "return": "",
            "body": "function _deallocate(DynamicArray memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }",
            "start": "972",
            "end": "977",
            "class": "DynamicArrayLib",
            "signature": " _deallocateDynamicArray memory result",
            "full_signature": "function _deallocate(DynamicArray memory result) private  pure",
            "class_method_signature": "DynamicArrayLib._deallocateDynamicArray memory result",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Deallocates memory for a DynamicArray.\n *\n * Steps:\n * 1. Use inline assembly to deallocate memory by updating the free memory pointer.\n * 2. The memory pointer is set to the address of the result, effectively deallocating the memory.\n */"
        },
        {
            "identifier": "toUint256Array",
            "parameters": "address[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function toUint256Array(address[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "170",
            "end": "175",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) toUint256Arrayaddress[] memory a",
            "full_signature": "function toUint256Array(address[] memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.toUint256Arrayaddress[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of addresses to an array of uint256.\n * @dev This function uses inline assembly to directly reinterpret the memory layout of the input array.\n * @param a The input array of addresses.\n * @return result The resulting array of uint256 values.\n */"
        },
        {
            "identifier": "asBoolArray",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (bool[] memory result)",
            "body": "function asBoolArray(uint256[] memory a) internal pure returns (bool[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "154",
            "end": "159",
            "class": "DynamicArrayLib",
            "signature": "returns (bool[] memory result) asBoolArrayuint256[] memory a",
            "full_signature": "function asBoolArray(uint256[] memory a) internal  pure returns (bool[] memory result)",
            "class_method_signature": "DynamicArrayLib.asBoolArrayuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of uint256 values into an array of boolean values.\n * @dev This function uses inline assembly to directly reinterpret the memory layout of the input array.\n * @param a The input array of uint256 values.\n * @return result The resulting array of boolean values, which shares the same memory as the input array.\n */"
        },
        {
            "identifier": "asUint256Array",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function asUint256Array(DynamicArray memory a)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "start": "777",
            "end": "786",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) asUint256ArrayDynamicArray memory a",
            "full_signature": "function asUint256Array(DynamicArray memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.asUint256ArrayDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a DynamicArray to a uint256 array.\n * \n * @param a The DynamicArray to be converted.\n * @return result The resulting uint256 array.\n * \n * @dev Uses inline assembly to load the uint256 array from the DynamicArray.\n */"
        },
        {
            "identifier": "popUint256",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function popUint256(DynamicArray memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "start": "634",
            "end": "642",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) popUint256DynamicArray memory a",
            "full_signature": "function popUint256(DynamicArray memory a) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.popUint256DynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Pops the last element from a DynamicArray of uint256.\n * \n * Steps:\n * 1. Load the base pointer of the array.\n * 2. Load the length of the array.\n * 3. Calculate the memory address of the last element.\n * 4. Load the value of the last element.\n * 5. Decrement the length of the array by 1, ensuring it does not underflow.\n * \n * @param a The DynamicArray from which to pop the last element.\n * @return result The value of the popped element.\n */"
        },
        {
            "identifier": "popAddress",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (address result)",
            "body": "function popAddress(DynamicArray memory a) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "start": "646",
            "end": "654",
            "class": "DynamicArrayLib",
            "signature": "returns (address result) popAddressDynamicArray memory a",
            "full_signature": "function popAddress(DynamicArray memory a) internal  pure returns (address result)",
            "class_method_signature": "DynamicArrayLib.popAddressDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Pops the last address from a dynamic array and returns it.\n *\n * Steps:\n * 1. Load the base pointer of the dynamic array.\n * 2. Load the length of the array.\n * 3. Calculate the memory address of the last element in the array.\n * 4. Retrieve the last address from the calculated memory address.\n * 5. Decrement the length of the array by 1, ensuring it does not underflow.\n *\n * @param a The dynamic array from which to pop the last address.\n * @return result The last address in the array.\n */"
        },
        {
            "identifier": "popBytes32",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function popBytes32(DynamicArray memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "start": "670",
            "end": "678",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32 result) popBytes32DynamicArray memory a",
            "full_signature": "function popBytes32(DynamicArray memory a) internal  pure returns (bytes32 result)",
            "class_method_signature": "DynamicArrayLib.popBytes32DynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Pops the last bytes32 element from a DynamicArray.\n *\n * Steps:\n * 1. Load the base pointer of the array from memory.\n * 2. Load the length of the array from the base pointer.\n * 3. Calculate the memory address of the last element in the array.\n * 4. Load the last element (bytes32) from the calculated address.\n * 5. Decrement the array length by 1, ensuring it does not underflow.\n *\n * @param a The DynamicArray from which to pop the last element.\n * @return result The last bytes32 element popped from the array.\n */"
        },
        {
            "identifier": "asBoolArray",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (bool[] memory result)",
            "body": "function asBoolArray(DynamicArray memory a) internal pure returns (bool[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "start": "801",
            "end": "806",
            "class": "DynamicArrayLib",
            "signature": "returns (bool[] memory result) asBoolArrayDynamicArray memory a",
            "full_signature": "function asBoolArray(DynamicArray memory a) internal  pure returns (bool[] memory result)",
            "class_method_signature": "DynamicArrayLib.asBoolArrayDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a DynamicArray into a bool array.\n *\n * Steps:\n * 1. Uses inline assembly to load the data from the DynamicArray.\n * 2. Returns the loaded data as a bool array.\n */"
        },
        {
            "identifier": "_toUint",
            "parameters": "bool b",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function _toUint(bool b) private pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(b))\n        }\n    }",
            "start": "980",
            "end": "985",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) _toUintbool b",
            "full_signature": "function _toUint(bool b) private  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib._toUintbool b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a boolean value to a uint256 representation.\n * @dev Uses inline assembly to perform the conversion efficiently.\n * @param b The boolean value to convert.\n * @return result The uint256 representation of the boolean (1 for true, 0 for false).\n */"
        },
        {
            "identifier": "asBytes32Array",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory result)",
            "body": "function asBytes32Array(DynamicArray memory a)\n        internal\n        pure\n        returns (bytes32[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "start": "809",
            "end": "818",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32[] memory result) asBytes32ArrayDynamicArray memory a",
            "full_signature": "function asBytes32Array(DynamicArray memory a) internal  pure returns (bytes32[] memory result)",
            "class_method_signature": "DynamicArrayLib.asBytes32ArrayDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a DynamicArray to a bytes32 array.\n *\n * Steps:\n * 1. Uses inline assembly to load the memory address of the DynamicArray.\n * 2. Returns the result as a bytes32 array.\n *\n * @param a The DynamicArray to be converted.\n * @return result The converted bytes32 array.\n */"
        },
        {
            "identifier": "asAddressArray",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (address[] memory result)",
            "body": "function asAddressArray(uint256[] memory a) internal pure returns (address[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "146",
            "end": "151",
            "class": "DynamicArrayLib",
            "signature": "returns (address[] memory result) asAddressArrayuint256[] memory a",
            "full_signature": "function asAddressArray(uint256[] memory a) internal  pure returns (address[] memory result)",
            "class_method_signature": "DynamicArrayLib.asAddressArrayuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 array into an address array.\n * @dev This function uses inline assembly to directly cast the input array to an address array.\n * @param a The input uint256 array to be converted.\n * @return result The resulting address array.\n */"
        },
        {
            "identifier": "asAddressArray",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (address[] memory result)",
            "body": "function asAddressArray(DynamicArray memory a)\n        internal\n        pure\n        returns (address[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(a)\n        }\n    }",
            "start": "789",
            "end": "798",
            "class": "DynamicArrayLib",
            "signature": "returns (address[] memory result) asAddressArrayDynamicArray memory a",
            "full_signature": "function asAddressArray(DynamicArray memory a) internal  pure returns (address[] memory result)",
            "class_method_signature": "DynamicArrayLib.asAddressArrayDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a DynamicArray to an address array.\n *\n * Steps:\n * 1. Takes a DynamicArray as input.\n * 2. Uses inline assembly to load the address array from the DynamicArray.\n * 3. Returns the resulting address array.\n */"
        },
        {
            "identifier": "toUint256Array",
            "parameters": "bytes32[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function toUint256Array(bytes32[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "186",
            "end": "191",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) toUint256Arraybytes32[] memory a",
            "full_signature": "function toUint256Array(bytes32[] memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.toUint256Arraybytes32[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of `bytes32` to an array of `uint256`.\n * @dev This function uses inline assembly to directly reinterpret the memory layout of the input array.\n * @param a The input array of `bytes32` values.\n * @return result The resulting array of `uint256` values.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/SafeTransferLib.sol": [
        {
            "identifier": "safeTransferAllFrom",
            "parameters": "address token, address from, address to",
            "modifiers": "",
            "return": "returns (uint256 amount)",
            "body": "function safeTransferAllFrom(address token, address from, address to)\n        internal\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x60, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, 0x23b872dd) // `transferFrom(address,address,uint256)`.\n            amount := mload(0x60) // The `amount` is already at 0x60. We'll need to return it.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "245",
            "end": "278",
            "class": "SafeTransferLib",
            "signature": "returns (uint256 amount) safeTransferAllFromaddress token, address from, address to",
            "full_signature": "function safeTransferAllFrom(address token, address from, address to) internal   returns (uint256 amount)",
            "class_method_signature": "SafeTransferLib.safeTransferAllFromaddress token, address from, address to",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers all tokens from one address to another.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the `to` argument in memory.\n * 3. Store the `from` argument in memory.\n * 4. Store the `balanceOf(address)` function selector in memory.\n *\n * 5. Read the balance of the `from` address, reverting if the call fails.\n * 6. If the balance read fails, revert with `TransferFromFailed()`.\n *\n * 7. Store the `transferFrom(address,address,uint256)` function selector in memory.\n * 8. Load the `amount` from memory (already at 0x60).\n *\n * 9. Perform the transfer, reverting if the call fails.\n * 10. If the transfer fails, check if the token contract exists and if the returndata size is valid.\n * 11. If the transfer still fails, revert with `TransferFromFailed()`.\n *\n * 12. Restore the zero slot to zero.\n * 13. Restore the free memory pointer.\n *\n * @param token The address of the token contract.\n * @param from The address from which tokens are transferred.\n * @param to The address to which tokens are transferred.\n * @return amount The amount of tokens transferred.\n */"
        },
        {
            "identifier": "safeApproveWithRetry",
            "parameters": "address token, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function safeApproveWithRetry(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            // Perform the approval, retrying upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x34, 0) // Store 0 for the `amount`.\n                    mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n                    pop(call(gas(), token, 0, 0x10, 0x44, codesize(), 0x00)) // Reset the approval.\n                    mstore(0x34, amount) // Store back the original `amount`.\n                    // Retry the approval, reverting upon failure.\n                    success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n                    if iszero(and(eq(mload(0x00), 1), success)) {\n                        // Check the `extcodesize` again just in case the token selfdestructs lol.\n                        if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                            mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                            revert(0x1c, 0x04)\n                        }\n                    }\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "start": "355",
            "end": "382",
            "class": "SafeTransferLib",
            "signature": " safeApproveWithRetryaddress token, address to, uint256 amount",
            "full_signature": "function safeApproveWithRetry(address token, address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.safeApproveWithRetryaddress token, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely approves a token transfer with a retry mechanism in case of failure.\n *\n * Steps:\n * 1. Store the `to` and `amount` arguments in memory.\n * 2. Store the `approve(address,uint256)` function selector in memory.\n * 3. Perform the approval call and check for success.\n * 4. If the initial call fails, check if the token contract exists and has a valid return size.\n * 5. Reset the approval by setting the `amount` to 0 and retry the approval call.\n * 6. If the retry fails, check the `extcodesize` again to ensure the token contract still exists.\n * 7. If the retry still fails, revert with an `ApproveFailed()` error.\n * 8. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "PERMIT2",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant PERMIT2 = 0x000000000022D473030F116dDEE9F6B43aC78BA3;",
            "start": "58",
            "end": "58",
            "class": "SafeTransferLib",
            "signature": "address PERMIT2",
            "full_signature": "address internal constant PERMIT2",
            "class_method_signature": "SafeTransferLib.PERMIT2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the PERMIT2 contract.\n * @dev The address is set to `0x000000000022D473030F116dDEE9F6B43aC78BA3`.\n */"
        },
        {
            "identifier": "TotalSupplyQueryFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error TotalSupplyQueryFailed();",
            "start": "29",
            "end": "29",
            "class": "SafeTransferLib",
            "signature": " TotalSupplyQueryFailed",
            "full_signature": "function TotalSupplyQueryFailed()",
            "class_method_signature": "SafeTransferLib.TotalSupplyQueryFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the query for total supply has failed.\n */"
        },
        {
            "identifier": "forceSafeTransferETH",
            "parameters": "address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function forceSafeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "start": "137",
            "end": "151",
            "class": "SafeTransferLib",
            "signature": " forceSafeTransferETHaddress to, uint256 amount",
            "full_signature": "function forceSafeTransferETH(address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.forceSafeTransferETHaddress to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to safely transfer ETH to a specified address.\n * \n * Steps:\n * 1. Check if the contract's balance is less than the specified amount.\n * 2. If true, revert with the error `ETHTransferFailed()`.\n * 3. Attempt to transfer the ETH using a low-level call with a gas stipend to prevent griefing.\n * 4. If the transfer fails:\n *    - Store the recipient address in scratch space.\n *    - Prepare opcodes for `PUSH20` and `SELFDESTRUCT`.\n *    - Attempt to create a new contract with the specified amount of ETH.\n *    - If creation fails, revert with an empty error.\n */"
        },
        {
            "identifier": "safeTransferAllETH",
            "parameters": "address to",
            "modifiers": "",
            "return": "",
            "body": "function safeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Transfer all the ETH and check if it succeeded or not.\n            if iszero(call(gas(), to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "95",
            "end": "104",
            "class": "SafeTransferLib",
            "signature": " safeTransferAllETHaddress to",
            "full_signature": "function safeTransferAllETH(address to) internal",
            "class_method_signature": "SafeTransferLib.safeTransferAllETHaddress to",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers all ETH from the contract to a specified address.\n * \n * Steps:\n * 1. Use inline assembly to perform a low-level call to transfer ETH.\n * 2. Check if the transfer was successful.\n * 3. If the transfer fails, revert with the error `ETHTransferFailed()`.\n */"
        },
        {
            "identifier": "safeTransfer",
            "parameters": "address token, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function safeTransfer(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "start": "282",
            "end": "298",
            "class": "SafeTransferLib",
            "signature": " safeTransferaddress token, address to, uint256 amount",
            "full_signature": "function safeTransfer(address token, address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.safeTransferaddress token, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers tokens from the contract to a specified address.\n *\n * Steps:\n * 1. Store the `to` address in memory at offset 0x14.\n * 2. Store the `amount` in memory at offset 0x34.\n * 3. Store the function selector for `transfer(address,uint256)` in memory at offset 0x00.\n *\n * 4. Perform a low-level call to the token contract to execute the transfer.\n * 5. Check if the transfer was successful by verifying the return data and the success flag.\n * 6. If the transfer fails, revert with the `TransferFailed()` error.\n *\n * 7. Restore the part of the free memory pointer that was overwritten.\n */"
        },
        {
            "identifier": "TransferFromFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error TransferFromFailed();",
            "start": "20",
            "end": "20",
            "class": "SafeTransferLib",
            "signature": " TransferFromFailed",
            "full_signature": "function TransferFromFailed()",
            "class_method_signature": "SafeTransferLib.TransferFromFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a transferFrom operation has failed.\n */"
        },
        {
            "identifier": "permit2TransferFrom",
            "parameters": "address token, address from, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function permit2TransferFrom(address token, address from, address to, uint256 amount)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(m, 0x74), shr(96, shl(96, token)))\n            mstore(add(m, 0x54), amount)\n            mstore(add(m, 0x34), to)\n            mstore(add(m, 0x20), shl(96, from))\n            // `transferFrom(address,address,uint160,address)`.\n            mstore(m, 0x36c78516000000000000000000000000)\n            let p := PERMIT2\n            let exists := eq(chainid(), 1)\n            if iszero(exists) { exists := iszero(iszero(extcodesize(p))) }\n            if iszero(\n                and(\n                    call(gas(), p, 0, add(m, 0x10), 0x84, codesize(), 0x00),\n                    lt(iszero(extcodesize(token)), exists) // Token has code and Permit2 exists.\n                )\n            ) {\n                mstore(0x00, 0x7939f4248757f0fd) // `TransferFromFailed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(iszero(shr(160, amount))))), 0x04)\n            }\n        }\n    }",
            "start": "431",
            "end": "456",
            "class": "SafeTransferLib",
            "signature": " permit2TransferFromaddress token, address from, address to, uint256 amount",
            "full_signature": "function permit2TransferFrom(address token, address from, address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.permit2TransferFromaddress token, address from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to handle token transfers using Permit2.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the token address, amount, recipient, and sender in memory.\n * 3. Prepare the function selector for `transferFrom(address,address,uint160,address)`.\n * 4. Check if the Permit2 contract exists on the current chain.\n * 5. If Permit2 exists, call the `transferFrom` function on the Permit2 contract.\n * 6. If the call fails or the token does not have code, revert with an appropriate error.\n * 7. Revert with `TransferFromFailed()` or `Permit2AmountOverflow()` if the transfer fails.\n */"
        },
        {
            "identifier": "WETH9",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant WETH9 = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;",
            "start": "53",
            "end": "53",
            "class": "SafeTransferLib",
            "signature": "address WETH9",
            "full_signature": "address internal constant WETH9",
            "class_method_signature": "SafeTransferLib.WETH9",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the address of the WETH9 token on the Ethereum mainnet.\n * WETH9 is the wrapped version of Ether (ETH) used in decentralized exchanges and smart contracts.\n */"
        },
        {
            "identifier": "Permit2Failed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error Permit2Failed();",
            "start": "32",
            "end": "32",
            "class": "SafeTransferLib",
            "signature": " Permit2Failed",
            "full_signature": "function Permit2Failed()",
            "class_method_signature": "SafeTransferLib.Permit2Failed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the Permit2 operation failed.\n */"
        },
        {
            "identifier": "ETHTransferFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ETHTransferFailed();",
            "start": "17",
            "end": "17",
            "class": "SafeTransferLib",
            "signature": " ETHTransferFailed",
            "full_signature": "function ETHTransferFailed()",
            "class_method_signature": "SafeTransferLib.ETHTransferFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that an ETH transfer has failed.\n */"
        },
        {
            "identifier": "safeApprove",
            "parameters": "address token, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function safeApprove(address token, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            mstore(0x00, 0x095ea7b3000000000000000000000000) // `approve(address,uint256)`.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x3e3f8f73) // `ApproveFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "start": "334",
            "end": "349",
            "class": "SafeTransferLib",
            "signature": " safeApproveaddress token, address to, uint256 amount",
            "full_signature": "function safeApprove(address token, address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.safeApproveaddress token, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely approves a token transfer by calling the `approve` function on the token contract.\n *\n * Steps:\n * 1. Store the `to` address in memory at position 0x14.\n * 2. Store the `amount` in memory at position 0x34.\n * 3. Store the `approve` function selector in memory at position 0x00.\n * 4. Perform a low-level call to the token contract to execute the `approve` function.\n * 5. Check if the call was successful and the return data is valid.\n * 6. If the call fails, revert with the `ApproveFailed` error.\n * 7. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "forceSafeTransferETH",
            "parameters": "address to, uint256 amount, uint256 gasStipend",
            "modifiers": "",
            "return": "",
            "body": "function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if lt(selfbalance(), amount) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(amount, 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "start": "107",
            "end": "121",
            "class": "SafeTransferLib",
            "signature": " forceSafeTransferETHaddress to, uint256 amount, uint256 gasStipend",
            "full_signature": "function forceSafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal",
            "class_method_signature": "SafeTransferLib.forceSafeTransferETHaddress to, uint256 amount, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to force a safe transfer of ETH to a specified address.\n * \n * Steps:\n * 1. Check if the contract's balance is less than the specified amount.\n *    - If true, revert with the error `ETHTransferFailed()`.\n * \n * 2. Attempt to transfer the specified amount of ETH to the target address using the provided gas stipend.\n *    - If the transfer fails:\n *      a. Store the target address in scratch space.\n *      b. Prepare opcodes for `PUSH20` and `SELFDESTRUCT`.\n *      c. Attempt to create a new contract with the specified amount of ETH, using the prepared opcodes.\n *      d. If the contract creation fails, revert with an empty error.\n * \n * @param to The address to which ETH will be transferred.\n * @param amount The amount of ETH to transfer.\n * @param gasStipend The gas stipend provided for the transfer.\n */"
        },
        {
            "identifier": "simplePermit2",
            "parameters": "address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "",
            "return": "",
            "body": "function simplePermit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, 0x927da105) // `allowance(address,address,address)`.\n            {\n                let addressMask := shr(96, not(0))\n                mstore(add(m, 0x20), and(addressMask, owner))\n                mstore(add(m, 0x40), and(addressMask, token))\n                mstore(add(m, 0x60), and(addressMask, spender))\n                mstore(add(m, 0xc0), and(addressMask, spender))\n            }\n            let p := mul(PERMIT2, iszero(shr(160, amount)))\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x5f), // Returns 3 words: `amount`, `expiration`, `nonce`.\n                    staticcall(gas(), p, add(m, 0x1c), 0x64, add(m, 0x60), 0x60)\n                )\n            ) {\n                mstore(0x00, 0x6b836e6b8757f0fd) // `Permit2Failed()` or `Permit2AmountOverflow()`.\n                revert(add(0x18, shl(2, iszero(p))), 0x04)\n            }\n            mstore(m, 0x2b67b570) // `Permit2.permit` (PermitSingle variant).\n            // `owner` is already `add(m, 0x20)`.\n            // `token` is already at `add(m, 0x40)`.\n            mstore(add(m, 0x60), amount)\n            mstore(add(m, 0x80), 0xffffffffffff) // `expiration = type(uint48).max`.\n            // `nonce` is already at `add(m, 0xa0)`.\n            // `spender` is already at `add(m, 0xc0)`.\n            mstore(add(m, 0xe0), deadline)\n            mstore(add(m, 0x100), 0x100) // `signature` offset.\n            mstore(add(m, 0x120), 0x41) // `signature` length.\n            mstore(add(m, 0x140), r)\n            mstore(add(m, 0x160), s)\n            mstore(add(m, 0x180), shl(248, v))\n            if iszero( // Revert if token does not have code, or if the call fails.\n            mul(extcodesize(token), call(gas(), p, 0, add(m, 0x1c), 0x184, codesize(), 0x00))) {\n                mstore(0x00, 0x6b836e6b) // `Permit2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "515",
            "end": "565",
            "class": "SafeTransferLib",
            "signature": " simplePermit2address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function simplePermit2(address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) internal",
            "class_method_signature": "SafeTransferLib.simplePermit2address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to handle a simplified version of the Permit2 approval mechanism.\n * \n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the function selector for `allowance(address,address,address)` in memory.\n * 3. Mask and store the `owner`, `token`, and `spender` addresses in memory.\n * 4. Calculate the Permit2 address based on the `amount` value.\n * 5. Perform a static call to the Permit2 contract to retrieve the allowance details.\n * 6. Revert if the call fails or if the returndata size is insufficient.\n * 7. Store the function selector for `Permit2.permit` (PermitSingle variant) in memory.\n * 8. Store the `amount`, `expiration`, `nonce`, `spender`, `deadline`, and `signature` details in memory.\n * 9. Perform a call to the Permit2 contract to execute the permit.\n * 10. Revert if the token does not have code or if the call fails.\n */"
        },
        {
            "identifier": "safeTransferETH",
            "parameters": "address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function safeTransferETH(address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "84",
            "end": "92",
            "class": "SafeTransferLib",
            "signature": " safeTransferETHaddress to, uint256 amount",
            "full_signature": "function safeTransferETH(address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.safeTransferETHaddress to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers ETH to a specified address.\n *\n * @dev This function uses low-level assembly to perform the ETH transfer.\n * If the transfer fails, it reverts with the error `ETHTransferFailed()`.\n *\n * Steps:\n * 1. Use assembly to call the `to` address with the specified `amount` of ETH.\n * 2. If the call fails, store the error selector `0xb12d13eb` (ETHTransferFailed) in memory.\n * 3. Revert with the error message.\n */"
        },
        {
            "identifier": "safeTransferAll",
            "parameters": "address token, address to",
            "modifiers": "",
            "return": "returns (uint256 amount)",
            "body": "function safeTransferAll(address token, address to) internal returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x70a08231) // Store the function selector of `balanceOf(address)`.\n            mstore(0x20, address()) // Store the address of the current contract.\n            // Read the balance, reverting upon failure.\n            if iszero(\n                and( // The arguments of `and` are evaluated from right to left.\n                    gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                    staticcall(gas(), token, 0x1c, 0x24, 0x34, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, to) // Store the `to` argument.\n            amount := mload(0x34) // The `amount` is already at 0x34. We'll need to return it.\n            mstore(0x00, 0xa9059cbb000000000000000000000000) // `transfer(address,uint256)`.\n            // Perform the transfer, reverting upon failure.\n            let success := call(gas(), token, 0, 0x10, 0x44, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x90b8ec18) // `TransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "start": "302",
            "end": "330",
            "class": "SafeTransferLib",
            "signature": "returns (uint256 amount) safeTransferAlladdress token, address to",
            "full_signature": "function safeTransferAll(address token, address to) internal   returns (uint256 amount)",
            "class_method_signature": "SafeTransferLib.safeTransferAlladdress token, address to",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers all tokens of a specific ERC20 token from the current contract to a specified address.\n * @dev Uses low-level assembly to interact with the ERC20 token contract directly.\n * \n * Steps:\n * 1. Store the function selector for `balanceOf(address)` in memory.\n * 2. Store the address of the current contract in memory.\n * 3. Perform a static call to retrieve the balance of the current contract.\n *    - Revert if the call fails or returns less than 32 bytes.\n * 4. Store the `to` address in memory.\n * 5. Load the retrieved balance into the `amount` variable.\n * 6. Store the function selector for `transfer(address,uint256)` in memory.\n * 7. Perform a call to transfer the tokens to the specified address.\n *    - Revert if the transfer fails or if the token contract does not return a success value.\n * 8. Restore the overwritten part of the free memory pointer.\n * \n * @param token The address of the ERC20 token to transfer.\n * @param to The address to which the tokens will be transferred.\n * @return amount The amount of tokens transferred.\n */"
        },
        {
            "identifier": "trySafeTransferAllETH",
            "parameters": "address to, uint256 gasStipend",
            "modifiers": "",
            "return": "returns (bool success)",
            "body": "function trySafeTransferAllETH(address to, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)\n        }\n    }",
            "start": "179",
            "end": "187",
            "class": "SafeTransferLib",
            "signature": "returns (bool success) trySafeTransferAllETHaddress to, uint256 gasStipend",
            "full_signature": "function trySafeTransferAllETH(address to, uint256 gasStipend) internal   returns (bool success)",
            "class_method_signature": "SafeTransferLib.trySafeTransferAllETHaddress to, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to safely transfer all ETH from the current contract to a specified address.\n * @dev Uses low-level assembly to perform the transfer, ensuring memory safety.\n * @param to The address to which the ETH will be transferred.\n * @param gasStipend The amount of gas to be provided for the transfer operation.\n * @return success A boolean indicating whether the transfer was successful.\n */"
        },
        {
            "identifier": "forceSafeTransferAllETH",
            "parameters": "address to, uint256 gasStipend",
            "modifiers": "",
            "return": "",
            "body": "function forceSafeTransferAllETH(address to, uint256 gasStipend) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gasStipend, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "start": "124",
            "end": "134",
            "class": "SafeTransferLib",
            "signature": " forceSafeTransferAllETHaddress to, uint256 gasStipend",
            "full_signature": "function forceSafeTransferAllETH(address to, uint256 gasStipend) internal",
            "class_method_signature": "SafeTransferLib.forceSafeTransferAllETHaddress to, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Transfers all ETH from the contract to the specified address with a gas stipend.\n * \n * Steps:\n * 1. Use inline assembly to perform a low-level call to transfer ETH.\n * 2. If the call fails, store the recipient address in scratch space.\n * 3. Prepare opcodes for `PUSH20` and `SELFDESTRUCT` in memory.\n * 4. Attempt to create a new contract with the remaining balance, using the prepared opcodes.\n * 5. If the creation fails, revert with the remaining gas.\n */"
        },
        {
            "identifier": "safeTransferFrom",
            "parameters": "address token, address from, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            let success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                if iszero(lt(or(iszero(extcodesize(token)), returndatasize()), success)) {\n                    mstore(0x00, 0x7939f424) // `TransferFromFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "198",
            "end": "216",
            "class": "SafeTransferLib",
            "signature": " safeTransferFromaddress token, address from, address to, uint256 amount",
            "full_signature": "function safeTransferFrom(address token, address from, address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.safeTransferFromaddress token, address from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers tokens from one address to another using low-level assembly.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the `amount` argument in memory.\n * 3. Store the `to` argument in memory.\n * 4. Store the `from` argument in memory.\n * 5. Store the function selector for `transferFrom(address,address,uint256)` in memory.\n * 6. Perform a low-level call to the token contract to execute the transfer.\n * 7. Check if the call was successful and the return data is valid.\n * 8. If the call fails, revert with the `TransferFromFailed()` error.\n * 9. Restore the zero slot to zero.\n * 10. Restore the free memory pointer.\n */"
        },
        {
            "identifier": "TransferFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error TransferFailed();",
            "start": "23",
            "end": "23",
            "class": "SafeTransferLib",
            "signature": " TransferFailed",
            "full_signature": "function TransferFailed()",
            "class_method_signature": "SafeTransferLib.TransferFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a transfer operation has failed.\n */"
        },
        {
            "identifier": "GAS_STIPEND_NO_GRIEF",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant GAS_STIPEND_NO_GRIEF = 100000;",
            "start": "46",
            "end": "46",
            "class": "SafeTransferLib",
            "signature": "uint256 GAS_STIPEND_NO_GRIEF",
            "full_signature": "uint256 internal constant GAS_STIPEND_NO_GRIEF",
            "class_method_signature": "SafeTransferLib.GAS_STIPEND_NO_GRIEF",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the gas stipend to prevent griefing attacks.\n * This value is used to ensure that a minimum amount of gas is provided for certain operations,\n * preventing potential denial-of-service attacks by limiting the gas consumption.\n */"
        },
        {
            "identifier": "totalSupply",
            "parameters": "address token",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function totalSupply(address token) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x18160ddd) // `totalSupply()`.\n            if iszero(\n                and(gt(returndatasize(), 0x1f), staticcall(gas(), token, 0x1c, 0x04, 0x00, 0x20))\n            ) {\n                mstore(0x00, 0x54cd9435) // `TotalSupplyQueryFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "start": "404",
            "end": "416",
            "class": "SafeTransferLib",
            "signature": "returns (uint256 result) totalSupplyaddress token",
            "full_signature": "function totalSupply(address token) internal  view returns (uint256 result)",
            "class_method_signature": "SafeTransferLib.totalSupplyaddress token",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the total supply of a given token using low-level assembly.\n *\n * Steps:\n * 1. Store the selector for the `totalSupply()` function in memory.\n * 2. Perform a static call to the token contract to retrieve the total supply.\n * 3. Check if the call was successful and the return data is valid.\n * 4. If the call fails, revert with the error `TotalSupplyQueryFailed()`.\n * 5. Load and return the total supply value from memory.\n */"
        },
        {
            "identifier": "safeTransferFrom2",
            "parameters": "address token, address from, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function safeTransferFrom2(address token, address from, address to, uint256 amount) internal {\n        if (!trySafeTransferFrom(token, from, to, amount)) {\n            permit2TransferFrom(token, from, to, amount);\n        }\n    }",
            "start": "423",
            "end": "427",
            "class": "SafeTransferLib",
            "signature": " safeTransferFrom2address token, address from, address to, uint256 amount",
            "full_signature": "function safeTransferFrom2(address token, address from, address to, uint256 amount) internal",
            "class_method_signature": "SafeTransferLib.safeTransferFrom2address token, address from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Safely transfers tokens from one address to another using either `trySafeTransferFrom` or `permit2TransferFrom`.\n *\n * Steps:\n * 1. Attempt to transfer tokens using `trySafeTransferFrom`.\n * 2. If the transfer fails, fallback to `permit2TransferFrom` to complete the transfer.\n *\n * @param token The address of the token to transfer.\n * @param from The address from which tokens are transferred.\n * @param to The address to which tokens are transferred.\n * @param amount The amount of tokens to transfer.\n */"
        },
        {
            "identifier": "GAS_STIPEND_NO_STORAGE_WRITES",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES = 2300;",
            "start": "42",
            "end": "42",
            "class": "SafeTransferLib",
            "signature": "uint256 GAS_STIPEND_NO_STORAGE_WRITES",
            "full_signature": "uint256 internal constant GAS_STIPEND_NO_STORAGE_WRITES",
            "class_method_signature": "SafeTransferLib.GAS_STIPEND_NO_STORAGE_WRITES",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the gas stipend for operations that do not involve storage writes.\n * @dev This value is typically used to estimate gas costs for operations that are read-only or do not modify state.\n */"
        },
        {
            "identifier": "permit2",
            "parameters": "address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "",
            "return": "",
            "body": "function permit2(\n        address token,\n        address owner,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        bool success;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} shl(96, xor(token, WETH9)) {} {\n                mstore(0x00, 0x3644e515) // `DOMAIN_SEPARATOR()`.\n                if iszero(\n                    and( // The arguments of `and` are evaluated from right to left.\n                        lt(iszero(mload(0x00)), eq(returndatasize(), 0x20)), // Returns 1 non-zero word.\n                        // Gas stipend to limit gas burn for tokens that don't refund gas when\n                        // an non-existing function is called. 5K should be enough for a SLOAD.\n                        staticcall(5000, token, 0x1c, 0x04, 0x00, 0x20)\n                    )\n                ) { break }\n                // After here, we can be sure that token is a contract.\n                let m := mload(0x40)\n                mstore(add(m, 0x34), spender)\n                mstore(add(m, 0x20), shl(96, owner))\n                mstore(add(m, 0x74), deadline)\n                if eq(mload(0x00), DAI_DOMAIN_SEPARATOR) {\n                    mstore(0x14, owner)\n                    mstore(0x00, 0x7ecebe00000000000000000000000000) // `nonces(address)`.\n                    mstore(add(m, 0x94), staticcall(gas(), token, 0x10, 0x24, add(m, 0x54), 0x20))\n                    mstore(m, 0x8fcbaf0c000000000000000000000000) // `IDAIPermit.permit`.\n                    // `nonces` is already at `add(m, 0x54)`.\n                    // `1` is already stored at `add(m, 0x94)`.\n                    mstore(add(m, 0xb4), and(0xff, v))\n                    mstore(add(m, 0xd4), r)\n                    mstore(add(m, 0xf4), s)\n                    success := call(gas(), token, 0, add(m, 0x10), 0x104, codesize(), 0x00)\n                    break\n                }\n                mstore(m, 0xd505accf000000000000000000000000) // `IERC20Permit.permit`.\n                mstore(add(m, 0x54), amount)\n                mstore(add(m, 0x94), and(0xff, v))\n                mstore(add(m, 0xb4), r)\n                mstore(add(m, 0xd4), s)\n                success := call(gas(), token, 0, add(m, 0x10), 0xe4, codesize(), 0x00)\n                break\n            }\n        }\n        if (!success) simplePermit2(token, owner, spender, amount, deadline, v, r, s);\n    }",
            "start": "461",
            "end": "512",
            "class": "SafeTransferLib",
            "signature": " permit2address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function permit2(address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) internal",
            "class_method_signature": "SafeTransferLib.permit2address token, address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to handle permit2 functionality for ERC20 tokens.\n *\n * Steps:\n * 1. Check if the token is a contract by verifying the DOMAIN_SEPARATOR.\n * 2. If the token is a contract, prepare the permit2 call data.\n * 3. If the token is DAI, use the DAI-specific permit function.\n * 4. If the token is not DAI, use the standard ERC20 permit function.\n * 5. Execute the permit2 call with the prepared data.\n * 6. If the permit2 call fails, fallback to a simpler permit2 implementation.\n *\n * @param token The address of the ERC20 token.\n * @param owner The address of the token owner.\n * @param spender The address of the spender.\n * @param amount The amount of tokens to permit.\n * @param deadline The deadline for the permit.\n * @param v The recovery byte of the signature.\n * @param r The first 32 bytes of the signature.\n * @param s The second 32 bytes of the signature.\n */"
        },
        {
            "identifier": "ApproveFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ApproveFailed();",
            "start": "26",
            "end": "26",
            "class": "SafeTransferLib",
            "signature": " ApproveFailed",
            "full_signature": "function ApproveFailed()",
            "class_method_signature": "SafeTransferLib.ApproveFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that an approval operation failed.\n */"
        },
        {
            "identifier": "trySafeTransferFrom",
            "parameters": "address token, address from, address to, uint256 amount",
            "modifiers": "",
            "return": "returns (bool success)",
            "body": "function trySafeTransferFrom(address token, address from, address to, uint256 amount)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, amount) // Store the `amount` argument.\n            mstore(0x40, to) // Store the `to` argument.\n            mstore(0x2c, shl(96, from)) // Store the `from` argument.\n            mstore(0x0c, 0x23b872dd000000000000000000000000) // `transferFrom(address,address,uint256)`.\n            success := call(gas(), token, 0, 0x1c, 0x64, 0x00, 0x20)\n            if iszero(and(eq(mload(0x00), 1), success)) {\n                success := lt(or(iszero(extcodesize(token)), returndatasize()), success)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "221",
            "end": "239",
            "class": "SafeTransferLib",
            "signature": "returns (bool success) trySafeTransferFromaddress token, address from, address to, uint256 amount",
            "full_signature": "function trySafeTransferFrom(address token, address from, address to, uint256 amount) internal   returns (bool success)",
            "class_method_signature": "SafeTransferLib.trySafeTransferFromaddress token, address from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to safely transfer tokens from one address to another using low-level assembly.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the `amount` argument in memory.\n * 3. Store the `to` argument in memory.\n * 4. Store the `from` argument in memory.\n * 5. Store the function selector for `transferFrom(address,address,uint256)` in memory.\n * 6. Perform a low-level call to the token contract to execute the transfer.\n * 7. Check if the call was successful and if the token contract exists.\n * 8. Restore the zero slot to zero.\n * 9. Restore the free memory pointer.\n *\n * @param token The address of the token contract.\n * @param from The address from which tokens are transferred.\n * @param to The address to which tokens are transferred.\n * @param amount The amount of tokens to transfer.\n * @return success A boolean indicating whether the transfer was successful.\n */"
        },
        {
            "identifier": "forceSafeTransferAllETH",
            "parameters": "address to",
            "modifiers": "",
            "return": "",
            "body": "function forceSafeTransferAllETH(address to) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // forgefmt: disable-next-item\n            if iszero(call(GAS_STIPEND_NO_GRIEF, to, selfbalance(), codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, to) // Store the address in scratch space.\n                mstore8(0x0b, 0x73) // Opcode `PUSH20`.\n                mstore8(0x20, 0xff) // Opcode `SELFDESTRUCT`.\n                if iszero(create(selfbalance(), 0x0b, 0x16)) { revert(codesize(), codesize()) } // For gas estimation.\n            }\n        }\n    }",
            "start": "154",
            "end": "165",
            "class": "SafeTransferLib",
            "signature": " forceSafeTransferAllETHaddress to",
            "full_signature": "function forceSafeTransferAllETH(address to) internal",
            "class_method_signature": "SafeTransferLib.forceSafeTransferAllETHaddress to",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Transfers all ETH from the contract to the specified address.\n * @dev Uses low-level assembly to ensure gas efficiency and safety.\n * \n * Steps:\n * 1. Attempts to transfer the contract's balance to the specified address using `call`.\n * 2. If the transfer fails:\n *    - Stores the recipient address in scratch space.\n *    - Prepares opcodes for `PUSH20` and `SELFDESTRUCT`.\n *    - Attempts to create a new contract with the remaining balance, which will self-destruct and send funds to the recipient.\n *    - If the creation fails, reverts the transaction.\n */"
        },
        {
            "identifier": "DAI_DOMAIN_SEPARATOR",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant DAI_DOMAIN_SEPARATOR =\n        0xdbb8cf42e1ecb028be3f3dbc922e1d878b963f411dc388ced501601c60f7c6f7;",
            "start": "49",
            "end": "50",
            "class": "SafeTransferLib",
            "signature": "bytes32 DAI_DOMAIN_SEPARATOR",
            "full_signature": "bytes32 internal constant DAI_DOMAIN_SEPARATOR",
            "class_method_signature": "SafeTransferLib.DAI_DOMAIN_SEPARATOR",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the domain separator for DAI.\n * This is used in EIP-712 compliant signing to ensure that signatures are unique to the DAI contract.\n */"
        },
        {
            "identifier": "trySafeTransferETH",
            "parameters": "address to, uint256 amount, uint256 gasStipend",
            "modifiers": "",
            "return": "returns (bool success)",
            "body": "function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend)\n        internal\n        returns (bool success)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            success := call(gasStipend, to, amount, codesize(), 0x00, codesize(), 0x00)\n        }\n    }",
            "start": "168",
            "end": "176",
            "class": "SafeTransferLib",
            "signature": "returns (bool success) trySafeTransferETHaddress to, uint256 amount, uint256 gasStipend",
            "full_signature": "function trySafeTransferETH(address to, uint256 amount, uint256 gasStipend) internal   returns (bool success)",
            "class_method_signature": "SafeTransferLib.trySafeTransferETHaddress to, uint256 amount, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to safely transfer ETH to a specified address with a given gas stipend.\n * @dev Uses low-level assembly to perform the transfer, ensuring memory safety.\n *\n * @param to The address to which ETH will be transferred.\n * @param amount The amount of ETH to transfer.\n * @param gasStipend The amount of gas to allocate for the transfer.\n * @return success A boolean indicating whether the transfer was successful.\n */"
        },
        {
            "identifier": "Permit2AmountOverflow",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error Permit2AmountOverflow();",
            "start": "35",
            "end": "35",
            "class": "SafeTransferLib",
            "signature": " Permit2AmountOverflow",
            "full_signature": "function Permit2AmountOverflow()",
            "class_method_signature": "SafeTransferLib.Permit2AmountOverflow",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the amount in a Permit2 operation has overflowed.\n * This error is thrown when the amount specified in a Permit2 operation exceeds the allowable limit.\n */"
        },
        {
            "identifier": "balanceOf",
            "parameters": "address token, address account",
            "modifiers": "view",
            "return": "returns (uint256 amount)",
            "body": "function balanceOf(address token, address account) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, account) // Store the `account` argument.\n            mstore(0x00, 0x70a08231000000000000000000000000) // `balanceOf(address)`.\n            amount :=\n                mul( // The arguments of `mul` are evaluated from right to left.\n                    mload(0x20),\n                    and( // The arguments of `and` are evaluated from right to left.\n                        gt(returndatasize(), 0x1f), // At least 32 bytes returned.\n                        staticcall(gas(), token, 0x10, 0x24, 0x20, 0x20)\n                    )\n                )\n        }\n    }",
            "start": "386",
            "end": "400",
            "class": "SafeTransferLib",
            "signature": "returns (uint256 amount) balanceOfaddress token, address account",
            "full_signature": "function balanceOf(address token, address account) internal  view returns (uint256 amount)",
            "class_method_signature": "SafeTransferLib.balanceOfaddress token, address account",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the token balance of a specific account.\n *\n * @param token The address of the token contract.\n * @param account The address of the account to query the balance for.\n * @return amount The balance of the specified account.\n *\n * Steps:\n * 1. Store the `account` argument in memory.\n * 2. Store the `balanceOf(address)` function selector in memory.\n * 3. Perform a static call to the token contract to retrieve the balance.\n * 4. Ensure that the return data is at least 32 bytes.\n * 5. Multiply the result by 1 (effectively returning the balance).\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DynamicBufferLib.sol": [
        {
            "identifier": "pBytes30",
            "parameters": "DynamicBuffer memory buffer, bytes30 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes30(DynamicBuffer memory buffer, bytes30 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 30));\n    }",
            "start": "852",
            "end": "859",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes30DynamicBuffer memory buffer, bytes30 data",
            "full_signature": "function pBytes30(DynamicBuffer memory buffer, bytes30 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes30DynamicBuffer memory buffer, bytes30 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes30 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the bytes30 data to the buffer by converting it to a bytes32 value and truncating it to 30 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes16",
            "parameters": "DynamicBuffer memory buffer, bytes16 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes16(DynamicBuffer memory buffer, bytes16 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 16));\n    }",
            "start": "712",
            "end": "719",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes16DynamicBuffer memory buffer, bytes16 data",
            "full_signature": "function pBytes16(DynamicBuffer memory buffer, bytes16 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes16DynamicBuffer memory buffer, bytes16 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 16-byte data chunk to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Append the 16-byte data chunk to the provided buffer.\n * 3. Return the updated buffer.\n *\n * @param buffer The dynamic buffer to which the data will be appended.\n * @param data The 16-byte data to append to the buffer.\n * @return result The updated dynamic buffer with the appended data.\n */"
        },
        {
            "identifier": "pBytes27",
            "parameters": "bytes27 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes27(bytes27 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes27(result, data);\n    }",
            "start": "1253",
            "end": "1255",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes27bytes27 data",
            "full_signature": "function pBytes27(bytes27 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes27bytes27 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a bytes27 data into a DynamicBuffer.\n * @param data The bytes27 data to be packed.\n * @return result A DynamicBuffer containing the packed bytes27 data.\n */"
        },
        {
            "identifier": "pUint152",
            "parameters": "uint152 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint152(uint152 data) internal pure returns (DynamicBuffer memory result) {\n        pUint152(result, data);\n    }",
            "start": "1053",
            "end": "1055",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint152uint152 data",
            "full_signature": "function pUint152(uint152 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint152uint152 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint152 value into a DynamicBuffer.\n * @param data The uint152 value to be packed.\n * @return result A DynamicBuffer containing the packed uint152 value.\n */"
        },
        {
            "identifier": "pBytes14",
            "parameters": "DynamicBuffer memory buffer, bytes14 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes14(DynamicBuffer memory buffer, bytes14 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 14));\n    }",
            "start": "692",
            "end": "699",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes14DynamicBuffer memory buffer, bytes14 data",
            "full_signature": "function pBytes14(DynamicBuffer memory buffer, bytes14 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes14DynamicBuffer memory buffer, bytes14 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Appends a 14-byte value to a dynamic buffer.  \n *  \n * Steps:  \n * 1. Deallocate the current result buffer to free up memory.  \n * 2. Append the 14-byte data to the provided buffer using the `p` function.  \n * 3. Return the updated buffer as the result.  \n */  "
        },
        {
            "identifier": "pBytes19",
            "parameters": "bytes19 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes19(bytes19 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes19(result, data);\n    }",
            "start": "1213",
            "end": "1215",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes19bytes19 data",
            "full_signature": "function pBytes19(bytes19 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes19bytes19 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to convert a `bytes19` data type into a `DynamicBuffer` memory result.\n * @param data The `bytes19` data to be processed.\n * @return result The resulting `DynamicBuffer` memory object.\n */"
        },
        {
            "identifier": "pBytes17",
            "parameters": "DynamicBuffer memory buffer, bytes17 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes17(DynamicBuffer memory buffer, bytes17 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 17));\n    }",
            "start": "722",
            "end": "729",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes17DynamicBuffer memory buffer, bytes17 data",
            "full_signature": "function pBytes17(DynamicBuffer memory buffer, bytes17 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes17DynamicBuffer memory buffer, bytes17 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 17-byte data chunk to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 17-byte data chunk to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes31",
            "parameters": "DynamicBuffer memory buffer, bytes31 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes31(DynamicBuffer memory buffer, bytes31 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 31));\n    }",
            "start": "862",
            "end": "869",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes31DynamicBuffer memory buffer, bytes31 data",
            "full_signature": "function pBytes31(DynamicBuffer memory buffer, bytes31 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes31DynamicBuffer memory buffer, bytes31 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Appends a bytes31 value to a DynamicBuffer.  \n *  \n * Steps:  \n * 1. Deallocate the result buffer to ensure it is clean.  \n * 2. Append the bytes31 data to the buffer by converting it to a bytes32 value  \n *    and truncating it to 31 bytes using the `_single` helper function.  \n * 3. Return the updated buffer.  \n */  "
        },
        {
            "identifier": "pBytes18",
            "parameters": "bytes18 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes18(bytes18 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes18(result, data);\n    }",
            "start": "1208",
            "end": "1210",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes18bytes18 data",
            "full_signature": "function pBytes18(bytes18 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes18bytes18 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to convert a `bytes18` data type into a `DynamicBuffer` memory type.\n * @param data The `bytes18` data to be converted.\n * @return result A `DynamicBuffer` memory type containing the converted data.\n */"
        },
        {
            "identifier": "pUint224",
            "parameters": "DynamicBuffer memory buffer, uint224 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint224(DynamicBuffer memory buffer, uint224 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 28));\n    }",
            "start": "512",
            "end": "519",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint224DynamicBuffer memory buffer, uint224 data",
            "full_signature": "function pUint224(DynamicBuffer memory buffer, uint224 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint224DynamicBuffer memory buffer, uint224 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint224 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Pack the uint224 data into the buffer using the `p` function.\n * 3. Return the updated buffer.\n *\n * @param buffer The DynamicBuffer to which the data will be packed.\n * @param data The uint224 value to be packed into the buffer.\n * @return result The updated DynamicBuffer after packing the data.\n */"
        },
        {
            "identifier": "pUint184",
            "parameters": "uint184 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint184(uint184 data) internal pure returns (DynamicBuffer memory result) {\n        pUint184(result, data);\n    }",
            "start": "1073",
            "end": "1075",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint184uint184 data",
            "full_signature": "function pUint184(uint184 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint184uint184 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint184 value into a DynamicBuffer.\n * @param data The uint184 value to be packed.\n * @return result A DynamicBuffer containing the packed uint184 value.\n */"
        },
        {
            "identifier": "pBytes23",
            "parameters": "bytes23 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes23(bytes23 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes23(result, data);\n    }",
            "start": "1233",
            "end": "1235",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes23bytes23 data",
            "full_signature": "function pBytes23(bytes23 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes23bytes23 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes23` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes23` with the `DynamicBuffer` and the input data.\n */"
        },
        {
            "identifier": "pUint112",
            "parameters": "uint112 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint112(uint112 data) internal pure returns (DynamicBuffer memory result) {\n        pUint112(result, data);\n    }",
            "start": "1028",
            "end": "1030",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint112uint112 data",
            "full_signature": "function pUint112(uint112 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint112uint112 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint112 value into a DynamicBuffer.\n * @param data The uint112 value to be packed.\n * @return result A DynamicBuffer containing the packed uint112 value.\n */"
        },
        {
            "identifier": "pUint168",
            "parameters": "uint168 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint168(uint168 data) internal pure returns (DynamicBuffer memory result) {\n        pUint168(result, data);\n    }",
            "start": "1063",
            "end": "1065",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint168uint168 data",
            "full_signature": "function pUint168(uint168 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint168uint168 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to pack a uint168 value into a DynamicBuffer.\n * @param data The uint168 value to be packed.\n * @return result A DynamicBuffer containing the packed uint168 value.\n */"
        },
        {
            "identifier": "pBytes23",
            "parameters": "DynamicBuffer memory buffer, bytes23 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes23(DynamicBuffer memory buffer, bytes23 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 23));\n    }",
            "start": "782",
            "end": "789",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes23DynamicBuffer memory buffer, bytes23 data",
            "full_signature": "function pBytes23(DynamicBuffer memory buffer, bytes23 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes23DynamicBuffer memory buffer, bytes23 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 23-byte data chunk to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Append the 23-byte data to the provided buffer using the internal `p` function.\n * 3. Return the updated buffer as the result.\n */"
        },
        {
            "identifier": "pBytes2",
            "parameters": "DynamicBuffer memory buffer, bytes2 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes2(DynamicBuffer memory buffer, bytes2 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 2));\n    }",
            "start": "572",
            "end": "579",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes2DynamicBuffer memory buffer, bytes2 data",
            "full_signature": "function pBytes2(DynamicBuffer memory buffer, bytes2 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes2DynamicBuffer memory buffer, bytes2 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a `bytes2` value to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean.\n * 2. Append the `bytes2` data to the provided `buffer` by converting it to a `bytes32` value and slicing it to 2 bytes.\n * 3. Return the updated buffer as `result`.\n *\n * @param buffer The dynamic buffer to which the `bytes2` data will be appended.\n * @param data The `bytes2` value to append to the buffer.\n * @return result The updated dynamic buffer containing the appended data.\n */"
        },
        {
            "identifier": "pUint104",
            "parameters": "DynamicBuffer memory buffer, uint104 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint104(DynamicBuffer memory buffer, uint104 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 13));\n    }",
            "start": "362",
            "end": "369",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint104DynamicBuffer memory buffer, uint104 data",
            "full_signature": "function pUint104(DynamicBuffer memory buffer, uint104 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint104DynamicBuffer memory buffer, uint104 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 104-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 104-bit unsigned integer to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint48",
            "parameters": "DynamicBuffer memory buffer, uint48 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint48(DynamicBuffer memory buffer, uint48 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 6));\n    }",
            "start": "292",
            "end": "299",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint48DynamicBuffer memory buffer, uint48 data",
            "full_signature": "function pUint48(DynamicBuffer memory buffer, uint48 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint48DynamicBuffer memory buffer, uint48 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a 48-bit unsigned integer into a DynamicBuffer.\n * \n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Packs the 48-bit unsigned integer into the buffer using the `p` function.\n * 3. Returns the updated buffer.\n */"
        },
        {
            "identifier": "pBytes29",
            "parameters": "bytes29 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes29(bytes29 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes29(result, data);\n    }",
            "start": "1263",
            "end": "1265",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes29bytes29 data",
            "full_signature": "function pBytes29(bytes29 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes29bytes29 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes29` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes29` with the `DynamicBuffer` and the input `bytes29` data.\n */"
        },
        {
            "identifier": "pBytes31",
            "parameters": "bytes31 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes31(bytes31 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes31(result, data);\n    }",
            "start": "1273",
            "end": "1275",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes31bytes31 data",
            "full_signature": "function pBytes31(bytes31 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes31bytes31 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to convert a `bytes31` value into a `DynamicBuffer`.\n *\n * @param data The `bytes31` data to be converted.\n * @return result A `DynamicBuffer` containing the converted data.\n */"
        },
        {
            "identifier": "pUint96",
            "parameters": "uint96 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint96(uint96 data) internal pure returns (DynamicBuffer memory result) {\n        pUint96(result, data);\n    }",
            "start": "1018",
            "end": "1020",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint96uint96 data",
            "full_signature": "function pUint96(uint96 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint96uint96 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint96 value into a DynamicBuffer.\n * @param data The uint96 value to be packed.\n * @return result A DynamicBuffer containing the packed uint96 value.\n */"
        },
        {
            "identifier": "pUint128",
            "parameters": "DynamicBuffer memory buffer, uint128 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint128(DynamicBuffer memory buffer, uint128 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 16));\n    }",
            "start": "392",
            "end": "399",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint128DynamicBuffer memory buffer, uint128 data",
            "full_signature": "function pUint128(DynamicBuffer memory buffer, uint128 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint128DynamicBuffer memory buffer, uint128 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 128-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Appends the 128-bit unsigned integer to the buffer by converting it to a byte sequence of length 16.\n * 3. Returns the updated buffer.\n */"
        },
        {
            "identifier": "pUint176",
            "parameters": "DynamicBuffer memory buffer, uint176 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint176(DynamicBuffer memory buffer, uint176 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 22));\n    }",
            "start": "452",
            "end": "459",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint176DynamicBuffer memory buffer, uint176 data",
            "full_signature": "function pUint176(DynamicBuffer memory buffer, uint176 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint176DynamicBuffer memory buffer, uint176 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 176-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Appends the 176-bit unsigned integer to the buffer by packing it into 22 bytes.\n * 3. Returns the updated buffer.\n */"
        },
        {
            "identifier": "pBytes22",
            "parameters": "DynamicBuffer memory buffer, bytes22 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes22(DynamicBuffer memory buffer, bytes22 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 22));\n    }",
            "start": "772",
            "end": "779",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes22DynamicBuffer memory buffer, bytes22 data",
            "full_signature": "function pBytes22(DynamicBuffer memory buffer, bytes22 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes22DynamicBuffer memory buffer, bytes22 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 22-byte data chunk to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 22-byte data chunk to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint40",
            "parameters": "uint40 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint40(uint40 data) internal pure returns (DynamicBuffer memory result) {\n        pUint40(result, data);\n    }",
            "start": "983",
            "end": "985",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint40uint40 data",
            "full_signature": "function pUint40(uint40 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint40uint40 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint40 value into a DynamicBuffer.\n * @param data The uint40 value to be packed.\n * @return result A DynamicBuffer containing the packed uint40 value.\n */"
        },
        {
            "identifier": "pUint64",
            "parameters": "uint64 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint64(uint64 data) internal pure returns (DynamicBuffer memory result) {\n        pUint64(result, data);\n    }",
            "start": "998",
            "end": "1000",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint64uint64 data",
            "full_signature": "function pUint64(uint64 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint64uint64 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `uint64` value and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pUint64` with the `DynamicBuffer` and the `uint64` data as arguments.\n */"
        },
        {
            "identifier": "pBytes18",
            "parameters": "DynamicBuffer memory buffer, bytes18 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes18(DynamicBuffer memory buffer, bytes18 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 18));\n    }",
            "start": "732",
            "end": "739",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes18DynamicBuffer memory buffer, bytes18 data",
            "full_signature": "function pBytes18(DynamicBuffer memory buffer, bytes18 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes18DynamicBuffer memory buffer, bytes18 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes18 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the bytes18 data to the buffer by converting it to a bytes32 value with a length of 18.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint224",
            "parameters": "uint224 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint224(uint224 data) internal pure returns (DynamicBuffer memory result) {\n        pUint224(result, data);\n    }",
            "start": "1098",
            "end": "1100",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint224uint224 data",
            "full_signature": "function pUint224(uint224 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint224uint224 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint224 value into a DynamicBuffer.\n * @param data The uint224 value to be packed.\n * @return result A DynamicBuffer containing the packed uint224 value.\n */"
        },
        {
            "identifier": "pBytes25",
            "parameters": "DynamicBuffer memory buffer, bytes25 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes25(DynamicBuffer memory buffer, bytes25 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 25));\n    }",
            "start": "802",
            "end": "809",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes25DynamicBuffer memory buffer, bytes25 data",
            "full_signature": "function pBytes25(DynamicBuffer memory buffer, bytes25 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes25DynamicBuffer memory buffer, bytes25 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes25 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the bytes25 data to the buffer by converting it to a bytes32 value \n *    and truncating it to 25 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes12",
            "parameters": "DynamicBuffer memory buffer, bytes12 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes12(DynamicBuffer memory buffer, bytes12 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 12));\n    }",
            "start": "672",
            "end": "679",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes12DynamicBuffer memory buffer, bytes12 data",
            "full_signature": "function pBytes12(DynamicBuffer memory buffer, bytes12 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes12DynamicBuffer memory buffer, bytes12 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 12-byte data chunk to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is clean.\n * 2. Append the 12-byte data to the provided DynamicBuffer using the `p` function.\n * 3. Return the updated DynamicBuffer.\n */"
        },
        {
            "identifier": "pUint56",
            "parameters": "uint56 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint56(uint56 data) internal pure returns (DynamicBuffer memory result) {\n        pUint56(result, data);\n    }",
            "start": "993",
            "end": "995",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint56uint56 data",
            "full_signature": "function pUint56(uint56 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint56uint56 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint56 value into a DynamicBuffer.\n * @param data The uint56 value to be packed.\n * @return result A DynamicBuffer containing the packed uint56 value.\n */"
        },
        {
            "identifier": "pBytes5",
            "parameters": "DynamicBuffer memory buffer, bytes5 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes5(DynamicBuffer memory buffer, bytes5 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 5));\n    }",
            "start": "602",
            "end": "609",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes5DynamicBuffer memory buffer, bytes5 data",
            "full_signature": "function pBytes5(DynamicBuffer memory buffer, bytes5 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes5DynamicBuffer memory buffer, bytes5 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes5 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the bytes5 data to the buffer by converting it to a bytes32 value and truncating it to 5 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint248",
            "parameters": "DynamicBuffer memory buffer, uint248 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint248(DynamicBuffer memory buffer, uint248 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 31));\n    }",
            "start": "542",
            "end": "549",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint248DynamicBuffer memory buffer, uint248 data",
            "full_signature": "function pUint248(DynamicBuffer memory buffer, uint248 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint248DynamicBuffer memory buffer, uint248 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 248-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 248-bit unsigned integer to the buffer by packing it into 31 bytes.\n * 3. Return the updated buffer.\n *\n * @param buffer The dynamic buffer to which the data will be appended.\n * @param data The 248-bit unsigned integer to append.\n * @return result The updated dynamic buffer with the appended data.\n */"
        },
        {
            "identifier": "pBytes22",
            "parameters": "bytes22 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes22(bytes22 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes22(result, data);\n    }",
            "start": "1228",
            "end": "1230",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes22bytes22 data",
            "full_signature": "function pBytes22(bytes22 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes22bytes22 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes22` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes22` with the `DynamicBuffer` and the input data.\n */"
        },
        {
            "identifier": "pUint128",
            "parameters": "uint128 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint128(uint128 data) internal pure returns (DynamicBuffer memory result) {\n        pUint128(result, data);\n    }",
            "start": "1038",
            "end": "1040",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint128uint128 data",
            "full_signature": "function pUint128(uint128 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint128uint128 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint128 value into a DynamicBuffer.\n * @param data The uint128 value to be packed.\n * @return result A DynamicBuffer containing the packed uint128 value.\n */"
        },
        {
            "identifier": "pBytes10",
            "parameters": "bytes10 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes10(bytes10 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes10(result, data);\n    }",
            "start": "1168",
            "end": "1170",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes10bytes10 data",
            "full_signature": "function pBytes10(bytes10 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes10bytes10 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes10` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes10` with the `DynamicBuffer` and the `bytes10` data as arguments.\n */"
        },
        {
            "identifier": "pUint72",
            "parameters": "uint72 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint72(uint72 data) internal pure returns (DynamicBuffer memory result) {\n        pUint72(result, data);\n    }",
            "start": "1003",
            "end": "1005",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint72uint72 data",
            "full_signature": "function pUint72(uint72 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint72uint72 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint72 value into a DynamicBuffer.\n * @param data The uint72 value to be packed.\n * @return result A DynamicBuffer containing the packed uint72 value.\n */"
        },
        {
            "identifier": "pUint48",
            "parameters": "uint48 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint48(uint48 data) internal pure returns (DynamicBuffer memory result) {\n        pUint48(result, data);\n    }",
            "start": "988",
            "end": "990",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint48uint48 data",
            "full_signature": "function pUint48(uint48 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint48uint48 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint48 value into a DynamicBuffer.\n * @param data The uint48 value to be packed.\n * @return result A DynamicBuffer containing the packed uint48 value.\n */"
        },
        {
            "identifier": "pUint184",
            "parameters": "DynamicBuffer memory buffer, uint184 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint184(DynamicBuffer memory buffer, uint184 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 23));\n    }",
            "start": "462",
            "end": "469",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint184DynamicBuffer memory buffer, uint184 data",
            "full_signature": "function pUint184(DynamicBuffer memory buffer, uint184 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint184DynamicBuffer memory buffer, uint184 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a uint184 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Appends the uint184 value to the buffer by encoding it into 23 bytes.\n * 3. Returns the updated buffer.\n */"
        },
        {
            "identifier": "pUint248",
            "parameters": "uint248 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint248(uint248 data) internal pure returns (DynamicBuffer memory result) {\n        pUint248(result, data);\n    }",
            "start": "1113",
            "end": "1115",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint248uint248 data",
            "full_signature": "function pUint248(uint248 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint248uint248 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint248 value into a DynamicBuffer.\n * @param data The uint248 value to be packed.\n * @return result A DynamicBuffer containing the packed uint248 value.\n */"
        },
        {
            "identifier": "pBytes4",
            "parameters": "DynamicBuffer memory buffer, bytes4 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes4(DynamicBuffer memory buffer, bytes4 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 4));\n    }",
            "start": "592",
            "end": "599",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes4DynamicBuffer memory buffer, bytes4 data",
            "full_signature": "function pBytes4(DynamicBuffer memory buffer, bytes4 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes4DynamicBuffer memory buffer, bytes4 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 4-byte (bytes4) value to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer to free up memory.\n * 2. Append the 4-byte value to the provided buffer using the `p` function.\n * 3. Return the updated buffer as the result.\n *\n * @param buffer The dynamic buffer to which the bytes4 value will be appended.\n * @param data The 4-byte value to append to the buffer.\n * @return result The updated dynamic buffer containing the appended bytes4 value.\n */"
        },
        {
            "identifier": "pBytes26",
            "parameters": "bytes26 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes26(bytes26 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes26(result, data);\n    }",
            "start": "1248",
            "end": "1250",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes26bytes26 data",
            "full_signature": "function pBytes26(bytes26 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes26bytes26 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes26` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes26` with the `DynamicBuffer` and the `bytes26` data as arguments.\n */"
        },
        {
            "identifier": "pBytes26",
            "parameters": "DynamicBuffer memory buffer, bytes26 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes26(DynamicBuffer memory buffer, bytes26 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 26));\n    }",
            "start": "812",
            "end": "819",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes26DynamicBuffer memory buffer, bytes26 data",
            "full_signature": "function pBytes26(DynamicBuffer memory buffer, bytes26 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes26DynamicBuffer memory buffer, bytes26 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Appends a bytes26 value to a DynamicBuffer.  \n *  \n * Steps:  \n * 1. Deallocate the result buffer to ensure it is clean.  \n * 2. Append the bytes26 data to the provided buffer using the `p` function,  \n *    after converting it to a bytes32 value with a length of 26 bytes.  \n *  \n * @param buffer The DynamicBuffer to which the data will be appended.  \n * @param data The bytes26 value to append.  \n * @return result The updated DynamicBuffer after appending the data.  \n */  "
        },
        {
            "identifier": "pUint192",
            "parameters": "uint192 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint192(uint192 data) internal pure returns (DynamicBuffer memory result) {\n        pUint192(result, data);\n    }",
            "start": "1078",
            "end": "1080",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint192uint192 data",
            "full_signature": "function pUint192(uint192 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint192uint192 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint192 value into a DynamicBuffer.\n * @param data The uint192 value to be packed.\n * @return result A DynamicBuffer containing the packed uint192 value.\n */"
        },
        {
            "identifier": "pUint216",
            "parameters": "uint216 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint216(uint216 data) internal pure returns (DynamicBuffer memory result) {\n        pUint216(result, data);\n    }",
            "start": "1093",
            "end": "1095",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint216uint216 data",
            "full_signature": "function pUint216(uint216 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint216uint216 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint216 value into a DynamicBuffer.\n * @param data The uint216 value to be packed.\n * @return result A DynamicBuffer containing the packed uint216 value.\n */"
        },
        {
            "identifier": "pUint88",
            "parameters": "DynamicBuffer memory buffer, uint88 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint88(DynamicBuffer memory buffer, uint88 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 11));\n    }",
            "start": "342",
            "end": "349",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint88DynamicBuffer memory buffer, uint88 data",
            "full_signature": "function pUint88(DynamicBuffer memory buffer, uint88 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint88DynamicBuffer memory buffer, uint88 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint88 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the current buffer to free up memory.\n * 2. Pack the uint88 value into the buffer using the `_single` helper function.\n * 3. Return the updated buffer.\n *\n * @param buffer The DynamicBuffer to which the uint88 value will be packed.\n * @param data The uint88 value to be packed.\n * @return result The updated DynamicBuffer containing the packed uint88 value.\n */"
        },
        {
            "identifier": "pBytes6",
            "parameters": "bytes6 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes6(bytes6 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes6(result, data);\n    }",
            "start": "1148",
            "end": "1150",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes6bytes6 data",
            "full_signature": "function pBytes6(bytes6 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes6bytes6 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes6` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes6` with the `DynamicBuffer` and `bytes6` data as arguments.\n */"
        },
        {
            "identifier": "pUint200",
            "parameters": "DynamicBuffer memory buffer, uint200 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint200(DynamicBuffer memory buffer, uint200 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 25));\n    }",
            "start": "482",
            "end": "489",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint200DynamicBuffer memory buffer, uint200 data",
            "full_signature": "function pUint200(DynamicBuffer memory buffer, uint200 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint200DynamicBuffer memory buffer, uint200 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a uint200 value to a DynamicBuffer in a packed format.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Pack the uint200 value into a single byte array with a length of 25 bytes.\n * 3. Append the packed data to the provided DynamicBuffer.\n * 4. Return the updated DynamicBuffer.\n */"
        },
        {
            "identifier": "_single",
            "parameters": "bytes32 data, uint256 n",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function _single(bytes32 data, uint256 n) private pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 0x00\n            mstore(0x20, data)\n            mstore(result, n)\n        }\n    }",
            "start": "1305",
            "end": "1312",
            "class": "DynamicBufferLib",
            "signature": "returns (bytes memory result) _singlebytes32 data, uint256 n",
            "full_signature": "function _single(bytes32 data, uint256 n) private  pure returns (bytes memory result)",
            "class_method_signature": "DynamicBufferLib._singlebytes32 data, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that manipulates memory to store data and a number.\n *\n * Steps:\n * 1. Initialize the result pointer to 0x00.\n * 2. Store the provided `data` in memory at position 0x20.\n * 3. Store the provided `n` in memory at the result pointer.\n *\n * @param data The bytes32 data to be stored in memory.\n * @param n The uint256 number to be stored in memory.\n * @return result The memory pointer containing the stored data and number.\n */"
        },
        {
            "identifier": "pUint240",
            "parameters": "DynamicBuffer memory buffer, uint240 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint240(DynamicBuffer memory buffer, uint240 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 30));\n    }",
            "start": "532",
            "end": "539",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint240DynamicBuffer memory buffer, uint240 data",
            "full_signature": "function pUint240(DynamicBuffer memory buffer, uint240 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint240DynamicBuffer memory buffer, uint240 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 240-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is clean before use.\n * 2. Append the 240-bit unsigned integer to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes11",
            "parameters": "DynamicBuffer memory buffer, bytes11 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes11(DynamicBuffer memory buffer, bytes11 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 11));\n    }",
            "start": "662",
            "end": "669",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes11DynamicBuffer memory buffer, bytes11 data",
            "full_signature": "function pBytes11(DynamicBuffer memory buffer, bytes11 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes11DynamicBuffer memory buffer, bytes11 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends an 11-byte data chunk to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer to free up memory.\n * 2. Append the 11-byte data chunk to the provided buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint144",
            "parameters": "uint144 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint144(uint144 data) internal pure returns (DynamicBuffer memory result) {\n        pUint144(result, data);\n    }",
            "start": "1048",
            "end": "1050",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint144uint144 data",
            "full_signature": "function pUint144(uint144 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint144uint144 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint144 value into a DynamicBuffer.\n * @param data The uint144 value to be packed.\n * @return result A DynamicBuffer containing the packed uint144 value.\n */"
        },
        {
            "identifier": "pUint64",
            "parameters": "DynamicBuffer memory buffer, uint64 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint64(DynamicBuffer memory buffer, uint64 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 8));\n    }",
            "start": "312",
            "end": "319",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint64DynamicBuffer memory buffer, uint64 data",
            "full_signature": "function pUint64(DynamicBuffer memory buffer, uint64 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint64DynamicBuffer memory buffer, uint64 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 64-bit unsigned integer (uint64) to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer to free up memory.\n * 2. Append the uint64 data to the buffer by converting it to a 8-byte array.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes6",
            "parameters": "DynamicBuffer memory buffer, bytes6 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes6(DynamicBuffer memory buffer, bytes6 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 6));\n    }",
            "start": "612",
            "end": "619",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes6DynamicBuffer memory buffer, bytes6 data",
            "full_signature": "function pBytes6(DynamicBuffer memory buffer, bytes6 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes6DynamicBuffer memory buffer, bytes6 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 6-byte value to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer to free up memory.\n * 2. Append the provided 6-byte data to the buffer using the `p` function.\n * 3. Return the updated buffer as the result.\n */"
        },
        {
            "identifier": "pBytes13",
            "parameters": "DynamicBuffer memory buffer, bytes13 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes13(DynamicBuffer memory buffer, bytes13 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 13));\n    }",
            "start": "682",
            "end": "689",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes13DynamicBuffer memory buffer, bytes13 data",
            "full_signature": "function pBytes13(DynamicBuffer memory buffer, bytes13 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes13DynamicBuffer memory buffer, bytes13 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 13-byte data chunk to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 13-byte data to the provided buffer using the `p` function.\n * 3. Return the updated buffer.\n *\n * @param buffer The dynamic buffer to which the data will be appended.\n * @param data The 13-byte data to append.\n * @return result The updated dynamic buffer with the appended data.\n */"
        },
        {
            "identifier": "pUint160",
            "parameters": "uint160 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint160(uint160 data) internal pure returns (DynamicBuffer memory result) {\n        pUint160(result, data);\n    }",
            "start": "1058",
            "end": "1060",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint160uint160 data",
            "full_signature": "function pUint160(uint160 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint160uint160 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint160 value into a DynamicBuffer.\n * @param data The uint160 value to be packed.\n * @return result A DynamicBuffer containing the packed uint160 value.\n */"
        },
        {
            "identifier": "pUint24",
            "parameters": "DynamicBuffer memory buffer, uint24 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint24(DynamicBuffer memory buffer, uint24 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 3));\n    }",
            "start": "262",
            "end": "269",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint24DynamicBuffer memory buffer, uint24 data",
            "full_signature": "function pUint24(DynamicBuffer memory buffer, uint24 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint24DynamicBuffer memory buffer, uint24 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 24-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Appends the 24-bit unsigned integer to the buffer by converting it to a 3-byte sequence.\n * 3. Returns the updated buffer.\n */"
        },
        {
            "identifier": "pBytes7",
            "parameters": "bytes7 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes7(bytes7 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes7(result, data);\n    }",
            "start": "1153",
            "end": "1155",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes7bytes7 data",
            "full_signature": "function pBytes7(bytes7 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes7bytes7 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes7` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes7` with the `DynamicBuffer` and the input `data`.\n */"
        },
        {
            "identifier": "pBytes25",
            "parameters": "bytes25 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes25(bytes25 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes25(result, data);\n    }",
            "start": "1243",
            "end": "1245",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes25bytes25 data",
            "full_signature": "function pBytes25(bytes25 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes25bytes25 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to append a bytes25 data to a DynamicBuffer.\n * @param data The bytes25 data to be appended.\n * @return result The DynamicBuffer containing the appended data.\n */"
        },
        {
            "identifier": "pBytes10",
            "parameters": "DynamicBuffer memory buffer, bytes10 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes10(DynamicBuffer memory buffer, bytes10 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 10));\n    }",
            "start": "652",
            "end": "659",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes10DynamicBuffer memory buffer, bytes10 data",
            "full_signature": "function pBytes10(DynamicBuffer memory buffer, bytes10 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes10DynamicBuffer memory buffer, bytes10 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a `bytes10` value to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocates the memory of the `result` buffer.\n * 2. Appends the `bytes10` data to the provided `buffer` by converting it to a `bytes32` value with a length of 10.\n * 3. Returns the updated buffer as `result`.\n */"
        },
        {
            "identifier": "pUint56",
            "parameters": "DynamicBuffer memory buffer, uint56 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint56(DynamicBuffer memory buffer, uint56 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 7));\n    }",
            "start": "302",
            "end": "309",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint56DynamicBuffer memory buffer, uint56 data",
            "full_signature": "function pUint56(DynamicBuffer memory buffer, uint56 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint56DynamicBuffer memory buffer, uint56 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 56-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 56-bit unsigned integer to the buffer by packing it into 7 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint16",
            "parameters": "DynamicBuffer memory buffer, uint16 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint16(DynamicBuffer memory buffer, uint16 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 2));\n    }",
            "start": "252",
            "end": "259",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint16DynamicBuffer memory buffer, uint16 data",
            "full_signature": "function pUint16(DynamicBuffer memory buffer, uint16 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint16DynamicBuffer memory buffer, uint16 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 16-bit unsigned integer (uint16) to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Append the uint16 data to the buffer by converting it to a 2-byte sequence.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint232",
            "parameters": "uint232 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint232(uint232 data) internal pure returns (DynamicBuffer memory result) {\n        pUint232(result, data);\n    }",
            "start": "1103",
            "end": "1105",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint232uint232 data",
            "full_signature": "function pUint232(uint232 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint232uint232 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint232 value into a DynamicBuffer.\n * @param data The uint232 value to be packed.\n * @return result A DynamicBuffer containing the packed uint232 value.\n */"
        },
        {
            "identifier": "pUint176",
            "parameters": "uint176 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint176(uint176 data) internal pure returns (DynamicBuffer memory result) {\n        pUint176(result, data);\n    }",
            "start": "1068",
            "end": "1070",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint176uint176 data",
            "full_signature": "function pUint176(uint176 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint176uint176 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint176 value into a DynamicBuffer.\n * @param data The uint176 value to be packed.\n * @return result A DynamicBuffer containing the packed uint176 value.\n */"
        },
        {
            "identifier": "pUint80",
            "parameters": "uint80 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint80(uint80 data) internal pure returns (DynamicBuffer memory result) {\n        pUint80(result, data);\n    }",
            "start": "1008",
            "end": "1010",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint80uint80 data",
            "full_signature": "function pUint80(uint80 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint80uint80 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint80 value into a DynamicBuffer.\n * @param data The uint80 value to be packed.\n * @return result A DynamicBuffer containing the packed uint80 value.\n */"
        },
        {
            "identifier": "pUint136",
            "parameters": "DynamicBuffer memory buffer, uint136 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint136(DynamicBuffer memory buffer, uint136 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 17));\n    }",
            "start": "402",
            "end": "409",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint136DynamicBuffer memory buffer, uint136 data",
            "full_signature": "function pUint136(DynamicBuffer memory buffer, uint136 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint136DynamicBuffer memory buffer, uint136 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint136 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Pack the uint136 data into the buffer using the `p` function, \n *    with the data formatted as a single 17-byte value.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes2",
            "parameters": "bytes2 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes2(bytes2 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes2(result, data);\n    }",
            "start": "1128",
            "end": "1130",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes2bytes2 data",
            "full_signature": "function pBytes2(bytes2 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes2bytes2 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to convert a `bytes2` data type into a `DynamicBuffer`.\n * @param data The `bytes2` data to be converted.\n * @return result A `DynamicBuffer` containing the converted data.\n */"
        },
        {
            "identifier": "pBytes20",
            "parameters": "bytes20 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes20(bytes20 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes20(result, data);\n    }",
            "start": "1218",
            "end": "1220",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes20bytes20 data",
            "full_signature": "function pBytes20(bytes20 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes20bytes20 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes20` data and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes20` with the `result` and `data` as arguments.\n */"
        },
        {
            "identifier": "pUint96",
            "parameters": "DynamicBuffer memory buffer, uint96 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint96(DynamicBuffer memory buffer, uint96 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 12));\n    }",
            "start": "352",
            "end": "359",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint96DynamicBuffer memory buffer, uint96 data",
            "full_signature": "function pUint96(DynamicBuffer memory buffer, uint96 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint96DynamicBuffer memory buffer, uint96 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint96 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is empty.\n * 2. Pack the uint96 data into the buffer using the `p` function, ensuring it is treated as a 12-byte value.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes21",
            "parameters": "DynamicBuffer memory buffer, bytes21 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes21(DynamicBuffer memory buffer, bytes21 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 21));\n    }",
            "start": "762",
            "end": "769",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes21DynamicBuffer memory buffer, bytes21 data",
            "full_signature": "function pBytes21(DynamicBuffer memory buffer, bytes21 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes21DynamicBuffer memory buffer, bytes21 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 21-byte data chunk to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Append the 21-byte data to the provided buffer using the `p` function.\n * 3. Return the updated buffer as the result.\n */"
        },
        {
            "identifier": "pUint208",
            "parameters": "uint208 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint208(uint208 data) internal pure returns (DynamicBuffer memory result) {\n        pUint208(result, data);\n    }",
            "start": "1088",
            "end": "1090",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint208uint208 data",
            "full_signature": "function pUint208(uint208 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint208uint208 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint208 value into a DynamicBuffer.\n * @param data The uint208 value to be packed.\n * @return result A DynamicBuffer containing the packed uint208 value.\n */"
        },
        {
            "identifier": "pBytes9",
            "parameters": "DynamicBuffer memory buffer, bytes9 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes9(DynamicBuffer memory buffer, bytes9 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 9));\n    }",
            "start": "642",
            "end": "649",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes9DynamicBuffer memory buffer, bytes9 data",
            "full_signature": "function pBytes9(DynamicBuffer memory buffer, bytes9 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes9DynamicBuffer memory buffer, bytes9 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 9-byte value to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 9-byte value to the provided buffer using the `p` function.\n * 3. Return the updated buffer.\n *\n * @param buffer The dynamic buffer to which the data will be appended.\n * @param data The 9-byte value to append to the buffer.\n * @return result The updated dynamic buffer after appending the data.\n */"
        },
        {
            "identifier": "pUint120",
            "parameters": "uint120 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint120(uint120 data) internal pure returns (DynamicBuffer memory result) {\n        pUint120(result, data);\n    }",
            "start": "1033",
            "end": "1035",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint120uint120 data",
            "full_signature": "function pUint120(uint120 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint120uint120 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint120 value into a DynamicBuffer.\n * @param data The uint120 value to be packed.\n * @return result A DynamicBuffer containing the packed uint120 value.\n */"
        },
        {
            "identifier": "pBytes4",
            "parameters": "bytes4 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes4(bytes4 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes4(result, data);\n    }",
            "start": "1138",
            "end": "1140",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes4bytes4 data",
            "full_signature": "function pBytes4(bytes4 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes4bytes4 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to append a `bytes4` value to a `DynamicBuffer`.\n *\n * @param data The `bytes4` value to be appended to the buffer.\n * @return result The `DynamicBuffer` with the appended `bytes4` value.\n */"
        },
        {
            "identifier": "pBytes19",
            "parameters": "DynamicBuffer memory buffer, bytes19 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes19(DynamicBuffer memory buffer, bytes19 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 19));\n    }",
            "start": "742",
            "end": "749",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes19DynamicBuffer memory buffer, bytes19 data",
            "full_signature": "function pBytes19(DynamicBuffer memory buffer, bytes19 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes19DynamicBuffer memory buffer, bytes19 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes19 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer to free up memory.\n * 2. Append the bytes19 data to the provided buffer by converting it to a bytes32 value and truncating it to 19 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint232",
            "parameters": "DynamicBuffer memory buffer, uint232 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint232(DynamicBuffer memory buffer, uint232 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 29));\n    }",
            "start": "522",
            "end": "529",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint232DynamicBuffer memory buffer, uint232 data",
            "full_signature": "function pUint232(DynamicBuffer memory buffer, uint232 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint232DynamicBuffer memory buffer, uint232 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 232-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 232-bit unsigned integer to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint144",
            "parameters": "DynamicBuffer memory buffer, uint144 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint144(DynamicBuffer memory buffer, uint144 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 18));\n    }",
            "start": "412",
            "end": "419",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint144DynamicBuffer memory buffer, uint144 data",
            "full_signature": "function pUint144(DynamicBuffer memory buffer, uint144 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint144DynamicBuffer memory buffer, uint144 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint144 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer to free up memory.\n * 2. Pack the uint144 data into the buffer using the `p` function with a specified length of 18 bytes.\n * 3. Return the updated DynamicBuffer.\n */"
        },
        {
            "identifier": "pUint160",
            "parameters": "DynamicBuffer memory buffer, uint160 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint160(DynamicBuffer memory buffer, uint160 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 20));\n    }",
            "start": "432",
            "end": "439",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint160DynamicBuffer memory buffer, uint160 data",
            "full_signature": "function pUint160(DynamicBuffer memory buffer, uint160 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint160DynamicBuffer memory buffer, uint160 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint160 value into a DynamicBuffer.\n * \n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Pack the uint160 value into the buffer using the `p` function, ensuring the data is treated as a 20-byte value.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint136",
            "parameters": "uint136 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint136(uint136 data) internal pure returns (DynamicBuffer memory result) {\n        pUint136(result, data);\n    }",
            "start": "1043",
            "end": "1045",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint136uint136 data",
            "full_signature": "function pUint136(uint136 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint136uint136 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint136 value into a DynamicBuffer.\n * @param data The uint136 value to be packed.\n * @return result A DynamicBuffer containing the packed uint136 value.\n */"
        },
        {
            "identifier": "pBytes24",
            "parameters": "DynamicBuffer memory buffer, bytes24 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes24(DynamicBuffer memory buffer, bytes24 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 24));\n    }",
            "start": "792",
            "end": "799",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes24DynamicBuffer memory buffer, bytes24 data",
            "full_signature": "function pBytes24(DynamicBuffer memory buffer, bytes24 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes24DynamicBuffer memory buffer, bytes24 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Appends a 24-byte data chunk to a dynamic buffer.  \n *  \n * Steps:  \n * 1. Deallocate the existing result buffer to free up memory.  \n * 2. Append the 24-byte data chunk to the provided buffer using the `p` function.  \n * 3. Return the updated buffer as the result.  \n */  "
        },
        {
            "identifier": "pUint40",
            "parameters": "DynamicBuffer memory buffer, uint40 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint40(DynamicBuffer memory buffer, uint40 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 5));\n    }",
            "start": "282",
            "end": "289",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint40DynamicBuffer memory buffer, uint40 data",
            "full_signature": "function pUint40(DynamicBuffer memory buffer, uint40 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint40DynamicBuffer memory buffer, uint40 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Packs a 40-bit unsigned integer into a DynamicBuffer.  \n *  \n * Steps:  \n * 1. Deallocate the current result buffer to free up memory.  \n * 2. Pack the 40-bit unsigned integer into the buffer using the `p` function,  \n *    with the data formatted as a 5-byte sequence using `_single`.  \n * 3. Return the updated DynamicBuffer.  \n */  "
        },
        {
            "identifier": "pBytes20",
            "parameters": "DynamicBuffer memory buffer, bytes20 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes20(DynamicBuffer memory buffer, bytes20 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 20));\n    }",
            "start": "752",
            "end": "759",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes20DynamicBuffer memory buffer, bytes20 data",
            "full_signature": "function pBytes20(DynamicBuffer memory buffer, bytes20 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes20DynamicBuffer memory buffer, bytes20 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes20 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is empty.\n * 2. Append the bytes20 data to the buffer using the `p` function.\n * 3. Return the updated buffer.\n *\n * @param buffer The DynamicBuffer to which the bytes20 data will be appended.\n * @param data The bytes20 data to append to the buffer.\n * @return result The updated DynamicBuffer containing the appended data.\n */"
        },
        {
            "identifier": "pUint168",
            "parameters": "DynamicBuffer memory buffer, uint168 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint168(DynamicBuffer memory buffer, uint168 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 21));\n    }",
            "start": "442",
            "end": "449",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint168DynamicBuffer memory buffer, uint168 data",
            "full_signature": "function pUint168(DynamicBuffer memory buffer, uint168 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint168DynamicBuffer memory buffer, uint168 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 168-bit unsigned integer to a dynamic buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 168-bit unsigned integer to the buffer by calling the internal `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint88",
            "parameters": "uint88 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint88(uint88 data) internal pure returns (DynamicBuffer memory result) {\n        pUint88(result, data);\n    }",
            "start": "1013",
            "end": "1015",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint88uint88 data",
            "full_signature": "function pUint88(uint88 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint88uint88 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint88 value into a DynamicBuffer.\n * @param data The uint88 value to be packed.\n * @return result A DynamicBuffer containing the packed uint88 value.\n */"
        },
        {
            "identifier": "_single",
            "parameters": "uint256 data, uint256 n",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function _single(uint256 data, uint256 n) private pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 0x00\n            mstore(n, data)\n            mstore(result, n)\n        }\n    }",
            "start": "1295",
            "end": "1302",
            "class": "DynamicBufferLib",
            "signature": "returns (bytes memory result) _singleuint256 data, uint256 n",
            "full_signature": "function _single(uint256 data, uint256 n) private  pure returns (bytes memory result)",
            "class_method_signature": "DynamicBufferLib._singleuint256 data, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private pure function that processes a single uint256 data value and returns a bytes memory result.\n * \n * Steps:\n * 1. Initialize the result pointer to 0x00.\n * 2. Store the provided data at the memory location specified by `n`.\n * 3. Store the value of `n` at the memory location specified by the result pointer.\n * \n * @param data The uint256 data value to be processed.\n * @param n The memory location where the data is stored.\n * @return result The bytes memory result containing the stored data and `n`.\n */"
        },
        {
            "identifier": "pBytes13",
            "parameters": "bytes13 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes13(bytes13 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes13(result, data);\n    }",
            "start": "1183",
            "end": "1185",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes13bytes13 data",
            "full_signature": "function pBytes13(bytes13 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes13bytes13 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes13` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes13` with the `DynamicBuffer` and the input `bytes13` data.\n */"
        },
        {
            "identifier": "pUint192",
            "parameters": "DynamicBuffer memory buffer, uint192 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint192(DynamicBuffer memory buffer, uint192 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 24));\n    }",
            "start": "472",
            "end": "479",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint192DynamicBuffer memory buffer, uint192 data",
            "full_signature": "function pUint192(DynamicBuffer memory buffer, uint192 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint192DynamicBuffer memory buffer, uint192 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a uint192 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the uint192 value to the buffer by converting it to a 24-byte sequence.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "_deallocate",
            "parameters": "DynamicBuffer memory result",
            "modifiers": "pure",
            "return": "",
            "body": "function _deallocate(DynamicBuffer memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Deallocate, as we have already allocated.\n        }\n    }",
            "start": "1287",
            "end": "1292",
            "class": "DynamicBufferLib",
            "signature": " _deallocateDynamicBuffer memory result",
            "full_signature": "function _deallocate(DynamicBuffer memory result) private  pure",
            "class_method_signature": "DynamicBufferLib._deallocateDynamicBuffer memory result",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Deallocates memory for a DynamicBuffer.\n *\n * Steps:\n * 1. Use inline assembly to deallocate memory by resetting the free memory pointer.\n * 2. The free memory pointer is set to the address of the DynamicBuffer result.\n *\n * @dev This function is marked as private and pure, meaning it does not modify state and is only callable within the contract.\n */"
        },
        {
            "identifier": "pBytes28",
            "parameters": "DynamicBuffer memory buffer, bytes28 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes28(DynamicBuffer memory buffer, bytes28 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 28));\n    }",
            "start": "832",
            "end": "839",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes28DynamicBuffer memory buffer, bytes28 data",
            "full_signature": "function pBytes28(DynamicBuffer memory buffer, bytes28 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes28DynamicBuffer memory buffer, bytes28 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Appends a 28-byte data chunk to a dynamic buffer.  \n *  \n * Steps:  \n * 1. Deallocate the current result buffer to free up memory.  \n * 2. Append the 28-byte data chunk to the provided buffer using the `p` function.  \n * 3. Return the updated buffer as the result.  \n */  "
        },
        {
            "identifier": "pBytes15",
            "parameters": "DynamicBuffer memory buffer, bytes15 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes15(DynamicBuffer memory buffer, bytes15 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 15));\n    }",
            "start": "702",
            "end": "709",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes15DynamicBuffer memory buffer, bytes15 data",
            "full_signature": "function pBytes15(DynamicBuffer memory buffer, bytes15 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes15DynamicBuffer memory buffer, bytes15 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes15 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the bytes15 data to the buffer by converting it to a bytes32 value and truncating to 15 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes14",
            "parameters": "bytes14 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes14(bytes14 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes14(result, data);\n    }",
            "start": "1188",
            "end": "1190",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes14bytes14 data",
            "full_signature": "function pBytes14(bytes14 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes14bytes14 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes14` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes14` with the `DynamicBuffer` and the input data.\n */"
        },
        {
            "identifier": "pUint152",
            "parameters": "DynamicBuffer memory buffer, uint152 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint152(DynamicBuffer memory buffer, uint152 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 19));\n    }",
            "start": "422",
            "end": "429",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint152DynamicBuffer memory buffer, uint152 data",
            "full_signature": "function pUint152(DynamicBuffer memory buffer, uint152 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint152DynamicBuffer memory buffer, uint152 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint152 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is empty.\n * 2. Pack the uint152 value into the buffer using the `_single` function with a length of 19 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint104",
            "parameters": "uint104 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint104(uint104 data) internal pure returns (DynamicBuffer memory result) {\n        pUint104(result, data);\n    }",
            "start": "1023",
            "end": "1025",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint104uint104 data",
            "full_signature": "function pUint104(uint104 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint104uint104 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint104 value into a DynamicBuffer.\n * @param data The uint104 value to be packed.\n * @return result A DynamicBuffer containing the packed uint104 value.\n */"
        },
        {
            "identifier": "pBytes8",
            "parameters": "DynamicBuffer memory buffer, bytes8 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes8(DynamicBuffer memory buffer, bytes8 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 8));\n    }",
            "start": "632",
            "end": "639",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes8DynamicBuffer memory buffer, bytes8 data",
            "full_signature": "function pBytes8(DynamicBuffer memory buffer, bytes8 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes8DynamicBuffer memory buffer, bytes8 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes8 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is empty.\n * 2. Append the bytes8 value to the buffer by converting it to a bytes32 value and slicing it to 8 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes9",
            "parameters": "bytes9 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes9(bytes9 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes9(result, data);\n    }",
            "start": "1163",
            "end": "1165",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes9bytes9 data",
            "full_signature": "function pBytes9(bytes9 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes9bytes9 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a bytes9 value into a DynamicBuffer.\n * @param data The bytes9 value to be packed.\n * @return result A DynamicBuffer containing the packed bytes9 value.\n */"
        },
        {
            "identifier": "pBytes30",
            "parameters": "bytes30 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes30(bytes30 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes30(result, data);\n    }",
            "start": "1268",
            "end": "1270",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes30bytes30 data",
            "full_signature": "function pBytes30(bytes30 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes30bytes30 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes30` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes30` with the `DynamicBuffer` and the input `bytes30` data.\n */"
        },
        {
            "identifier": "pBytes24",
            "parameters": "bytes24 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes24(bytes24 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes24(result, data);\n    }",
            "start": "1238",
            "end": "1240",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes24bytes24 data",
            "full_signature": "function pBytes24(bytes24 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes24bytes24 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes24` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes24` with the `DynamicBuffer` and the input data.\n */"
        },
        {
            "identifier": "pBytes5",
            "parameters": "bytes5 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes5(bytes5 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes5(result, data);\n    }",
            "start": "1143",
            "end": "1145",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes5bytes5 data",
            "full_signature": "function pBytes5(bytes5 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes5bytes5 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes5` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes5` with the `DynamicBuffer` and `bytes5` data as arguments.\n */"
        },
        {
            "identifier": "pBytes21",
            "parameters": "bytes21 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes21(bytes21 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes21(result, data);\n    }",
            "start": "1223",
            "end": "1225",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes21bytes21 data",
            "full_signature": "function pBytes21(bytes21 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes21bytes21 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes21` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes21` with the `DynamicBuffer` and the input data.\n */"
        },
        {
            "identifier": "pUint216",
            "parameters": "DynamicBuffer memory buffer, uint216 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint216(DynamicBuffer memory buffer, uint216 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 27));\n    }",
            "start": "502",
            "end": "509",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint216DynamicBuffer memory buffer, uint216 data",
            "full_signature": "function pUint216(DynamicBuffer memory buffer, uint216 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint216DynamicBuffer memory buffer, uint216 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint216 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Pack the uint216 data into the buffer using the `p` function, with a fixed length of 27 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint208",
            "parameters": "DynamicBuffer memory buffer, uint208 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint208(DynamicBuffer memory buffer, uint208 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 26));\n    }",
            "start": "492",
            "end": "499",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint208DynamicBuffer memory buffer, uint208 data",
            "full_signature": "function pUint208(DynamicBuffer memory buffer, uint208 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint208DynamicBuffer memory buffer, uint208 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a uint208 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Appends the uint208 value to the buffer by calling the internal `p` function.\n * 3. Returns the updated buffer.\n *\n * @param buffer The DynamicBuffer to which the uint208 value is appended.\n * @param data The uint208 value to append.\n * @return result The updated DynamicBuffer with the appended uint208 value.\n */"
        },
        {
            "identifier": "pUint80",
            "parameters": "DynamicBuffer memory buffer, uint80 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint80(DynamicBuffer memory buffer, uint80 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 10));\n    }",
            "start": "332",
            "end": "339",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint80DynamicBuffer memory buffer, uint80 data",
            "full_signature": "function pUint80(DynamicBuffer memory buffer, uint80 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint80DynamicBuffer memory buffer, uint80 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint80 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the current result buffer.\n * 2. Pack the uint80 value into the buffer using the `_single` function with a fixed length of 10.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint24",
            "parameters": "uint24 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint24(uint24 data) internal pure returns (DynamicBuffer memory result) {\n        pUint24(result, data);\n    }",
            "start": "973",
            "end": "975",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint24uint24 data",
            "full_signature": "function pUint24(uint24 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint24uint24 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint24 value into a DynamicBuffer.\n * @param data The uint24 value to be packed.\n * @return result A DynamicBuffer containing the packed uint24 value.\n */"
        },
        {
            "identifier": "pUint112",
            "parameters": "DynamicBuffer memory buffer, uint112 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint112(DynamicBuffer memory buffer, uint112 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 14));\n    }",
            "start": "372",
            "end": "379",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint112DynamicBuffer memory buffer, uint112 data",
            "full_signature": "function pUint112(DynamicBuffer memory buffer, uint112 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint112DynamicBuffer memory buffer, uint112 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Packs a uint112 value into a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocates the memory of the result buffer.\n * 2. Packs the uint112 data into the buffer using the `p` function.\n * 3. Returns the updated buffer.\n */"
        },
        {
            "identifier": "pBytes12",
            "parameters": "bytes12 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes12(bytes12 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes12(result, data);\n    }",
            "start": "1178",
            "end": "1180",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes12bytes12 data",
            "full_signature": "function pBytes12(bytes12 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes12bytes12 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes12` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes12` with the `DynamicBuffer` result and the input `bytes12` data.\n */"
        },
        {
            "identifier": "pBytes7",
            "parameters": "DynamicBuffer memory buffer, bytes7 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes7(DynamicBuffer memory buffer, bytes7 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 7));\n    }",
            "start": "622",
            "end": "629",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes7DynamicBuffer memory buffer, bytes7 data",
            "full_signature": "function pBytes7(DynamicBuffer memory buffer, bytes7 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes7DynamicBuffer memory buffer, bytes7 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes7 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is empty.\n * 2. Append the bytes7 data to the buffer by converting it to a bytes32 value and truncating it to 7 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint72",
            "parameters": "DynamicBuffer memory buffer, uint72 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint72(DynamicBuffer memory buffer, uint72 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 9));\n    }",
            "start": "322",
            "end": "329",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint72DynamicBuffer memory buffer, uint72 data",
            "full_signature": "function pUint72(DynamicBuffer memory buffer, uint72 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint72DynamicBuffer memory buffer, uint72 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Packs a 72-bit unsigned integer (`data`) into a `DynamicBuffer`.  \n *  \n * Steps:  \n * 1. Deallocate the memory of the `result` buffer.  \n * 2. Pack the 72-bit unsigned integer into the buffer using the `_single` helper function with a size of 9 bytes.  \n * 3. Return the updated `DynamicBuffer`.  \n */  "
        },
        {
            "identifier": "pBytes11",
            "parameters": "bytes11 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes11(bytes11 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes11(result, data);\n    }",
            "start": "1173",
            "end": "1175",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes11bytes11 data",
            "full_signature": "function pBytes11(bytes11 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes11bytes11 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes11` input and returns a `DynamicBuffer` memory result.\n * \n * Steps:\n * 1. Calls the `pBytes11` function with the `result` and `data` parameters.\n * 2. Returns the `DynamicBuffer` memory result.\n */"
        },
        {
            "identifier": "pUint16",
            "parameters": "uint16 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint16(uint16 data) internal pure returns (DynamicBuffer memory result) {\n        pUint16(result, data);\n    }",
            "start": "968",
            "end": "970",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint16uint16 data",
            "full_signature": "function pUint16(uint16 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint16uint16 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to pack a uint16 value into a DynamicBuffer.\n * @param data The uint16 value to be packed.\n * @return result A DynamicBuffer containing the packed uint16 value.\n */"
        },
        {
            "identifier": "pBytes15",
            "parameters": "bytes15 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes15(bytes15 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes15(result, data);\n    }",
            "start": "1193",
            "end": "1195",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes15bytes15 data",
            "full_signature": "function pBytes15(bytes15 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes15bytes15 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes15` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes15` with the `DynamicBuffer` and `bytes15` data as arguments.\n */"
        },
        {
            "identifier": "pBytes29",
            "parameters": "DynamicBuffer memory buffer, bytes29 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes29(DynamicBuffer memory buffer, bytes29 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 29));\n    }",
            "start": "842",
            "end": "849",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes29DynamicBuffer memory buffer, bytes29 data",
            "full_signature": "function pBytes29(DynamicBuffer memory buffer, bytes29 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes29DynamicBuffer memory buffer, bytes29 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a 29-byte slice (bytes29) to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Append the 29-byte slice to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint200",
            "parameters": "uint200 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint200(uint200 data) internal pure returns (DynamicBuffer memory result) {\n        pUint200(result, data);\n    }",
            "start": "1083",
            "end": "1085",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint200uint200 data",
            "full_signature": "function pUint200(uint200 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint200uint200 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to pack a uint200 value into a DynamicBuffer.\n * @param data The uint200 value to be packed.\n * @return result A DynamicBuffer containing the packed uint200 value.\n */"
        },
        {
            "identifier": "pBytes16",
            "parameters": "bytes16 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes16(bytes16 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes16(result, data);\n    }",
            "start": "1198",
            "end": "1200",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes16bytes16 data",
            "full_signature": "function pBytes16(bytes16 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes16bytes16 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes16` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes16` with the `DynamicBuffer` and `bytes16` data as arguments.\n */"
        },
        {
            "identifier": "pBytes17",
            "parameters": "bytes17 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes17(bytes17 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes17(result, data);\n    }",
            "start": "1203",
            "end": "1205",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes17bytes17 data",
            "full_signature": "function pBytes17(bytes17 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes17bytes17 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function that takes a `bytes17` input and returns a `DynamicBuffer` memory result.\n * The function internally calls another function `pBytes17` with the `DynamicBuffer` and `bytes17` data as arguments.\n */"
        },
        {
            "identifier": "pUint120",
            "parameters": "DynamicBuffer memory buffer, uint120 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint120(DynamicBuffer memory buffer, uint120 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 15));\n    }",
            "start": "382",
            "end": "389",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint120DynamicBuffer memory buffer, uint120 data",
            "full_signature": "function pUint120(DynamicBuffer memory buffer, uint120 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint120DynamicBuffer memory buffer, uint120 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " \n/**  \n * @notice Packs a 120-bit unsigned integer into a DynamicBuffer.  \n *  \n * Steps:  \n * 1. Deallocate the result buffer to ensure it is clean.  \n * 2. Pack the 120-bit unsigned integer into the buffer using the `p` function,  \n *    with the data formatted as a single 15-byte chunk.  \n *  \n * @param buffer The DynamicBuffer to which the data will be appended.  \n * @param data The 120-bit unsigned integer to be packed.  \n * @return result The updated DynamicBuffer containing the packed data.  \n */  "
        },
        {
            "identifier": "pUint240",
            "parameters": "uint240 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint240(uint240 data) internal pure returns (DynamicBuffer memory result) {\n        pUint240(result, data);\n    }",
            "start": "1108",
            "end": "1110",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint240uint240 data",
            "full_signature": "function pUint240(uint240 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint240uint240 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to pack a uint240 value into a DynamicBuffer.\n * @param data The uint240 value to be packed.\n * @return result A DynamicBuffer containing the packed uint240 value.\n */"
        },
        {
            "identifier": "pBytes8",
            "parameters": "bytes8 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes8(bytes8 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes8(result, data);\n    }",
            "start": "1158",
            "end": "1160",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes8bytes8 data",
            "full_signature": "function pBytes8(bytes8 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes8bytes8 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to convert a `bytes8` value into a `DynamicBuffer`.\n * \n * @param data The `bytes8` value to be converted.\n * @return result A `DynamicBuffer` containing the converted data.\n */"
        },
        {
            "identifier": "pBytes27",
            "parameters": "DynamicBuffer memory buffer, bytes27 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes27(DynamicBuffer memory buffer, bytes27 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 27));\n    }",
            "start": "822",
            "end": "829",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes27DynamicBuffer memory buffer, bytes27 data",
            "full_signature": "function pBytes27(DynamicBuffer memory buffer, bytes27 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes27DynamicBuffer memory buffer, bytes27 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Appends a bytes27 value to a DynamicBuffer.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is empty.\n * 2. Append the bytes27 data to the buffer using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes28",
            "parameters": "bytes28 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes28(bytes28 data) internal pure returns (DynamicBuffer memory result) {\n        pBytes28(result, data);\n    }",
            "start": "1258",
            "end": "1260",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes28bytes28 data",
            "full_signature": "function pBytes28(bytes28 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes28bytes28 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal pure function to convert a bytes28 value into a DynamicBuffer.\n * @param data The bytes28 value to be converted.\n * @return result A DynamicBuffer containing the converted bytes28 data.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/UpgradeableBeacon.sol": [
        {
            "identifier": "_setImplementation",
            "parameters": "address newImplementation",
            "modifiers": "",
            "return": "",
            "body": "function _setImplementation(address newImplementation) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clean the upper 96 bits.\n            if iszero(extcodesize(newImplementation)) {\n                mstore(0x00, 0x6d3e283b) // `NewImplementationHasNoCode()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT, newImplementation) // Store the implementation.\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n        }\n    }",
            "start": "104",
            "end": "116",
            "class": "UpgradeableBeacon",
            "signature": " _setImplementationaddress newImplementation",
            "full_signature": "function _setImplementation(address newImplementation) internal virtual",
            "class_method_signature": "UpgradeableBeacon._setImplementationaddress newImplementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to set a new implementation address for an upgradeable beacon.\n * \n * Steps:\n * 1. Clean the upper 96 bits of the new implementation address to ensure it is properly formatted.\n * 2. Check if the new implementation address contains code. If not, revert with an error message.\n * 3. Store the new implementation address in the designated storage slot.\n * 4. Emit an `Upgraded` event to log the change of implementation.\n *\n * @param newImplementation The address of the new implementation to be set.\n */"
        },
        {
            "identifier": "owner",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function owner() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_UPGRADEABLE_BEACON_OWNER_SLOT)\n        }\n    }",
            "start": "140",
            "end": "145",
            "class": "UpgradeableBeacon",
            "signature": "returns (address result) owner",
            "full_signature": "function owner() public  view returns (address result)",
            "class_method_signature": "UpgradeableBeacon.owner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the address of the owner stored in the contract's storage.\n * \n * Steps:\n * 1. Uses inline assembly to read the owner address from the storage slot `_UPGRADEABLE_BEACON_OWNER_SLOT`.\n * 2. Returns the retrieved address as the result.\n */"
        },
        {
            "identifier": "_OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE =\n        0x8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e0;",
            "start": "56",
            "end": "57",
            "class": "UpgradeableBeacon",
            "signature": "uint256 _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE",
            "full_signature": "uint256 private constant _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE",
            "class_method_signature": "UpgradeableBeacon._OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the event signature for the ownership transferred event.\n * The value is the keccak256 hash of the event signature \"OwnershipTransferred(address,address)\".\n */"
        },
        {
            "identifier": "renounceOwnership",
            "parameters": "",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function renounceOwnership() public virtual onlyOwner {\n        _setOwner(address(0));\n    }",
            "start": "165",
            "end": "167",
            "class": "UpgradeableBeacon",
            "signature": " renounceOwnership",
            "full_signature": "function renounceOwnership() public virtual onlyOwner",
            "class_method_signature": "UpgradeableBeacon.renounceOwnership",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Allows the current owner to renounce ownership of the contract.\n * @dev This function can only be called by the current owner. After calling this function,\n * the contract will no longer have an owner, and ownership-related functions will be disabled.\n */"
        },
        {
            "identifier": "onlyOwner",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyOwner() virtual {\n        _checkOwner();\n        _;\n    }",
            "start": "186",
            "end": "189",
            "class": "UpgradeableBeacon",
            "signature": " onlyOwner",
            "full_signature": "function onlyOwner()  virtual",
            "class_method_signature": "UpgradeableBeacon.onlyOwner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that restricts access to the owner of the contract.\n * \n * Steps:\n * 1. Calls the internal `_checkOwner()` function to verify if the caller is the owner.\n * 2. If the caller is the owner, the function proceeds with the rest of the code.\n */"
        },
        {
            "identifier": "upgradeTo",
            "parameters": "address newImplementation",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function upgradeTo(address newImplementation) public virtual onlyOwner {\n        _setImplementation(newImplementation);\n    }",
            "start": "148",
            "end": "150",
            "class": "UpgradeableBeacon",
            "signature": " upgradeToaddress newImplementation",
            "full_signature": "function upgradeTo(address newImplementation) public virtual onlyOwner",
            "class_method_signature": "UpgradeableBeacon.upgradeToaddress newImplementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Upgrades the contract to a new implementation address.\n * @dev This function can only be called by the owner.\n * @param newImplementation The address of the new implementation to upgrade to.\n */"
        },
        {
            "identifier": "_UPGRADEABLE_BEACON_OWNER_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _UPGRADEABLE_BEACON_OWNER_SLOT = 0x4343a0dc92ed22dbfc;",
            "start": "69",
            "end": "69",
            "class": "UpgradeableBeacon",
            "signature": "uint256 _UPGRADEABLE_BEACON_OWNER_SLOT",
            "full_signature": "uint256 internal constant _UPGRADEABLE_BEACON_OWNER_SLOT",
            "class_method_signature": "UpgradeableBeacon._UPGRADEABLE_BEACON_OWNER_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the storage slot for the owner of an upgradeable beacon.\n * This slot is used to store the address of the owner who has the authority to upgrade the beacon.\n */"
        },
        {
            "identifier": "_constructUpgradeableBeacon",
            "parameters": "address initialOwner, address initialImplementation",
            "modifiers": "",
            "return": "",
            "body": "function _constructUpgradeableBeacon(address initialOwner, address initialImplementation)\n        internal\n        virtual\n    {\n        _initializeUpgradeableBeacon(initialOwner, initialImplementation);\n    }",
            "start": "80",
            "end": "85",
            "class": "UpgradeableBeacon",
            "signature": " _constructUpgradeableBeaconaddress initialOwner, address initialImplementation",
            "full_signature": "function _constructUpgradeableBeacon(address initialOwner, address initialImplementation) internal virtual",
            "class_method_signature": "UpgradeableBeacon._constructUpgradeableBeaconaddress initialOwner, address initialImplementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Constructs an upgradeable beacon with the specified initial owner and implementation.\n *\n * @param initialOwner The address of the initial owner of the beacon.\n * @param initialImplementation The address of the initial implementation contract.\n *\n * This function is internal and virtual, allowing it to be overridden by derived contracts.\n * It initializes the upgradeable beacon with the provided owner and implementation addresses.\n */"
        },
        {
            "identifier": "_setOwner",
            "parameters": "address newOwner",
            "modifiers": "",
            "return": "",
            "body": "function _setOwner(address newOwner) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            newOwner := shr(96, shl(96, newOwner)) // Clean the upper 96 bits.\n            let oldOwner := sload(_UPGRADEABLE_BEACON_OWNER_SLOT)\n            sstore(_UPGRADEABLE_BEACON_OWNER_SLOT, newOwner) // Store the owner.\n            // Emit the {OwnershipTransferred} event.\n            log3(codesize(), 0x00, _OWNERSHIP_TRANSFERRED_EVENT_SIGNATURE, oldOwner, newOwner)\n        }\n    }",
            "start": "119",
            "end": "128",
            "class": "UpgradeableBeacon",
            "signature": " _setOwneraddress newOwner",
            "full_signature": "function _setOwner(address newOwner) internal virtual",
            "class_method_signature": "UpgradeableBeacon._setOwneraddress newOwner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to set a new owner for the contract.\n *\n * Steps:\n * 1. Clean the upper 96 bits of the new owner address to ensure it is properly formatted.\n * 2. Load the current owner from storage.\n * 3. Store the new owner in the designated storage slot.\n * 4. Emit the {OwnershipTransferred} event with the old and new owner addresses.\n */"
        },
        {
            "identifier": "implementation",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function implementation() public view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT)\n        }\n    }",
            "start": "132",
            "end": "137",
            "class": "UpgradeableBeacon",
            "signature": "returns (address result) implementation",
            "full_signature": "function implementation() public  view returns (address result)",
            "class_method_signature": "UpgradeableBeacon.implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the implementation address stored in the specified storage slot.\n * \n * Steps:\n * 1. Use inline assembly to load the value from the storage slot `_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT`.\n * 2. Return the loaded value as the result.\n */"
        },
        {
            "identifier": "NewOwnerIsZeroAddress",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error NewOwnerIsZeroAddress();",
            "start": "36",
            "end": "36",
            "class": "UpgradeableBeacon",
            "signature": " NewOwnerIsZeroAddress",
            "full_signature": "function NewOwnerIsZeroAddress()",
            "class_method_signature": "UpgradeableBeacon.NewOwnerIsZeroAddress",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the new owner address provided is the zero address.\n * This error is typically thrown when an operation attempts to set the owner to an invalid (zero) address.\n */"
        },
        {
            "identifier": "_UPGRADED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _UPGRADED_EVENT_SIGNATURE =\n        0xbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b;",
            "start": "52",
            "end": "53",
            "class": "UpgradeableBeacon",
            "signature": "uint256 _UPGRADED_EVENT_SIGNATURE",
            "full_signature": "uint256 private constant _UPGRADED_EVENT_SIGNATURE",
            "class_method_signature": "UpgradeableBeacon._UPGRADED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant variable that stores the event signature for an upgrade event.\n * The value is a keccak256 hash of the event signature, which is used to identify the event in logs.\n */"
        },
        {
            "identifier": "OwnershipTransferred",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "event OwnershipTransferred(address indexed oldOwner, address indexed newOwner);",
            "start": "49",
            "end": "49",
            "class": "UpgradeableBeacon",
            "signature": " OwnershipTransferred",
            "full_signature": "function OwnershipTransferred()",
            "class_method_signature": "UpgradeableBeacon.OwnershipTransferred",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Emitted when ownership is transferred from one address to another.\n * @param oldOwner The address of the previous owner.\n * @param newOwner The address of the new owner.\n */"
        },
        {
            "identifier": "Unauthorized",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error Unauthorized();",
            "start": "33",
            "end": "33",
            "class": "UpgradeableBeacon",
            "signature": " Unauthorized",
            "full_signature": "function Unauthorized()",
            "class_method_signature": "UpgradeableBeacon.Unauthorized",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error to indicate unauthorized access or action.\n * This error is thrown when a function or operation is attempted by an unauthorized entity.\n */"
        },
        {
            "identifier": "_initializeUpgradeableBeacon",
            "parameters": "address initialOwner, address initialImplementation",
            "modifiers": "",
            "return": "",
            "body": "function _initializeUpgradeableBeacon(address initialOwner, address initialImplementation)\n        internal\n        virtual\n    {\n        // We don't need to check if `initialOwner` is the zero address here,\n        // as some use cases may not want the beacon to be owned.\n        _setOwner(initialOwner);\n        _setImplementation(initialImplementation);\n    }",
            "start": "93",
            "end": "101",
            "class": "UpgradeableBeacon",
            "signature": " _initializeUpgradeableBeaconaddress initialOwner, address initialImplementation",
            "full_signature": "function _initializeUpgradeableBeacon(address initialOwner, address initialImplementation) internal virtual",
            "class_method_signature": "UpgradeableBeacon._initializeUpgradeableBeaconaddress initialOwner, address initialImplementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Initializes an upgradeable beacon with the given owner and implementation.\n *\n * Steps:\n * 1. Sets the owner of the beacon to `initialOwner`.\n * 2. Sets the implementation of the beacon to `initialImplementation`.\n *\n * @dev No zero address check is performed for `initialOwner` as some use cases may not require the beacon to be owned.\n *\n * @param initialOwner The address of the initial owner of the beacon.\n * @param initialImplementation The address of the initial implementation of the beacon.\n */"
        },
        {
            "identifier": "NewImplementationHasNoCode",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error NewImplementationHasNoCode();",
            "start": "30",
            "end": "30",
            "class": "UpgradeableBeacon",
            "signature": " NewImplementationHasNoCode",
            "full_signature": "function NewImplementationHasNoCode()",
            "class_method_signature": "UpgradeableBeacon.NewImplementationHasNoCode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": " error indicating that the new implementation contract has no code.\n * This error is typically thrown when attempting to upgrade to a new implementation\n * that does not contain any executable code.\n */"
        },
        {
            "identifier": "_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT = 0x911c5a209f08d5ec5e;",
            "start": "65",
            "end": "65",
            "class": "UpgradeableBeacon",
            "signature": "uint256 _UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT",
            "full_signature": "uint256 internal constant _UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT",
            "class_method_signature": "UpgradeableBeacon._UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant internal variable `_UPGRADEABLE_BEACON_IMPLEMENTATION_SLOT` with a specific slot value.\n * This slot is typically used in upgradeable beacon patterns to store the implementation address.\n */"
        },
        {
            "identifier": "Upgraded",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "event Upgraded(address indexed implementation);",
            "start": "43",
            "end": "43",
            "class": "UpgradeableBeacon",
            "signature": " Upgraded",
            "full_signature": "function Upgraded()",
            "class_method_signature": "UpgradeableBeacon.Upgraded",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Emitted when the contract is upgraded to a new implementation.\n * @param implementation The address of the new implementation contract.\n */"
        },
        {
            "identifier": "transferOwnership",
            "parameters": "address newOwner",
            "modifiers": "onlyOwner",
            "return": "",
            "body": "function transferOwnership(address newOwner) public virtual onlyOwner {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(shl(96, newOwner)) {\n                mstore(0x00, 0x7448fbae) // `NewOwnerIsZeroAddress()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _setOwner(newOwner);\n    }",
            "start": "153",
            "end": "162",
            "class": "UpgradeableBeacon",
            "signature": " transferOwnershipaddress newOwner",
            "full_signature": "function transferOwnership(address newOwner) public virtual onlyOwner",
            "class_method_signature": "UpgradeableBeacon.transferOwnershipaddress newOwner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Transfers ownership of the contract to a new address.\n * @dev This function can only be called by the current owner.\n * @param newOwner The address of the new owner.\n * \n * Steps:\n * 1. Check if the new owner address is not zero.\n * 2. If the new owner address is zero, revert with the error `NewOwnerIsZeroAddress()`.\n * 3. If the new owner address is valid, call the internal `_setOwner` function to update the owner.\n */"
        },
        {
            "identifier": "_checkOwner",
            "parameters": "",
            "modifiers": "view",
            "return": "",
            "body": "function _checkOwner() internal view virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the caller is not the stored owner, revert.\n            if iszero(eq(caller(), sload(_UPGRADEABLE_BEACON_OWNER_SLOT))) {\n                mstore(0x00, 0x82b42900) // `Unauthorized()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "170",
            "end": "179",
            "class": "UpgradeableBeacon",
            "signature": " _checkOwner",
            "full_signature": "function _checkOwner() internal virtual view",
            "class_method_signature": "UpgradeableBeacon._checkOwner",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to check if the caller is the owner.\n *\n * Steps:\n * 1. Use inline assembly to compare the caller's address with the stored owner's address.\n * 2. If the caller is not the owner, revert with the `Unauthorized()` error.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/Lifebuoy.sol": [
        {
            "identifier": "onlyRescuer",
            "parameters": "uint256 modeLock",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyRescuer(uint256 modeLock) virtual {\n        _checkRescuer(modeLock);\n        _;\n    }",
            "start": "312",
            "end": "315",
            "class": "Lifebuoy",
            "signature": " onlyRescueruint256 modeLock",
            "full_signature": "function onlyRescuer(uint256 modeLock)  virtual",
            "class_method_signature": "Lifebuoy.onlyRescueruint256 modeLock",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Modifier to restrict access to functions that can only be called by a rescuer.\n * @dev This modifier checks if the caller is a rescuer by calling the `_checkRescuer` function.\n * @param modeLock The mode lock parameter used to validate the rescuer.\n */"
        },
        {
            "identifier": "_lifebuoyDefaultDeployer",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (address)",
            "body": "function _lifebuoyDefaultDeployer() internal view virtual returns (address) {\n        // I know about EIP7645, and I will stop it if it gets traction.\n        // Worse case, I will add an `ecrecover` method. But not today.\n        return tx.origin;\n    }",
            "start": "121",
            "end": "125",
            "class": "Lifebuoy",
            "signature": "returns (address) _lifebuoyDefaultDeployer",
            "full_signature": "function _lifebuoyDefaultDeployer() internal virtual view returns (address)",
            "class_method_signature": "Lifebuoy._lifebuoyDefaultDeployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the address of the transaction originator (tx.origin).\n * @dev This function is a placeholder and may be updated in the future to handle EIP7645 or include an `ecrecover` method.\n * @return The address of the transaction originator.\n */"
        },
        {
            "identifier": "_LIFEBUOY_RESCUE_ERC6909_LOCK",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _LIFEBUOY_RESCUE_ERC6909_LOCK = 1 << 7;",
            "start": "77",
            "end": "77",
            "class": "Lifebuoy",
            "signature": "uint256 _LIFEBUOY_RESCUE_ERC6909_LOCK",
            "full_signature": "uint256 internal constant _LIFEBUOY_RESCUE_ERC6909_LOCK",
            "class_method_signature": "Lifebuoy._LIFEBUOY_RESCUE_ERC6909_LOCK",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing a bitmask for the Lifebuoy Rescue ERC6909 lock.\n * The value is a bitwise shift of 1 by 7 positions, resulting in the binary value 10000000.\n */"
        },
        {
            "identifier": "_checkRescuer",
            "parameters": "uint256 modeLock",
            "modifiers": "view",
            "return": "",
            "body": "function _checkRescuer(uint256 modeLock) internal view virtual {\n        uint256 locks = rescueLocked();\n        bytes32 h = _lifebuoyDeployerHash;\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // If the `modeLock` flag is true, set all bits in `locks` to true.\n                locks := or(sub(0, iszero(iszero(and(modeLock, locks)))), locks)\n                // Caller is the deployer\n                // AND the contract is not a proxy\n                // AND `locks & _LIFEBUOY_DEPLOYER_ACCESS_LOCK` is false.\n                mstore(0x20, caller())\n                mstore(and(locks, _LIFEBUOY_DEPLOYER_ACCESS_LOCK), address())\n                if eq(keccak256(0x00, 0x40), h) { break }\n                // If the caller is `owner()`\n                // AND `locks & _LIFEBUOY_OWNER_ACCESS_LOCK` is false.\n                mstore(0x08, 0x8da5cb5b0a0362e0) // `owner()` and `RescueUnauthorizedOrLocked()`.\n                if and( // The arguments of `and` are evaluated from right to left.\n                    lt(\n                        and(locks, _LIFEBUOY_OWNER_ACCESS_LOCK),\n                        and(gt(returndatasize(), 0x1f), eq(mload(0x00), caller()))\n                    ),\n                    staticcall(gas(), address(), 0x20, 0x04, 0x00, 0x20)\n                ) { break }\n                revert(0x24, 0x04)\n            }\n        }\n    }",
            "start": "282",
            "end": "309",
            "class": "Lifebuoy",
            "signature": " _checkRescueruint256 modeLock",
            "full_signature": "function _checkRescuer(uint256 modeLock) internal virtual view",
            "class_method_signature": "Lifebuoy._checkRescueruint256 modeLock",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to check if the caller is authorized to perform a rescue operation.\n * \n * Steps:\n * 1. Retrieve the current rescue locks.\n * 2. Use assembly to perform low-level checks:\n *    - If `modeLock` flag is true, set all bits in `locks` to true.\n *    - Check if the caller is the deployer and the contract is not a proxy.\n *    - If the caller is the deployer and the contract is not a proxy, and the `locks & _LIFEBUOY_DEPLOYER_ACCESS_LOCK` is false, break the loop.\n *    - If the caller is the owner and `locks & _LIFEBUOY_OWNER_ACCESS_LOCK` is false, break the loop.\n * 3. If none of the conditions are met, revert with an error.\n */"
        },
        {
            "identifier": "_lockRescue",
            "parameters": "uint256 locksToSet",
            "modifiers": "",
            "return": "",
            "body": "function _lockRescue(uint256 locksToSet) internal virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := _RESCUE_LOCKED_FLAGS_SLOT\n            sstore(s, or(sload(s), locksToSet))\n        }\n    }",
            "start": "269",
            "end": "275",
            "class": "Lifebuoy",
            "signature": " _lockRescueuint256 locksToSet",
            "full_signature": "function _lockRescue(uint256 locksToSet) internal virtual",
            "class_method_signature": "Lifebuoy._lockRescueuint256 locksToSet",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to lock rescue operations by setting specific flags.\n * \n * @param locksToSet The flags to set for locking rescue operations.\n * \n * Steps:\n * 1. Use inline assembly to safely interact with storage.\n * 2. Load the current value from the storage slot `_RESCUE_LOCKED_FLAGS_SLOT`.\n * 3. Perform a bitwise OR operation with `locksToSet` to set the new flags.\n * 4. Store the updated value back into the storage slot.\n */"
        },
        {
            "identifier": "_LIFEBUOY_RESCUE_ERC1155_LOCK",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant _LIFEBUOY_RESCUE_ERC1155_LOCK = 1 << 6;",
            "start": "74",
            "end": "74",
            "class": "Lifebuoy",
            "signature": "uint256 _LIFEBUOY_RESCUE_ERC1155_LOCK",
            "full_signature": "uint256 internal constant _LIFEBUOY_RESCUE_ERC1155_LOCK",
            "class_method_signature": "Lifebuoy._LIFEBUOY_RESCUE_ERC1155_LOCK",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing a bitmask for the ERC1155 rescue lock.\n * This constant is used to manage specific states or permissions related to ERC1155 token rescues.\n */"
        },
        {
            "identifier": "rescueLocked",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint256 locks)",
            "body": "function rescueLocked() public view virtual returns (uint256 locks) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            locks := sload(_RESCUE_LOCKED_FLAGS_SLOT)\n        }\n    }",
            "start": "251",
            "end": "256",
            "class": "Lifebuoy",
            "signature": "returns (uint256 locks) rescueLocked",
            "full_signature": "function rescueLocked() public virtual view returns (uint256 locks)",
            "class_method_signature": "Lifebuoy.rescueLocked",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the locked flags for rescue operations.\n *\n * Steps:\n * 1. Use inline assembly to load the value stored at the `_RESCUE_LOCKED_FLAGS_SLOT` storage slot.\n * 2. Return the loaded value as the number of locks.\n */"
        },
        {
            "identifier": "_lifebuoyDeployerHash",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal immutable _lifebuoyDeployerHash;",
            "start": "86",
            "end": "86",
            "class": "Lifebuoy",
            "signature": "bytes32 _lifebuoyDeployerHash",
            "full_signature": "bytes32 internal  _lifebuoyDeployerHash",
            "class_method_signature": "Lifebuoy._lifebuoyDeployerHash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice An internal immutable variable that stores the hash of the deployer address for the Lifebuoy contract.\n * This is typically used for access control or verification purposes.\n */"
        },
        {
            "identifier": "_RESCUE_LOCKED_FLAGS_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant _RESCUE_LOCKED_FLAGS_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffb8e2915b;",
            "start": "98",
            "end": "99",
            "class": "Lifebuoy",
            "signature": "bytes32 _RESCUE_LOCKED_FLAGS_SLOT",
            "full_signature": "bytes32 internal constant _RESCUE_LOCKED_FLAGS_SLOT",
            "class_method_signature": "Lifebuoy._RESCUE_LOCKED_FLAGS_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "s a constant `_RESCUE_LOCKED_FLAGS_SLOT` with a specific bytes32 value.\n * This value is likely used as a storage slot identifier for managing rescue-related flags or states in the contract.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibRLP.sol": [
        {
            "identifier": "_updateTail",
            "parameters": "List memory list, List memory result",
            "modifiers": "pure",
            "return": "",
            "body": "function _updateTail(List memory list, List memory result) private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let v := or(shr(mload(list), result), mload(list))\n            let tail := shr(40, v)\n            mstore(list, xor(shl(40, xor(tail, result)), v)) // Update the tail.\n            mstore(tail, or(mload(tail), result)) // Make the previous tail point to `result`.\n        }\n    }",
            "start": "382",
            "end": "390",
            "class": "LibRLP",
            "signature": " _updateTailList memory list, List memory result",
            "full_signature": "function _updateTail(List memory list, List memory result) private  pure",
            "class_method_signature": "LibRLP._updateTailList memory list, List memory result",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Updates the tail of a linked list in memory.\n *\n * Steps:\n * 1. Perform bitwise operations to calculate the new tail value.\n * 2. Update the tail of the list by storing the new tail value.\n * 3. Make the previous tail point to the new result.\n *\n * @dev This function uses inline assembly for low-level memory manipulation.\n * @param list The original list whose tail is to be updated.\n * @param result The new tail to be added to the list.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/Initializable.sol": [
        {
            "identifier": "onlyInitializing",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier onlyInitializing() virtual {\n        _checkInitializing();\n        _;\n    }",
            "start": "124",
            "end": "127",
            "class": "Initializable",
            "signature": " onlyInitializing",
            "full_signature": "function onlyInitializing()  virtual",
            "class_method_signature": "Initializable.onlyInitializing",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier that ensures the function can only be called during the initialization phase.\n * \n * Steps:\n * 1. Calls the internal `_checkInitializing()` function to verify if the contract is in the initializing state.\n * 2. Executes the function body if the check passes.\n */"
        },
        {
            "identifier": "_initializableSlot",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes32)",
            "body": "function _initializableSlot() internal pure virtual returns (bytes32) {\n        return _INITIALIZABLE_SLOT;\n    }",
            "start": "47",
            "end": "49",
            "class": "Initializable",
            "signature": "returns (bytes32) _initializableSlot",
            "full_signature": "function _initializableSlot() internal virtual pure returns (bytes32)",
            "class_method_signature": "Initializable._initializableSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the storage slot used for initializable state.\n * @dev This function is internal, pure, and virtual, allowing it to be overridden by derived contracts.\n * @return bytes32 The storage slot for the initializable state.\n */"
        },
        {
            "identifier": "_checkInitializing",
            "parameters": "",
            "modifiers": "view",
            "return": "",
            "body": "function _checkInitializing() internal view virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(and(1, sload(s))) {\n                mstore(0x00, 0xd7e6bcf8) // `NotInitializing()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "130",
            "end": "139",
            "class": "Initializable",
            "signature": " _checkInitializing",
            "full_signature": "function _checkInitializing() internal virtual view",
            "class_method_signature": "Initializable._checkInitializing",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to check if the contract is being initialized.\n * \n * Steps:\n * 1. Retrieve the storage slot for the initializable state.\n * 2. Use inline assembly to check if the contract is in the process of being initialized.\n * 3. If not, revert with the error `NotInitializing()`.\n */"
        },
        {
            "identifier": "_getInitializedVersion",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (uint64 version)",
            "body": "function _getInitializedVersion() internal view virtual returns (uint64 version) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := shr(1, sload(s))\n        }\n    }",
            "start": "169",
            "end": "175",
            "class": "Initializable",
            "signature": "returns (uint64 version) _getInitializedVersion",
            "full_signature": "function _getInitializedVersion() internal virtual view returns (uint64 version)",
            "class_method_signature": "Initializable._getInitializedVersion",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the initialized version of the contract.\n *\n * Steps:\n * 1. Get the storage slot for the initializable version.\n * 2. Use assembly to load the value from the storage slot.\n * 3. Shift the value right by 1 bit to get the version.\n * 4. Return the version.\n */"
        },
        {
            "identifier": "_disableInitializers",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "function _disableInitializers() internal virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            if and(i, 1) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            let uint64max := shr(192, s) // Computed to save bytecode.\n            if iszero(eq(shr(1, i), uint64max)) {\n                // Set `initializing` to 0, `initializedVersion` to `2**64 - 1`.\n                sstore(s, shl(1, uint64max))\n                // Emit the {Initialized} event.\n                mstore(0x20, uint64max)\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }",
            "start": "148",
            "end": "166",
            "class": "Initializable",
            "signature": " _disableInitializers",
            "full_signature": "function _disableInitializers() internal virtual",
            "class_method_signature": "Initializable._disableInitializers",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Disables the initializers for the contract, preventing reinitialization.\n *\n * Steps:\n * 1. Load the initializable slot from storage.\n * 2. Check if the contract is already initialized. If so, revert with `InvalidInitialization()`.\n * 3. Compute the maximum value for a uint64 (2^64 - 1) to save bytecode.\n * 4. If the contract is not fully initialized, set the `initializing` flag to 0 and the `initializedVersion` to the maximum uint64 value.\n * 5. Emit the `Initialized` event to signal that the contract is now fully initialized.\n */"
        },
        {
            "identifier": "_INITIALIZABLE_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private constant _INITIALIZABLE_SLOT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffbf601132;",
            "start": "39",
            "end": "40",
            "class": "Initializable",
            "signature": "bytes32 _INITIALIZABLE_SLOT",
            "full_signature": "bytes32 private constant _INITIALIZABLE_SLOT",
            "class_method_signature": "Initializable._INITIALIZABLE_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant `_INITIALIZABLE_SLOT` is defined with a specific bytes32 value.\n * This slot is likely used for storing initialization state or other related data in a contract.\n */"
        },
        {
            "identifier": "reinitializer",
            "parameters": "uint64 version",
            "modifiers": "",
            "return": "",
            "body": "modifier reinitializer(uint64 version) virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            version := and(version, 0xffffffffffffffff) // Clean upper bits.\n            let i := sload(s)\n            // If `initializing == 1 || initializedVersion >= version`.\n            if iszero(lt(and(i, 1), lt(shr(1, i), version))) {\n                mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                revert(0x1c, 0x04)\n            }\n            // Set `initializing` to 1, `initializedVersion` to `version`.\n            sstore(s, or(1, shl(1, version)))\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Set `initializing` to 0, `initializedVersion` to `version`.\n            sstore(s, shl(1, version))\n            // Emit the {Initialized} event.\n            mstore(0x20, version)\n            log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n        }\n    }",
            "start": "97",
            "end": "120",
            "class": "Initializable",
            "signature": " reinitializeruint64 version",
            "full_signature": "function reinitializer(uint64 version)  virtual",
            "class_method_signature": "Initializable.reinitializeruint64 version",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A reinitializer modifier that ensures a contract can only be reinitialized once per version.\n *\n * Steps:\n * 1. Load the storage slot for initialization state.\n * 2. Clean the upper bits of the version to ensure it fits within 64 bits.\n * 3. Check if the contract is already initializing or if the initialized version is greater than or equal to the provided version.\n * 4. If the above condition is true, revert with an `InvalidInitialization` error.\n * 5. Set the `initializing` flag to 1 and update the `initializedVersion` to the provided version.\n * 6. Execute the function body.\n * 7. After execution, set the `initializing` flag to 0 and update the `initializedVersion` to the provided version.\n * 8. Emit an `Initialized` event with the version.\n */"
        },
        {
            "identifier": "initializer",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier initializer() virtual {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            let i := sload(s)\n            // Set `initializing` to 1, `initializedVersion` to 1.\n            sstore(s, 3)\n            // If `!(initializing == 0 && initializedVersion == 0)`.\n            if i {\n                // If `!(address(this).code.length == 0 && initializedVersion == 1)`.\n                if iszero(lt(extcodesize(address()), eq(shr(1, i), 1))) {\n                    mstore(0x00, 0xf92ee8a9) // `InvalidInitialization()`.\n                    revert(0x1c, 0x04)\n                }\n                s := shl(shl(255, i), s) // Skip initializing if `initializing == 1`.\n            }\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if s {\n                // Set `initializing` to 0, `initializedVersion` to 1.\n                sstore(s, 2)\n                // Emit the {Initialized} event.\n                mstore(0x20, 1)\n                log1(0x20, 0x20, _INTIALIZED_EVENT_SIGNATURE)\n            }\n        }\n    }",
            "start": "61",
            "end": "89",
            "class": "Initializable",
            "signature": " initializer",
            "full_signature": "function initializer()  virtual",
            "class_method_signature": "Initializable.initializer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A modifier to ensure that a contract is initialized only once.\n *\n * Steps:\n * 1. Load the storage slot for the initializable state.\n * 2. Use assembly to check and set the initialization state:\n *    - If the contract is already initialized or initializing, revert with `InvalidInitialization()`.\n *    - Otherwise, set the `initializing` flag to 1 and `initializedVersion` to 1.\n * 3. Execute the function body (`_`).\n * 4. After execution, use assembly to:\n *    - Set `initializing` to 0 and `initializedVersion` to 1.\n *    - Emit the `Initialized` event.\n *\n * @dev This modifier is designed to prevent re-initialization and ensure proper initialization flow.\n */"
        },
        {
            "identifier": "_isInitializing",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function _isInitializing() internal view virtual returns (bool result) {\n        bytes32 s = _initializableSlot();\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, sload(s))\n        }\n    }",
            "start": "178",
            "end": "184",
            "class": "Initializable",
            "signature": "returns (bool result) _isInitializing",
            "full_signature": "function _isInitializing() internal virtual view returns (bool result)",
            "class_method_signature": "Initializable._isInitializing",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the contract is currently being initialized.\n * \n * Steps:\n * 1. Retrieve the storage slot for the initialization status.\n * 2. Use assembly to load the value from the storage slot.\n * 3. Check if the least significant bit is set (indicating initialization).\n * 4. Return the result as a boolean.\n */"
        },
        {
            "identifier": "_INTIALIZED_EVENT_SIGNATURE",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private constant _INTIALIZED_EVENT_SIGNATURE =\n        0xc7f505b2f371ae2175ee4913f4499e1f2633a7b5936321eed1cdaeb6115181d2;",
            "start": "26",
            "end": "27",
            "class": "Initializable",
            "signature": "bytes32 _INTIALIZED_EVENT_SIGNATURE",
            "full_signature": "bytes32 private constant _INTIALIZED_EVENT_SIGNATURE",
            "class_method_signature": "Initializable._INTIALIZED_EVENT_SIGNATURE",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the event signature for the \"Initialized\" event.\n * This is typically used to identify and filter specific events in the contract.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EnumerableMapLib.sol": [
        {
            "identifier": "AddressToBytes32Map",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct AddressToBytes32Map {\n        EnumerableSetLib.AddressSet _keys;\n        mapping(address => bytes32) _values;\n    }",
            "start": "58",
            "end": "61",
            "class": "EnumerableMapLib",
            "signature": " AddressToBytes32Map",
            "full_signature": "function AddressToBytes32Map()",
            "class_method_signature": "EnumerableMapLib.AddressToBytes32Map",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function AddressSet()', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct that maps addresses to bytes32 values.\n * \n * Fields:\n * - `_keys`: An enumerable set of addresses used to store the keys of the mapping.\n * - `_values`: A mapping from addresses to bytes32 values, storing the actual data.\n */"
        },
        {
            "identifier": "Uint256ToAddressMap",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Uint256ToAddressMap {\n        EnumerableSetLib.Uint256Set _keys;\n        mapping(uint256 => address) _values;\n    }",
            "start": "52",
            "end": "55",
            "class": "EnumerableMapLib",
            "signature": " Uint256ToAddressMap",
            "full_signature": "function Uint256ToAddressMap()",
            "class_method_signature": "EnumerableMapLib.Uint256ToAddressMap",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function Uint256Set()', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct representing a mapping from uint256 keys to address values.\n * \n * Fields:\n * - `_keys`: An EnumerableSet of uint256 keys.\n * - `_values`: A mapping from uint256 keys to address values.\n */"
        },
        {
            "identifier": "AddressToAddressMap",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct AddressToAddressMap {\n        EnumerableSetLib.AddressSet _keys;\n        mapping(address => address) _values;\n    }",
            "start": "70",
            "end": "73",
            "class": "EnumerableMapLib",
            "signature": " AddressToAddressMap",
            "full_signature": "function AddressToAddressMap()",
            "class_method_signature": "EnumerableMapLib.AddressToAddressMap",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function AddressSet()', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct representing a mapping from addresses to addresses.\n * \n * The struct contains:\n * 1. `_keys`: An enumerable set of addresses representing the keys in the mapping.\n * 2. `_values`: A mapping from addresses to addresses, storing the actual values.\n */"
        },
        {
            "identifier": "Uint256ToUint256Map",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Uint256ToUint256Map {\n        EnumerableSetLib.Uint256Set _keys;\n        mapping(uint256 => uint256) _values;\n    }",
            "start": "46",
            "end": "49",
            "class": "EnumerableMapLib",
            "signature": " Uint256ToUint256Map",
            "full_signature": "function Uint256ToUint256Map()",
            "class_method_signature": "EnumerableMapLib.Uint256ToUint256Map",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function Uint256Set()', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct representing a mapping from uint256 keys to uint256 values.\n * \n * Fields:\n * - `_keys`: An EnumerableSet of uint256 keys.\n * - `_values`: A mapping from uint256 keys to uint256 values.\n */"
        },
        {
            "identifier": "Bytes32ToAddressMap",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Bytes32ToAddressMap {\n        EnumerableSetLib.Bytes32Set _keys;\n        mapping(bytes32 => address) _values;\n    }",
            "start": "34",
            "end": "37",
            "class": "EnumerableMapLib",
            "signature": " Bytes32ToAddressMap",
            "full_signature": "function Bytes32ToAddressMap()",
            "class_method_signature": "EnumerableMapLib.Bytes32ToAddressMap",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function Bytes32Set()', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct representing a mapping from bytes32 keys to address values.\n * \n * Fields:\n * - `_keys`: An EnumerableSet of bytes32 keys to track the keys in the mapping.\n * - `_values`: A mapping from bytes32 keys to their corresponding address values.\n */"
        },
        {
            "identifier": "Uint256ToBytes32Map",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Uint256ToBytes32Map {\n        EnumerableSetLib.Uint256Set _keys;\n        mapping(uint256 => bytes32) _values;\n    }",
            "start": "40",
            "end": "43",
            "class": "EnumerableMapLib",
            "signature": " Uint256ToBytes32Map",
            "full_signature": "function Uint256ToBytes32Map()",
            "class_method_signature": "EnumerableMapLib.Uint256ToBytes32Map",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function Uint256Set()', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct that maps uint256 keys to bytes32 values.\n * \n * The struct contains:\n * 1. `_keys`: An EnumerableSet of uint256 keys.\n * 2. `_values`: A mapping from uint256 keys to bytes32 values.\n */"
        },
        {
            "identifier": "Bytes32ToBytes32Map",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Bytes32ToBytes32Map {\n        EnumerableSetLib.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }",
            "start": "22",
            "end": "25",
            "class": "EnumerableMapLib",
            "signature": " Bytes32ToBytes32Map",
            "full_signature": "function Bytes32ToBytes32Map()",
            "class_method_signature": "EnumerableMapLib.Bytes32ToBytes32Map",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function Bytes32Set()', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct representing a mapping from bytes32 keys to bytes32 values.\n * \n * Fields:\n * - `_keys`: An enumerable set of bytes32 keys.\n * - `_values`: A mapping from bytes32 keys to bytes32 values.\n */"
        },
        {
            "identifier": "_revertNotFound",
            "parameters": "",
            "modifiers": "pure",
            "return": "",
            "body": "function _revertNotFound() private pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, 0x88682bf3) // `EnumerableMapKeyNotFound()`.\n            revert(0x1c, 0x04)\n        }\n    }",
            "start": "615",
            "end": "621",
            "class": "EnumerableMapLib",
            "signature": " _revertNotFound",
            "full_signature": "function _revertNotFound() private  pure",
            "class_method_signature": "EnumerableMapLib._revertNotFound",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)'}",
            "human_labeled_comment": "/**\n * @notice Reverts the transaction with a custom error indicating that a key was not found in an enumerable map.\n *\n * Steps:\n * 1. Store the error selector `EnumerableMapKeyNotFound()` at memory location 0x00.\n * 2. Revert the transaction, returning the error selector stored in memory.\n */"
        },
        {
            "identifier": "Bytes32ToUint256Map",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Bytes32ToUint256Map {\n        EnumerableSetLib.Bytes32Set _keys;\n        mapping(bytes32 => uint256) _values;\n    }",
            "start": "28",
            "end": "31",
            "class": "EnumerableMapLib",
            "signature": " Bytes32ToUint256Map",
            "full_signature": "function Bytes32ToUint256Map()",
            "class_method_signature": "EnumerableMapLib.Bytes32ToUint256Map",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)', 'function Bytes32Set()', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice A struct that maps `bytes32` keys to `uint256` values.\n * \n * The struct contains:\n * - `_keys`: An `EnumerableSetLib.Bytes32Set` to store the keys.\n * - `_values`: A mapping from `bytes32` keys to `uint256` values.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibPRNG.sol": [
        {
            "identifier": "standardNormalWad",
            "parameters": "PRNG memory prng",
            "modifiers": "pure",
            "return": "returns (int256 result)",
            "body": "function standardNormalWad(PRNG memory prng) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Technically, this is the Irwin-Hall distribution with 20 samples.\n            // The chance of drawing a sample outside 10 \u03c3 from the standard normal distribution\n            // is \u2248 0.000000000000000000000015, which is insignificant for most practical purposes.\n            // Passes the Kolmogorov-Smirnov test for 200k samples. Uses about 322 gas.\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n            let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n            let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n            let m := 0x1fffffffffffffff1fffffffffffffff1fffffffffffffff1fffffffffffffff\n            let s := 0x1000000000000000100000000000000010000000000000001\n            let r1 := mulmod(result, a, n)\n            let r2 := mulmod(r1, a, n)\n            let r3 := mulmod(r2, a, n)\n            // forgefmt: disable-next-item\n            result := sub(sar(96, mul(26614938895861601847173011183,\n                add(add(shr(192, mul(s, add(and(m, result), and(m, r1)))),\n                shr(192, mul(s, add(and(m, r2), and(m, r3))))),\n                shr(192, mul(s, and(m, mulmod(r3, a, n))))))), 7745966692414833770)\n        }\n    }",
            "start": "108",
            "end": "130",
            "class": "LibPRNG",
            "signature": "returns (int256 result) standardNormalWadPRNG memory prng",
            "full_signature": "function standardNormalWad(PRNG memory prng) internal  pure returns (int256 result)",
            "class_method_signature": "LibPRNG.standardNormalWadPRNG memory prng",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Generates a standard normal distribution value using a pseudo-random number generator (PRNG).\n *\n * Steps:\n * 1. Uses assembly for memory-safe operations.\n * 2. Generates a pseudo-random number using the keccak256 hash of the PRNG state.\n * 3. Updates the PRNG state with the generated result.\n * 4. Defines constants for prime numbers and other mathematical operations.\n * 5. Performs modular arithmetic to manipulate the random number.\n * 6. Combines the results of multiple modular operations to produce a final value.\n * 7. Adjusts the final value to fit within the standard normal distribution range.\n *\n * @param prng The PRNG state used to generate the random number.\n * @return result The generated standard normal distribution value.\n */"
        },
        {
            "identifier": "LazyShuffler",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct LazyShuffler {\n        // Bits Layout:\n        // - [0..31]    `numShuffled`\n        // - [32..223]  `permutationSlot`\n        // - [224..255] `length`\n        uint256 _state;\n    }",
            "start": "48",
            "end": "54",
            "class": "LibPRNG",
            "signature": " LazyShuffler",
            "full_signature": "function LazyShuffler()",
            "class_method_signature": "LibPRNG.LazyShuffler",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct `LazyShuffler` used for managing a shuffled state.\n *\n * Bits Layout:\n * - [0..31]    `numShuffled`: Tracks the number of elements shuffled.\n * - [32..223]  `permutationSlot`: Stores the permutation slot for shuffling.\n * - [224..255] `length`: Represents the total length of the elements to be shuffled.\n *\n * The struct uses a single `uint256` (`_state`) to efficiently pack these values.\n */"
        },
        {
            "identifier": "numShuffled",
            "parameters": "LazyShuffler storage $",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function numShuffled(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(0xffffffff, sload($.slot))\n        }\n    }",
            "start": "380",
            "end": "385",
            "class": "LibPRNG",
            "signature": "returns (uint256 result) numShuffledLazyShuffler storage $",
            "full_signature": "function numShuffled(LazyShuffler storage $) internal  view returns (uint256 result)",
            "class_method_signature": "LibPRNG.numShuffledLazyShuffler storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the number of shuffled elements from the LazyShuffler storage.\n * \n * Steps:\n * 1. Use inline assembly to load the value from the storage slot of the LazyShuffler.\n * 2. Apply a bitmask (0xffffffff) to ensure only the lower 32 bits are considered.\n * 3. Return the result as a uint256.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, bytes memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, bytes memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                let b := add(a, 0x01)\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let o := mod(shr(128, r), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n\n                    {\n                        let o := mod(and(r, mask), n)\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let t := mload(add(b, n))\n                        mstore8(add(a, n), mload(add(b, o)))\n                        mstore8(add(a, o), t)\n                    }\n                }\n            }\n        }\n    }",
            "start": "278",
            "end": "318",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, bytes memory a",
            "full_signature": "function shuffle(PRNG memory prng, bytes memory a) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, bytes memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles the elements of a byte array using a pseudo-random number generator (PRNG).\n *\n * Steps:\n * 1. Load the length of the byte array `a` into `n`.\n * 2. Initialize `w` to `not(0)` and `mask` to `shr(128, w)`.\n * 3. If `n` is non-zero, proceed with shuffling:\n *    a. Calculate the base address `b` for the byte array.\n *    b. Iterate through the array:\n *       i. Generate a pseudo-random number `r` using `keccak256` with the PRNG state.\n *       ii. Update the PRNG state with the new random number.\n *       iii. Calculate an index `o` using modulo operation on `r` and `n`.\n *       iv. Decrement `n` by 1.\n *       v. If `n` is zero, break the loop.\n *       vi. Swap the elements at positions `n` and `o` in the byte array.\n *       vii. Repeat the process with a different index calculation using `mask`.\n * 4. The byte array is shuffled in place.\n *\n * Note: There is a negligible modulo bias if the array length is not a power of 2, but it is not a concern for fairness or security.\n */"
        },
        {
            "identifier": "PRNG",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct PRNG {\n        uint256 state;\n    }",
            "start": "43",
            "end": "45",
            "class": "LibPRNG",
            "signature": " PRNG",
            "full_signature": "function PRNG()",
            "class_method_signature": "LibPRNG.PRNG",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct named PRNG (Pseudo-Random Number Generator).\n * @dev The struct contains a single state variable, which is used to store the current state of the PRNG.\n * @param state A uint256 variable representing the current state of the PRNG.\n */"
        },
        {
            "identifier": "InvalidNewLazyShufflerLength",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error InvalidNewLazyShufflerLength();",
            "start": "17",
            "end": "17",
            "class": "LibPRNG",
            "signature": " InvalidNewLazyShufflerLength",
            "full_signature": "function InvalidNewLazyShufflerLength()",
            "class_method_signature": "LibPRNG.InvalidNewLazyShufflerLength",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the length provided for a new lazy shuffler is invalid.\n */"
        },
        {
            "identifier": "LazyShufflerNotInitialized",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error LazyShufflerNotInitialized();",
            "start": "20",
            "end": "20",
            "class": "LibPRNG",
            "signature": " LazyShufflerNotInitialized",
            "full_signature": "function LazyShufflerNotInitialized()",
            "class_method_signature": "LibPRNG.LazyShufflerNotInitialized",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the LazyShuffler has not been initialized.\n */"
        },
        {
            "identifier": "LazyShufflerGetOutOfBounds",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error LazyShufflerGetOutOfBounds();",
            "start": "29",
            "end": "29",
            "class": "LibPRNG",
            "signature": " LazyShufflerGetOutOfBounds",
            "full_signature": "function LazyShufflerGetOutOfBounds()",
            "class_method_signature": "LibPRNG.LazyShufflerGetOutOfBounds",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating an out-of-bounds access in the LazyShuffler.\n * @dev This error is thrown when attempting to access an index that is outside the valid range.\n */"
        },
        {
            "identifier": "LazyShuffleFinished",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error LazyShuffleFinished();",
            "start": "26",
            "end": "26",
            "class": "LibPRNG",
            "signature": " LazyShuffleFinished",
            "full_signature": "function LazyShuffleFinished()",
            "class_method_signature": "LibPRNG.LazyShuffleFinished",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the lazy shuffle operation has finished.\n * This error is likely used to signal that a specific operation or state transition\n * related to a \"lazy shuffle\" has been completed or is no longer valid.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, address[] memory a, uint256 k",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, address[] memory a, uint256 k) internal pure {\n        shuffle(prng, _toUints(a), k);\n    }",
            "start": "273",
            "end": "275",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, address[] memory a, uint256 k",
            "full_signature": "function shuffle(PRNG memory prng, address[] memory a, uint256 k) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, address[] memory a, uint256 k",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles an array of addresses using a pseudo-random number generator (PRNG).\n *\n * @param prng The PRNG state used for shuffling.\n * @param a The array of addresses to be shuffled.\n * @param k The number of elements to shuffle.\n *\n * Internally, the function converts the address array to an array of uints and calls the shuffle function for uints.\n */"
        },
        {
            "identifier": "length",
            "parameters": "LazyShuffler storage $",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function length(LazyShuffler storage $) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload($.slot))\n        }\n    }",
            "start": "389",
            "end": "394",
            "class": "LibPRNG",
            "signature": "returns (uint256 result) lengthLazyShuffler storage $",
            "full_signature": "function length(LazyShuffler storage $) internal  view returns (uint256 result)",
            "class_method_signature": "LibPRNG.lengthLazyShuffler storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves the length of the LazyShuffler storage.\n *\n * Steps:\n * 1. Use inline assembly to read the length from the storage slot.\n * 2. Shift the value right by 224 bits to extract the length.\n * 3. Return the extracted length.\n */"
        },
        {
            "identifier": "WAD",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant WAD = 1e18;",
            "start": "36",
            "end": "36",
            "class": "LibPRNG",
            "signature": "uint256 WAD",
            "full_signature": "uint256 internal constant WAD",
            "class_method_signature": "LibPRNG.WAD",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the fixed-point decimal precision (1e18).\n * This is commonly used in Solidity for handling decimal arithmetic with integers.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, uint256[] memory a, uint256 k",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, uint256[] memory a, uint256 k) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            k := xor(k, mul(xor(k, n), lt(n, k))) // `min(n, k)`.\n            if k {\n                let mask := shr(128, not(0))\n                let b := 0\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, add(b, mod(shr(128, r), sub(n, b)))))\n                        let i := add(a, shl(5, b))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                        b := add(b, 1)\n                        if eq(b, k) { break }\n                    }\n\n                    {\n                        let j := add(a, shl(5, add(b, mod(and(r, mask), sub(n, b)))))\n                        let i := add(a, shl(5, b))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                        b := add(b, 1)\n                        if eq(b, k) { break }\n                    }\n                }\n            }\n        }\n    }",
            "start": "223",
            "end": "263",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, uint256[] memory a, uint256 k",
            "full_signature": "function shuffle(PRNG memory prng, uint256[] memory a, uint256 k) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, uint256[] memory a, uint256 k",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles an array of uint256 values using a pseudo-random number generator (PRNG).\n *\n * @param prng The PRNG state used to generate random numbers.\n * @param a The array of uint256 values to be shuffled.\n * @param k The number of elements to shuffle. If k is greater than the array length, it is clamped to the array length.\n *\n * Steps:\n * 1. Load the length of the array `a` into `n`.\n * 2. Clamp `k` to the minimum of `n` and `k` to ensure it does not exceed the array length.\n * 3. If `k` is greater than 0, proceed with shuffling:\n *    a. Initialize a mask to extract the lower 128 bits of the random number.\n *    b. Iterate through the array, swapping elements based on random indices generated using `keccak256`.\n *    c. Update the PRNG state with the new random number after each iteration.\n *    d. Continue swapping until `k` elements have been shuffled.\n *\n * Note: There is a negligible modulo bias if the array length is not a power of 2, but it is not a concern for fairness or security.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, int256[] memory a, uint256 k",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, int256[] memory a, uint256 k) internal pure {\n        shuffle(prng, _toUints(a), k);\n    }",
            "start": "267",
            "end": "269",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, int256[] memory a, uint256 k",
            "full_signature": "function shuffle(PRNG memory prng, int256[] memory a, uint256 k) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, int256[] memory a, uint256 k",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles an array of integers using a pseudo-random number generator (PRNG).\n *\n * @param prng The PRNG state used for shuffling.\n * @param a The array of integers to be shuffled.\n * @param k The number of elements to shuffle.\n *\n * Steps:\n * 1. Convert the input array of integers to an array of unsigned integers.\n * 2. Call the internal `shuffle` function with the converted array and the specified number of elements.\n */"
        },
        {
            "identifier": "next",
            "parameters": "PRNG memory prng",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function next(PRNG memory prng) internal pure returns (uint256 result) {\n        // We simply use `keccak256` for a great balance between\n        // runtime gas costs, bytecode size, and statistical properties.\n        //\n        // A high-quality LCG with a 32-byte state\n        // is only about 30% more gas efficient during runtime,\n        // but requires a 32-byte multiplier, which can cause bytecode bloat\n        // when this function is inlined.\n        //\n        // Using this method is about 2x more efficient than\n        // `nextRandomness = uint256(keccak256(abi.encode(randomness)))`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(prng, 0x20)\n            mstore(prng, result)\n        }\n    }",
            "start": "70",
            "end": "86",
            "class": "LibPRNG",
            "signature": "returns (uint256 result) nextPRNG memory prng",
            "full_signature": "function next(PRNG memory prng) internal  pure returns (uint256 result)",
            "class_method_signature": "LibPRNG.nextPRNG memory prng",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Generates the next pseudo-random number in the sequence using the provided PRNG state.\n * \n * This function uses the `keccak256` hash function to generate a pseudo-random number. \n * The choice of `keccak256` is made for its balance between runtime gas costs, bytecode size, and statistical properties.\n * \n * Steps:\n * 1. The `keccak256` hash function is applied to the PRNG state to generate a new pseudo-random number.\n * 2. The new pseudo-random number is stored back into the PRNG state for future use.\n * \n * Notes:\n * - This method is more gas-efficient compared to using `keccak256` with `abi.encode`.\n * - The function is implemented using inline assembly for memory safety and efficiency.\n */"
        },
        {
            "identifier": "next",
            "parameters": "LazyShuffler storage $, uint256 randomness",
            "modifiers": "",
            "return": "returns (uint256 chosen)",
            "body": "function next(LazyShuffler storage $, uint256 randomness) internal returns (uint256 chosen) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function _get(u32_, state_, i_) -> _value {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                _value := and(m_, shr(o_, sload(s_)))\n                _value := xor(i_, mul(xor(i_, sub(_value, 1)), iszero(iszero(_value))))\n            }\n            function _set(u32_, state_, i_, value_) {\n                let s_ := add(shr(sub(4, u32_), i_), shr(64, shl(32, state_))) // Bucket slot.\n                let o_ := shl(add(4, u32_), and(i_, shr(u32_, 15))) // Bucket slot offset (bits).\n                let m_ := sub(shl(shl(u32_, 16), 1), 1) // Value mask.\n                let v_ := sload(s_) // Bucket slot value.\n                value_ := mul(iszero(eq(i_, value_)), add(value_, 1))\n                sstore(s_, xor(v_, shl(o_, and(m_, xor(shr(o_, v_), value_)))))\n            }\n            let state := sload($.slot) // The packed value at `$`.\n            let shuffled := and(0xffffffff, state) // Number of elements shuffled.\n            let n := shr(224, state) // Length of `$`.\n            let remainder := sub(n, shuffled) // Number of elements left to shuffle.\n            if iszero(remainder) {\n                mstore(0x00, 0x51065f79) // `LazyShuffleFinished()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, randomness) // (Re)hash the randomness so that we don't\n            mstore(0x20, shuffled) // need to expect guarantees on its distribution.\n            let index := add(mod(keccak256(0x00, 0x40), remainder), shuffled)\n            chosen := _get(gt(n, 0xfffe), state, index)\n            _set(gt(n, 0xfffe), state, index, _get(gt(n, 0xfffe), state, shuffled))\n            _set(gt(n, 0xfffe), state, shuffled, chosen)\n            sstore($.slot, add(1, state)) // Increment the `numShuffled` by 1, and store it.\n        }\n    }",
            "start": "442",
            "end": "476",
            "class": "LibPRNG",
            "signature": "returns (uint256 chosen) nextLazyShuffler storage $, uint256 randomness",
            "full_signature": "function next(LazyShuffler storage $, uint256 randomness) internal   returns (uint256 chosen)",
            "class_method_signature": "LibPRNG.nextLazyShuffler storage $, uint256 randomness",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Selects the next element in a lazy shuffler using a randomness value.\n *\n * Steps:\n * 1. Retrieve the current state of the lazy shuffler from storage.\n * 2. Extract the number of elements already shuffled and the total length of the shuffler.\n * 3. Calculate the number of elements remaining to be shuffled.\n * 4. If no elements are left to shuffle, revert with the error `LazyShuffleFinished()`.\n *\n * 5. Hash the provided randomness value with the number of shuffled elements to ensure uniform distribution.\n * 6. Compute the index of the next element to be chosen using the hashed randomness.\n *\n * 7. Retrieve the value at the computed index and swap it with the value at the shuffled boundary.\n * 8. Update the storage to reflect the new state of the shuffler.\n * 9. Increment the count of shuffled elements and store the updated state.\n *\n * @param $ The lazy shuffler storage reference.\n * @param randomness A randomness value used to determine the next element.\n * @return chosen The next element chosen from the shuffler.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, uint256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a)\n            let w := not(0)\n            let mask := shr(128, w)\n            if n {\n                for { a := add(a, 0x20) } 1 {} {\n                    // We can just directly use `keccak256`, cuz\n                    // the other approaches don't save much.\n                    let r := keccak256(prng, 0x20)\n                    mstore(prng, r)\n\n                    // Note that there will be a very tiny modulo bias\n                    // if the length of the array is not a power of 2.\n                    // For all practical purposes, it is negligible\n                    // and will not be a fairness or security concern.\n                    {\n                        let j := add(a, shl(5, mod(shr(128, r), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n\n                    {\n                        let j := add(a, shl(5, mod(and(r, mask), n)))\n                        n := add(n, w) // `sub(n, 1)`.\n                        if iszero(n) { break }\n\n                        let i := add(a, shl(5, n))\n                        let t := mload(i)\n                        mstore(i, mload(j))\n                        mstore(j, t)\n                    }\n                }\n            }\n        }\n    }",
            "start": "168",
            "end": "209",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, uint256[] memory a",
            "full_signature": "function shuffle(PRNG memory prng, uint256[] memory a) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, uint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles an array using a pseudo-random number generator (PRNG).\n *\n * Steps:\n * 1. Load the length of the array `a` into `n`.\n * 2. Initialize `w` to `not(0)` (all bits set to 1) and `mask` to the lower 128 bits of `w`.\n * 3. If the array is not empty, proceed with the shuffling process.\n *\n * 4. Iterate through the array:\n *    a. Generate a pseudo-random number `r` using `keccak256` on the PRNG state.\n *    b. Update the PRNG state with the new random number.\n *    c. Calculate the index `j` for swapping using the random number and the array length.\n *    d. Decrement `n` (equivalent to `n = n - 1`).\n *    e. If `n` is zero, break out of the loop.\n *    f. Swap the elements at indices `i` and `j`.\n *\n * 5. Repeat the process with a different index calculation using the lower 128 bits of the random number.\n *\n * Notes:\n * - The function uses inline assembly for memory safety and efficiency.\n * - There is a negligible modulo bias if the array length is not a power of 2, but it is not a concern for fairness or security.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, address[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, address[] memory a) internal pure {\n        shuffle(prng, _toUints(a));\n    }",
            "start": "217",
            "end": "219",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, address[] memory a",
            "full_signature": "function shuffle(PRNG memory prng, address[] memory a) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, address[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles an array of addresses using a pseudo-random number generator (PRNG).\n * \n * @param prng The PRNG state used for shuffling.\n * @param a The array of addresses to be shuffled.\n * \n * @dev Internally converts the address array to an array of uints and calls the shuffle function for uints.\n */"
        },
        {
            "identifier": "uniform",
            "parameters": "PRNG memory prng, uint256 upper",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function uniform(PRNG memory prng, uint256 upper) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := keccak256(prng, 0x20)\n                mstore(prng, result)\n                if iszero(lt(result, mod(sub(0, upper), upper))) { break }\n            }\n            result := mod(result, upper)\n        }\n    }",
            "start": "95",
            "end": "105",
            "class": "LibPRNG",
            "signature": "returns (uint256 result) uniformPRNG memory prng, uint256 upper",
            "full_signature": "function uniform(PRNG memory prng, uint256 upper) internal  pure returns (uint256 result)",
            "class_method_signature": "LibPRNG.uniformPRNG memory prng, uint256 upper",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Generates a uniformly distributed random number within a specified upper bound.\n *\n * Steps:\n * 1. Use inline assembly for efficient memory-safe operations.\n * 2. Continuously generate a random number using keccak256 hash of the PRNG state.\n * 3. Update the PRNG state with the newly generated random number.\n * 4. Check if the generated number is within the desired range (less than the upper bound).\n * 5. If the number is within the range, break the loop.\n * 6. Return the result modulo the upper bound to ensure it is within the specified range.\n */"
        },
        {
            "identifier": "initialized",
            "parameters": "LazyShuffler storage $",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function initialized(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(iszero(sload($.slot)))\n        }\n    }",
            "start": "397",
            "end": "402",
            "class": "LibPRNG",
            "signature": "returns (bool result) initializedLazyShuffler storage $",
            "full_signature": "function initialized(LazyShuffler storage $) internal  view returns (bool result)",
            "class_method_signature": "LibPRNG.initializedLazyShuffler storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the LazyShuffler storage is initialized.\n * \n * @dev Uses low-level assembly to check if the storage slot is non-zero.\n * \n * @param $ The LazyShuffler storage to check.\n * @return result A boolean indicating whether the storage is initialized (true) or not (false).\n */"
        },
        {
            "identifier": "_toUints",
            "parameters": "int256[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory casted)",
            "body": "function _toUints(int256[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := a\n        }\n    }",
            "start": "483",
            "end": "488",
            "class": "LibPRNG",
            "signature": "returns (uint256[] memory casted) _toUintsint256[] memory a",
            "full_signature": "function _toUints(int256[] memory a) private  pure returns (uint256[] memory casted)",
            "class_method_signature": "LibPRNG._toUintsint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of int256 to an array of uint256.\n * @dev This function uses inline assembly to perform the conversion.\n * @param a The input array of int256 values.\n * @return casted The resulting array of uint256 values.\n */"
        },
        {
            "identifier": "InvalidInitialLazyShufflerLength",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error InvalidInitialLazyShufflerLength();",
            "start": "14",
            "end": "14",
            "class": "LibPRNG",
            "signature": " InvalidInitialLazyShufflerLength",
            "full_signature": "function InvalidInitialLazyShufflerLength()",
            "class_method_signature": "LibPRNG.InvalidInitialLazyShufflerLength",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the initial length provided for the lazy shuffler is invalid.\n */"
        },
        {
            "identifier": "finished",
            "parameters": "LazyShuffler storage $",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function finished(LazyShuffler storage $) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            result := eq(shr(224, state), and(0xffffffff, state))\n        }\n    }",
            "start": "406",
            "end": "416",
            "class": "LibPRNG",
            "signature": "returns (bool result) finishedLazyShuffler storage $",
            "full_signature": "function finished(LazyShuffler storage $) internal  view returns (bool result)",
            "class_method_signature": "LibPRNG.finishedLazyShuffler storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the LazyShuffler has finished shuffling.\n *\n * Steps:\n * 1. Load the packed state value from storage.\n * 2. If the state is zero, revert with the error `LazyShufflerNotInitialized()`.\n * 3. Check if the upper 32 bits of the state match the lower 32 bits.\n * 4. Return the result of the comparison.\n */"
        },
        {
            "identifier": "shuffle",
            "parameters": "PRNG memory prng, int256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function shuffle(PRNG memory prng, int256[] memory a) internal pure {\n        shuffle(prng, _toUints(a));\n    }",
            "start": "212",
            "end": "214",
            "class": "LibPRNG",
            "signature": " shufflePRNG memory prng, int256[] memory a",
            "full_signature": "function shuffle(PRNG memory prng, int256[] memory a) internal  pure",
            "class_method_signature": "LibPRNG.shufflePRNG memory prng, int256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Shuffles an array of integers using a pseudo-random number generator (PRNG).\n * @param prng The PRNG state used for shuffling.\n * @param a The array of integers to be shuffled.\n * @dev Internally converts the integer array to an array of unsigned integers before shuffling.\n */"
        },
        {
            "identifier": "restart",
            "parameters": "LazyShuffler storage $",
            "modifiers": "",
            "return": "",
            "body": "function restart(LazyShuffler storage $) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot)\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, shl(32, shr(32, state)))\n        }\n    }",
            "start": "367",
            "end": "377",
            "class": "LibPRNG",
            "signature": " restartLazyShuffler storage $",
            "full_signature": "function restart(LazyShuffler storage $) internal",
            "class_method_signature": "LibPRNG.restartLazyShuffler storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Restarts the LazyShuffler by resetting its state.\n *\n * Steps:\n * 1. Load the current state of the LazyShuffler from storage.\n * 2. If the state is zero (uninitialized), revert with the error `LazyShufflerNotInitialized()`.\n * 3. Shift the state to reset it and store the updated state back into storage.\n */"
        },
        {
            "identifier": "exponentialWad",
            "parameters": "PRNG memory prng",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function exponentialWad(PRNG memory prng) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Passes the Kolmogorov-Smirnov test for 200k samples.\n            // Gas usage varies, starting from about 172+ gas.\n            let r := keccak256(prng, 0x20)\n            mstore(prng, r)\n            let p := shl(129, r)\n            let w := shl(1, r)\n            if iszero(gt(w, p)) {\n                let n := 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff43 // Prime.\n                let a := 0x100000000000000000000000000000051 // Prime and a primitive root of `n`.\n                for {} 1 {} {\n                    r := mulmod(r, a, n)\n                    if iszero(lt(shl(129, r), w)) {\n                        r := mulmod(r, a, n)\n                        result := add(1000000000000000000, result)\n                        w := shl(1, r)\n                        p := shl(129, r)\n                        if iszero(lt(w, p)) { break }\n                        continue\n                    }\n                    w := shl(1, r)\n                    if iszero(lt(w, shl(129, r))) { break }\n                }\n            }\n            result := add(div(p, shl(129, 170141183460469231732)), result)\n        }\n    }",
            "start": "133",
            "end": "161",
            "class": "LibPRNG",
            "signature": "returns (uint256 result) exponentialWadPRNG memory prng",
            "full_signature": "function exponentialWad(PRNG memory prng) internal  pure returns (uint256 result)",
            "class_method_signature": "LibPRNG.exponentialWadPRNG memory prng",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Generates a pseudo-random number using an exponential distribution in wad format.\n * @dev This function uses a PRNG (Pseudo-Random Number Generator) to produce a random number.\n * The function employs assembly for gas efficiency and passes the Kolmogorov-Smirnov test for 200k samples.\n * \n * Steps:\n * 1. Compute a hash of the PRNG state to generate a random seed.\n * 2. Store the new random seed back into the PRNG state.\n * 3. Perform bitwise operations to manipulate the random seed.\n * 4. Check if the manipulated seed meets certain conditions to ensure randomness.\n * 5. Use modular arithmetic to further randomize the seed.\n * 6. Adjust the result based on the manipulated seed.\n * 7. Return the final result in wad format (1e18).\n */"
        },
        {
            "identifier": "get",
            "parameters": "LazyShuffler storage $, uint256 index",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function get(LazyShuffler storage $, uint256 index) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            let n := shr(224, state) // Length of `$`.\n            if iszero(lt(index, n)) {\n                mstore(0x00, 0x61367cc4) // `LazyShufflerGetOutOfBounds()`.\n                revert(0x1c, 0x04)\n            }\n            let u32 := gt(n, 0xfffe)\n            let s := add(shr(sub(4, u32), index), shr(64, shl(32, state))) // Bucket slot.\n            let o := shl(add(4, u32), and(index, shr(u32, 15))) // Bucket slot offset (bits).\n            let m := sub(shl(shl(u32, 16), 1), 1) // Value mask.\n            result := and(m, shr(o, sload(s)))\n            result := xor(index, mul(xor(index, sub(result, 1)), iszero(iszero(result))))\n        }\n    }",
            "start": "420",
            "end": "436",
            "class": "LibPRNG",
            "signature": "returns (uint256 result) getLazyShuffler storage $, uint256 index",
            "full_signature": "function get(LazyShuffler storage $, uint256 index) internal  view returns (uint256 result)",
            "class_method_signature": "LibPRNG.getLazyShuffler storage $, uint256 index",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Retrieves a value from the LazyShuffler storage at a specific index.\n *\n * Steps:\n * 1. Load the packed state value from storage.\n * 2. Extract the length of the LazyShuffler from the state.\n * 3. Check if the index is out of bounds. If so, revert with `LazyShufflerGetOutOfBounds()` error.\n * 4. Determine if the length exceeds 0xfffe (u32 flag).\n * 5. Calculate the bucket slot and offset based on the index and u32 flag.\n * 6. Compute the value mask.\n * 7. Retrieve the value from the bucket slot and apply the mask.\n * 8. Adjust the result by XORing with the index and applying a conditional subtraction.\n *\n * @param $ The LazyShuffler storage reference.\n * @param index The index of the value to retrieve.\n * @return result The value at the specified index.\n */"
        },
        {
            "identifier": "LazyShufflerAlreadyInitialized",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error LazyShufflerAlreadyInitialized();",
            "start": "23",
            "end": "23",
            "class": "LibPRNG",
            "signature": " LazyShufflerAlreadyInitialized",
            "full_signature": "function LazyShufflerAlreadyInitialized()",
            "class_method_signature": "LibPRNG.LazyShufflerAlreadyInitialized",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the LazyShuffler has already been initialized.\n */"
        },
        {
            "identifier": "initialize",
            "parameters": "LazyShuffler storage $, uint256 n",
            "modifiers": "",
            "return": "",
            "body": "function initialize(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(sub(n, 1), 0xfffffffe)) {\n                mstore(0x00, 0x83b53941) // `InvalidInitialLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if sload($.slot) {\n                mstore(0x00, 0x0c9f11f2) // `LazyShufflerAlreadyInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, $.slot)\n            sstore($.slot, or(shl(224, n), shl(32, shr(64, keccak256(0x00, 0x20)))))\n        }\n    }",
            "start": "328",
            "end": "342",
            "class": "LibPRNG",
            "signature": " initializeLazyShuffler storage $, uint256 n",
            "full_signature": "function initialize(LazyShuffler storage $, uint256 n) internal",
            "class_method_signature": "LibPRNG.initializeLazyShuffler storage $, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Initializes a LazyShuffler with a given length `n`.\n *\n * Steps:\n * 1. Check if `n` is within the valid range (less than 0xfffffffe).\n * 2. If `n` is invalid, revert with the error `InvalidInitialLazyShufflerLength`.\n *\n * 3. Check if the LazyShuffler has already been initialized.\n * 4. If already initialized, revert with the error `LazyShufflerAlreadyInitialized`.\n *\n * 5. Store the initial state of the LazyShuffler in storage:\n *    - The upper 32 bits contain the length `n`.\n *    - The lower 32 bits contain a random seed derived from the storage slot's hash.\n *\n * @dev This function uses low-level assembly for gas efficiency and memory safety.\n */"
        },
        {
            "identifier": "seed",
            "parameters": "PRNG memory prng, uint256 state",
            "modifiers": "pure",
            "return": "",
            "body": "function seed(PRNG memory prng, uint256 state) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(prng, state)\n        }\n    }",
            "start": "61",
            "end": "66",
            "class": "LibPRNG",
            "signature": " seedPRNG memory prng, uint256 state",
            "full_signature": "function seed(PRNG memory prng, uint256 state) internal  pure",
            "class_method_signature": "LibPRNG.seedPRNG memory prng, uint256 state",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Seeds the PRNG (Pseudo-Random Number Generator) with a given state.\n * \n * @param prng The PRNG struct to be seeded.\n * @param state The state value to seed the PRNG with.\n * \n * @dev Uses inline assembly to store the state in the PRNG struct.\n */"
        },
        {
            "identifier": "grow",
            "parameters": "LazyShuffler storage $, uint256 n",
            "modifiers": "",
            "return": "",
            "body": "function grow(LazyShuffler storage $, uint256 n) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let state := sload($.slot) // The packed value at `$`.\n            // If the new length is smaller than the old length, revert.\n            if lt(n, shr(224, state)) {\n                mstore(0x00, 0xbed37c6e) // `InvalidNewLazyShufflerLength()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(state) {\n                mstore(0x00, 0x1ead2566) // `LazyShufflerNotInitialized()`.\n                revert(0x1c, 0x04)\n            }\n            sstore($.slot, or(shl(224, n), shr(32, shl(32, state))))\n        }\n    }",
            "start": "346",
            "end": "361",
            "class": "LibPRNG",
            "signature": " growLazyShuffler storage $, uint256 n",
            "full_signature": "function grow(LazyShuffler storage $, uint256 n) internal",
            "class_method_signature": "LibPRNG.growLazyShuffler storage $, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Grows the size of the LazyShuffler to accommodate a new length `n`.\n *\n * Steps:\n * 1. Load the current state of the LazyShuffler from storage.\n * 2. Check if the new length `n` is smaller than the current length.\n *    - If true, revert with `InvalidNewLazyShufflerLength()` error.\n * 3. Check if the LazyShuffler is uninitialized (state is zero).\n *    - If true, revert with `LazyShufflerNotInitialized()` error.\n * 4. Update the LazyShuffler's state in storage by packing the new length `n` \n *    with the existing state, preserving the lower 32 bits of the state.\n *\n * @dev This function uses low-level assembly for efficient storage manipulation.\n */"
        },
        {
            "identifier": "_toUints",
            "parameters": "address[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory casted)",
            "body": "function _toUints(address[] memory a) private pure returns (uint256[] memory casted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // As any address written to memory will have the upper 96 bits\n            // of the word zeroized (as per Solidity spec), we can directly\n            // compare these addresses as if they are whole uint256 words.\n            casted := a\n        }\n    }",
            "start": "491",
            "end": "499",
            "class": "LibPRNG",
            "signature": "returns (uint256[] memory casted) _toUintsaddress[] memory a",
            "full_signature": "function _toUints(address[] memory a) private  pure returns (uint256[] memory casted)",
            "class_method_signature": "LibPRNG._toUintsaddress[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts an array of addresses to an array of uint256 values.\n * @dev This function uses inline assembly to directly cast the address array to a uint256 array.\n *      Since Solidity ensures that the upper 96 bits of an address are zeroed when stored in memory,\n *      the addresses can be treated as uint256 values without additional manipulation.\n * @param a The input array of addresses to be converted.\n * @return casted The resulting array of uint256 values.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ReentrancyGuard.sol": [
        {
            "identifier": "_REENTRANCY_GUARD_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _REENTRANCY_GUARD_SLOT = 0x929eee149b4bd21268;",
            "start": "21",
            "end": "21",
            "class": "ReentrancyGuard",
            "signature": "uint256 _REENTRANCY_GUARD_SLOT",
            "full_signature": "uint256 private constant _REENTRANCY_GUARD_SLOT",
            "class_method_signature": "ReentrancyGuard._REENTRANCY_GUARD_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant representing the storage slot for the reentrancy guard.\n * This is used to prevent reentrancy attacks by storing a flag in a specific storage slot.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/FixedPointMathLib.sol": [
        {
            "identifier": "divUp",
            "parameters": "uint256 x, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function divUp(uint256 x, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(d) {\n                mstore(0x00, 0x65244e4e) // `DivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(x, d))), div(x, d))\n        }\n    }",
            "start": "645",
            "end": "654",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) divUpuint256 x, uint256 d",
            "full_signature": "function divUp(uint256 x, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.divUpuint256 x, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs division of two unsigned integers, rounding up the result.\n * @dev This function uses inline assembly for gas efficiency and checks for division by zero.\n * If the divisor `d` is zero, it reverts with a `DivFailed()` error.\n * The result is calculated as `(x / d) + (x % d != 0 ? 1 : 0)` to ensure rounding up.\n * @param x The dividend.\n * @param d The divisor.\n * @return z The result of the division, rounded up.\n */"
        },
        {
            "identifier": "ExpOverflow",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ExpOverflow();",
            "start": "13",
            "end": "13",
            "class": "FixedPointMathLib",
            "signature": " ExpOverflow",
            "full_signature": "function ExpOverflow()",
            "class_method_signature": "FixedPointMathLib.ExpOverflow",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating an overflow in an exponentiation operation.\n */"
        },
        {
            "identifier": "powWad",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function powWad(int256 x, int256 y) internal pure returns (int256) {\n        // Using `ln(x)` means `x` must be greater than 0.\n        return expWad((lnWad(x) * y) / int256(WAD));\n    }",
            "start": "199",
            "end": "202",
            "class": "FixedPointMathLib",
            "signature": "returns (int256) powWadint256 x, int256 y",
            "full_signature": "function powWad(int256 x, int256 y) internal  pure returns (int256)",
            "class_method_signature": "FixedPointMathLib.powWadint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calculates the power of `x` raised to `y` using Wad precision.\n * \n * Steps:\n * 1. Requires `x` to be greater than 0 since it uses `lnWad(x)` internally.\n * 2. Computes the natural logarithm of `x` using `lnWad`.\n * 3. Multiplies the result by `y` and divides by `WAD` to maintain precision.\n * 4. Computes the exponential of the result using `expWad` to get the final value.\n * \n * @param x The base value, must be greater than 0.\n * @param y The exponent value.\n * @return The result of `x` raised to the power of `y` in Wad precision.\n */"
        },
        {
            "identifier": "rawDivWadUp",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawDivWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }",
            "start": "189",
            "end": "194",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawDivWadUpuint256 x, uint256 y",
            "full_signature": "function rawDivWadUp(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawDivWadUpuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a division operation with WAD (1e18) precision, rounding up the result.\n *\n * Steps:\n * 1. Multiply `x` by WAD (1e18) to scale it up.\n * 2. Check if there is a remainder when dividing the scaled `x` by `y`.\n * 3. If there is a remainder, add 1 to the result to round up.\n * 4. Return the final result.\n *\n * @param x The numerator.\n * @param y The denominator.\n * @return z The result of the division, rounded up.\n */"
        },
        {
            "identifier": "rawMulWadUp",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawMulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(iszero(iszero(mod(mul(x, y), WAD))), div(mul(x, y), WAD))\n        }\n    }",
            "start": "125",
            "end": "130",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawMulWadUpuint256 x, uint256 y",
            "full_signature": "function rawMulWadUp(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawMulWadUpuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Multiplies two unsigned integers (x and y) and rounds the result up to the nearest WAD (1e18).\n * \n * Steps:\n * 1. Multiply x and y.\n * 2. Check if there is a remainder when dividing the product by WAD.\n * 3. If there is a remainder, add 1 to the result of the division.\n * 4. Return the final result.\n *\n * @param x The first unsigned integer.\n * @param y The second unsigned integer.\n * @return z The result of the multiplication, rounded up to the nearest WAD.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibZip.sol": [
        {
            "identifier": "cdFallback",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "function cdFallback() internal {\n        assembly {\n            if iszero(calldatasize()) { return(calldatasize(), calldatasize()) }\n            let o := 0\n            let f := not(3) // For negating the first 4 bytes.\n            for { let i := 0 } lt(i, calldatasize()) {} {\n                let c := byte(0, xor(add(i, f), calldataload(i)))\n                i := add(i, 1)\n                if iszero(c) {\n                    let d := byte(0, xor(add(i, f), calldataload(i)))\n                    i := add(i, 1)\n                    // Fill with either 0xff or 0x00.\n                    mstore(o, not(0))\n                    if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                    o := add(o, add(and(d, 0x7f), 1))\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            let success := delegatecall(gas(), address(), 0x00, o, codesize(), 0x00)\n            returndatacopy(0x00, 0x00, returndatasize())\n            if iszero(success) { revert(0x00, returndatasize()) }\n            return(0x00, returndatasize())\n        }\n    }",
            "start": "249",
            "end": "274",
            "class": "LibZip",
            "signature": " cdFallback",
            "full_signature": "function cdFallback() internal",
            "class_method_signature": "LibZip.cdFallback",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to handle custom fallback logic using assembly.\n *\n * Steps:\n * 1. Check if there is no calldata. If true, return immediately.\n * 2. Initialize an offset `o` to 0 and a mask `f` to negate the first 4 bytes.\n * 3. Loop through the calldata:\n *    a. Extract a byte from the calldata, XOR it with the mask, and check if it is zero.\n *    b. If zero, extract the next byte and determine if it is greater than 0x7f.\n *    c. Store either 0xff or 0x00 in memory based on the extracted byte.\n *    d. Update the offset `o` accordingly.\n *    e. If the byte is not zero, store it in memory and increment the offset.\n * 4. Perform a delegatecall using the processed calldata.\n * 5. Copy the return data and check if the delegatecall was successful.\n * 6. If successful, return the data. Otherwise, revert with the return data.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EIP712.sol": [
        {
            "identifier": "_cachedDomainSeparator",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private immutable _cachedDomainSeparator;",
            "start": "28",
            "end": "28",
            "class": "EIP712",
            "signature": "bytes32 _cachedDomainSeparator",
            "full_signature": "bytes32 private  _cachedDomainSeparator",
            "class_method_signature": "EIP712._cachedDomainSeparator",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private immutable variable that stores the cached domain separator.\n * The domain separator is used in EIP-712 typed data signing to prevent replay attacks.\n * It is calculated once during contract deployment and cached for efficiency.\n */"
        },
        {
            "identifier": "_buildDomainSeparator",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bytes32 separator)",
            "body": "function _buildDomainSeparator() private view returns (bytes32 separator) {\n        // We will use `separator` to store the name hash to save a bit of gas.\n        bytes32 versionHash;\n        if (_domainNameAndVersionMayChange()) {\n            (string memory name, string memory version) = _domainNameAndVersion();\n            separator = keccak256(bytes(name));\n            versionHash = keccak256(bytes(version));\n        } else {\n            separator = _cachedNameHash;\n            versionHash = _cachedVersionHash;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Load the free memory pointer.\n            mstore(m, _DOMAIN_TYPEHASH)\n            mstore(add(m, 0x20), separator) // Name hash.\n            mstore(add(m, 0x40), versionHash)\n            mstore(add(m, 0x60), chainid())\n            mstore(add(m, 0x80), address())\n            separator := keccak256(m, 0xa0)\n        }\n    }",
            "start": "176",
            "end": "197",
            "class": "EIP712",
            "signature": "returns (bytes32 separator) _buildDomainSeparator",
            "full_signature": "function _buildDomainSeparator() private  view returns (bytes32 separator)",
            "class_method_signature": "EIP712._buildDomainSeparator",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Builds and returns the EIP-712 domain separator for signing typed data.\n *\n * Steps:\n * 1. Determine if the domain name and version may change.\n * 2. If they may change, compute the name and version hashes dynamically.\n * 3. If they are static, use the cached name and version hashes.\n * 4. Use inline assembly to construct the domain separator in memory:\n *    - Load the free memory pointer.\n *    - Store the domain type hash.\n *    - Store the name hash.\n *    - Store the version hash.\n *    - Store the chain ID.\n *    - Store the contract address.\n *    - Compute the final domain separator hash.\n *\n * @return separator The computed EIP-712 domain separator.\n */"
        },
        {
            "identifier": "_domainNameAndVersionMayChange",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function _domainNameAndVersionMayChange() internal pure virtual returns (bool result) {}",
            "start": "95",
            "end": "95",
            "class": "EIP712",
            "signature": "returns (bool result) _domainNameAndVersionMayChange",
            "full_signature": "function _domainNameAndVersionMayChange() internal virtual pure returns (bool result)",
            "class_method_signature": "EIP712._domainNameAndVersionMayChange",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A virtual internal function that indicates whether the domain name and version may change.\n * @dev This function is marked as pure and virtual, meaning it can be overridden by derived contracts.\n * @return result A boolean indicating if the domain name and version may change.\n */"
        },
        {
            "identifier": "_domainNameAndVersion",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (string memory name, string memory version)",
            "body": "function _domainNameAndVersion()\n        internal\n        view\n        virtual\n        returns (string memory name, string memory version);",
            "start": "86",
            "end": "90",
            "class": "EIP712",
            "signature": "returns (string memory name, string memory version) _domainNameAndVersion",
            "full_signature": "function _domainNameAndVersion() internal virtual view returns (string memory name, string memory version)",
            "class_method_signature": "EIP712._domainNameAndVersion",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal view function to retrieve the domain name and version.\n *\n * @return name The domain name.\n * @return version The domain version.\n */"
        },
        {
            "identifier": "_cachedDomainSeparatorInvalidated",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function _cachedDomainSeparatorInvalidated() private view returns (bool result) {\n        uint256 cachedChainId = _cachedChainId;\n        uint256 cachedThis = _cachedThis;\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := iszero(and(eq(chainid(), cachedChainId), eq(address(), cachedThis)))\n        }\n    }",
            "start": "200",
            "end": "207",
            "class": "EIP712",
            "signature": "returns (bool result) _cachedDomainSeparatorInvalidated",
            "full_signature": "function _cachedDomainSeparatorInvalidated() private  view returns (bool result)",
            "class_method_signature": "EIP712._cachedDomainSeparatorInvalidated",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if the cached domain separator is invalidated.\n *\n * The function compares the current chain ID and contract address with the cached values.\n * If either the chain ID or the contract address has changed, the domain separator is considered invalidated.\n *\n * @return result A boolean indicating whether the cached domain separator is invalidated.\n *                - `true` if the domain separator is invalidated.\n *                - `false` if the domain separator is still valid.\n */"
        },
        {
            "identifier": "_cachedNameHash",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private immutable _cachedNameHash;",
            "start": "26",
            "end": "26",
            "class": "EIP712",
            "signature": "bytes32 _cachedNameHash",
            "full_signature": "bytes32 private  _cachedNameHash",
            "class_method_signature": "EIP712._cachedNameHash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private immutable variable that stores the cached hash of a name.\n * This variable is immutable, meaning its value can only be set once during construction and cannot be modified afterward.\n */"
        },
        {
            "identifier": "_cachedThis",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private immutable _cachedThis;",
            "start": "24",
            "end": "24",
            "class": "EIP712",
            "signature": "uint256 _cachedThis",
            "full_signature": "uint256 private  _cachedThis",
            "class_method_signature": "EIP712._cachedThis",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private immutable variable `_cachedThis` of type `uint256`.\n * This variable is immutable, meaning its value can only be set once during construction and cannot be modified afterward.\n */"
        },
        {
            "identifier": "_cachedVersionHash",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 private immutable _cachedVersionHash;",
            "start": "27",
            "end": "27",
            "class": "EIP712",
            "signature": "bytes32 _cachedVersionHash",
            "full_signature": "bytes32 private  _cachedVersionHash",
            "class_method_signature": "EIP712._cachedVersionHash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private immutable variable `_cachedVersionHash` of type `bytes32`.\n * This variable is used to store a cached hash value, likely related to a version or configuration.\n * Being immutable, its value can only be set once during contract deployment and cannot be modified afterward.\n */"
        },
        {
            "identifier": "_DOMAIN_TYPEHASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant _DOMAIN_TYPEHASH =\n        0x8b73c3c69bb8fe3d512ecc4cf759cc79239f7b179b0ffacaa9a75d522b39400f;",
            "start": "21",
            "end": "22",
            "class": "EIP712",
            "signature": "bytes32 _DOMAIN_TYPEHASH",
            "full_signature": "bytes32 internal constant _DOMAIN_TYPEHASH",
            "class_method_signature": "EIP712._DOMAIN_TYPEHASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the EIP-712 domain type hash.\n * This is used for structured data hashing in EIP-712 compliant contracts.\n */"
        },
        {
            "identifier": "_domainSeparator",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bytes32 separator)",
            "body": "function _domainSeparator() internal view virtual returns (bytes32 separator) {\n        if (_domainNameAndVersionMayChange()) {\n            separator = _buildDomainSeparator();\n        } else {\n            separator = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) separator = _buildDomainSeparator();\n        }\n    }",
            "start": "102",
            "end": "109",
            "class": "EIP712",
            "signature": "returns (bytes32 separator) _domainSeparator",
            "full_signature": "function _domainSeparator() internal virtual view returns (bytes32 separator)",
            "class_method_signature": "EIP712._domainSeparator",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Returns the domain separator used in EIP-712 typed data hashing.\n * \n * The domain separator is a unique identifier for the contract and is used to prevent replay attacks.\n * \n * Steps:\n * 1. Check if the domain name and version may change.\n * 2. If they may change, build a new domain separator.\n * 3. If they are not expected to change, use the cached domain separator.\n * 4. If the cached domain separator is invalidated, build a new domain separator.\n * \n * @return separator The domain separator as a bytes32 value.\n */"
        },
        {
            "identifier": "_cachedChainId",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private immutable _cachedChainId;",
            "start": "25",
            "end": "25",
            "class": "EIP712",
            "signature": "uint256 _cachedChainId",
            "full_signature": "uint256 private  _cachedChainId",
            "class_method_signature": "EIP712._cachedChainId",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private immutable variable that stores the cached chain ID.\n * This variable is immutable, meaning its value is set once during contract deployment and cannot be changed afterward.\n */"
        },
        {
            "identifier": "_hashTypedData",
            "parameters": "bytes32 structHash",
            "modifiers": "view",
            "return": "returns (bytes32 digest)",
            "body": "function _hashTypedData(bytes32 structHash) internal view virtual returns (bytes32 digest) {\n        // We will use `digest` to store the domain separator to save a bit of gas.\n        if (_domainNameAndVersionMayChange()) {\n            digest = _buildDomainSeparator();\n        } else {\n            digest = _cachedDomainSeparator;\n            if (_cachedDomainSeparatorInvalidated()) digest = _buildDomainSeparator();\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute the digest.\n            mstore(0x00, 0x1901000000000000) // Store \"\\x19\\x01\".\n            mstore(0x1a, digest) // Store the domain separator.\n            mstore(0x3a, structHash) // Store the struct hash.\n            digest := keccak256(0x18, 0x42)\n            // Restore the part of the free memory slot that was overwritten.\n            mstore(0x3a, 0)\n        }\n    }",
            "start": "124",
            "end": "142",
            "class": "EIP712",
            "signature": "returns (bytes32 digest) _hashTypedDatabytes32 structHash",
            "full_signature": "function _hashTypedData(bytes32 structHash) internal virtual view returns (bytes32 digest)",
            "class_method_signature": "EIP712._hashTypedDatabytes32 structHash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Computes the EIP-712 typed data hash for a given struct hash.\n *\n * Steps:\n * 1. Check if the domain name and version may change.\n * 2. If true, build a new domain separator and store it in `digest`.\n * 3. If false, use the cached domain separator.\n * 4. If the cached domain separator is invalidated, build a new one.\n *\n * 5. Use inline assembly to compute the digest:\n *    a. Store the EIP-712 prefix (0x1901) in memory.\n *    b. Store the domain separator in memory.\n *    c. Store the struct hash in memory.\n *    d. Compute the keccak256 hash of the concatenated data.\n *    e. Restore the overwritten memory slot.\n *\n * @param structHash The hash of the struct to be signed.\n * @return digest The computed EIP-712 typed data hash.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ReentrancyGuardTransient.sol": [
        {
            "identifier": "_useTransientReentrancyGuardOnlyOnMainnet",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function _useTransientReentrancyGuardOnlyOnMainnet() internal view virtual returns (bool) {\n        return true;\n    }",
            "start": "120",
            "end": "122",
            "class": "ReentrancyGuardTransient",
            "signature": "returns (bool) _useTransientReentrancyGuardOnlyOnMainnet",
            "full_signature": "function _useTransientReentrancyGuardOnlyOnMainnet() internal virtual view returns (bool)",
            "class_method_signature": "ReentrancyGuardTransient._useTransientReentrancyGuardOnlyOnMainnet",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to determine if the transient reentrancy guard should only be used on the mainnet.\n * @return bool Returns `true` if the guard should only be used on the mainnet, otherwise `false`.\n */"
        },
        {
            "identifier": "_REENTRANCY_GUARD_SLOT",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _REENTRANCY_GUARD_SLOT = 0x8000000000ab143c06;",
            "start": "24",
            "end": "24",
            "class": "ReentrancyGuardTransient",
            "signature": "uint256 _REENTRANCY_GUARD_SLOT",
            "full_signature": "uint256 private constant _REENTRANCY_GUARD_SLOT",
            "class_method_signature": "ReentrancyGuardTransient._REENTRANCY_GUARD_SLOT",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a private constant `_REENTRANCY_GUARD_SLOT` with a specific slot value.\n * This slot is likely used for reentrancy protection in the contract.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibCall.sol": [
        {
            "identifier": "staticCallContract",
            "parameters": "address target, bytes memory data",
            "modifiers": "view",
            "return": "returns (bytes memory result)",
            "body": "function staticCallContract(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(staticcall(gas(), target, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "start": "83",
            "end": "107",
            "class": "LibCall",
            "signature": "returns (bytes memory result) staticCallContractaddress target, bytes memory data",
            "full_signature": "function staticCallContract(address target, bytes memory data) internal  view returns (bytes memory result)",
            "class_method_signature": "LibCall.staticCallContractaddress target, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a static call to a target contract with the provided data.\n * \n * Steps:\n * 1. Allocate memory for the result.\n * 2. Perform a static call to the target contract using the provided data.\n * 3. If the call fails, revert with the returned data.\n * 4. If the call succeeds but returns no data, check if the target is a contract.\n *    - If the target is not a contract, revert with `TargetIsNotContract()` error.\n * 5. Store the length of the returned data.\n * 6. Copy the returned data into the result memory.\n * 7. Allocate additional memory for the result.\n * \n * @param target The address of the contract to call.\n * @param data The calldata to send to the target contract.\n * @return result The returned data from the static call.\n */"
        },
        {
            "identifier": "setSelector",
            "parameters": "bytes4 newSelector, bytes memory data",
            "modifiers": "pure",
            "return": "",
            "body": "function setSelector(bytes4 newSelector, bytes memory data) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(gt(mload(data), 0x03)) {\n                mstore(0x00, 0x0acec8bd) // `DataTooShort()`.\n                revert(0x1c, 0x04)\n            }\n            let o := add(data, 0x20)\n            mstore(o, or(shr(32, shl(32, mload(o))), newSelector))\n        }\n    }",
            "start": "209",
            "end": "219",
            "class": "LibCall",
            "signature": " setSelectorbytes4 newSelector, bytes memory data",
            "full_signature": "function setSelector(bytes4 newSelector, bytes memory data) internal  pure",
            "class_method_signature": "LibCall.setSelectorbytes4 newSelector, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Sets the function selector in the provided data.\n * @dev This function is used to replace the first 4 bytes of the data with a new selector.\n *      It performs a low-level assembly operation to ensure memory safety.\n * \n * Steps:\n * 1. Check if the length of the data is greater than 3 bytes. If not, revert with `DataTooShort()` error.\n * 2. Calculate the offset where the selector is stored in the data.\n * 3. Replace the first 4 bytes of the data with the new selector while preserving the rest of the data.\n * \n * @param newSelector The new 4-byte function selector to be set.\n * @param data The data in which the selector will be replaced.\n */"
        },
        {
            "identifier": "delegateCallContract",
            "parameters": "address target, bytes memory data",
            "modifiers": "",
            "return": "returns (bytes memory result)",
            "body": "function delegateCallContract(address target, bytes memory data)\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(delegatecall(gas(), target, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "start": "110",
            "end": "133",
            "class": "LibCall",
            "signature": "returns (bytes memory result) delegateCallContractaddress target, bytes memory data",
            "full_signature": "function delegateCallContract(address target, bytes memory data) internal   returns (bytes memory result)",
            "class_method_signature": "LibCall.delegateCallContractaddress target, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a delegate call to a target contract with the provided data.\n *\n * Steps:\n * 1. Load the free memory pointer into `result`.\n * 2. Execute a delegate call to the target contract using the provided data.\n * 3. If the delegate call fails, revert with the returned data.\n * 4. If the delegate call succeeds but returns no data, check if the target is a contract.\n *    - If the target is not a contract, revert with the error `TargetIsNotContract()`.\n * 5. Store the length of the returned data in `result`.\n * 6. Copy the returned data into memory starting at `result + 0x20`.\n * 7. Update the free memory pointer to account for the returned data.\n *\n * @param target The address of the contract to delegate call.\n * @param data The data to send with the delegate call.\n * @return result The returned data from the delegate call.\n */"
        },
        {
            "identifier": "callContract",
            "parameters": "address target, uint256 value, bytes memory data",
            "modifiers": "",
            "return": "returns (bytes memory result)",
            "body": "function callContract(address target, uint256 value, bytes memory data)\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(call(gas(), target, value, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "start": "31",
            "end": "54",
            "class": "LibCall",
            "signature": "returns (bytes memory result) callContractaddress target, uint256 value, bytes memory data",
            "full_signature": "function callContract(address target, uint256 value, bytes memory data) internal   returns (bytes memory result)",
            "class_method_signature": "LibCall.callContractaddress target, uint256 value, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calls an external contract with the specified target address, value, and data.\n * @dev This function uses low-level assembly to perform the call and handle reverts.\n *\n * Steps:\n * 1. Load the free memory pointer to store the result.\n * 2. Perform a low-level call to the target contract with the provided gas, value, and data.\n * 3. If the call fails, revert with the returned data.\n * 4. If the call succeeds but the target is not a contract, revert with a custom error `TargetIsNotContract`.\n * 5. Store the length of the returned data.\n * 6. Copy the returned data to the result memory location.\n * 7. Update the free memory pointer to allocate memory for the result.\n *\n * @param target The address of the contract to call.\n * @param value The amount of Ether to send with the call.\n * @param data The calldata to send with the call.\n * @return result The returned data from the contract call.\n */"
        },
        {
            "identifier": "tryStaticCall",
            "parameters": "address target, uint256 gasStipend, uint16 maxCopy, bytes memory data",
            "modifiers": "view",
            "return": "returns (bool success, bool exceededMaxCopy, bytes memory result)",
            "body": "function tryStaticCall(address target, uint256 gasStipend, uint16 maxCopy, bytes memory data)\n        internal\n        view\n        returns (bool success, bool exceededMaxCopy, bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            success :=\n                staticcall(gasStipend, target, add(data, 0x20), mload(data), codesize(), 0x00)\n            let n := returndatasize()\n            if gt(returndatasize(), and(0xffff, maxCopy)) {\n                n := and(0xffff, maxCopy)\n                exceededMaxCopy := 1\n            }\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, n) // Copy the returndata.\n            mstore(0x40, add(o, n)) // Allocate the memory.\n        }\n    }",
            "start": "174",
            "end": "194",
            "class": "LibCall",
            "signature": "returns (bool success, bool exceededMaxCopy, bytes memory result) tryStaticCalladdress target, uint256 gasStipend, uint16 maxCopy, bytes memory data",
            "full_signature": "function tryStaticCall(address target, uint256 gasStipend, uint16 maxCopy, bytes memory data) internal  view returns (bool success, bool exceededMaxCopy, bytes memory result)",
            "class_method_signature": "LibCall.tryStaticCalladdress target, uint256 gasStipend, uint16 maxCopy, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a static call to a target address with specified gas stipend and maximum data copy size.\n * @dev This function is marked as `internal` and `view`, meaning it can only be called within the contract and does not modify state.\n * \n * Steps:\n * 1. Allocate memory for the result.\n * 2. Perform a static call to the target address with the provided gas stipend and data.\n * 3. Check if the return data size exceeds the maximum allowed copy size.\n * 4. If the return data size exceeds the limit, truncate it to the maximum allowed size and set `exceededMaxCopy` to true.\n * 5. Store the length of the return data in the result.\n * 6. Copy the return data into the result memory.\n * 7. Allocate memory for the result data.\n *\n * @param target The address to which the static call is made.\n * @param gasStipend The amount of gas to be used for the static call.\n * @param maxCopy The maximum number of bytes to copy from the return data.\n * @param data The data to be sent with the static call.\n * @return success A boolean indicating whether the static call was successful.\n * @return exceededMaxCopy A boolean indicating whether the return data exceeded the maximum allowed copy size.\n * @return result The return data from the static call, truncated if necessary.\n */"
        },
        {
            "identifier": "tryCall",
            "parameters": "address target, uint256 value, uint256 gasStipend, uint16 maxCopy, bytes memory data",
            "modifiers": "",
            "return": "returns (bool success, bool exceededMaxCopy, bytes memory result)",
            "body": "function tryCall(\n        address target,\n        uint256 value,\n        uint256 gasStipend,\n        uint16 maxCopy,\n        bytes memory data\n    ) internal returns (bool success, bool exceededMaxCopy, bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            success :=\n                call(gasStipend, target, value, add(data, 0x20), mload(data), codesize(), 0x00)\n            let n := returndatasize()\n            if gt(returndatasize(), and(0xffff, maxCopy)) {\n                n := and(0xffff, maxCopy)\n                exceededMaxCopy := 1\n            }\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, n) // Copy the returndata.\n            mstore(0x40, add(o, n)) // Allocate the memory.\n        }\n    }",
            "start": "147",
            "end": "169",
            "class": "LibCall",
            "signature": "returns (bool success, bool exceededMaxCopy, bytes memory result) tryCalladdress target, uint256 value, uint256 gasStipend, uint16 maxCopy, bytes memory data",
            "full_signature": "function tryCall(address target, uint256 value, uint256 gasStipend, uint16 maxCopy, bytes memory data) internal   returns (bool success, bool exceededMaxCopy, bytes memory result)",
            "class_method_signature": "LibCall.tryCalladdress target, uint256 value, uint256 gasStipend, uint16 maxCopy, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to call a target address with specified value, gas stipend, and data.\n * @dev This function is designed to be memory-safe and uses inline assembly for low-level operations.\n *\n * Steps:\n * 1. Allocate memory for the result.\n * 2. Perform a low-level call to the target address with the specified gas stipend, value, and data.\n * 3. Check if the returned data size exceeds the maximum allowed copy size.\n * 4. If the returned data size exceeds the limit, truncate it and set the `exceededMaxCopy` flag.\n * 5. Store the length of the returned data in the result memory.\n * 6. Copy the returned data into the result memory.\n * 7. Update the free memory pointer to allocate memory for the result.\n *\n * @param target The address to call.\n * @param value The amount of Ether to send with the call.\n * @param gasStipend The amount of gas to provide for the call.\n * @param maxCopy The maximum number of bytes to copy from the returned data.\n * @param data The calldata to send with the call.\n * @return success Whether the call was successful.\n * @return exceededMaxCopy Whether the returned data exceeded the maximum allowed copy size.\n * @return result The returned data from the call.\n */"
        },
        {
            "identifier": "DataTooShort",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error DataTooShort();",
            "start": "20",
            "end": "20",
            "class": "LibCall",
            "signature": " DataTooShort",
            "full_signature": "function DataTooShort()",
            "class_method_signature": "LibCall.DataTooShort",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the provided data is too short.\n */"
        },
        {
            "identifier": "TargetIsNotContract",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error TargetIsNotContract();",
            "start": "17",
            "end": "17",
            "class": "LibCall",
            "signature": " TargetIsNotContract",
            "full_signature": "function TargetIsNotContract()",
            "class_method_signature": "LibCall.TargetIsNotContract",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the target address is not a contract.\n */"
        },
        {
            "identifier": "bubbleUpRevert",
            "parameters": "bytes memory revertReturnData",
            "modifiers": "pure",
            "return": "",
            "body": "function bubbleUpRevert(bytes memory revertReturnData) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            revert(add(0x20, revertReturnData), mload(revertReturnData))\n        }\n    }",
            "start": "201",
            "end": "206",
            "class": "LibCall",
            "signature": " bubbleUpRevertbytes memory revertReturnData",
            "full_signature": "function bubbleUpRevert(bytes memory revertReturnData) internal  pure",
            "class_method_signature": "LibCall.bubbleUpRevertbytes memory revertReturnData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal function to revert a transaction and bubble up the revert reason.\n * \n * Steps:\n * 1. Use inline assembly to revert the transaction.\n * 2. The revert reason is passed as `revertReturnData`.\n * 3. The assembly code calculates the memory offset and length of the revert reason.\n * 4. The transaction is reverted with the provided reason.\n */"
        },
        {
            "identifier": "callContract",
            "parameters": "address target, bytes memory data",
            "modifiers": "",
            "return": "returns (bytes memory result)",
            "body": "function callContract(address target, bytes memory data)\n        internal\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            if iszero(call(gas(), target, 0, add(data, 0x20), mload(data), codesize(), 0x00)) {\n                // Bubble up the revert if the call reverts.\n                returndatacopy(result, 0x00, returndatasize())\n                revert(result, returndatasize())\n            }\n            if iszero(returndatasize()) {\n                if iszero(extcodesize(target)) {\n                    mstore(0x00, 0x5a836a5f) // `TargetIsNotContract()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            mstore(result, returndatasize()) // Store the length.\n            let o := add(result, 0x20)\n            returndatacopy(o, 0x00, returndatasize()) // Copy the returndata.\n            mstore(0x40, add(o, returndatasize())) // Allocate the memory.\n        }\n    }",
            "start": "57",
            "end": "80",
            "class": "LibCall",
            "signature": "returns (bytes memory result) callContractaddress target, bytes memory data",
            "full_signature": "function callContract(address target, bytes memory data) internal   returns (bytes memory result)",
            "class_method_signature": "LibCall.callContractaddress target, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Calls an external contract with the provided target address and data.\n * @dev This function uses low-level assembly to perform the call and handle reverts.\n *\n * Steps:\n * 1. Load the free memory pointer into `result`.\n * 2. Perform a low-level call to the target contract with the provided data.\n * 3. If the call reverts, copy the revert data and propagate the revert.\n * 4. If the call succeeds but the target is not a contract, revert with `TargetIsNotContract()` error.\n * 5. Store the length of the return data in `result`.\n * 6. Copy the return data into memory and update the free memory pointer.\n *\n * @param target The address of the contract to call.\n * @param data The calldata to send to the target contract.\n * @return result The return data from the external call.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibClone.sol": [
        {
            "identifier": "cloneDeterministic_PUSH0",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic_PUSH0(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic_PUSH0(0, implementation, salt);\n    }",
            "start": "351",
            "end": "356",
            "class": "LibClone",
            "signature": "returns (address instance) cloneDeterministic_PUSH0address implementation, bytes32 salt",
            "full_signature": "function cloneDeterministic_PUSH0(address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneDeterministic_PUSH0address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using the PUSH0 opcode.\n * @param implementation The address of the implementation contract to clone.\n * @param salt A unique salt to ensure deterministic deployment.\n * @return instance The address of the newly created clone.\n * @dev This function internally calls `cloneDeterministic_PUSH0` with a value of 0.\n */"
        },
        {
            "identifier": "PUSH0_CLONE_CODE_HASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant PUSH0_CLONE_CODE_HASH =\n        0x67bc6bde1b84d66e267c718ba44cf3928a615d29885537955cb43d44b3e789dc;",
            "start": "81",
            "end": "82",
            "class": "LibClone",
            "signature": "bytes32 PUSH0_CLONE_CODE_HASH",
            "full_signature": "bytes32 internal constant PUSH0_CLONE_CODE_HASH",
            "class_method_signature": "LibClone.PUSH0_CLONE_CODE_HASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the keccak256 hash of the PUSH0 clone code.\n * This is used internally for specific operations related to the PUSH0 opcode.\n */"
        },
        {
            "identifier": "CLONE_CODE_HASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant CLONE_CODE_HASH =\n        0x48db2cfdb2853fce0b464f1f93a1996469459df3ab6c812106074c4106a1eb1f;",
            "start": "76",
            "end": "77",
            "class": "LibClone",
            "signature": "bytes32 CLONE_CODE_HASH",
            "full_signature": "bytes32 internal constant CLONE_CODE_HASH",
            "class_method_signature": "LibClone.CLONE_CODE_HASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the keccak256 hash of the clone creation code.\n * This is used to verify the integrity of cloned contracts or to ensure that the correct\n * contract is being interacted with.\n */"
        },
        {
            "identifier": "clone_PUSH0",
            "parameters": "address implementation",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function clone_PUSH0(address implementation) internal returns (address instance) {\n        instance = clone_PUSH0(0, implementation);\n    }",
            "start": "269",
            "end": "271",
            "class": "LibClone",
            "signature": "returns (address instance) clone_PUSH0address implementation",
            "full_signature": "function clone_PUSH0(address implementation) internal   returns (address instance)",
            "class_method_signature": "LibClone.clone_PUSH0address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Clones a contract using the PUSH0 opcode.\n * @param implementation The address of the contract to clone.\n * @return instance The address of the newly cloned contract instance.\n */"
        },
        {
            "identifier": "cloneDeterministic_PUSH0",
            "parameters": "uint256 value, address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create2(value, 0x0e, 0x36, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "360",
            "end": "376",
            "class": "LibClone",
            "signature": "returns (address instance) cloneDeterministic_PUSH0uint256 value, address implementation, bytes32 salt",
            "full_signature": "function cloneDeterministic_PUSH0(uint256 value, address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneDeterministic_PUSH0uint256 value, address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using the CREATE2 opcode with PUSH0 optimization.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract to clone.\n * @param salt A unique salt to ensure deterministic address generation.\n *\n * Steps:\n * 1. Store the precomputed bytecode in memory for the CREATE2 deployment.\n * 2. Store the implementation address in memory.\n * 3. Store the initialization code in memory.\n * 4. Use CREATE2 to deploy the contract with the provided value, memory offset, length, and salt.\n * 5. If the deployment fails, revert with the `DeploymentFailed()` error.\n * 6. Restore the overwritten part of the free memory pointer.\n *\n * @return instance The address of the newly deployed contract.\n */"
        },
        {
            "identifier": "predictDeterministicAddress_PUSH0",
            "parameters": "address implementation, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress_PUSH0(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash_PUSH0(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "405",
            "end": "412",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddress_PUSH0address implementation, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress_PUSH0(address implementation, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddress_PUSH0address implementation, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using the PUSH0 opcode.\n * \n * @param implementation The address of the implementation contract.\n * @param salt A unique salt used to generate the deterministic address.\n * @param deployer The address of the deployer.\n * \n * @return predicted The predicted deterministic address for the contract deployment.\n * \n * Steps:\n * 1. Compute the initialization code hash for the implementation contract using `initCodeHash_PUSH0`.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address.\n */"
        },
        {
            "identifier": "argLoad",
            "parameters": "bytes memory args, uint256 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function argLoad(bytes memory args, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(args, 0x20), offset))\n        }\n    }",
            "start": "2857",
            "end": "2862",
            "class": "LibClone",
            "signature": "returns (bytes32 result) argLoadbytes memory args, uint256 offset",
            "full_signature": "function argLoad(bytes memory args, uint256 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibClone.argLoadbytes memory args, uint256 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Loads a bytes32 value from a specific offset in a bytes memory array.\n *\n * Steps:\n * 1. Use inline assembly to load a bytes32 value from the given offset in the bytes memory array.\n * 2. The offset is added to the base address of the array (skipping the length prefix).\n * 3. The result is returned as a bytes32 value.\n *\n * @param args The bytes memory array from which to load the value.\n * @param offset The offset within the array from which to load the value.\n * @return result The bytes32 value loaded from the specified offset.\n */"
        },
        {
            "identifier": "clone_PUSH0",
            "parameters": "uint256 value, address implementation",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function clone_PUSH0(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 5f         | PUSH0             | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 5f         | PUSH0             | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (45 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 5f      | PUSH0          | 0                      |                       |\n             * 5f      | PUSH0          | 0 0                    |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                |                       |\n             * 5f      | PUSH0          | 0 cds 0 0              |                       |\n             * 5f      | PUSH0          | 0 0 cds 0 0            |                       |\n             * 37      | CALLDATACOPY   | 0 0                    | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0                | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 cds 0 0              | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0         | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0     | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success            | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 rds success          | [0..cds): calldata    |\n             * 5f      | PUSH0          | 0 0 rds success        | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success                | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x29 | PUSH1 0x29     | 0x29 success           | [0..rds): returndata  |\n             * 57      | JUMPI          |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       |                        | [0..rds): returndata  |\n             * 3d      | RETURNDATASIZE | rds                    | [0..rds): returndata  |\n             * 5f      | PUSH0          | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            instance := create(value, 0x0e, 0x36)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "275",
            "end": "348",
            "class": "LibClone",
            "signature": "returns (address instance) clone_PUSH0uint256 value, address implementation",
            "full_signature": "function clone_PUSH0(uint256 value, address implementation) internal   returns (address instance)",
            "class_method_signature": "LibClone.clone_PUSH0uint256 value, address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Clones a contract using the PUSH0 opcode and delegates calls to the implementation contract.\n *\n * Steps:\n * 1. Store the runtime code and implementation address in memory.\n * 2. Use the `create` opcode to deploy the contract with the provided value.\n * 3. If the deployment fails, revert with the error `DeploymentFailed()`.\n * 4. Restore the overwritten part of the free memory pointer.\n *\n * Assembly Details:\n * - The assembly block contains the creation and runtime code for the contract.\n * - The creation code initializes the contract and copies the runtime code.\n * - The runtime code handles calldata, delegates calls to the implementation, and manages return data.\n * - If the delegate call fails, the contract reverts with the return data.\n * - If successful, the contract returns the return data.\n */"
        },
        {
            "identifier": "ETHTransferFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error ETHTransferFailed();",
            "start": "116",
            "end": "116",
            "class": "LibClone",
            "signature": " ETHTransferFailed",
            "full_signature": "function ETHTransferFailed()",
            "class_method_signature": "LibClone.ETHTransferFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that an ETH transfer has failed.\n */"
        },
        {
            "identifier": "CWIA_CODE_HASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant CWIA_CODE_HASH =\n        0x3cf92464268225a4513da40a34d967354684c32cd0edd67b5f668dfe3550e940;",
            "start": "86",
            "end": "87",
            "class": "LibClone",
            "signature": "bytes32 CWIA_CODE_HASH",
            "full_signature": "bytes32 internal constant CWIA_CODE_HASH",
            "class_method_signature": "LibClone.CWIA_CODE_HASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant variable storing the code hash for CWIA (likely a contract or interface).\n * This hash is used for verification or identification purposes in the contract.\n */"
        },
        {
            "identifier": "initCodeHashERC1967Bootstrap",
            "parameters": "address authorizedUpgrader",
            "modifiers": "pure",
            "return": "returns (bytes32)",
            "body": "function initCodeHashERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(initCodeERC1967Bootstrap(authorizedUpgrader));\n    }",
            "start": "1782",
            "end": "1788",
            "class": "LibClone",
            "signature": "returns (bytes32) initCodeHashERC1967Bootstrapaddress authorizedUpgrader",
            "full_signature": "function initCodeHashERC1967Bootstrap(address authorizedUpgrader) internal  pure returns (bytes32)",
            "class_method_signature": "LibClone.initCodeHashERC1967Bootstrapaddress authorizedUpgrader",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Computes the keccak256 hash of the initialization code for an ERC1967 bootstrap contract.\n *\n * @param authorizedUpgrader The address of the authorized upgrader.\n * @return The keccak256 hash of the initialization code.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/WebAuthn.sol": [
        {
            "identifier": "encodeAuth",
            "parameters": "WebAuthnAuth memory auth",
            "modifiers": "pure",
            "return": "returns (bytes memory)",
            "body": "function encodeAuth(WebAuthnAuth memory auth) internal pure returns (bytes memory) {\n        return abi.encode(auth);\n    }",
            "start": "173",
            "end": "175",
            "class": "WebAuthn",
            "signature": "returns (bytes memory) encodeAuthWebAuthnAuth memory auth",
            "full_signature": "function encodeAuth(WebAuthnAuth memory auth) internal  pure returns (bytes memory)",
            "class_method_signature": "WebAuthn.encodeAuthWebAuthnAuth memory auth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'function encode(bytes memory data) internal  pure returns (string memory)', 'uint256 internal constant A', 'function encode(bytes memory data, bool fileSafe, bool noPadding) internal  pure returns (string memory result)', 'function encode(bytes memory data, bool fileSafe) internal  pure returns (string memory result)', 'function encode(bytes memory data) internal  pure returns (string memory result)'}",
            "human_labeled_comment": "/**\n * @notice Encodes a WebAuthnAuth struct into a bytes array.\n *\n * @param auth The WebAuthnAuth struct to be encoded.\n * @return bytes The encoded bytes representation of the WebAuthnAuth struct.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/P256.sol": [
        {
            "identifier": "_HALF_N",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 private constant _HALF_N =\n        0x7fffffff800000007fffffffffffffffde737d56d38bcf4279dce5617e3192a8;",
            "start": "37",
            "end": "38",
            "class": "P256",
            "signature": "uint256 _HALF_N",
            "full_signature": "uint256 private constant _HALF_N",
            "class_method_signature": "P256._HALF_N",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice A private constant variable `_HALF_N` representing a large 256-bit integer value.\n * The value is a hexadecimal constant used for specific calculations or constraints in the contract.\n */"
        },
        {
            "identifier": "P256VerificationFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error P256VerificationFailed();",
            "start": "15",
            "end": "15",
            "class": "P256",
            "signature": " P256VerificationFailed",
            "full_signature": "function P256VerificationFailed()",
            "class_method_signature": "P256.P256VerificationFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the P256 verification process has failed.\n */"
        },
        {
            "identifier": "tryDecodePointCalldata",
            "parameters": "bytes calldata encoded",
            "modifiers": "pure",
            "return": "returns (bytes32 x, bytes32 y)",
            "body": "function tryDecodePointCalldata(bytes calldata encoded)\n        internal\n        pure\n        returns (bytes32 x, bytes32 y)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := gt(encoded.length, 0x3f)\n            x := mul(calldataload(encoded.offset), t)\n            y := mul(calldataload(add(encoded.offset, 0x20)), t)\n        }\n    }",
            "start": "128",
            "end": "139",
            "class": "P256",
            "signature": "returns (bytes32 x, bytes32 y) tryDecodePointCalldatabytes calldata encoded",
            "full_signature": "function tryDecodePointCalldata(bytes calldata encoded) internal  pure returns (bytes32 x, bytes32 y)",
            "class_method_signature": "P256.tryDecodePointCalldatabytes calldata encoded",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to decode a point from the provided calldata.\n * @dev This function uses inline assembly to safely decode the x and y coordinates of a point.\n *      It checks if the encoded data length is greater than 0x3f (63 bytes) to ensure valid data.\n *      If the data is valid, it loads the x and y coordinates from the calldata.\n * @param encoded The calldata containing the encoded point.\n * @return x The x-coordinate of the decoded point.\n * @return y The y-coordinate of the decoded point.\n */"
        },
        {
            "identifier": "verifySignature",
            "parameters": "bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function verifySignature(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, hash)\n            mstore(add(m, 0x20), r)\n            mstore(add(m, 0x40), s)\n            mstore(add(m, 0x60), x)\n            mstore(add(m, 0x80), y)\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\n            // RIP-7212 dictates that success returns `uint256(1)`.\n            // But failure returns zero returndata, which is ambiguous.\n            if iszero(returndatasize()) {\n                pop(staticcall(gas(), VERIFIER, m, 0xa0, returndatasize(), 0x20))\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure,\n                // allowing us to use the returndatasize to determine existence.\n                if iszero(returndatasize()) {\n                    mstore(returndatasize(), 0xd0d5039b) // `P256VerificationFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            // Optimize for happy path. Users are unlikely to pass in malleable signatures.\n            isValid := lt(gt(s, _HALF_N), eq(1, mload(0x00)))\n        }\n    }",
            "start": "80",
            "end": "109",
            "class": "P256",
            "signature": "returns (bool isValid) verifySignaturebytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "full_signature": "function verifySignature(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y) internal  view returns (bool isValid)",
            "class_method_signature": "P256.verifySignaturebytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Verifies a signature using the provided hash, r, s, x, and y values.\n *\n * Steps:\n * 1. Load the memory pointer at 0x40.\n * 2. Store the hash, r, s, x, and y values in memory.\n * 3. Zeroize the return slot before making static calls.\n * 4. Perform a static call to the RIP precompile with the stored values.\n * 5. Check if the returndatasize is zero, indicating a potential failure.\n * 6. If returndatasize is zero, perform another static call to the verifier.\n * 7. If the verifier also fails, revert with the error `P256VerificationFailed()`.\n * 8. Optimize for the happy path by checking if the signature is valid and non-malleable.\n * 9. Return `isValid` as true if the signature is valid, otherwise false.\n */"
        },
        {
            "identifier": "N",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant N = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551;",
            "start": "34",
            "end": "34",
            "class": "P256",
            "signature": "uint256 N",
            "full_signature": "uint256 internal constant N",
            "class_method_signature": "P256.N",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant `N` with a specific 256-bit hexadecimal value.\n * This value is typically used in cryptographic operations or as a modulus in elliptic curve computations.\n */"
        },
        {
            "identifier": "tryDecodePoint",
            "parameters": "bytes memory encoded",
            "modifiers": "pure",
            "return": "returns (bytes32 x, bytes32 y)",
            "body": "function tryDecodePoint(bytes memory encoded) internal pure returns (bytes32 x, bytes32 y) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let t := gt(mload(encoded), 0x3f)\n            x := mul(mload(add(encoded, 0x20)), t)\n            y := mul(mload(add(encoded, 0x40)), t)\n        }\n    }",
            "start": "117",
            "end": "124",
            "class": "P256",
            "signature": "returns (bytes32 x, bytes32 y) tryDecodePointbytes memory encoded",
            "full_signature": "function tryDecodePoint(bytes memory encoded) internal  pure returns (bytes32 x, bytes32 y)",
            "class_method_signature": "P256.tryDecodePointbytes memory encoded",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Attempts to decode a point from the given encoded bytes.\n * @dev Uses inline assembly to safely decode the x and y coordinates from the encoded bytes.\n * \n * Steps:\n * 1. Check if the length of the encoded bytes is greater than 0x3f.\n * 2. Load the x coordinate from the encoded bytes at offset 0x20.\n * 3. Load the y coordinate from the encoded bytes at offset 0x40.\n * 4. Multiply the loaded values by the result of the length check to ensure valid coordinates.\n * \n * @param encoded The encoded bytes containing the point coordinates.\n * @return x The decoded x coordinate.\n * @return y The decoded y coordinate.\n */"
        },
        {
            "identifier": "verifySignatureAllowMalleability",
            "parameters": "bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function verifySignatureAllowMalleability(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, hash)\n            mstore(add(m, 0x20), r)\n            mstore(add(m, 0x40), s)\n            mstore(add(m, 0x60), x)\n            mstore(add(m, 0x80), y)\n            mstore(0x00, 0) // Zeroize the return slot before the staticcalls.\n            pop(staticcall(gas(), RIP_PRECOMPILE, m, 0xa0, 0x00, 0x20))\n            // RIP-7212 dictates that success returns `uint256(1)`.\n            // But failure returns zero returndata, which is ambiguous.\n            if iszero(returndatasize()) {\n                pop(staticcall(gas(), VERIFIER, m, 0xa0, returndatasize(), 0x20))\n                // Unlike RIP-7212, the verifier returns `uint256(0)` on failure,\n                // allowing us to use the returndatasize to determine existence.\n                if iszero(returndatasize()) {\n                    mstore(returndatasize(), 0xd0d5039b) // `P256VerificationFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            isValid := eq(1, mload(0x00))\n        }\n    }",
            "start": "46",
            "end": "76",
            "class": "P256",
            "signature": "returns (bool isValid) verifySignatureAllowMalleabilitybytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "full_signature": "function verifySignatureAllowMalleability(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y) internal  view returns (bool isValid)",
            "class_method_signature": "P256.verifySignatureAllowMalleabilitybytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Verifies a signature while allowing for malleability, using low-level assembly for efficiency.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store the hash, r, s, x, and y values in the allocated memory.\n * 3. Zeroize the return slot before making static calls.\n * 4. Perform a static call to the RIP precompile with the stored values.\n * 5. Check if the returndatasize is zero, indicating a potential failure.\n * 6. If returndatasize is zero, perform a static call to the verifier.\n * 7. If the verifier also fails (returndatasize is zero), revert with the error `P256VerificationFailed()`.\n * 8. Set `isValid` to true if the result from the precompile or verifier is 1, otherwise false.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibString.sol": [
        {
            "identifier": "toHexStringNoPrefix",
            "parameters": "bytes memory raw",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexStringNoPrefix(bytes memory raw) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(raw)\n            result := add(mload(0x40), 2) // Skip 2 bytes for the optional prefix.\n            mstore(result, add(n, n)) // Store the length of the output.\n\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n            let o := add(result, 0x20)\n            let end := add(raw, n)\n            for {} iszero(eq(raw, end)) {} {\n                raw := add(raw, 1)\n                mstore8(add(o, 1), mload(and(mload(raw), 15)))\n                mstore8(o, mload(and(shr(4, mload(raw)), 15)))\n                o := add(o, 2)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "start": "408",
            "end": "427",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringNoPrefixbytes memory raw",
            "full_signature": "function toHexStringNoPrefix(bytes memory raw) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringNoPrefixbytes memory raw",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a byte array to a hexadecimal string without the \"0x\" prefix.\n *\n * Steps:\n * 1. Load the length of the input byte array.\n * 2. Calculate the starting position of the result string, skipping 2 bytes for the optional prefix.\n * 3. Store the length of the output string.\n *\n * 4. Store the lookup table for hexadecimal characters (\"0123456789abcdef\").\n * 5. Initialize pointers for the output string and the end of the input byte array.\n * 6. Iterate through each byte of the input array:\n *    - Convert each nibble (4 bits) to its corresponding hexadecimal character.\n *    - Store the characters in the output string.\n *\n * 7. Zeroize the slot after the string to ensure no leftover data.\n * 8. Allocate memory for the output string.\n */"
        },
        {
            "identifier": "unpackOne",
            "parameters": "bytes32 packed",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function unpackOne(bytes32 packed) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40) // Grab the free memory pointer.\n            mstore(0x40, add(result, 0x40)) // Allocate 2 words (1 for the length, 1 for the bytes).\n            mstore(result, 0) // Zeroize the length slot.\n            mstore(add(result, 0x1f), packed) // Store the length and bytes.\n            mstore(add(add(result, 0x20), mload(result)), 0) // Right pad with zeroes.\n        }\n    }",
            "start": "901",
            "end": "910",
            "class": "LibString",
            "signature": "returns (string memory result) unpackOnebytes32 packed",
            "full_signature": "function unpackOne(bytes32 packed) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.unpackOnebytes32 packed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Unpacks a single `bytes32` value into a `string` in memory.\n * \n * Steps:\n * 1. Retrieve the free memory pointer.\n * 2. Allocate 2 words of memory (1 for the length, 1 for the bytes).\n * 3. Zeroize the length slot.\n * 4. Store the packed `bytes32` value into the allocated memory.\n * 5. Right pad the result with zeroes to ensure proper alignment.\n * \n * @param packed The `bytes32` value to unpack.\n * @return result The unpacked `string` value.\n */"
        },
        {
            "identifier": "toSmallString",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function toSmallString(string memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(s)\n            if iszero(lt(result, 33)) {\n                mstore(0x00, 0xec92f9a3) // `TooBigForSmallString()`.\n                revert(0x1c, 0x04)\n            }\n            result := shl(shl(3, sub(32, result)), mload(add(s, result)))\n        }\n    }",
            "start": "695",
            "end": "705",
            "class": "LibString",
            "signature": "returns (bytes32 result) toSmallStringstring memory s",
            "full_signature": "function toSmallString(string memory s) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibString.toSmallStringstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a string into a small string representation (bytes32).\n * @dev The function ensures the input string is small enough to fit into a bytes32.\n *      If the string is too large, it reverts with the error `TooBigForSmallString()`.\n * @param s The input string to be converted.\n * @return result The bytes32 representation of the small string.\n *\n * Steps:\n * 1. Load the length of the string.\n * 2. Check if the length is less than 33 (to fit into bytes32).\n * 3. If the string is too large, revert with the error `TooBigForSmallString()`.\n * 4. Shift and store the string data into the result bytes32.\n */"
        },
        {
            "identifier": "HEXDIGITS_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant HEXDIGITS_7_BIT_ASCII = 0x7e0000007e03ff000000000000;",
            "start": "63",
            "end": "63",
            "class": "LibString",
            "signature": "uint128 HEXDIGITS_7_BIT_ASCII",
            "full_signature": "uint128 internal constant HEXDIGITS_7_BIT_ASCII",
            "class_method_signature": "LibString.HEXDIGITS_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a 128-bit value encoding 7-bit ASCII hex digits.\n * The value is a bitmask or encoded data used for specific operations involving hex digits.\n */"
        },
        {
            "identifier": "packOne",
            "parameters": "string memory a",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function packOne(string memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We don't need to zero right pad the string,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    // Load the length and the bytes.\n                    mload(add(a, 0x1f)),\n                    // `length != 0 && length < 32`. Abuses underflow.\n                    // Assumes that the length is valid and within the block gas limit.\n                    lt(sub(mload(a), 1), 0x1f)\n                )\n        }\n    }",
            "start": "882",
            "end": "896",
            "class": "LibString",
            "signature": "returns (bytes32 result) packOnestring memory a",
            "full_signature": "function packOne(string memory a) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibString.packOnestring memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Packs a string into a bytes32 value using a custom non-standard packing scheme.\n * \n * Steps:\n * 1. Load the length and bytes of the string.\n * 2. Multiply the length by a condition that checks if the length is non-zero and less than 32.\n * 3. Return the packed bytes32 result.\n * \n * @dev This function uses inline assembly for memory-safe operations and assumes the length is valid and within the block gas limit.\n * \n * @param a The string to be packed.\n * @return result The packed bytes32 value.\n */"
        },
        {
            "identifier": "LOWERCASE_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant LOWERCASE_7_BIT_ASCII = 0x7fffffe000000000000000000000000;",
            "start": "54",
            "end": "54",
            "class": "LibString",
            "signature": "uint128 LOWERCASE_7_BIT_ASCII",
            "full_signature": "uint128 internal constant LOWERCASE_7_BIT_ASCII",
            "class_method_signature": "LibString.LOWERCASE_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a 128-bit integer mask for 7-bit ASCII lowercase characters.\n * The value is used to filter or manipulate lowercase ASCII characters in a bitwise context.\n */"
        },
        {
            "identifier": "split",
            "parameters": "string memory subject, string memory delimiter",
            "modifiers": "pure",
            "return": "returns (string[] memory result)",
            "body": "function split(string memory subject, string memory delimiter)\n        internal\n        pure\n        returns (string[] memory result)\n    {\n        bytes[] memory a = LibBytes.split(bytes(subject), bytes(delimiter));\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n        }\n    }",
            "start": "621",
            "end": "631",
            "class": "LibString",
            "signature": "returns (string[] memory result) splitstring memory subject, string memory delimiter",
            "full_signature": "function split(string memory subject, string memory delimiter) internal  pure returns (string[] memory result)",
            "class_method_signature": "LibString.splitstring memory subject, string memory delimiter",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function split(bytes memory subject, bytes memory delimiter) internal  pure returns (bytes[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice Splits a string into an array of substrings based on a delimiter.\n *\n * @param subject The string to be split.\n * @param delimiter The delimiter used to split the string.\n *\n * @return result An array of strings resulting from the split operation.\n *\n * Steps:\n * 1. Convert the input strings (`subject` and `delimiter`) into byte arrays.\n * 2. Use `LibBytes.split` to split the byte array of `subject` based on the byte array of `delimiter`.\n * 3. Use assembly to assign the resulting byte array to the `result` string array.\n */"
        },
        {
            "identifier": "LETTERS_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant LETTERS_7_BIT_ASCII = 0x7fffffe07fffffe0000000000000000;",
            "start": "51",
            "end": "51",
            "class": "LibString",
            "signature": "uint128 LETTERS_7_BIT_ASCII",
            "full_signature": "uint128 internal constant LETTERS_7_BIT_ASCII",
            "class_method_signature": "LibString.LETTERS_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask for 7-bit ASCII letters.\n * The value is a 128-bit unsigned integer where specific bits are set to 1\n * to represent valid 7-bit ASCII letters.\n */"
        },
        {
            "identifier": "toMinimalHexString",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toMinimalHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(add(result, o), 0x3078) // Store the \"0x\" prefix, accounting for leading zero.\n            result := sub(add(result, o), 2) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }",
            "start": "263",
            "end": "273",
            "class": "LibString",
            "signature": "returns (string memory result) toMinimalHexStringuint256 value",
            "full_signature": "function toMinimalHexString(uint256 value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toMinimalHexStringuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a minimal hex string representation.\n *\n * Steps:\n * 1. Convert the value to a hex string without the \"0x\" prefix using `toHexStringNoPrefix`.\n * 2. Use inline assembly to optimize memory operations.\n * 3. Check if the first character is a leading zero.\n * 4. Compute the length of the resulting hex string.\n * 5. Store the \"0x\" prefix, adjusting for the presence of a leading zero.\n * 6. Adjust the pointer to account for the leading zero.\n * 7. Store the final length of the hex string, adjusting for the leading zero.\n *\n * @param value The uint256 value to convert to a hex string.\n * @return result The minimal hex string representation of the value, prefixed with \"0x\".\n */"
        },
        {
            "identifier": "is7BitASCII",
            "parameters": "string memory s, uint128 allowed",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function is7BitASCII(string memory s, uint128 allowed) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if mload(s) {\n                let allowed_ := shr(128, shl(128, allowed))\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := and(result, shr(byte(0, mload(o)), allowed_))\n                    o := add(o, 1)\n                    if iszero(and(result, lt(o, end))) { break }\n                }\n            }\n        }\n    }",
            "start": "479",
            "end": "493",
            "class": "LibString",
            "signature": "returns (bool result) is7BitASCIIstring memory s, uint128 allowed",
            "full_signature": "function is7BitASCII(string memory s, uint128 allowed) internal  pure returns (bool result)",
            "class_method_signature": "LibString.is7BitASCIIstring memory s, uint128 allowed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Checks if a given string consists only of 7-bit ASCII characters.\n *\n * @param s The string to be checked.\n * @param allowed A bitmask representing allowed characters.\n * @return result Returns `true` if all characters in the string are 7-bit ASCII and allowed, otherwise `false`.\n *\n * Steps:\n * 1. Initialize `result` as `true` (1).\n * 2. If the string is not empty:\n *    a. Extract the allowed characters from the `allowed` bitmask.\n *    b. Iterate through each character in the string:\n *       i. Check if the character is allowed by shifting and masking the `allowed` bitmask.\n *       ii. Update `result` to reflect whether the character is allowed.\n *       iii. Move to the next character.\n *    c. Break the loop if the end of the string is reached or if an invalid character is found.\n * 3. Return the final result.\n */"
        },
        {
            "identifier": "encodeURIComponent",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function encodeURIComponent(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Store \"0123456789ABCDEF\" in scratch space.\n            // Uppercased to be consistent with JavaScript's implementation.\n            mstore(0x0f, 0x30313233343536373839414243444546)\n            let o := add(result, 0x20)\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // If not in `[0-9A-Z-a-z-_.!~*'()]`.\n                if iszero(and(1, shr(c, 0x47fffffe87fffffe03ff678200000000))) {\n                    mstore8(o, 0x25) // '%'.\n                    mstore8(add(o, 1), mload(and(shr(4, c), 15)))\n                    mstore8(add(o, 2), mload(and(c, 15)))\n                    o := add(o, 3)\n                    continue\n                }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "start": "820",
            "end": "846",
            "class": "LibString",
            "signature": "returns (string memory result) encodeURIComponentstring memory s",
            "full_signature": "function encodeURIComponent(string memory s) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.encodeURIComponentstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Encodes a string using URI component encoding rules.\n * \n * Steps:\n * 1. Allocate memory for the result.\n * 2. Store the hexadecimal representation of \"0123456789ABCDEF\" in scratch space.\n * 3. Iterate through each character of the input string.\n * 4. For each character, check if it is a valid URI component character (0-9, A-Z, a-z, '-', '_', '.', '!', '~', '*', ''', '(', ')').\n * 5. If the character is not valid, encode it as a percent-encoded value (e.g., '%20' for space).\n * 6. Store the encoded character in the result.\n * 7. Update the result length and allocate memory for the next character.\n * 8. Zeroize the slot after the string to clean up memory.\n * \n * @param s The input string to be encoded.\n * @return result The URI component encoded string.\n */"
        },
        {
            "identifier": "runeCount",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function runeCount(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                mstore(0x00, div(not(0), 255))\n                mstore(0x20, 0x0202020202020202020202020202020202020202020202020303030304040506)\n                let o := add(s, 0x20)\n                let end := add(o, mload(s))\n                for { result := 1 } 1 { result := add(result, 1) } {\n                    o := add(o, byte(0, mload(shr(250, mload(o)))))\n                    if iszero(lt(o, end)) { break }\n                }\n            }\n        }\n    }",
            "start": "434",
            "end": "448",
            "class": "LibString",
            "signature": "returns (uint256 result) runeCountstring memory s",
            "full_signature": "function runeCount(string memory s) internal  pure returns (uint256 result)",
            "class_method_signature": "LibString.runeCountstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Calculates the number of runes (Unicode characters) in a string.\n *\n * Steps:\n * 1. Check if the string is non-empty.\n * 2. Store a magic number and a lookup table in memory for efficient rune counting.\n * 3. Initialize the result counter to 1.\n * 4. Iterate through the string, incrementing the result counter for each rune.\n * 5. Break the loop when the end of the string is reached.\n * 6. Return the total count of runes.\n *\n * @param s The input string to count runes in.\n * @return result The number of runes in the string.\n */"
        },
        {
            "identifier": "NOT_FOUND",
            "parameters": "",
            "modifiers": "",
            "return": "uint256",
            "body": "uint256 internal constant NOT_FOUND = type(uint256).max;",
            "start": "45",
            "end": "45",
            "class": "LibString",
            "signature": "uint256 NOT_FOUND",
            "full_signature": "uint256 internal constant NOT_FOUND",
            "class_method_signature": "LibString.NOT_FOUND",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'uint256 internal constant NOT_FOUND'}",
            "human_labeled_comment": "/**\n * @notice A constant representing the maximum value of a uint256, used to indicate a \"not found\" state.\n */"
        },
        {
            "identifier": "StringStorage",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct StringStorage {\n        bytes32 _spacer;\n    }",
            "start": "23",
            "end": "25",
            "class": "LibString",
            "signature": " StringStorage",
            "full_signature": "function StringStorage()",
            "class_method_signature": "LibString.StringStorage",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `StringStorage` with a single field `_spacer` of type `bytes32`.\n * This struct is likely used as a placeholder or for alignment purposes in storage.\n */"
        },
        {
            "identifier": "normalizeSmallString",
            "parameters": "bytes32 s",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function normalizeSmallString(bytes32 s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} byte(result, s) { result := add(result, 1) } {} // Scan for '\\0'.\n            mstore(0x00, s)\n            mstore(result, 0x00)\n            result := mload(0x00)\n        }\n    }",
            "start": "684",
            "end": "692",
            "class": "LibString",
            "signature": "returns (bytes32 result) normalizeSmallStringbytes32 s",
            "full_signature": "function normalizeSmallString(bytes32 s) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibString.normalizeSmallStringbytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Normalizes a small string stored in a `bytes32` by scanning for the null terminator (`\\0`).\n * \n * Steps:\n * 1. Use inline assembly to scan the `bytes32` input `s` for the null terminator.\n * 2. Store the original `bytes32` value in memory at position `0x00`.\n * 3. Overwrite the null terminator position with `0x00` to ensure proper termination.\n * 4. Load the normalized result from memory and return it.\n */"
        },
        {
            "identifier": "packTwo",
            "parameters": "string memory a, string memory b",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function packTwo(string memory a, string memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            // We don't need to zero right pad the strings,\n            // since this is our own custom non-standard packing scheme.\n            result :=\n                mul(\n                    or( // Load the length and the bytes of `a` and `b`.\n                    shl(shl(3, sub(0x1f, aLen)), mload(add(a, aLen))), mload(sub(add(b, 0x1e), aLen))),\n                    // `totalLen != 0 && totalLen < 31`. Abuses underflow.\n                    // Assumes that the lengths are valid and within the block gas limit.\n                    lt(sub(add(aLen, mload(b)), 1), 0x1e)\n                )\n        }\n    }",
            "start": "914",
            "end": "929",
            "class": "LibString",
            "signature": "returns (bytes32 result) packTwostring memory a, string memory b",
            "full_signature": "function packTwo(string memory a, string memory b) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibString.packTwostring memory a, string memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Packs two strings into a single bytes32 value using a custom non-standard packing scheme.\n * \n * Steps:\n * 1. Load the length of the first string `a`.\n * 2. Use bitwise operations to combine the lengths and bytes of `a` and `b` into a single bytes32 value.\n * 3. Ensure the total length of the combined strings is less than 31 bytes to fit within the bytes32 limit.\n * 4. Return the packed bytes32 result.\n * \n * Note: This function assumes that the lengths of the strings are valid and within the block gas limit.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "string memory subject, string memory needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function indexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), from);\n    }",
            "start": "537",
            "end": "543",
            "class": "LibString",
            "signature": "returns (uint256) indexOfstring memory subject, string memory needle, uint256 from",
            "full_signature": "function indexOf(string memory subject, string memory needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "LibString.indexOfstring memory subject, string memory needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function indexOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256)', 'function indexOf(bytes memory subject, bytes memory needle, uint256 from) internal  pure returns (uint256 result)'}",
            "human_labeled_comment": "/**\n * @notice Finds the index of a substring (`needle`) within a string (`subject`) starting from a specified position (`from`).\n *\n * @param subject The string to search within.\n * @param needle The substring to search for.\n * @param from The position in `subject` to start the search from.\n * @return The index of the first occurrence of `needle` in `subject` starting from `from`. Returns a value representing \"not found\" if the substring is not found.\n *\n * @dev Internally uses `LibBytes.indexOf` to perform the search on the byte representation of the strings.\n */"
        },
        {
            "identifier": "toHexStringNoPrefix",
            "parameters": "uint256 value, uint256 byteCount",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexStringNoPrefix(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, `byteCount * 2` bytes\n            // for the digits, 0x02 bytes for the prefix, and 0x20 bytes for the length.\n            // We add 0x20 to the total and round down to a multiple of 0x20.\n            // (0x20 + 0x20 + 0x02 + 0x20) = 0x62.\n            result := add(mload(0x40), and(add(shl(1, byteCount), 0x42), not(0x1f)))\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            // Store \"0123456789abcdef\" in scratch space.\n            mstore(0x0f, 0x30313233343536373839616263646566)\n\n            let start := sub(result, add(byteCount, byteCount))\n            let w := not(1) // Tsk.\n            let temp := value\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for {} 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(xor(result, start)) { break }\n            }\n            if temp {\n                mstore(0x00, 0x2194895a) // `HexLengthInsufficient()`.\n                revert(0x1c, 0x04)\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "203",
            "end": "242",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringNoPrefixuint256 value, uint256 byteCount",
            "full_signature": "function toHexStringNoPrefix(uint256 value, uint256 byteCount) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringNoPrefixuint256 value, uint256 byteCount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a hex string without the \"0x\" prefix.\n * @dev This function uses low-level assembly to efficiently convert the value to a hex string.\n * \n * Steps:\n * 1. Allocate memory for the result, ensuring it is padded and aligned correctly.\n * 2. Store the hex digits \"0123456789abcdef\" in scratch space for quick access.\n * 3. Iterate through the value, converting each byte to its corresponding hex character.\n * 4. Handle edge cases, such as zero values, and ensure the result is correctly formatted.\n * 5. Revert if the input value exceeds the expected byte count.\n * 6. Store the length of the resulting hex string and return it.\n */"
        },
        {
            "identifier": "length",
            "parameters": "StringStorage storage $",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function length(StringStorage storage $) internal view returns (uint256) {\n        return LibBytes.length(bytesStorage($));\n    }",
            "start": "102",
            "end": "104",
            "class": "LibString",
            "signature": "returns (uint256) lengthStringStorage storage $",
            "full_signature": "function length(StringStorage storage $) internal  view returns (uint256)",
            "class_method_signature": "LibString.lengthStringStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)'}",
            "human_labeled_comment": "/**\n * @notice Returns the length of the string stored in the StringStorage struct.\n *\n * @param $ The StringStorage struct containing the string data.\n * @return uint256 The length of the string in bytes.\n */"
        },
        {
            "identifier": "lower",
            "parameters": "string memory subject",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function lower(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, false);\n    }",
            "start": "709",
            "end": "711",
            "class": "LibString",
            "signature": "returns (string memory result) lowerstring memory subject",
            "full_signature": "function lower(string memory subject) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.lowerstring memory subject",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a string to lowercase.\n * @param subject The input string to be converted.\n * @return result The resulting string in lowercase.\n */"
        },
        {
            "identifier": "toHexString",
            "parameters": "bytes memory raw",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexString(bytes memory raw) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(raw);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "395",
            "end": "404",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringbytes memory raw",
            "full_signature": "function toHexString(bytes memory raw) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringbytes memory raw",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a bytes array into a hexadecimal string prefixed with \"0x\".\n *\n * Steps:\n * 1. Convert the bytes array to a hexadecimal string without the \"0x\" prefix using `toHexStringNoPrefix`.\n * 2. Use inline assembly to:\n *    - Compute the length of the resulting string including the \"0x\" prefix.\n *    - Store the \"0x\" prefix at the beginning of the string.\n *    - Adjust the pointer to account for the prefix.\n *    - Store the computed length in the result.\n *\n * @param raw The bytes array to be converted.\n * @return result The hexadecimal string representation of the input bytes, prefixed with \"0x\".\n */"
        },
        {
            "identifier": "PUNCTUATION_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant PUNCTUATION_7_BIT_ASCII = 0x78000001f8000001fc00fffe00000000;",
            "start": "72",
            "end": "72",
            "class": "LibString",
            "signature": "uint128 PUNCTUATION_7_BIT_ASCII",
            "full_signature": "uint128 internal constant PUNCTUATION_7_BIT_ASCII",
            "class_method_signature": "LibString.PUNCTUATION_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask for 7-bit ASCII punctuation characters.\n * The value is a 128-bit unsigned integer (uint128) that encodes specific punctuation characters.\n * The bitmask can be used to check or filter punctuation characters in text processing.\n */"
        },
        {
            "identifier": "bytesStorage",
            "parameters": "StringStorage storage $",
            "modifiers": "pure",
            "return": "returns (LibBytes.BytesStorage storage casted)",
            "body": "function bytesStorage(StringStorage storage $)\n        internal\n        pure\n        returns (LibBytes.BytesStorage storage casted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted.slot := $.slot\n        }\n    }",
            "start": "112",
            "end": "121",
            "class": "LibString",
            "signature": "returns (LibBytes.BytesStorage storage casted) bytesStorageStringStorage storage $",
            "full_signature": "function bytesStorage(StringStorage storage $) internal  pure returns (LibBytes.BytesStorage storage casted)",
            "class_method_signature": "LibString.bytesStorageStringStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function BytesStorage()'}",
            "human_labeled_comment": "/**\n * @notice Converts a `StringStorage` reference to a `LibBytes.BytesStorage` reference.\n * @dev This function uses inline assembly to safely cast the storage slot of the input `StringStorage` to `BytesStorage`.\n * @param $ The `StringStorage` reference to be casted.\n * @return casted The resulting `LibBytes.BytesStorage` reference with the same storage slot as the input.\n */"
        },
        {
            "identifier": "PRINTABLE_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant PRINTABLE_7_BIT_ASCII = 0x7fffffffffffffffffffffff00003e00;",
            "start": "69",
            "end": "69",
            "class": "LibString",
            "signature": "uint128 PRINTABLE_7_BIT_ASCII",
            "full_signature": "uint128 internal constant PRINTABLE_7_BIT_ASCII",
            "class_method_signature": "LibString.PRINTABLE_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask for printable 7-bit ASCII characters.\n * The value is a bitmask that filters out non-printable characters and retains printable ones.\n */"
        },
        {
            "identifier": "TooBigForSmallString",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error TooBigForSmallString();",
            "start": "35",
            "end": "35",
            "class": "LibString",
            "signature": " TooBigForSmallString",
            "full_signature": "function TooBigForSmallString()",
            "class_method_signature": "LibString.TooBigForSmallString",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the provided data is too large to fit into a small string.\n */"
        },
        {
            "identifier": "eq",
            "parameters": "string memory a, string memory b",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function eq(string memory a, string memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := eq(keccak256(add(a, 0x20), mload(a)), keccak256(add(b, 0x20), mload(b)))\n        }\n    }",
            "start": "849",
            "end": "854",
            "class": "LibString",
            "signature": "returns (bool result) eqstring memory a, string memory b",
            "full_signature": "function eq(string memory a, string memory b) internal  pure returns (bool result)",
            "class_method_signature": "LibString.eqstring memory a, string memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Compares two strings for equality.\n *\n * @param a The first string to compare.\n * @param b The second string to compare.\n * @return result True if the strings are equal, false otherwise.\n *\n * Steps:\n * 1. Use inline assembly to compute the Keccak-256 hash of both strings.\n * 2. Compare the hashes to determine if the strings are equal.\n * 3. Return the result of the comparison.\n */"
        },
        {
            "identifier": "fromSmallString",
            "parameters": "bytes32 s",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function fromSmallString(bytes32 s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let n := 0\n            for {} byte(n, s) { n := add(n, 1) } {} // Scan for '\\0'.\n            mstore(result, n) // Store the length.\n            let o := add(result, 0x20)\n            mstore(o, s) // Store the bytes of the string.\n            mstore(add(o, n), 0) // Zeroize the slot after the string.\n            mstore(0x40, add(result, 0x40)) // Allocate memory.\n        }\n    }",
            "start": "669",
            "end": "681",
            "class": "LibString",
            "signature": "returns (string memory result) fromSmallStringbytes32 s",
            "full_signature": "function fromSmallString(bytes32 s) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.fromSmallStringbytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a small string stored in a `bytes32` type to a `string` type.\n * \n * Steps:\n * 1. Load the free memory pointer into `result`.\n * 2. Initialize a counter `n` to 0.\n * 3. Scan the `bytes32` input `s` for the null terminator (`\\0`) to determine the length of the string.\n * 4. Store the length of the string in the first 32 bytes of `result`.\n * 5. Store the bytes of the string starting at offset 0x20 in `result`.\n * 6. Zeroize the slot after the string to ensure proper memory alignment.\n * 7. Update the free memory pointer to allocate memory for the result.\n * \n * @param s The `bytes32` input representing the small string.\n * @return result The converted `string` output.\n */"
        },
        {
            "identifier": "escapeJSON",
            "parameters": "string memory s, bool addDoubleQuotes",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function escapeJSON(string memory s, bool addDoubleQuotes)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            // Store \"\\\\u0000\" in scratch space.\n            // Store \"0123456789abcdef\" in scratch space.\n            // Also, store `{0x08:\"b\", 0x09:\"t\", 0x0a:\"n\", 0x0c:\"f\", 0x0d:\"r\"}`.\n            // into the scratch space.\n            mstore(0x15, 0x5c75303030303031323334353637383961626364656662746e006672)\n            // Bitmask for detecting `[\"\\\"\",\"\\\\\"]`.\n            let e := or(shl(0x22, 1), shl(0x5c, 1))\n            for { let end := add(s, mload(s)) } iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                if iszero(lt(c, 0x20)) {\n                    if iszero(and(shl(c, 1), e)) {\n                        // Not in `[\"\\\"\",\"\\\\\"]`.\n                        mstore8(o, c)\n                        o := add(o, 1)\n                        continue\n                    }\n                    mstore8(o, 0x5c) // \"\\\\\".\n                    mstore8(add(o, 1), c)\n                    o := add(o, 2)\n                    continue\n                }\n                if iszero(and(shl(c, 1), 0x3700)) {\n                    // Not in `[\"\\b\",\"\\t\",\"\\n\",\"\\f\",\"\\d\"]`.\n                    mstore8(0x1d, mload(shr(4, c))) // Hex value.\n                    mstore8(0x1e, mload(and(c, 15))) // Hex value.\n                    mstore(o, mload(0x19)) // \"\\\\u00XX\".\n                    o := add(o, 6)\n                    continue\n                }\n                mstore8(o, 0x5c) // \"\\\\\".\n                mstore8(add(o, 1), mload(add(c, 8)))\n                o := add(o, 2)\n            }\n            if addDoubleQuotes {\n                mstore8(o, 34)\n                o := add(1, o)\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "start": "753",
            "end": "808",
            "class": "LibString",
            "signature": "returns (string memory result) escapeJSONstring memory s, bool addDoubleQuotes",
            "full_signature": "function escapeJSON(string memory s, bool addDoubleQuotes) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.escapeJSONstring memory s, bool addDoubleQuotes",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Escapes a JSON string by adding escape sequences for special characters.\n * @dev This function handles escaping characters like quotes, backslashes, and control characters.\n *      It also optionally wraps the result in double quotes.\n *\n * Steps:\n * 1. Allocate memory for the result string.\n * 2. If `addDoubleQuotes` is true, prepend the result with a double quote.\n * 3. Load precomputed values into scratch space for efficient character processing.\n * 4. Iterate through each character in the input string:\n *    - If the character is not a special character, copy it directly to the result.\n *    - If the character is a backslash or double quote, escape it with a backslash.\n *    - If the character is a control character, escape it with a Unicode sequence.\n * 5. If `addDoubleQuotes` is true, append a double quote to the result.\n * 6. Zeroize the memory slot after the string and store the length of the result.\n * 7. Allocate memory for the final result.\n *\n * @param s The input string to escape.\n * @param addDoubleQuotes Whether to wrap the result in double quotes.\n * @return result The escaped JSON string.\n */"
        },
        {
            "identifier": "toHexStringNoPrefix",
            "parameters": "address value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexStringNoPrefix(address value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            // Allocate memory.\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x28 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x28) is 0x80.\n            mstore(0x40, add(result, 0x80))\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            result := add(result, 2)\n            mstore(result, 40) // Store the length.\n            let o := add(result, 0x20)\n            mstore(add(o, 40), 0) // Zeroize the slot after the string.\n            value := shl(96, value)\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let i := 0 } 1 {} {\n                let p := add(o, add(i, i))\n                let temp := byte(i, value)\n                mstore8(add(p, 1), mload(and(temp, 15)))\n                mstore8(p, mload(shr(4, temp)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n        }\n    }",
            "start": "364",
            "end": "391",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringNoPrefixaddress value",
            "full_signature": "function toHexStringNoPrefix(address value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringNoPrefixaddress value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts an address to a hex string without the \"0x\" prefix.\n * \n * Steps:\n * 1. Allocate memory for the result string.\n * 2. Store the lookup table for hex digits (\"0123456789abcdef\") in memory.\n * 3. Adjust the result pointer to skip the \"0x\" prefix.\n * 4. Store the length of the address (40 characters) in memory.\n * 5. Zeroize the slot after the string to ensure proper memory alignment.\n * 6. Shift the address value to align it for processing.\n * 7. Convert the address to a hex string by iterating through each byte:\n *    - Extract each nibble (4 bits) of the address.\n *    - Map the nibble to its corresponding hex character using the lookup table.\n *    - Store the hex characters in memory from right to left.\n * 8. Break the loop after processing all 20 bytes of the address.\n */"
        },
        {
            "identifier": "escapeJSON",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function escapeJSON(string memory s) internal pure returns (string memory result) {\n        result = escapeJSON(s, false);\n    }",
            "start": "811",
            "end": "813",
            "class": "LibString",
            "signature": "returns (string memory result) escapeJSONstring memory s",
            "full_signature": "function escapeJSON(string memory s) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.escapeJSONstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Escapes a JSON string by calling an internal helper function.\n * @param s The input string to be escaped.\n * @return result The escaped JSON string.\n * @dev This function is a wrapper that calls another internal function with an additional boolean parameter set to false.\n */"
        },
        {
            "identifier": "toHexString",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexString(uint256 value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "248",
            "end": "257",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringuint256 value",
            "full_signature": "function toHexString(uint256 value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to its hexadecimal string representation with a \"0x\" prefix.\n *\n * Steps:\n * 1. Convert the value to a hexadecimal string without the \"0x\" prefix using `toHexStringNoPrefix`.\n * 2. Use inline assembly to:\n *    a. Calculate the length of the resulting string.\n *    b. Prepend the \"0x\" prefix to the string.\n *    c. Adjust the pointer to account for the prefix.\n *    d. Store the length of the final string.\n *\n * @param value The uint256 value to convert to a hexadecimal string.\n * @return result The hexadecimal string representation of the value with a \"0x\" prefix.\n */"
        },
        {
            "identifier": "cmp",
            "parameters": "string memory a, string memory b",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function cmp(string memory a, string memory b) internal pure returns (int256) {\n        return LibBytes.cmp(bytes(a), bytes(b));\n    }",
            "start": "876",
            "end": "878",
            "class": "LibString",
            "signature": "returns (int256) cmpstring memory a, string memory b",
            "full_signature": "function cmp(string memory a, string memory b) internal  pure returns (int256)",
            "class_method_signature": "LibString.cmpstring memory a, string memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function cmp(bytes memory a, bytes memory b) internal  pure returns (int256 result)'}",
            "human_labeled_comment": "/**\n * @notice Compares two strings lexicographically.\n * @param a The first string to compare.\n * @param b The second string to compare.\n * @return An integer representing the comparison result:\n *         - Less than 0 if `a` is lexicographically less than `b`.\n *         - 0 if `a` is equal to `b`.\n *         - Greater than 0 if `a` is lexicographically greater than `b`.\n * @dev Internally converts strings to bytes and uses `LibBytes.cmp` for comparison.\n */"
        },
        {
            "identifier": "contains",
            "parameters": "string memory subject, string memory needle",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function contains(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.contains(bytes(subject), bytes(needle));\n    }",
            "start": "575",
            "end": "577",
            "class": "LibString",
            "signature": "returns (bool) containsstring memory subject, string memory needle",
            "full_signature": "function contains(string memory subject, string memory needle) internal  pure returns (bool)",
            "class_method_signature": "LibString.containsstring memory subject, string memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function contains(bytes memory subject, bytes memory needle) internal  pure returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Checks if a string (`subject`) contains another string (`needle`).\n * @param subject The string to search within.\n * @param needle The string to search for.\n * @return bool True if `needle` is found within `subject`, otherwise false.\n */"
        },
        {
            "identifier": "directReturn",
            "parameters": "string memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function directReturn(string memory a) internal pure {\n        assembly {\n            // Assumes that the string does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the string is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the string.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }",
            "start": "958",
            "end": "970",
            "class": "LibString",
            "signature": " directReturnstring memory a",
            "full_signature": "function directReturn(string memory a) internal  pure",
            "class_method_signature": "LibString.directReturnstring memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function set(BytesStorage storage $, bytes memory s) internal', 'function directReturn(bytes memory a) internal  pure', 'function directReturn(bytes[] memory a) internal  pure', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Internal function to directly return a string from memory using inline assembly.\n *\n * Steps:\n * 1. Calculate the start of the return data by subtracting 0x20 from the string's memory pointer.\n * 2. Calculate the unpadded size of the return data by adding 0x40 to the length of the string.\n * 3. Right pad the string with zeroes to ensure proper alignment.\n * 4. Store the return offset at the start of the return data.\n * 5. End the transaction and return the string data, ensuring the size is properly aligned.\n */"
        },
        {
            "identifier": "unpackTwo",
            "parameters": "bytes32 packed",
            "modifiers": "pure",
            "return": "returns (string memory resultA, string memory resultB)",
            "body": "function unpackTwo(bytes32 packed)\n        internal\n        pure\n        returns (string memory resultA, string memory resultB)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            resultA := mload(0x40) // Grab the free memory pointer.\n            resultB := add(resultA, 0x40)\n            // Allocate 2 words for each string (1 for the length, 1 for the byte). Total 4 words.\n            mstore(0x40, add(resultB, 0x40))\n            // Zeroize the length slots.\n            mstore(resultA, 0)\n            mstore(resultB, 0)\n            // Store the lengths and bytes.\n            mstore(add(resultA, 0x1f), packed)\n            mstore(add(resultB, 0x1f), mload(add(add(resultA, 0x20), mload(resultA))))\n            // Right pad with zeroes.\n            mstore(add(add(resultA, 0x20), mload(resultA)), 0)\n            mstore(add(add(resultB, 0x20), mload(resultB)), 0)\n        }\n    }",
            "start": "934",
            "end": "955",
            "class": "LibString",
            "signature": "returns (string memory resultA, string memory resultB) unpackTwobytes32 packed",
            "full_signature": "function unpackTwo(bytes32 packed) internal  pure returns (string memory resultA, string memory resultB)",
            "class_method_signature": "LibString.unpackTwobytes32 packed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Unpacks a single `bytes32` value into two separate strings.\n *\n * Steps:\n * 1. Allocate memory for the two resulting strings (`resultA` and `resultB`).\n * 2. Update the free memory pointer to account for the allocated memory.\n * 3. Initialize the length slots of both strings to zero.\n * 4. Store the packed data into the allocated memory for both strings.\n * 5. Right-pad the strings with zeroes to ensure proper alignment.\n *\n * @param packed The `bytes32` value to be unpacked into two strings.\n * @return resultA The first unpacked string.\n * @return resultB The second unpacked string.\n */"
        },
        {
            "identifier": "repeat",
            "parameters": "string memory subject, uint256 times",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function repeat(string memory subject, uint256 times) internal pure returns (string memory) {\n        return string(LibBytes.repeat(bytes(subject), times));\n    }",
            "start": "590",
            "end": "592",
            "class": "LibString",
            "signature": "returns (string memory) repeatstring memory subject, uint256 times",
            "full_signature": "function repeat(string memory subject, uint256 times) internal  pure returns (string memory)",
            "class_method_signature": "LibString.repeatstring memory subject, uint256 times",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function repeat(bytes memory subject, uint256 times) internal  pure returns (bytes memory result)'}",
            "human_labeled_comment": "/**\n * @notice Repeats a given string a specified number of times.\n * \n * @param subject The string to be repeated.\n * @param times The number of times the string should be repeated.\n * @return A new string that is the result of repeating the input string.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "StringStorage storage $",
            "modifiers": "",
            "return": "",
            "body": "function clear(StringStorage storage $) internal {\n        delete $._spacer;\n    }",
            "start": "92",
            "end": "94",
            "class": "LibString",
            "signature": " clearStringStorage storage $",
            "full_signature": "function clear(StringStorage storage $) internal",
            "class_method_signature": "LibString.clearStringStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function clear(BytesStorage storage $) internal'}",
            "human_labeled_comment": "/**\n * @notice Clears the storage of a StringStorage struct by deleting its spacer.\n * @param $ The StringStorage struct to be cleared.\n */"
        },
        {
            "identifier": "setCalldata",
            "parameters": "StringStorage storage $, string calldata s",
            "modifiers": "",
            "return": "",
            "body": "function setCalldata(StringStorage storage $, string calldata s) internal {\n        LibBytes.setCalldata(bytesStorage($), bytes(s));\n    }",
            "start": "87",
            "end": "89",
            "class": "LibString",
            "signature": " setCalldataStringStorage storage $, string calldata s",
            "full_signature": "function setCalldata(StringStorage storage $, string calldata s) internal",
            "class_method_signature": "LibString.setCalldataStringStorage storage $, string calldata s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function set(BytesStorage storage $, bytes memory s) internal', 'function setCalldata(BytesStorage storage $, bytes calldata s) internal'}",
            "human_labeled_comment": "/**\n * @notice Sets the calldata for a StringStorage struct.\n * @param $ The StringStorage struct to modify.\n * @param s The string data to set as calldata.\n * @dev Internally converts the string to bytes and sets it using LibBytes.setCalldata.\n */"
        },
        {
            "identifier": "UPPERCASE_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant UPPERCASE_7_BIT_ASCII = 0x7fffffe0000000000000000;",
            "start": "57",
            "end": "57",
            "class": "LibString",
            "signature": "uint128 UPPERCASE_7_BIT_ASCII",
            "full_signature": "uint128 internal constant UPPERCASE_7_BIT_ASCII",
            "class_method_signature": "LibString.UPPERCASE_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a 128-bit unsigned integer with specific bit patterns.\n * The value is a bitmask that corresponds to the uppercase 7-bit ASCII characters.\n * The bitmask is used to filter or identify uppercase letters in certain operations.\n */"
        },
        {
            "identifier": "toMinimalHexStringNoPrefix",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toMinimalHexStringNoPrefix(uint256 value)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := eq(byte(0, mload(add(result, 0x20))), 0x30) // Whether leading zero is present.\n            let n := mload(result) // Get the length.\n            result := add(result, o) // Move the pointer, accounting for leading zero.\n            mstore(result, sub(n, o)) // Store the length, accounting for leading zero.\n        }\n    }",
            "start": "278",
            "end": "291",
            "class": "LibString",
            "signature": "returns (string memory result) toMinimalHexStringNoPrefixuint256 value",
            "full_signature": "function toMinimalHexStringNoPrefix(uint256 value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toMinimalHexStringNoPrefixuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a minimal hexadecimal string without the \"0x\" prefix.\n * \n * Steps:\n * 1. Convert the value to a hexadecimal string without the prefix using `toHexStringNoPrefix`.\n * 2. Use assembly to check if the first character is a leading zero.\n * 3. Adjust the string pointer and length to remove the leading zero if present.\n * 4. Return the minimal hexadecimal string.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "string memory subject, string memory needle",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function indexOf(string memory subject, string memory needle) internal pure returns (uint256) {\n        return LibBytes.indexOf(bytes(subject), bytes(needle), 0);\n    }",
            "start": "548",
            "end": "550",
            "class": "LibString",
            "signature": "returns (uint256) indexOfstring memory subject, string memory needle",
            "full_signature": "function indexOf(string memory subject, string memory needle) internal  pure returns (uint256)",
            "class_method_signature": "LibString.indexOfstring memory subject, string memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function indexOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256)', 'function indexOf(bytes memory subject, bytes memory needle, uint256 from) internal  pure returns (uint256 result)'}",
            "human_labeled_comment": "/**\n * @notice Finds the index of a substring (`needle`) within a string (`subject`).\n * @dev The search starts from the beginning of the string (index 0).\n * @param subject The string in which to search for the substring.\n * @param needle The substring to search for within the subject string.\n * @return The index of the first occurrence of the substring within the string. \n *         If the substring is not found, the function will return an invalid index (e.g., `type(uint256).max`).\n */"
        },
        {
            "identifier": "concat",
            "parameters": "string memory a, string memory b",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function concat(string memory a, string memory b) internal pure returns (string memory) {\n        return string(LibBytes.concat(bytes(a), bytes(b)));\n    }",
            "start": "635",
            "end": "637",
            "class": "LibString",
            "signature": "returns (string memory) concatstring memory a, string memory b",
            "full_signature": "function concat(string memory a, string memory b) internal  pure returns (string memory)",
            "class_method_signature": "LibString.concatstring memory a, string memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function concat(bytes memory a, bytes memory b) internal  pure returns (bytes memory result)'}",
            "human_labeled_comment": "/**\n * @notice Concatenates two strings together.\n * @param a The first string to concatenate.\n * @param b The second string to concatenate.\n * @return The concatenated string.\n * @dev Internally uses `LibBytes.concat` to concatenate the byte representations of the strings.\n */"
        },
        {
            "identifier": "DIGITS_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant DIGITS_7_BIT_ASCII = 0x3ff000000000000;",
            "start": "60",
            "end": "60",
            "class": "LibString",
            "signature": "uint128 DIGITS_7_BIT_ASCII",
            "full_signature": "uint128 internal constant DIGITS_7_BIT_ASCII",
            "class_method_signature": "LibString.DIGITS_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a 7-bit ASCII value for digits.\n * @dev The value is stored as a uint128 and is used for encoding or decoding purposes.\n */"
        },
        {
            "identifier": "indicesOf",
            "parameters": "string memory subject, string memory needle",
            "modifiers": "pure",
            "return": "returns (uint256[] memory)",
            "body": "function indicesOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256[] memory)\n    {\n        return LibBytes.indicesOf(bytes(subject), bytes(needle));\n    }",
            "start": "612",
            "end": "618",
            "class": "LibString",
            "signature": "returns (uint256[] memory) indicesOfstring memory subject, string memory needle",
            "full_signature": "function indicesOf(string memory subject, string memory needle) internal  pure returns (uint256[] memory)",
            "class_method_signature": "LibString.indicesOfstring memory subject, string memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function indicesOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256[] memory result)'}",
            "human_labeled_comment": "/**\n * @notice Finds the indices of all occurrences of a substring (`needle`) within a string (`subject`).\n *\n * @param subject The string to search within.\n * @param needle The substring to search for.\n * @return uint256[] memory An array of indices where the substring occurs in the subject string.\n *\n * @dev Internally calls `LibBytes.indicesOf` after converting the strings to byte arrays.\n */"
        },
        {
            "identifier": "OCTDIGITS_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant OCTDIGITS_7_BIT_ASCII = 0xff000000000000;",
            "start": "66",
            "end": "66",
            "class": "LibString",
            "signature": "uint128 OCTDIGITS_7_BIT_ASCII",
            "full_signature": "uint128 internal constant OCTDIGITS_7_BIT_ASCII",
            "class_method_signature": "LibString.OCTDIGITS_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing the 7-bit ASCII encoding for octal digits.\n * The value is a bitmask used to extract or manipulate specific bits related to octal digits.\n */"
        },
        {
            "identifier": "toHexStringNoPrefix",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexStringNoPrefix(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We need 0x20 bytes for the trailing zeros padding, 0x20 bytes for the length,\n            // 0x02 bytes for the prefix, and 0x40 bytes for the digits.\n            // The next multiple of 0x20 above (0x20 + 0x20 + 0x02 + 0x40) is 0xa0.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end to calculate the length later.\n            mstore(0x0f, 0x30313233343536373839616263646566) // Store the \"0123456789abcdef\" lookup.\n\n            let w := not(1) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 2)`.\n                mstore8(add(result, 1), mload(and(temp, 15)))\n                mstore8(result, mload(and(shr(4, temp), 15)))\n                temp := shr(8, temp)\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20)\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "297",
            "end": "324",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringNoPrefixuint256 value",
            "full_signature": "function toHexStringNoPrefix(uint256 value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringNoPrefixuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a hexadecimal string without the \"0x\" prefix.\n *\n * Steps:\n * 1. Allocate memory for the result string, accounting for padding, length, and digits.\n * 2. Store the \"0123456789abcdef\" lookup table in memory.\n * 3. Iterate through the value, converting each nibble to its corresponding hexadecimal character.\n * 4. Store the characters in reverse order (rightmost digit to leftmost digit).\n * 5. Calculate the length of the resulting string and store it in memory.\n * 6. Return the hexadecimal string without the \"0x\" prefix.\n */"
        },
        {
            "identifier": "to7BitASCIIAllowedLookup",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (uint128 result)",
            "body": "function to7BitASCIIAllowedLookup(string memory s) internal pure returns (uint128 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(s) {\n                let o := add(s, 0x20)\n                for { let end := add(o, mload(s)) } 1 {} {\n                    result := or(result, shl(byte(0, mload(o)), 1))\n                    o := add(o, 1)\n                    if iszero(lt(o, end)) { break }\n                }\n                if shr(128, result) {\n                    mstore(0x00, 0xc9807e0d) // `StringNot7BitASCII()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "start": "498",
            "end": "514",
            "class": "LibString",
            "signature": "returns (uint128 result) to7BitASCIIAllowedLookupstring memory s",
            "full_signature": "function to7BitASCIIAllowedLookup(string memory s) internal  pure returns (uint128 result)",
            "class_method_signature": "LibString.to7BitASCIIAllowedLookupstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a string to a 7-bit ASCII allowed lookup value.\n * @dev This function uses low-level assembly to process the string and ensure it only contains 7-bit ASCII characters.\n * \n * Steps:\n * 1. Check if the string length is non-zero.\n * 2. Load the string data into memory.\n * 3. Iterate through each character in the string:\n *    - Shift the result by the byte value of the character and OR it with the current result.\n *    - Move to the next character.\n *    - Break the loop if the end of the string is reached.\n * 4. Check if the result exceeds 128 bits (indicating non-7-bit ASCII characters).\n * 5. If non-7-bit ASCII characters are detected, revert with the error `StringNot7BitASCII()`.\n * \n * @param s The input string to be processed.\n * @return result A 128-bit value representing the 7-bit ASCII allowed lookup.\n */"
        },
        {
            "identifier": "WHITESPACE_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant WHITESPACE_7_BIT_ASCII = 0x100003e00;",
            "start": "75",
            "end": "75",
            "class": "LibString",
            "signature": "uint128 WHITESPACE_7_BIT_ASCII",
            "full_signature": "uint128 internal constant WHITESPACE_7_BIT_ASCII",
            "class_method_signature": "LibString.WHITESPACE_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a 7-bit ASCII whitespace value.\n * @dev The value is stored as a uint128 and represents a specific bitmask for whitespace characters.\n */"
        },
        {
            "identifier": "get",
            "parameters": "StringStorage storage $",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function get(StringStorage storage $) internal view returns (string memory) {\n        return string(LibBytes.get(bytesStorage($)));\n    }",
            "start": "107",
            "end": "109",
            "class": "LibString",
            "signature": "returns (string memory) getStringStorage storage $",
            "full_signature": "function get(StringStorage storage $) internal  view returns (string memory)",
            "class_method_signature": "LibString.getStringStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function get(BytesStorage storage $) internal  view returns (bytes memory result)'}",
            "human_labeled_comment": "/**\n * @notice Retrieves the stored string value from the StringStorage struct.\n * \n * @param $ The StringStorage struct containing the stored string.\n * @return string The retrieved string value.\n */"
        },
        {
            "identifier": "upper",
            "parameters": "string memory subject",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function upper(string memory subject) internal pure returns (string memory result) {\n        result = toCase(subject, true);\n    }",
            "start": "715",
            "end": "717",
            "class": "LibString",
            "signature": "returns (string memory result) upperstring memory subject",
            "full_signature": "function upper(string memory subject) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.upperstring memory subject",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a string to uppercase.\n * @param subject The input string to be converted.\n * @return result The resulting string in uppercase.\n * @dev Internally calls the `toCase` function with the `true` flag to indicate uppercase conversion.\n */"
        },
        {
            "identifier": "toString",
            "parameters": "int256 value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toString(int256 value) internal pure returns (string memory result) {\n        if (value >= 0) return toString(uint256(value));\n        unchecked {\n            result = toString(~uint256(value) + 1);\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We still have some spare memory space on the left,\n            // as we have allocated 3 words (96 bytes) for up to 78 digits.\n            let n := mload(result) // Load the string length.\n            mstore(result, 0x2d) // Store the '-' character.\n            result := sub(result, 1) // Move back the string pointer by a byte.\n            mstore(result, add(n, 1)) // Update the string length.\n        }\n    }",
            "start": "158",
            "end": "172",
            "class": "LibString",
            "signature": "returns (string memory result) toStringint256 value",
            "full_signature": "function toString(int256 value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toStringint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to a string representation.\n *\n * Steps:\n * 1. If the value is non-negative, convert it to a uint256 and call toString(uint256).\n * 2. If the value is negative, convert it to a positive uint256 by taking its two's complement (~value + 1).\n * 3. Use assembly to prepend a '-' character to the string representation of the positive value.\n * 4. Adjust the string pointer and update the string length to account for the added '-' character.\n *\n * @param value The int256 value to convert to a string.\n * @return result The string representation of the int256 value.\n */"
        },
        {
            "identifier": "is7BitASCII",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function is7BitASCII(string memory s) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            let mask := shl(7, div(not(0), 255))\n            let n := mload(s)\n            if n {\n                let o := add(s, 0x20)\n                let end := add(o, n)\n                let last := mload(end)\n                mstore(end, 0)\n                for {} 1 {} {\n                    if and(mask, mload(o)) {\n                        result := 0\n                        break\n                    }\n                    o := add(o, 0x20)\n                    if iszero(lt(o, end)) { break }\n                }\n                mstore(end, last)\n            }\n        }\n    }",
            "start": "452",
            "end": "474",
            "class": "LibString",
            "signature": "returns (bool result) is7BitASCIIstring memory s",
            "full_signature": "function is7BitASCII(string memory s) internal  pure returns (bool result)",
            "class_method_signature": "LibString.is7BitASCIIstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Checks if a given string is composed entirely of 7-bit ASCII characters.\n *\n * Steps:\n * 1. Initialize the result as true (1).\n * 2. Create a mask to check for non-7-bit ASCII characters.\n * 3. Load the length of the string.\n * 4. If the string is not empty:\n *    a. Calculate the starting and ending memory addresses of the string.\n *    b. Temporarily store the last byte of the string and replace it with 0.\n *    c. Iterate through the string, checking each character against the mask.\n *    d. If a non-7-bit ASCII character is found, set the result to false (0) and break.\n *    e. Restore the last byte of the string.\n * 5. Return the result.\n */"
        },
        {
            "identifier": "StringNot7BitASCII",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error StringNot7BitASCII();",
            "start": "38",
            "end": "38",
            "class": "LibString",
            "signature": " StringNot7BitASCII",
            "full_signature": "function StringNot7BitASCII()",
            "class_method_signature": "LibString.StringNot7BitASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a string is not 7-bit ASCII.\n * This error is thrown when a string contains characters outside the 7-bit ASCII range.\n */"
        },
        {
            "identifier": "replace",
            "parameters": "string memory subject, string memory needle, string memory replacement",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function replace(string memory subject, string memory needle, string memory replacement)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.replace(bytes(subject), bytes(needle), bytes(replacement)));\n    }",
            "start": "526",
            "end": "532",
            "class": "LibString",
            "signature": "returns (string memory) replacestring memory subject, string memory needle, string memory replacement",
            "full_signature": "function replace(string memory subject, string memory needle, string memory replacement) internal  pure returns (string memory)",
            "class_method_signature": "LibString.replacestring memory subject, string memory needle, string memory replacement",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function replace(bytes memory subject, bytes memory needle, bytes memory replacement) internal  pure returns (bytes memory result)'}",
            "human_labeled_comment": "/**\n * @notice Replaces all occurrences of a substring (`needle`) in a string (`subject`) with another string (`replacement`).\n *\n * @param subject The original string where replacements will be made.\n * @param needle The substring to be replaced.\n * @param replacement The string to replace `needle` with.\n *\n * @return The modified string with all occurrences of `needle` replaced by `replacement`.\n *\n * @dev Internally uses `LibBytes.replace` to perform the replacement on byte arrays.\n */"
        },
        {
            "identifier": "toHexString",
            "parameters": "uint256 value, uint256 byteCount",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexString(uint256 value, uint256 byteCount)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = toHexStringNoPrefix(value, byteCount);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "183",
            "end": "196",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringuint256 value, uint256 byteCount",
            "full_signature": "function toHexString(uint256 value, uint256 byteCount) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringuint256 value, uint256 byteCount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a hexadecimal string representation with a specified byte count.\n *\n * Steps:\n * 1. Convert the value to a hexadecimal string without the \"0x\" prefix using `toHexStringNoPrefix`.\n * 2. Use inline assembly to:\n *    - Compute the length of the resulting string.\n *    - Prepend the \"0x\" prefix to the string.\n *    - Adjust the pointer to account for the prefix.\n *    - Store the final length of the string.\n *\n * @param value The uint256 value to convert.\n * @param byteCount The number of bytes to represent in the hexadecimal string.\n * @return result The hexadecimal string representation of the value with the \"0x\" prefix.\n */"
        },
        {
            "identifier": "toCase",
            "parameters": "string memory subject, bool toUpper",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toCase(string memory subject, bool toUpper)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(subject)\n            if n {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let d := sub(subject, result)\n                let flags := shl(add(70, shl(5, toUpper)), 0x3ffffff)\n                for { let end := add(o, n) } 1 {} {\n                    let b := byte(0, mload(add(d, o)))\n                    mstore8(o, xor(and(shr(b, flags), 0x20), b))\n                    o := add(o, 1)\n                    if eq(o, end) { break }\n                }\n                mstore(result, n) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n            }\n        }\n    }",
            "start": "641",
            "end": "665",
            "class": "LibString",
            "signature": "returns (string memory result) toCasestring memory subject, bool toUpper",
            "full_signature": "function toCase(string memory subject, bool toUpper) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toCasestring memory subject, bool toUpper",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a string to either uppercase or lowercase based on the `toUpper` flag.\n * @dev Uses low-level assembly for efficient string manipulation.\n *\n * Steps:\n * 1. Load the length of the input string (`subject`).\n * 2. If the length is non-zero:\n *    a. Allocate memory for the result string.\n *    b. Calculate the offset for the result string.\n *    c. Determine the case conversion flags based on the `toUpper` parameter.\n *    d. Iterate through each character of the input string:\n *       - Convert the character to the desired case using bitwise operations.\n *       - Store the converted character in the result string.\n *    e. Store the length of the result string.\n *    f. Zeroize the memory slot after the string.\n *    g. Update the free memory pointer.\n * @param subject The input string to be converted.\n * @param toUpper A boolean flag: `true` for uppercase, `false` for lowercase.\n * @return result The converted string.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "string memory subject, string memory needle",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lastIndexOf(string memory subject, string memory needle)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), type(uint256).max);\n    }",
            "start": "566",
            "end": "572",
            "class": "LibString",
            "signature": "returns (uint256) lastIndexOfstring memory subject, string memory needle",
            "full_signature": "function lastIndexOf(string memory subject, string memory needle) internal  pure returns (uint256)",
            "class_method_signature": "LibString.lastIndexOfstring memory subject, string memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from) internal  pure returns (uint256 result)', 'function lastIndexOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a substring (`needle`) within a string (`subject`).\n * @param subject The string to search within.\n * @param needle The substring to search for.\n * @return The last index of `needle` in `subject`. Returns `type(uint256).max` if `needle` is not found.\n * @dev Internally converts the strings to bytes and uses `LibBytes.lastIndexOf` for the search.\n */"
        },
        {
            "identifier": "endsWith",
            "parameters": "string memory subject, string memory needle",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function endsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.endsWith(bytes(subject), bytes(needle));\n    }",
            "start": "585",
            "end": "587",
            "class": "LibString",
            "signature": "returns (bool) endsWithstring memory subject, string memory needle",
            "full_signature": "function endsWith(string memory subject, string memory needle) internal  pure returns (bool)",
            "class_method_signature": "LibString.endsWithstring memory subject, string memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function endsWith(bytes memory subject, bytes memory needle) internal  pure returns (bool result)'}",
            "human_labeled_comment": "/**\n * @notice Checks if a string ends with a specified substring.\n * @param subject The string to check.\n * @param needle The substring to check for at the end of the subject string.\n * @return bool Returns true if the subject string ends with the needle substring, otherwise false.\n */"
        },
        {
            "identifier": "escapeHTML",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function escapeHTML(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(s, mload(s))\n            let o := add(result, 0x20)\n            // Store the bytes of the packed offsets and strides into the scratch space.\n            // `packed = (stride << 5) | offset`. Max offset is 20. Max stride is 6.\n            mstore(0x1f, 0x900094)\n            mstore(0x08, 0xc0000000a6ab)\n            // Store \"&quot;&amp;&#39;&lt;&gt;\" into the scratch space.\n            mstore(0x00, shl(64, 0x2671756f743b26616d703b262333393b266c743b2667743b))\n            for {} iszero(eq(s, end)) {} {\n                s := add(s, 1)\n                let c := and(mload(s), 0xff)\n                // Not in `[\"\\\"\",\"'\",\"&\",\"<\",\">\"]`.\n                if iszero(and(shl(c, 1), 0x500000c400000000)) {\n                    mstore8(o, c)\n                    o := add(o, 1)\n                    continue\n                }\n                let t := shr(248, mload(c))\n                mstore(o, mload(and(t, 0x1f)))\n                o := add(o, shr(5, t))\n            }\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(o, 0x20)) // Allocate memory.\n        }\n    }",
            "start": "720",
            "end": "749",
            "class": "LibString",
            "signature": "returns (string memory result) escapeHTMLstring memory s",
            "full_signature": "function escapeHTML(string memory s) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.escapeHTMLstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function set(BytesStorage storage $, bytes memory s) internal', 'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Escapes HTML special characters in a string to prevent XSS attacks.\n *\n * Steps:\n * 1. Allocate memory for the result string.\n * 2. Calculate the end of the input string.\n * 3. Initialize the output pointer.\n * 4. Store packed offsets and strides into the scratch space.\n * 5. Store the HTML escape sequences into the scratch space.\n * 6. Iterate through each character of the input string.\n * 7. Check if the character is one of the special characters: `\"`, `'`, `&`, `<`, `>`.\n * 8. If not a special character, store it directly in the result.\n * 9. If it is a special character, replace it with the corresponding HTML escape sequence.\n * 10. Zeroize the slot after the string to ensure no leftover data.\n * 11. Store the length of the result string.\n * 12. Allocate memory for the result string.\n */"
        },
        {
            "identifier": "toHexStringChecksummed",
            "parameters": "address value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexStringChecksummed(address value) internal pure returns (string memory result) {\n        result = toHexString(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let mask := shl(6, div(not(0), 255)) // `0b010000000100000000 ...`\n            let o := add(result, 0x22)\n            let hashed := and(keccak256(o, 40), mul(34, mask)) // `0b10001000 ... `\n            let t := shl(240, 136) // `0b10001000 << 240`\n            for { let i := 0 } 1 {} {\n                mstore(add(i, i), mul(t, byte(i, hashed)))\n                i := add(i, 1)\n                if eq(i, 20) { break }\n            }\n            mstore(o, xor(mload(o), shr(1, and(mload(0x00), and(mload(o), mask)))))\n            o := add(o, 0x20)\n            mstore(o, xor(mload(o), shr(1, and(mload(0x20), and(mload(o), mask)))))\n        }\n    }",
            "start": "330",
            "end": "347",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringChecksummedaddress value",
            "full_signature": "function toHexStringChecksummed(address value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringChecksummedaddress value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts an Ethereum address to a checksummed hexadecimal string.\n *\n * Steps:\n * 1. Convert the address to a hexadecimal string using `toHexString`.\n * 2. Use inline assembly to apply the checksum algorithm:\n *    - Create a bitmask to identify specific bits in the address.\n *    - Compute the Keccak-256 hash of the address string.\n *    - Apply the checksum logic by XORing specific bits of the hash with the address string.\n *    - Iterate over the address string to apply the checksum to each character.\n *    - Adjust the final result to ensure proper checksum formatting.\n *\n * @param value The Ethereum address to be converted.\n * @return result The checksummed hexadecimal string representation of the address.\n */"
        },
        {
            "identifier": "eqs",
            "parameters": "string memory a, bytes32 b",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function eqs(string memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // These should be evaluated on compile time, as far as possible.\n            let m := not(shl(7, div(not(iszero(b)), 255))) // `0x7f7f ...`.\n            let x := not(or(m, or(b, add(m, and(b, m)))))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            result := gt(eq(mload(a), add(iszero(x), xor(31, shr(3, r)))),\n                xor(shr(add(8, r), b), shr(add(8, r), mload(add(a, 0x20)))))\n        }\n    }",
            "start": "857",
            "end": "872",
            "class": "LibString",
            "signature": "returns (bool result) eqsstring memory a, bytes32 b",
            "full_signature": "function eqs(string memory a, bytes32 b) internal  pure returns (bool result)",
            "class_method_signature": "LibString.eqsstring memory a, bytes32 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function eq(bytes memory a, bytes memory b) internal  pure returns (bool result)', 'function eqs(bytes memory a, bytes32 b) internal  pure returns (bool result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Compares a string `a` with a bytes32 `b` to check if they are equal.\n * @dev This function uses low-level assembly to optimize the comparison.\n * \n * Steps:\n * 1. Compute a mask `m` to handle padding and alignment.\n * 2. Compute `x` to determine the effective length of `b`.\n * 3. Calculate `r` to determine the number of significant bits in `x`.\n * 4. Compare the lengths of `a` and `b` using the computed values.\n * 5. Perform a bitwise comparison between the string `a` and the bytes32 `b`.\n * 6. Return `true` if they are equal, otherwise `false`.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "string memory subject, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function slice(string memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (string memory)\n    {\n        return string(LibBytes.slice(bytes(subject), start, end));\n    }",
            "start": "596",
            "end": "602",
            "class": "LibString",
            "signature": "returns (string memory) slicestring memory subject, uint256 start, uint256 end",
            "full_signature": "function slice(string memory subject, uint256 start, uint256 end) internal  pure returns (string memory)",
            "class_method_signature": "LibString.slicestring memory subject, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function slice(bytes memory subject, uint256 start) internal  pure returns (bytes memory result)', 'function slice(bytes memory subject, uint256 start, uint256 end) internal  pure returns (bytes memory result)'}",
            "human_labeled_comment": "/**\n * @notice Slices a string from a specified start index to an end index.\n *\n * @param subject The string to be sliced.\n * @param start The starting index of the slice (inclusive).\n * @param end The ending index of the slice (exclusive).\n * @return The sliced string.\n *\n * Steps:\n * 1. Convert the input string to bytes.\n * 2. Use LibBytes.slice to slice the bytes from the start to end index.\n * 3. Convert the sliced bytes back to a string and return it.\n */"
        },
        {
            "identifier": "ALPHANUMERIC_7_BIT_ASCII",
            "parameters": "",
            "modifiers": "",
            "return": "uint128",
            "body": "uint128 internal constant ALPHANUMERIC_7_BIT_ASCII = 0x7fffffe07fffffe03ff000000000000;",
            "start": "48",
            "end": "48",
            "class": "LibString",
            "signature": "uint128 ALPHANUMERIC_7_BIT_ASCII",
            "full_signature": "uint128 internal constant ALPHANUMERIC_7_BIT_ASCII",
            "class_method_signature": "LibString.ALPHANUMERIC_7_BIT_ASCII",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice A constant representing a bitmask for 7-bit ASCII alphanumeric characters.\n * The value is a 128-bit unsigned integer where specific bits are set to 1 to represent valid alphanumeric characters in 7-bit ASCII encoding.\n */"
        },
        {
            "identifier": "toHexString",
            "parameters": "address value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toHexString(address value) internal pure returns (string memory result) {\n        result = toHexStringNoPrefix(value);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := add(mload(result), 2) // Compute the length.\n            mstore(result, 0x3078) // Store the \"0x\" prefix.\n            result := sub(result, 2) // Move the pointer.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "351",
            "end": "360",
            "class": "LibString",
            "signature": "returns (string memory result) toHexStringaddress value",
            "full_signature": "function toHexString(address value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toHexStringaddress value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts an Ethereum address to a hexadecimal string representation with the \"0x\" prefix.\n *\n * Steps:\n * 1. Call `toHexStringNoPrefix` to get the hexadecimal string without the \"0x\" prefix.\n * 2. Use inline assembly to:\n *    - Compute the length of the resulting string including the \"0x\" prefix.\n *    - Store the \"0x\" prefix at the beginning of the string.\n *    - Adjust the pointer to account for the prefix.\n *    - Store the computed length of the string.\n *\n * @param value The address to be converted to a hexadecimal string.\n * @return result The hexadecimal string representation of the address with the \"0x\" prefix.\n */"
        },
        {
            "identifier": "toString",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function toString(uint256 value) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but\n            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.\n            // We will need 1 word for the trailing zeros padding, 1 word for the length,\n            // and 3 words for a maximum of 78 digits.\n            result := add(mload(0x40), 0x80)\n            mstore(0x40, add(result, 0x20)) // Allocate memory.\n            mstore(result, 0) // Zeroize the slot after the string.\n\n            let end := result // Cache the end of the memory to calculate the length later.\n            let w := not(0) // Tsk.\n            // We write the string from rightmost digit to leftmost digit.\n            // The following is essentially a do-while loop that also handles the zero case.\n            for { let temp := value } 1 {} {\n                result := add(result, w) // `sub(result, 1)`.\n                // Store the character to the pointer.\n                // The ASCII index of the '0' character is 48.\n                mstore8(result, add(48, mod(temp, 10)))\n                temp := div(temp, 10) // Keep dividing `temp` until zero.\n                if iszero(temp) { break }\n            }\n            let n := sub(end, result)\n            result := sub(result, 0x20) // Move the pointer 32 bytes back to make room for the length.\n            mstore(result, n) // Store the length.\n        }\n    }",
            "start": "128",
            "end": "155",
            "class": "LibString",
            "signature": "returns (string memory result) toStringuint256 value",
            "full_signature": "function toString(uint256 value) internal  pure returns (string memory result)",
            "class_method_signature": "LibString.toStringuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function length(BytesStorage storage $) internal  view returns (uint256 result)', 'function contains(bytes memory subject, bytes memory needle) internal  pure returns (bool)', 'function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)'}",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to its string representation.\n *\n * Steps:\n * 1. Allocate memory for the result string, ensuring 32-byte word alignment.\n * 2. Initialize the result pointer and allocate memory.\n * 3. Zeroize the slot after the string to ensure clean memory.\n * 4. Cache the end of the memory to calculate the length later.\n * 5. Use a loop to convert each digit of the uint256 value to its ASCII character.\n * 6. Store each character in the result memory, starting from the least significant digit.\n * 7. Break the loop when the value is fully converted.\n * 8. Calculate the length of the string and store it at the beginning of the result memory.\n * 9. Adjust the result pointer to account for the length and return the final string.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "string memory subject, string memory needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lastIndexOf(string memory subject, string memory needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return LibBytes.lastIndexOf(bytes(subject), bytes(needle), from);\n    }",
            "start": "555",
            "end": "561",
            "class": "LibString",
            "signature": "returns (uint256) lastIndexOfstring memory subject, string memory needle, uint256 from",
            "full_signature": "function lastIndexOf(string memory subject, string memory needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "LibString.lastIndexOfstring memory subject, string memory needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function lastIndexOf(bytes memory subject, bytes memory needle, uint256 from) internal  pure returns (uint256 result)', 'function lastIndexOf(bytes memory subject, bytes memory needle) internal  pure returns (uint256)'}",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a substring (`needle`) within a string (`subject`) starting from a specified position (`from`).\n *\n * @param subject The string to search within.\n * @param needle The substring to search for.\n * @param from The position in the string to start the search from.\n * @return The last index of the substring within the string, or 0 if not found.\n *\n * @dev Internally uses `LibBytes.lastIndexOf` to perform the search on the byte representation of the strings.\n */"
        },
        {
            "identifier": "isEmpty",
            "parameters": "StringStorage storage $",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function isEmpty(StringStorage storage $) internal view returns (bool) {\n        return uint256($._spacer) & 0xff == uint256(0);\n    }",
            "start": "97",
            "end": "99",
            "class": "LibString",
            "signature": "returns (bool) isEmptyStringStorage storage $",
            "full_signature": "function isEmpty(StringStorage storage $) internal  view returns (bool)",
            "class_method_signature": "LibString.isEmptyStringStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function isEmpty(BytesStorage storage $) internal  view returns (bool)'}",
            "human_labeled_comment": "/**\n * @notice Checks if the StringStorage is empty.\n * @param $ The StringStorage instance to check.\n * @return bool Returns true if the StringStorage is empty, otherwise false.\n * @dev The function checks the first byte of the storage to determine if it is empty.\n */"
        },
        {
            "identifier": "startsWith",
            "parameters": "string memory subject, string memory needle",
            "modifiers": "pure",
            "return": "returns (bool)",
            "body": "function startsWith(string memory subject, string memory needle) internal pure returns (bool) {\n        return LibBytes.startsWith(bytes(subject), bytes(needle));\n    }",
            "start": "580",
            "end": "582",
            "class": "LibString",
            "signature": "returns (bool) startsWithstring memory subject, string memory needle",
            "full_signature": "function startsWith(string memory subject, string memory needle) internal  pure returns (bool)",
            "class_method_signature": "LibString.startsWithstring memory subject, string memory needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function startsWith(bytes memory subject, bytes memory needle) internal  pure returns (bool result)'}",
            "human_labeled_comment": "/**\n * @notice Checks if a string starts with a specified substring.\n * \n * @param subject The string to check.\n * @param needle The substring to look for at the beginning of the subject.\n * @return bool Returns true if the subject starts with the needle, otherwise false.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "string memory subject, uint256 start",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function slice(string memory subject, uint256 start) internal pure returns (string memory) {\n        return string(LibBytes.slice(bytes(subject), start, type(uint256).max));\n    }",
            "start": "606",
            "end": "608",
            "class": "LibString",
            "signature": "returns (string memory) slicestring memory subject, uint256 start",
            "full_signature": "function slice(string memory subject, uint256 start) internal  pure returns (string memory)",
            "class_method_signature": "LibString.slicestring memory subject, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "{'function slice(bytes memory subject, uint256 start) internal  pure returns (bytes memory result)', 'function slice(bytes memory subject, uint256 start, uint256 end) internal  pure returns (bytes memory result)'}",
            "human_labeled_comment": "/**\n * @notice Slices a string starting from a specified index to the end of the string.\n *\n * @param subject The string to be sliced.\n * @param start The starting index from which to slice the string.\n * @return The sliced string starting from the specified index.\n */"
        },
        {
            "identifier": "HexLengthInsufficient",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error HexLengthInsufficient();",
            "start": "32",
            "end": "32",
            "class": "LibString",
            "signature": " HexLengthInsufficient",
            "full_signature": "function HexLengthInsufficient()",
            "class_method_signature": "LibString.HexLengthInsufficient",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBytes} from \"./LibBytes.sol\";"
            ],
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the provided hexadecimal length is insufficient.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ext/ithaca/BLS.sol": [
        {
            "identifier": "BLS12_G2MSM",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_G2MSM = 0x0000000000000000000000000000000000000010;",
            "start": "83",
            "end": "83",
            "class": "BLS",
            "signature": "address BLS12_G2MSM",
            "full_signature": "address internal constant BLS12_G2MSM",
            "class_method_signature": "BLS.BLS12_G2MSM",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_G2MSM contract.\n * This address is used to reference the BLS12_G2MSM contract in the code.\n */"
        },
        {
            "identifier": "msm",
            "parameters": "G2Point[] memory points, bytes32[] memory scalars",
            "modifiers": "view",
            "return": "returns (G2Point memory result)",
            "body": "function msm(G2Point[] memory points, bytes32[] memory scalars)\n        internal\n        view\n        returns (G2Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            let k := mload(points)\n            let d := sub(scalars, points)\n            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {\n                points := add(points, 0x20)\n                let o := add(result, mul(0x120, i))\n                mcopy(o, mload(points), 0x100)\n                mstore(add(o, 0x100), mload(add(d, points)))\n            }\n            if iszero(\n                and(\n                    and(eq(k, mload(scalars)), eq(returndatasize(), 0x100)),\n                    staticcall(gas(), BLS12_G2MSM, result, mul(0x120, k), result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0xe3dc5425) // `G2MSMFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "243",
            "end": "267",
            "class": "BLS",
            "signature": "returns (G2Point memory result) msmG2Point[] memory points, bytes32[] memory scalars",
            "full_signature": "function msm(G2Point[] memory points, bytes32[] memory scalars) internal  view returns (G2Point memory result)",
            "class_method_signature": "BLS.msmG2Point[] memory points, bytes32[] memory scalars",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a multi-scalar multiplication (MSM) operation on G2 points.\n *\n * @param points An array of G2 points to be multiplied.\n * @param scalars An array of scalars to multiply the G2 points by.\n * @return result The resulting G2 point after the multi-scalar multiplication.\n *\n * Steps:\n * 1. Load the number of points from the `points` array.\n * 2. Calculate the offset between the `scalars` and `points` arrays.\n * 3. Iterate over each point and scalar:\n *    - Update the `points` pointer to the next element.\n *    - Calculate the output offset for the result.\n *    - Copy the point data to the result offset.\n *    - Store the corresponding scalar value.\n * 4. Perform a static call to the BLS12_G2MSM precompile to compute the MSM.\n * 5. Check if the call was successful:\n *    - If not, revert with the error `G2MSMFailed()`.\n */"
        },
        {
            "identifier": "G2AddFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error G2AddFailed();",
            "start": "110",
            "end": "110",
            "class": "BLS",
            "signature": " G2AddFailed",
            "full_signature": "function G2AddFailed()",
            "class_method_signature": "BLS.G2AddFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the G2 addition operation failed.\n */"
        },
        {
            "identifier": "toG1",
            "parameters": "Fp memory element",
            "modifiers": "view",
            "return": "returns (G1Point memory result)",
            "body": "function toG1(Fp memory element) internal view returns (G1Point memory result) {\n        assembly (\"memory-safe\") {\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x80),\n                    staticcall(gas(), BLS12_MAP_FP_TO_G1, element, 0x40, result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0x24a289fc) // `MapFpToG1Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "299",
            "end": "311",
            "class": "BLS",
            "signature": "returns (G1Point memory result) toG1Fp memory element",
            "full_signature": "function toG1(Fp memory element) internal  view returns (G1Point memory result)",
            "class_method_signature": "BLS.toG1Fp memory element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Converts a field element (Fp) to a G1 point on the BLS12 curve.\n * \n * Steps:\n * 1. Use inline assembly for low-level operations.\n * 2. Check if the static call to the BLS12 mapping function (BLS12_MAP_FP_TO_G1) succeeds.\n * 3. If the call fails, revert with the error `MapFpToG1Failed()`.\n * 4. Return the resulting G1 point.\n */"
        },
        {
            "identifier": "G1MulFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error G1MulFailed();",
            "start": "104",
            "end": "104",
            "class": "BLS",
            "signature": " G1MulFailed",
            "full_signature": "function G1MulFailed()",
            "class_method_signature": "BLS.G1MulFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the G1 multiplication operation failed.\n */"
        },
        {
            "identifier": "MapFp2ToG2Failed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error MapFp2ToG2Failed();",
            "start": "125",
            "end": "125",
            "class": "BLS",
            "signature": " MapFp2ToG2Failed",
            "full_signature": "function MapFp2ToG2Failed()",
            "class_method_signature": "BLS.MapFp2ToG2Failed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the mapping of an element from the field Fp2 to the group G2 has failed.\n */"
        },
        {
            "identifier": "BLS12_MAP_FP2_TO_G2",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_MAP_FP2_TO_G2 = 0x0000000000000000000000000000000000000013;",
            "start": "92",
            "end": "92",
            "class": "BLS",
            "signature": "address BLS12_MAP_FP2_TO_G2",
            "full_signature": "address internal constant BLS12_MAP_FP2_TO_G2",
            "class_method_signature": "BLS.BLS12_MAP_FP2_TO_G2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12 mapping function from FP2 to G2.\n * This address is used internally within the contract for cryptographic operations.\n */"
        },
        {
            "identifier": "BLS12_G1MSM",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_G1MSM = 0x000000000000000000000000000000000000000d;",
            "start": "74",
            "end": "74",
            "class": "BLS",
            "signature": "address BLS12_G1MSM",
            "full_signature": "address internal constant BLS12_G1MSM",
            "class_method_signature": "BLS.BLS12_G1MSM",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_G1MSM contract.\n * This address is used to reference the BLS12_G1MSM contract in the code.\n */"
        },
        {
            "identifier": "G2MSMFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error G2MSMFailed();",
            "start": "116",
            "end": "116",
            "class": "BLS",
            "signature": " G2MSMFailed",
            "full_signature": "function G2MSMFailed()",
            "class_method_signature": "BLS.G2MSMFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the G2MSM operation failed.\n */"
        },
        {
            "identifier": "G1AddFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error G1AddFailed();",
            "start": "101",
            "end": "101",
            "class": "BLS",
            "signature": " G1AddFailed",
            "full_signature": "function G1AddFailed()",
            "class_method_signature": "BLS.G1AddFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the addition operation in group G1 failed.\n */"
        },
        {
            "identifier": "BLS12_PAIRING_CHECK",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_PAIRING_CHECK = 0x0000000000000000000000000000000000000011;",
            "start": "86",
            "end": "86",
            "class": "BLS",
            "signature": "address BLS12_PAIRING_CHECK",
            "full_signature": "address internal constant BLS12_PAIRING_CHECK",
            "class_method_signature": "BLS.BLS12_PAIRING_CHECK",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12 pairing check precompile.\n * This address is used to interact with the BLS12 pairing check functionality on the blockchain.\n */"
        },
        {
            "identifier": "G1MSMFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error G1MSMFailed();",
            "start": "107",
            "end": "107",
            "class": "BLS",
            "signature": " G1MSMFailed",
            "full_signature": "function G1MSMFailed()",
            "class_method_signature": "BLS.G1MSMFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the G1MSM operation failed.\n */"
        },
        {
            "identifier": "G2MulFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error G2MulFailed();",
            "start": "113",
            "end": "113",
            "class": "BLS",
            "signature": " G2MulFailed",
            "full_signature": "function G2MulFailed()",
            "class_method_signature": "BLS.G2MulFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the G2 multiplication operation failed.\n */"
        },
        {
            "identifier": "MapFpToG1Failed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error MapFpToG1Failed();",
            "start": "122",
            "end": "122",
            "class": "BLS",
            "signature": " MapFpToG1Failed",
            "full_signature": "function MapFpToG1Failed()",
            "class_method_signature": "BLS.MapFpToG1Failed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that the mapping of a field element to a point on the G1 curve failed.\n */"
        },
        {
            "identifier": "BLS12_G2ADD",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_G2ADD = 0x000000000000000000000000000000000000000E;",
            "start": "77",
            "end": "77",
            "class": "BLS",
            "signature": "address BLS12_G2ADD",
            "full_signature": "address internal constant BLS12_G2ADD",
            "class_method_signature": "BLS.BLS12_G2ADD",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_G2ADD operation.\n * This address is used to represent a specific operation or contract in the system.\n */"
        },
        {
            "identifier": "PairingFailed",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "error PairingFailed();",
            "start": "119",
            "end": "119",
            "class": "BLS",
            "signature": " PairingFailed",
            "full_signature": "function PairingFailed()",
            "class_method_signature": "BLS.PairingFailed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Custom error indicating that a pairing operation has failed.\n */"
        },
        {
            "identifier": "BLS12_MAP_FP_TO_G1",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_MAP_FP_TO_G1 = 0x0000000000000000000000000000000000000012;",
            "start": "89",
            "end": "89",
            "class": "BLS",
            "signature": "address BLS12_MAP_FP_TO_G1",
            "full_signature": "address internal constant BLS12_MAP_FP_TO_G1",
            "class_method_signature": "BLS.BLS12_MAP_FP_TO_G1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_MAP_FP_TO_G1 operation.\n * This address is used to map a field element to a point on the G1 curve in BLS12-381 cryptography.\n */"
        },
        {
            "identifier": "BLS12_G1MUL",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_G1MUL = 0x000000000000000000000000000000000000000C;",
            "start": "71",
            "end": "71",
            "class": "BLS",
            "signature": "address BLS12_G1MUL",
            "full_signature": "address internal constant BLS12_G1MUL",
            "class_method_signature": "BLS.BLS12_G1MUL",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_G1MUL precompile contract.\n * This address is used to interact with the BLS12-381 curve's G1 multiplication precompile.\n */"
        },
        {
            "identifier": "BLS12_G1ADD",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_G1ADD = 0x000000000000000000000000000000000000000b;",
            "start": "68",
            "end": "68",
            "class": "BLS",
            "signature": "address BLS12_G1ADD",
            "full_signature": "address internal constant BLS12_G1ADD",
            "class_method_signature": "BLS.BLS12_G1ADD",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_G1ADD operation.\n * This address is typically used for cryptographic operations involving the BLS12-381 curve.\n */"
        },
        {
            "identifier": "BLS12_G2MUL",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant BLS12_G2MUL = 0x000000000000000000000000000000000000000F;",
            "start": "80",
            "end": "80",
            "class": "BLS",
            "signature": "address BLS12_G2MUL",
            "full_signature": "address internal constant BLS12_G2MUL",
            "class_method_signature": "BLS.BLS12_G2MUL",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Defines a constant address for the BLS12_G2MUL precompile contract.\n * This address is used to interact with the BLS12-381 curve's G2 multiplication functionality.\n */"
        },
        {
            "identifier": "msm",
            "parameters": "G1Point[] memory points, bytes32[] memory scalars",
            "modifiers": "view",
            "return": "returns (G1Point memory result)",
            "body": "function msm(G1Point[] memory points, bytes32[] memory scalars)\n        internal\n        view\n        returns (G1Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            let k := mload(points)\n            let d := sub(scalars, points)\n            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {\n                points := add(points, 0x20)\n                let o := add(result, mul(0xa0, i))\n                mcopy(o, mload(points), 0x80)\n                mstore(add(o, 0x80), mload(add(points, d)))\n            }\n            if iszero(\n                and(\n                    and(eq(k, mload(scalars)), eq(returndatasize(), 0x80)),\n                    staticcall(gas(), BLS12_G1MSM, result, mul(0xa0, k), result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0x5f776986) // `G1MSMFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "174",
            "end": "198",
            "class": "BLS",
            "signature": "returns (G1Point memory result) msmG1Point[] memory points, bytes32[] memory scalars",
            "full_signature": "function msm(G1Point[] memory points, bytes32[] memory scalars) internal  view returns (G1Point memory result)",
            "class_method_signature": "BLS.msmG1Point[] memory points, bytes32[] memory scalars",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Performs a multi-scalar multiplication (MSM) operation on G1 points.\n *\n * @param points An array of G1 points to be multiplied.\n * @param scalars An array of scalars to multiply the G1 points by.\n * @return result The resulting G1 point after the MSM operation.\n *\n * Steps:\n * 1. Load the number of points from memory.\n * 2. Calculate the offset between the scalars and points arrays.\n * 3. Iterate through each point and scalar:\n *    - Copy the point data to a temporary location.\n *    - Store the scalar value in the corresponding location.\n * 4. Perform a static call to the BLS12_G1MSM precompile to compute the MSM result.\n * 5. Check if the operation was successful:\n *    - If not, revert with the error `G1MSMFailed()`.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ext/delegatexyz/DelegateCheckerLib.sol": [
        {
            "identifier": "checkDelegateForERC721",
            "parameters": "address to, address from, address contract_, uint256 id",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function checkDelegateForERC721(address to, address from, address contract_, uint256 id)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0xa0, m), 0)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(isValid) {\n                mstore(m, 0xaba69cf8) // `checkDelegateForToken(address,address,address,uint256)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x84, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "start": "144",
            "end": "167",
            "class": "DelegateCheckerLib",
            "signature": "returns (bool isValid) checkDelegateForERC721address to, address from, address contract_, uint256 id",
            "full_signature": "function checkDelegateForERC721(address to, address from, address contract_, uint256 id) internal  view returns (bool isValid)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForERC721address to, address from, address contract_, uint256 id",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a delegate is authorized for a specific ERC721 token.\n *\n * @param to The address of the delegate.\n * @param from The address of the delegator.\n * @param contract_ The address of the ERC721 contract.\n * @param id The token ID to check.\n * @return isValid A boolean indicating whether the delegate is authorized.\n *\n * Steps:\n * 1. Load memory pointer and prepare memory layout for the delegate check.\n * 2. Store the token ID, contract address, delegator, and delegate addresses in memory.\n * 3. Call the `checkDelegateForERC721` function in the DELEGATE_REGISTRY_V2 contract.\n * 4. If the delegate is not valid, fallback to calling `checkDelegateForToken` in the DELEGATE_REGISTRY_V1 contract.\n * 5. Return the validity of the delegate.\n */"
        },
        {
            "identifier": "checkDelegateForERC1155",
            "parameters": "address to, address from, address contract_, uint256 id, bytes32 rights",
            "modifiers": "view",
            "return": "returns (uint256 amount)",
            "body": "function checkDelegateForERC1155(\n        address to,\n        address from,\n        address contract_,\n        uint256 id,\n        bytes32 rights\n    ) internal view returns (uint256 amount) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, 0)\n            mstore(add(0xa0, m), rights)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, 0x00, 0x20)\n            amount := mul(mload(0x00), amount)\n            if iszero(or(rights, iszero(not(amount)))) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "start": "314",
            "end": "340",
            "class": "DelegateCheckerLib",
            "signature": "returns (uint256 amount) checkDelegateForERC1155address to, address from, address contract_, uint256 id, bytes32 rights",
            "full_signature": "function checkDelegateForERC1155(address to, address from, address contract_, uint256 id, bytes32 rights) internal  view returns (uint256 amount)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForERC1155address to, address from, address contract_, uint256 id, bytes32 rights",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks the delegated rights for an ERC1155 token between two addresses.\n *\n * @param to The address to which the rights are delegated.\n * @param from The address from which the rights are delegated.\n * @param contract_ The address of the ERC1155 contract.\n * @param id The ID of the ERC1155 token.\n * @param rights The specific rights being checked.\n *\n * @return amount The amount of delegated rights, if any.\n *\n * Steps:\n * 1. Load memory pointer and prepare memory layout for the delegate check.\n * 2. Store the parameters in memory for the delegate check.\n * 3. Perform a static call to the DELEGATE_REGISTRY_V2 contract to check for ERC1155 delegation.\n * 4. Calculate the amount of delegated rights based on the result.\n * 5. If no rights are found or if the rights are invalid, fallback to checking the DELEGATE_REGISTRY_V1 contract.\n * 6. Return the amount of delegated rights.\n */"
        },
        {
            "identifier": "checkDelegateForERC20",
            "parameters": "address to, address from, address contract_, bytes32 rights",
            "modifiers": "view",
            "return": "returns (uint256 amount)",
            "body": "function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, 0)\n            mstore(add(0x80, m), rights)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC20(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, 0x00, 0x20)\n            amount := mul(mload(0x00), amount)\n            if iszero(or(rights, iszero(not(amount)))) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "start": "245",
            "end": "268",
            "class": "DelegateCheckerLib",
            "signature": "returns (uint256 amount) checkDelegateForERC20address to, address from, address contract_, bytes32 rights",
            "full_signature": "function checkDelegateForERC20(address to, address from, address contract_, bytes32 rights) internal  view returns (uint256 amount)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForERC20address to, address from, address contract_, bytes32 rights",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks the delegated rights for ERC20 tokens between two addresses for a specific contract.\n * @dev This function uses low-level assembly to interact with the delegate registry contracts (V1 and V2).\n * It checks if the `to` address has the specified `rights` delegated from the `from` address for the `contract_`.\n * If the rights are not found in V2, it falls back to checking V1.\n *\n * Steps:\n * 1. Load memory pointer `m` at 0x40.\n * 2. Store the function selector and parameters in memory for the `checkDelegateForERC20` call.\n * 3. Perform a static call to the DELEGATE_REGISTRY_V2 contract to check for delegated rights.\n * 4. Multiply the result by the amount returned to ensure correctness.\n * 5. If no rights are found in V2, fall back to checking DELEGATE_REGISTRY_V1 using the `checkDelegateForContract` function.\n * 6. Return the amount of delegated rights found.\n *\n * @param to The address to check for delegated rights.\n * @param from The address that delegated the rights.\n * @param contract_ The contract address for which the rights are being checked.\n * @param rights The specific rights being checked.\n * @return amount The amount of delegated rights found (0 if none).\n */"
        },
        {
            "identifier": "DELEGATE_REGISTRY_V2",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant DELEGATE_REGISTRY_V2 = 0x00000000000000447e69651d841bD8D104Bed493;",
            "start": "17",
            "end": "17",
            "class": "DelegateCheckerLib",
            "signature": "address DELEGATE_REGISTRY_V2",
            "full_signature": "address internal constant DELEGATE_REGISTRY_V2",
            "class_method_signature": "DelegateCheckerLib.DELEGATE_REGISTRY_V2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the address of the DelegateRegistry V2 contract.\n * This address is used to interact with the DelegateRegistry V2 contract.\n */"
        },
        {
            "identifier": "checkDelegateForERC1155",
            "parameters": "address to, address from, address contract_, uint256 id",
            "modifiers": "view",
            "return": "returns (uint256 amount)",
            "body": "function checkDelegateForERC1155(address to, address from, address contract_, uint256 id)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let o := add(0xa0, m)\n            mstore(o, 0)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC1155(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb8705875000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, o, 0x20)\n            amount := mul(mload(o), amount)\n            if not(amount) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "start": "279",
            "end": "303",
            "class": "DelegateCheckerLib",
            "signature": "returns (uint256 amount) checkDelegateForERC1155address to, address from, address contract_, uint256 id",
            "full_signature": "function checkDelegateForERC1155(address to, address from, address contract_, uint256 id) internal  view returns (uint256 amount)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForERC1155address to, address from, address contract_, uint256 id",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks the delegated amount for a specific ERC1155 token between two addresses.\n *\n * @dev This function uses low-level assembly to interact with the delegate registry contracts.\n * It first attempts to check the delegation using `DELEGATE_REGISTRY_V2`. If no delegation is found,\n * it falls back to `DELEGATE_REGISTRY_V1` to check for a contract-level delegation.\n *\n * Steps:\n * 1. Allocate memory for the function call.\n * 2. Prepare the function call data for `checkDelegateForERC1155` in `DELEGATE_REGISTRY_V2`.\n * 3. Perform a static call to `DELEGATE_REGISTRY_V2` to check the delegation.\n * 4. If no delegation is found, prepare the function call data for `checkDelegateForContract` in `DELEGATE_REGISTRY_V1`.\n * 5. Perform a static call to `DELEGATE_REGISTRY_V1` to check for contract-level delegation.\n * 6. Return the amount of delegated tokens or the result of the contract-level delegation check.\n *\n * @param to The address to which the delegation is checked.\n * @param from The address from which the delegation is checked.\n * @param contract_ The address of the ERC1155 contract.\n * @param id The ID of the ERC1155 token.\n * @return amount The amount of tokens delegated or the result of the contract-level delegation check.\n */"
        },
        {
            "identifier": "checkDelegateForERC20",
            "parameters": "address to, address from, address contract_",
            "modifiers": "view",
            "return": "returns (uint256 amount)",
            "body": "function checkDelegateForERC20(address to, address from, address contract_)\n        internal\n        view\n        returns (uint256 amount)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let o := add(0x80, m)\n            mstore(o, 0)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC20(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0xba63c817000000000000000000000000)\n            amount := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, o, 0x20)\n            amount := mul(mload(o), amount)\n            if not(amount) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                let t := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                amount := or(sub(0, and(eq(mload(m), 1), t)), amount)\n            }\n        }\n    }",
            "start": "211",
            "end": "234",
            "class": "DelegateCheckerLib",
            "signature": "returns (uint256 amount) checkDelegateForERC20address to, address from, address contract_",
            "full_signature": "function checkDelegateForERC20(address to, address from, address contract_) internal  view returns (uint256 amount)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForERC20address to, address from, address contract_",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks the delegated amount of ERC20 tokens for a specific contract between two addresses.\n *\n * @dev This function uses low-level assembly to interact with the delegate registry contracts (V1 and V2).\n * It performs the following steps:\n * 1. Allocates memory and prepares the function call data for `checkDelegateForERC20`.\n * 2. Calls the delegate registry V2 contract to check the delegated amount.\n * 3. If the call to V2 fails or returns zero, it falls back to calling the delegate registry V1 contract.\n * 4. Returns the amount of delegated tokens, or zero if no delegation is found.\n *\n * @param to The address to which the delegation is being checked.\n * @param from The address from which the delegation is being checked.\n * @param contract_ The address of the ERC20 contract being checked.\n * @return amount The amount of delegated tokens, or zero if no delegation is found.\n */"
        },
        {
            "identifier": "DELEGATE_REGISTRY_V1",
            "parameters": "",
            "modifiers": "",
            "return": "address",
            "body": "address internal constant DELEGATE_REGISTRY_V1 = 0x00000000000076A84feF008CDAbe6409d2FE638B;",
            "start": "13",
            "end": "13",
            "class": "DelegateCheckerLib",
            "signature": "address DELEGATE_REGISTRY_V1",
            "full_signature": "address internal constant DELEGATE_REGISTRY_V1",
            "class_method_signature": "DelegateCheckerLib.DELEGATE_REGISTRY_V1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Internal constant representing the address of the Delegate Registry V1 contract.\n * This address is used to interact with the Delegate Registry V1 contract.\n */"
        },
        {
            "identifier": "checkDelegateForERC721",
            "parameters": "address to, address from, address contract_, uint256 id, bytes32 rights",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function checkDelegateForERC721(\n        address to,\n        address from,\n        address contract_,\n        uint256 id,\n        bytes32 rights\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0xa0, m), rights)\n            mstore(add(0x80, m), id)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForERC721(address,address,address,uint256,bytes32)`.\n            mstore(add(0x0c, m), 0xb9f36874000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0xa4, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(or(rights, isValid)) {\n                mstore(m, 0xaba69cf8) // `checkDelegateForToken(address,address,address,uint256)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x84, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "start": "175",
            "end": "200",
            "class": "DelegateCheckerLib",
            "signature": "returns (bool isValid) checkDelegateForERC721address to, address from, address contract_, uint256 id, bytes32 rights",
            "full_signature": "function checkDelegateForERC721(address to, address from, address contract_, uint256 id, bytes32 rights) internal  view returns (bool isValid)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForERC721address to, address from, address contract_, uint256 id, bytes32 rights",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "human_labeled_comment": "/**\n * @notice Checks if a delegate has the necessary rights for an ERC721 token.\n *\n * @param to The address of the delegate.\n * @param from The address of the delegator.\n * @param contract_ The address of the ERC721 contract.\n * @param id The token ID.\n * @param rights The specific rights to check for.\n *\n * @return isValid A boolean indicating whether the delegate has the specified rights.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the rights, token ID, contract address, delegator address, and delegate address in memory.\n * 3. Prepare the function selector for `checkDelegateForERC721`.\n * 4. Perform a static call to the DELEGATE_REGISTRY_V2 contract to check the delegate rights.\n * 5. Validate the result of the static call.\n * 6. If the rights are not valid or no rights are specified, fallback to checking with DELEGATE_REGISTRY_V1.\n * 7. Return the final validation result.\n */"
        }
    ]
}