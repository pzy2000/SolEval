{
    "/root/openzeppelin-contracts/contracts/utils/Packing.sol": [
        {
            "identifier": "pack_1_1",
            "parameters": "bytes1 left, bytes1 right",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function pack_1_1(bytes1 left, bytes1 right) internal pure returns (bytes2 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(248, not(0)))\n            right := and(right, shl(248, not(0)))\n            result := or(left, shr(8, right))\n        }\n    }",
            "start": "39",
            "end": "45",
            "class": "Packing",
            "signature": "returns (bytes2 result) pack_1_1bytes1 left, bytes1 right",
            "full_signature": "function pack_1_1(bytes1 left, bytes1 right) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.pack_1_1bytes1 left, bytes1 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two `bytes1` values into a single `bytes2` value.\n *\n * @param left The first `bytes1` value to be packed.\n * @param right The second `bytes1` value to be packed.\n * @return result The resulting `bytes2` value after packing.\n *\n * Steps:\n * 1. Clear the higher bits of the `left` value to ensure it fits within the lower 8 bits.\n * 2. Clear the higher bits of the `right` value to ensure it fits within the lower 8 bits.\n * 3. Combine the `left` and `right` values into a single `bytes2` value by shifting and OR-ing them.\n *\n * @dev This function uses inline assembly to perform bitwise operations for efficiency.\n */"
        },
        {
            "identifier": "pack_2_2",
            "parameters": "bytes2 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function pack_2_2(bytes2 left, bytes2 right) internal pure returns (bytes4 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "47",
            "end": "53",
            "class": "Packing",
            "signature": "returns (bytes4 result) pack_2_2bytes2 left, bytes2 right",
            "full_signature": "function pack_2_2(bytes2 left, bytes2 right) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.pack_2_2bytes2 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two `bytes2` values into a single `bytes4` value.\n *\n * @param left The first `bytes2` value to be packed.\n * @param right The second `bytes2` value to be packed.\n * @return result The resulting `bytes4` value after packing the two `bytes2` values.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Clear the upper 16 bits of `left` and `right` to ensure they are properly aligned.\n *    - Shift `right` by 16 bits to the right and combine it with `left` using the `or` operation.\n * 2. Return the resulting `bytes4` value.\n */"
        },
        {
            "identifier": "pack_2_4",
            "parameters": "bytes2 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function pack_2_4(bytes2 left, bytes4 right) internal pure returns (bytes6 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "55",
            "end": "61",
            "class": "Packing",
            "signature": "returns (bytes6 result) pack_2_4bytes2 left, bytes4 right",
            "full_signature": "function pack_2_4(bytes2 left, bytes4 right) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.pack_2_4bytes2 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes2` and a `bytes4` value into a single `bytes6` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations for packing.\n * - The `bytes2` value (`left`) is shifted left by 240 bits to align it properly.\n * - The `bytes4` value (`right`) is shifted left by 224 bits to align it properly.\n * - The `bytes4` value is then shifted right by 16 bits to combine it with the `bytes2` value.\n * - The result is a `bytes6` value that combines both inputs.\n *\n * @param left The `bytes2` value to be packed.\n * @param right The `bytes4` value to be packed.\n * @return result The packed `bytes6` value.\n */"
        },
        {
            "identifier": "pack_2_6",
            "parameters": "bytes2 left, bytes6 right",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function pack_2_6(bytes2 left, bytes6 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "63",
            "end": "69",
            "class": "Packing",
            "signature": "returns (bytes8 result) pack_2_6bytes2 left, bytes6 right",
            "full_signature": "function pack_2_6(bytes2 left, bytes6 right) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.pack_2_6bytes2 left, bytes6 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes2` and a `bytes6` into a single `bytes8` value.\n *\n * @param left The `bytes2` value to be packed into the higher-order bits of the result.\n * @param right The `bytes6` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes8` value combining `left` and `right`.\n *\n * Steps:\n * 1. Mask the `left` value to ensure it only occupies the higher-order 2 bytes.\n * 2. Mask the `right` value to ensure it only occupies the lower-order 6 bytes.\n * 3. Combine the masked `left` and `right` values into a single `bytes8` result.\n *\n * Assembly Details:\n * - `and(left, shl(240, not(0)))`: Ensures `left` is masked to 2 bytes.\n * - `and(right, shl(208, not(0)))`: Ensures `right` is masked to 6 bytes.\n * - `or(left, shr(16, right))`: Combines `left` and `right` into `result`.\n */"
        },
        {
            "identifier": "pack_2_8",
            "parameters": "bytes2 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function pack_2_8(bytes2 left, bytes8 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "71",
            "end": "77",
            "class": "Packing",
            "signature": "returns (bytes10 result) pack_2_8bytes2 left, bytes8 right",
            "full_signature": "function pack_2_8(bytes2 left, bytes8 right) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.pack_2_8bytes2 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes2` and a `bytes8` into a single `bytes10` value.\n *\n * @param left The `bytes2` value to be packed into the higher-order bits of the result.\n * @param right The `bytes8` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes10` value.\n *\n * Steps:\n * 1. Clear the lower 16 bits of the `left` value to ensure it fits into the higher-order bits.\n * 2. Clear the higher 64 bits of the `right` value to ensure it fits into the lower-order bits.\n * 3. Combine the `left` and `right` values by shifting `right` 16 bits to the right and performing a bitwise OR operation.\n *\n * @dev This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_2_10",
            "parameters": "bytes2 left, bytes10 right",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function pack_2_10(bytes2 left, bytes10 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "79",
            "end": "85",
            "class": "Packing",
            "signature": "returns (bytes12 result) pack_2_10bytes2 left, bytes10 right",
            "full_signature": "function pack_2_10(bytes2 left, bytes10 right) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.pack_2_10bytes2 left, bytes10 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes2` and a `bytes10` into a single `bytes12` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input bytes.\n * - The `bytes2` value is shifted left by 240 bits and masked to ensure it occupies the correct position.\n * - The `bytes10` value is shifted left by 176 bits and masked to ensure it occupies the correct position.\n * - The two values are then combined using a bitwise OR operation.\n *\n * @param left The `bytes2` value to be packed into the higher-order bits of the result.\n * @param right The `bytes10` value to be packed into the lower-order bits of the result.\n * @return result The combined `bytes12` value containing both `left` and `right`.\n *\n * Steps:\n * 1. Mask and shift the `left` value to align it with the higher-order bits of the result.\n * 2. Mask and shift the `right` value to align it with the lower-order bits of the result.\n * 3. Combine the two values using a bitwise OR operation to produce the final `bytes12` result.\n */"
        },
        {
            "identifier": "pack_2_20",
            "parameters": "bytes2 left, bytes20 right",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function pack_2_20(bytes2 left, bytes20 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "87",
            "end": "93",
            "class": "Packing",
            "signature": "returns (bytes22 result) pack_2_20bytes2 left, bytes20 right",
            "full_signature": "function pack_2_20(bytes2 left, bytes20 right) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.pack_2_20bytes2 left, bytes20 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes2` and a `bytes20` into a single `bytes22` value.\n *\n * @param left The `bytes2` value to be packed into the higher-order bits of the result.\n * @param right The `bytes20` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes22` value after packing.\n *\n * Steps:\n * 1. Clear the lower 16 bits of the `left` value to ensure it fits into the higher-order 16 bits of the result.\n * 2. Clear the higher 96 bits of the `right` value to ensure it fits into the lower-order 160 bits of the result.\n * 3. Combine the `left` and `right` values by shifting `right` 16 bits to the right and performing a bitwise OR operation with `left`.\n *\n * @dev This function uses inline assembly for low-level bit manipulation to optimize gas usage.\n */"
        },
        {
            "identifier": "pack_2_22",
            "parameters": "bytes2 left, bytes22 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_2_22(bytes2 left, bytes22 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(240, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(16, right))\n        }\n    }",
            "start": "95",
            "end": "101",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_2_22bytes2 left, bytes22 right",
            "full_signature": "function pack_2_22(bytes2 left, bytes22 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_2_22bytes2 left, bytes22 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes2` and a `bytes22` into a single `bytes24` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input values.\n * - The `bytes2` value is shifted left by 240 bits and masked to ensure it occupies the correct position.\n * - The `bytes22` value is shifted left by 80 bits and masked to ensure it occupies the correct position.\n * - The two values are then combined using a bitwise OR operation.\n *\n * @param left The `bytes2` value to be packed into the higher-order bits of the result.\n * @param right The `bytes22` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes24` value after packing the two inputs.\n *\n * Steps:\n * 1. Mask and shift the `left` value to align it with the higher-order bits of the result.\n * 2. Mask and shift the `right` value to align it with the lower-order bits of the result.\n * 3. Combine the two values using a bitwise OR operation to produce the final `bytes24` result.\n */"
        },
        {
            "identifier": "pack_4_2",
            "parameters": "bytes4 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function pack_4_2(bytes4 left, bytes2 right) internal pure returns (bytes6 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "103",
            "end": "109",
            "class": "Packing",
            "signature": "returns (bytes6 result) pack_4_2bytes4 left, bytes2 right",
            "full_signature": "function pack_4_2(bytes4 left, bytes2 right) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.pack_4_2bytes4 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes2` into a single `bytes6` value.\n *\n * @param left The `bytes4` value to be packed into the higher-order bits of the result.\n * @param right The `bytes2` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes6` value after packing the two inputs.\n *\n * Steps:\n * 1. Clear any extraneous bits from the `left` value by applying a mask.\n * 2. Clear any extraneous bits from the `right` value by applying a mask.\n * 3. Combine the `left` and `right` values into a single `bytes6` result using bitwise operations.\n *\n * Assembly Details:\n * - The `and` operation is used to mask out unwanted bits.\n * - The `shl` (shift left) and `shr` (shift right) operations are used to align the bits correctly.\n * - The `or` operation combines the two values into the final result.\n */"
        },
        {
            "identifier": "pack_4_4",
            "parameters": "bytes4 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function pack_4_4(bytes4 left, bytes4 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "111",
            "end": "117",
            "class": "Packing",
            "signature": "returns (bytes8 result) pack_4_4bytes4 left, bytes4 right",
            "full_signature": "function pack_4_4(bytes4 left, bytes4 right) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.pack_4_4bytes4 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two `bytes4` values into a single `bytes8` value.\n *\n * @param left The first `bytes4` value to be packed.\n * @param right The second `bytes4` value to be packed.\n * @return result The resulting `bytes8` value after packing.\n *\n * Steps:\n * 1. Clear the lower 32 bits of the `left` value to ensure it is properly aligned.\n * 2. Clear the lower 32 bits of the `right` value to ensure it is properly aligned.\n * 3. Combine the `left` value with the upper 32 bits of the `right` value using bitwise OR.\n * 4. Return the resulting `bytes8` value.\n *\n * Note: This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_4_6",
            "parameters": "bytes4 left, bytes6 right",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function pack_4_6(bytes4 left, bytes6 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "119",
            "end": "125",
            "class": "Packing",
            "signature": "returns (bytes10 result) pack_4_6bytes4 left, bytes6 right",
            "full_signature": "function pack_4_6(bytes4 left, bytes6 right) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.pack_4_6bytes4 left, bytes6 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes6` into a single `bytes10` value.\n *\n * @param left The `bytes4` value to be packed (left part of the result).\n * @param right The `bytes6` value to be packed (right part of the result).\n * @return result The packed `bytes10` value.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Mask the `left` value to ensure it is 4 bytes long.\n *    - Mask the `right` value to ensure it is 6 bytes long.\n *    - Combine the `left` and `right` values into a single `bytes10` result.\n * 2. Return the packed `bytes10` value.\n */"
        },
        {
            "identifier": "pack_4_8",
            "parameters": "bytes4 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function pack_4_8(bytes4 left, bytes8 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "127",
            "end": "133",
            "class": "Packing",
            "signature": "returns (bytes12 result) pack_4_8bytes4 left, bytes8 right",
            "full_signature": "function pack_4_8(bytes4 left, bytes8 right) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.pack_4_8bytes4 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes8` value into a single `bytes12` value.\n *\n * @param left The `bytes4` value to be packed into the higher-order bits of the result.\n * @param right The `bytes8` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes12` value combining `left` and `right`.\n *\n * Steps:\n * 1. Clear the higher-order bits of `left` to ensure it fits within 4 bytes.\n * 2. Clear the higher-order bits of `right` to ensure it fits within 8 bytes.\n * 3. Combine `left` and `right` into a single `bytes12` value by shifting `right` and performing a bitwise OR operation.\n *\n * Note: This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_4_12",
            "parameters": "bytes4 left, bytes12 right",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function pack_4_12(bytes4 left, bytes12 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "135",
            "end": "141",
            "class": "Packing",
            "signature": "returns (bytes16 result) pack_4_12bytes4 left, bytes12 right",
            "full_signature": "function pack_4_12(bytes4 left, bytes12 right) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.pack_4_12bytes4 left, bytes12 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` value and a `bytes12` value into a single `bytes16` value.\n *\n * @param left The `bytes4` value to be packed into the higher-order bits of the result.\n * @param right The `bytes12` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes16` value combining the `left` and `right` inputs.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Mask the `left` value to ensure it is a clean `bytes4` value.\n *    - Mask the `right` value to ensure it is a clean `bytes12` value.\n *    - Combine the `left` and `right` values into a single `bytes16` result using bitwise OR and shift operations.\n */"
        },
        {
            "identifier": "pack_4_16",
            "parameters": "bytes4 left, bytes16 right",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function pack_4_16(bytes4 left, bytes16 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "143",
            "end": "149",
            "class": "Packing",
            "signature": "returns (bytes20 result) pack_4_16bytes4 left, bytes16 right",
            "full_signature": "function pack_4_16(bytes4 left, bytes16 right) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.pack_4_16bytes4 left, bytes16 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes16` into a single `bytes20` value.\n *\n * @param left The `bytes4` value to be packed (left part of the result).\n * @param right The `bytes16` value to be packed (right part of the result).\n * @return result The resulting `bytes20` value after packing.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Clear the unused bits of `left` by shifting and masking.\n *    - Clear the unused bits of `right` by shifting and masking.\n *    - Combine `left` and the first 16 bits of `right` into a single `bytes20` value.\n * 2. Return the packed `bytes20` result.\n *\n * Note: This function uses low-level assembly for efficient bit manipulation.\n */"
        },
        {
            "identifier": "pack_4_20",
            "parameters": "bytes4 left, bytes20 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_4_20(bytes4 left, bytes20 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "151",
            "end": "157",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_4_20bytes4 left, bytes20 right",
            "full_signature": "function pack_4_20(bytes4 left, bytes20 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_4_20bytes4 left, bytes20 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes20` into a single `bytes24` value.\n *\n * @param left The `bytes4` value to be packed (leftmost part of the result).\n * @param right The `bytes20` value to be packed (rightmost part of the result).\n * @return result The packed `bytes24` value.\n *\n * Steps:\n * 1. Clear any extraneous bits from the `left` value by masking it with `shl(224, not(0))`.\n * 2. Clear any extraneous bits from the `right` value by masking it with `shl(96, not(0))`.\n * 3. Combine the `left` and `right` values by shifting `right` 32 bits to the right and performing a bitwise OR operation with `left`.\n *\n * @dev This function uses inline assembly for low-level bit manipulation to efficiently pack the two values.\n */"
        },
        {
            "identifier": "pack_4_24",
            "parameters": "bytes4 left, bytes24 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_4_24(bytes4 left, bytes24 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(64, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "159",
            "end": "165",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_4_24bytes4 left, bytes24 right",
            "full_signature": "function pack_4_24(bytes4 left, bytes24 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_4_24bytes4 left, bytes24 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes24` into a single `bytes28` value.\n *\n * @param left The `bytes4` value to be packed into the higher-order bits.\n * @param right The `bytes24` value to be packed into the lower-order bits.\n * @return result The resulting `bytes28` value after packing.\n *\n * Steps:\n * 1. Clear any extraneous bits from the `left` value by masking it with `0xFFFFFFFF` (4 bytes).\n * 2. Clear any extraneous bits from the `right` value by masking it with `0xFFFFFFFFFFFFFFFFFFFFFFFF` (24 bytes).\n * 3. Combine the `left` and `right` values by shifting the `right` value 32 bits to the right and performing a bitwise OR operation with the `left` value.\n * 4. Return the resulting `bytes28` value.\n */"
        },
        {
            "identifier": "pack_4_28",
            "parameters": "bytes4 left, bytes28 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_4_28(bytes4 left, bytes28 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(224, not(0)))\n            right := and(right, shl(32, not(0)))\n            result := or(left, shr(32, right))\n        }\n    }",
            "start": "167",
            "end": "173",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_4_28bytes4 left, bytes28 right",
            "full_signature": "function pack_4_28(bytes4 left, bytes28 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_4_28bytes4 left, bytes28 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes4` and a `bytes28` into a single `bytes32` value.\n *\n * @param left The `bytes4` value to be packed into the higher-order bits of the result.\n * @param right The `bytes28` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes32` value combining `left` and `right`.\n *\n * Steps:\n * 1. Clear the lower 28 bits of `left` by shifting it left by 224 bits and applying a mask.\n * 2. Clear the higher 4 bits of `right` by shifting it left by 32 bits and applying a mask.\n * 3. Combine `left` and `right` by performing a bitwise OR operation, where `left` occupies the higher-order bits and `right` occupies the lower-order bits.\n *\n * Note: This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_6_2",
            "parameters": "bytes6 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function pack_6_2(bytes6 left, bytes2 right) internal pure returns (bytes8 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }",
            "start": "175",
            "end": "181",
            "class": "Packing",
            "signature": "returns (bytes8 result) pack_6_2bytes6 left, bytes2 right",
            "full_signature": "function pack_6_2(bytes6 left, bytes2 right) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.pack_6_2bytes6 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes6` and a `bytes2` into a single `bytes8` value.\n *\n * @param left The `bytes6` value to be packed (left part of the result).\n * @param right The `bytes2` value to be packed (right part of the result).\n * @return result The packed `bytes8` value.\n *\n * Steps:\n * 1. Use bitwise operations to ensure the `left` value is properly aligned by masking and shifting.\n * 2. Use bitwise operations to ensure the `right` value is properly aligned by masking and shifting.\n * 3. Combine the `left` and `right` values using a bitwise OR operation to produce the final `bytes8` result.\n *\n * @dev This function uses inline assembly for low-level bit manipulation to optimize packing.\n */"
        },
        {
            "identifier": "pack_6_4",
            "parameters": "bytes6 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function pack_6_4(bytes6 left, bytes4 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }",
            "start": "183",
            "end": "189",
            "class": "Packing",
            "signature": "returns (bytes10 result) pack_6_4bytes6 left, bytes4 right",
            "full_signature": "function pack_6_4(bytes6 left, bytes4 right) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.pack_6_4bytes6 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes6` and a `bytes4` into a single `bytes10` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the higher bits of `left` to ensure it fits within 6 bytes.\n * 2. Clears the higher bits of `right` to ensure it fits within 4 bytes.\n * 3. Combines `left` and `right` into a single `bytes10` value by shifting and OR-ing the bits.\n *\n * @param left The `bytes6` value to be packed.\n * @param right The `bytes4` value to be packed.\n * @return result The packed `bytes10` value.\n */"
        },
        {
            "identifier": "pack_6_6",
            "parameters": "bytes6 left, bytes6 right",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function pack_6_6(bytes6 left, bytes6 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }",
            "start": "191",
            "end": "197",
            "class": "Packing",
            "signature": "returns (bytes12 result) pack_6_6bytes6 left, bytes6 right",
            "full_signature": "function pack_6_6(bytes6 left, bytes6 right) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.pack_6_6bytes6 left, bytes6 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two 6-byte values (`left` and `right`) into a single 12-byte value.\n *\n * @param left The first 6-byte value to be packed.\n * @param right The second 6-byte value to be packed.\n * @return result The resulting 12-byte value after packing.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Clear the upper 208 bits of `left` to ensure it is a clean 6-byte value.\n *    - Clear the upper 208 bits of `right` to ensure it is a clean 6-byte value.\n *    - Shift `right` by 48 bits to the right and combine it with `left` using a bitwise OR operation.\n * 2. Return the resulting 12-byte value.\n *\n * @dev This function uses low-level assembly to optimize packing and ensure memory safety.\n */"
        },
        {
            "identifier": "pack_6_10",
            "parameters": "bytes6 left, bytes10 right",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function pack_6_10(bytes6 left, bytes10 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }",
            "start": "199",
            "end": "205",
            "class": "Packing",
            "signature": "returns (bytes16 result) pack_6_10bytes6 left, bytes10 right",
            "full_signature": "function pack_6_10(bytes6 left, bytes10 right) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.pack_6_10bytes6 left, bytes10 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes6` and a `bytes10` value into a single `bytes16` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input values.\n * - The `bytes6` value is shifted left by 208 bits to align it with the higher-order bits of the `bytes16` result.\n * - The `bytes10` value is shifted left by 176 bits to align it with the lower-order bits of the `bytes16` result.\n * - The two values are then combined using a bitwise OR operation.\n *\n * @param left The `bytes6` value to be packed into the higher-order bits of the result.\n * @param right The `bytes10` value to be packed into the lower-order bits of the result.\n * @return result The combined `bytes16` value.\n *\n * Steps:\n * 1. Mask the `bytes6` value to ensure it fits within the higher-order bits of the `bytes16` result.\n * 2. Mask the `bytes10` value to ensure it fits within the lower-order bits of the `bytes16` result.\n * 3. Combine the two values using a bitwise OR operation to produce the final `bytes16` result.\n */"
        },
        {
            "identifier": "pack_6_16",
            "parameters": "bytes6 left, bytes16 right",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function pack_6_16(bytes6 left, bytes16 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }",
            "start": "207",
            "end": "213",
            "class": "Packing",
            "signature": "returns (bytes22 result) pack_6_16bytes6 left, bytes16 right",
            "full_signature": "function pack_6_16(bytes6 left, bytes16 right) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.pack_6_16bytes6 left, bytes16 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes6` and a `bytes16` into a single `bytes22` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input values.\n * - The `bytes6` value is shifted left by 208 bits to align it with the higher bits of the result.\n * - The `bytes16` value is shifted left by 128 bits to align it with the lower bits of the result.\n * - The two values are then combined using a bitwise OR operation.\n *\n * @param left The `bytes6` value to be packed into the higher bits of the result.\n * @param right The `bytes16` value to be packed into the lower bits of the result.\n * @return result The packed `bytes22` value.\n *\n * Steps:\n * 1. Shift the `bytes6` value left by 208 bits and mask it to ensure it fits within the higher bits.\n * 2. Shift the `bytes16` value left by 128 bits and mask it to ensure it fits within the lower bits.\n * 3. Combine the two values using a bitwise OR operation to produce the final `bytes22` result.\n */"
        },
        {
            "identifier": "pack_6_22",
            "parameters": "bytes6 left, bytes22 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_6_22(bytes6 left, bytes22 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(208, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(48, right))\n        }\n    }",
            "start": "215",
            "end": "221",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_6_22bytes6 left, bytes22 right",
            "full_signature": "function pack_6_22(bytes6 left, bytes22 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_6_22bytes6 left, bytes22 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes6` and a `bytes22` into a single `bytes28` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 208 bits of the `left` bytes6 value.\n * 2. Clears the lower 80 bits of the `right` bytes22 value.\n * 3. Combines the `left` and `right` values by shifting the `right` value and performing a bitwise OR operation.\n *\n * @param left The `bytes6` value to be packed into the higher-order bits of the result.\n * @param right The `bytes22` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes28` value after packing.\n */"
        },
        {
            "identifier": "pack_8_2",
            "parameters": "bytes8 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function pack_8_2(bytes8 left, bytes2 right) internal pure returns (bytes10 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "223",
            "end": "229",
            "class": "Packing",
            "signature": "returns (bytes10 result) pack_8_2bytes8 left, bytes2 right",
            "full_signature": "function pack_8_2(bytes8 left, bytes2 right) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.pack_8_2bytes8 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes8` and a `bytes2` into a single `bytes10` value.\n *\n * @param left The `bytes8` value to be packed into the higher-order bits of the result.\n * @param right The `bytes2` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes10` value combining `left` and `right`.\n *\n * Steps:\n * 1. Clear any extraneous bits from the `left` value by masking it with `shl(192, not(0))`.\n * 2. Clear any extraneous bits from the `right` value by masking it with `shl(240, not(0))`.\n * 3. Combine the `left` and `right` values by shifting `right` to the correct position and performing a bitwise OR operation.\n *\n * @dev This function uses inline assembly for low-level bit manipulation to ensure efficient packing of the values.\n */"
        },
        {
            "identifier": "pack_8_4",
            "parameters": "bytes8 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function pack_8_4(bytes8 left, bytes4 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "231",
            "end": "237",
            "class": "Packing",
            "signature": "returns (bytes12 result) pack_8_4bytes8 left, bytes4 right",
            "full_signature": "function pack_8_4(bytes8 left, bytes4 right) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.pack_8_4bytes8 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a bytes8 and a bytes4 value into a single bytes12 value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input values.\n * - The `left` (bytes8) is masked to ensure it only occupies the first 8 bytes.\n * - The `right` (bytes4) is masked to ensure it only occupies the next 4 bytes.\n * - The `right` value is shifted to align with the remaining space in the `left` value.\n * - The two values are combined using a bitwise OR operation to produce the final `result` (bytes12).\n *\n * @param left The first 8 bytes of the result.\n * @param right The next 4 bytes of the result.\n * @return result The combined bytes12 value.\n */"
        },
        {
            "identifier": "pack_8_8",
            "parameters": "bytes8 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function pack_8_8(bytes8 left, bytes8 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "239",
            "end": "245",
            "class": "Packing",
            "signature": "returns (bytes16 result) pack_8_8bytes8 left, bytes8 right",
            "full_signature": "function pack_8_8(bytes8 left, bytes8 right) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.pack_8_8bytes8 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two `bytes8` values into a single `bytes16` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 192 bits of the `left` bytes8 value.\n * 2. Clears the lower 192 bits of the `right` bytes8 value.\n * 3. Combines the `left` value with the upper 64 bits of the `right` value.\n *\n * @param left The first `bytes8` value to pack.\n * @param right The second `bytes8` value to pack.\n * @return result The packed `bytes16` value.\n */"
        },
        {
            "identifier": "pack_8_12",
            "parameters": "bytes8 left, bytes12 right",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function pack_8_12(bytes8 left, bytes12 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "247",
            "end": "253",
            "class": "Packing",
            "signature": "returns (bytes20 result) pack_8_12bytes8 left, bytes12 right",
            "full_signature": "function pack_8_12(bytes8 left, bytes12 right) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.pack_8_12bytes8 left, bytes12 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes8` and a `bytes12` into a single `bytes20` value.\n *\n * @param left The `bytes8` value to be packed into the higher-order bits of the result.\n * @param right The `bytes12` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes20` value after packing.\n *\n * Steps:\n * 1. Clear the lower 192 bits of the `left` value to ensure it only occupies the higher-order bits.\n * 2. Clear the lower 160 bits of the `right` value to ensure it only occupies the lower-order bits.\n * 3. Combine the `left` and `right` values by shifting `right` 64 bits to the right and performing a bitwise OR operation with `left`.\n *\n * Note: This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_8_16",
            "parameters": "bytes8 left, bytes16 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_8_16(bytes8 left, bytes16 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "255",
            "end": "261",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_8_16bytes8 left, bytes16 right",
            "full_signature": "function pack_8_16(bytes8 left, bytes16 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_8_16bytes8 left, bytes16 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes8` and a `bytes16` into a single `bytes24` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 192 bits of the `left` bytes8 value.\n * 2. Clears the lower 128 bits of the `right` bytes16 value.\n * 3. Combines the two values by shifting the `right` value and performing a bitwise OR operation.\n *\n * @param left The `bytes8` value to be packed into the higher-order bits of the result.\n * @param right The `bytes16` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes24` value after packing.\n */"
        },
        {
            "identifier": "pack_8_20",
            "parameters": "bytes8 left, bytes20 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_8_20(bytes8 left, bytes20 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "263",
            "end": "269",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_8_20bytes8 left, bytes20 right",
            "full_signature": "function pack_8_20(bytes8 left, bytes20 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_8_20bytes8 left, bytes20 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes8` and a `bytes20` value into a single `bytes28` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 192 bits of the `left` value (bytes8).\n * 2. Clears the lower 96 bits of the `right` value (bytes20).\n * 3. Combines the `left` and `right` values into a single `bytes28` result by shifting and OR-ing.\n *\n * @param left The `bytes8` value to be packed into the higher bits of the result.\n * @param right The `bytes20` value to be packed into the lower bits of the result.\n * @return result The packed `bytes28` value combining `left` and `right`.\n */"
        },
        {
            "identifier": "pack_8_24",
            "parameters": "bytes8 left, bytes24 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_8_24(bytes8 left, bytes24 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(192, not(0)))\n            right := and(right, shl(64, not(0)))\n            result := or(left, shr(64, right))\n        }\n    }",
            "start": "271",
            "end": "277",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_8_24bytes8 left, bytes24 right",
            "full_signature": "function pack_8_24(bytes8 left, bytes24 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_8_24bytes8 left, bytes24 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a bytes8 and a bytes24 into a single bytes32 value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 192 bits of the `left` bytes8 value.\n * 2. Clears the lower 64 bits of the `right` bytes24 value.\n * 3. Combines the `left` and `right` values by shifting `right` 64 bits to the right and performing a bitwise OR operation.\n *\n * @param left The bytes8 value to be packed into the higher-order bits of the result.\n * @param right The bytes24 value to be packed into the lower-order bits of the result.\n * @return result The packed bytes32 value combining `left` and `right`.\n */"
        },
        {
            "identifier": "pack_10_2",
            "parameters": "bytes10 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function pack_10_2(bytes10 left, bytes2 right) internal pure returns (bytes12 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }",
            "start": "279",
            "end": "285",
            "class": "Packing",
            "signature": "returns (bytes12 result) pack_10_2bytes10 left, bytes2 right",
            "full_signature": "function pack_10_2(bytes10 left, bytes2 right) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.pack_10_2bytes10 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Combines two bytes values (`bytes10` and `bytes2`) into a single `bytes12` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 176 bits of the `left` bytes10 value.\n * 2. Clears the lower 240 bits of the `right` bytes2 value.\n * 3. Combines the two values by shifting the `right` value and performing a bitwise OR operation.\n *\n * @param left The `bytes10` value to be packed as the higher-order bits.\n * @param right The `bytes2` value to be packed as the lower-order bits.\n * @return result The combined `bytes12` value.\n */"
        },
        {
            "identifier": "pack_10_6",
            "parameters": "bytes10 left, bytes6 right",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function pack_10_6(bytes10 left, bytes6 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }",
            "start": "287",
            "end": "293",
            "class": "Packing",
            "signature": "returns (bytes16 result) pack_10_6bytes10 left, bytes6 right",
            "full_signature": "function pack_10_6(bytes10 left, bytes6 right) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.pack_10_6bytes10 left, bytes6 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes10` and a `bytes6` into a single `bytes16` value.\n *\n * @param left The `bytes10` value to be packed into the higher-order bits of the result.\n * @param right The `bytes6` value to be packed into the lower-order bits of the result.\n * @return result The resulting `bytes16` value after packing.\n *\n * Steps:\n * 1. Clear the lower 176 bits of the `left` value to ensure it fits into the higher-order bits.\n * 2. Clear the lower 208 bits of the `right` value to ensure it fits into the lower-order bits.\n * 3. Combine the `left` and `right` values using bitwise OR and shift operations to form the final `bytes16` result.\n *\n * @dev This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_10_10",
            "parameters": "bytes10 left, bytes10 right",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function pack_10_10(bytes10 left, bytes10 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }",
            "start": "295",
            "end": "301",
            "class": "Packing",
            "signature": "returns (bytes20 result) pack_10_10bytes10 left, bytes10 right",
            "full_signature": "function pack_10_10(bytes10 left, bytes10 right) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.pack_10_10bytes10 left, bytes10 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two `bytes10` values into a single `bytes20` value.\n *\n * @param left The first `bytes10` value to be packed.\n * @param right The second `bytes10` value to be packed.\n * @return result The packed `bytes20` value.\n *\n * Steps:\n * 1. Use assembly to ensure memory safety.\n * 2. Clear the upper 176 bits of the `left` value to ensure it fits within the first 10 bytes.\n * 3. Clear the upper 176 bits of the `right` value to ensure it fits within the second 10 bytes.\n * 4. Combine the `left` and `right` values by shifting `right` 80 bits to the right and performing a bitwise OR operation with `left`.\n * 5. Return the resulting `bytes20` value.\n */"
        },
        {
            "identifier": "pack_10_12",
            "parameters": "bytes10 left, bytes12 right",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function pack_10_12(bytes10 left, bytes12 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }",
            "start": "303",
            "end": "309",
            "class": "Packing",
            "signature": "returns (bytes22 result) pack_10_12bytes10 left, bytes12 right",
            "full_signature": "function pack_10_12(bytes10 left, bytes12 right) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.pack_10_12bytes10 left, bytes12 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes10` and a `bytes12` into a single `bytes22` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 176 bits of the `left` bytes10 value.\n * 2. Clears the lower 160 bits of the `right` bytes12 value.\n * 3. Combines the two values by shifting `right` 80 bits to the right and performing a bitwise OR with `left`.\n *\n * @param left The `bytes10` value to be packed into the higher bits of the result.\n * @param right The `bytes12` value to be packed into the lower bits of the result.\n * @return result The resulting `bytes22` value after packing.\n */"
        },
        {
            "identifier": "pack_10_22",
            "parameters": "bytes10 left, bytes22 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_10_22(bytes10 left, bytes22 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(176, not(0)))\n            right := and(right, shl(80, not(0)))\n            result := or(left, shr(80, right))\n        }\n    }",
            "start": "311",
            "end": "317",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_10_22bytes10 left, bytes22 right",
            "full_signature": "function pack_10_22(bytes10 left, bytes22 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_10_22bytes10 left, bytes22 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes10` and a `bytes22` into a single `bytes32` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input values.\n * - The `bytes10` value is left-shifted by 176 bits to align it with the higher bits of the `bytes32` result.\n * - The `bytes22` value is right-shifted by 80 bits to align it with the lower bits of the `bytes32` result.\n * - The two values are then combined using a bitwise OR operation to produce the final `bytes32` result.\n *\n * @param left The `bytes10` value to be packed into the higher bits of the result.\n * @param right The `bytes22` value to be packed into the lower bits of the result.\n * @return result The combined `bytes32` value containing both `left` and `right` packed together.\n */"
        },
        {
            "identifier": "pack_12_4",
            "parameters": "bytes12 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function pack_12_4(bytes12 left, bytes4 right) internal pure returns (bytes16 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }",
            "start": "319",
            "end": "325",
            "class": "Packing",
            "signature": "returns (bytes16 result) pack_12_4bytes12 left, bytes4 right",
            "full_signature": "function pack_12_4(bytes12 left, bytes4 right) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.pack_12_4bytes12 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 12-byte value (`left`) and a 4-byte value (`right`) into a single 16-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations for efficient packing.\n *      - The `left` value is masked to ensure it fits within 12 bytes.\n *      - The `right` value is masked to ensure it fits within 4 bytes.\n *      - The packed result is created by combining the masked `left` value with the right-shifted `right` value.\n *\n * @param left The 12-byte value to be packed (left part of the result).\n * @param right The 4-byte value to be packed (right part of the result).\n * @return result The 16-byte packed value combining `left` and `right`.\n *\n * Steps:\n * 1. Mask the `left` value to 12 bytes by clearing any bits beyond the first 12 bytes.\n * 2. Mask the `right` value to 4 bytes by clearing any bits beyond the first 4 bytes.\n * 3. Combine the masked `left` value with the right-shifted `right` value to form the 16-byte result.\n */"
        },
        {
            "identifier": "pack_12_8",
            "parameters": "bytes12 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function pack_12_8(bytes12 left, bytes8 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }",
            "start": "327",
            "end": "333",
            "class": "Packing",
            "signature": "returns (bytes20 result) pack_12_8bytes12 left, bytes8 right",
            "full_signature": "function pack_12_8(bytes12 left, bytes8 right) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.pack_12_8bytes12 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 12-byte value and an 8-byte value into a single 20-byte value.\n *\n * @param left The 12-byte value to be packed.\n * @param right The 8-byte value to be packed.\n * @return result The resulting 20-byte value after packing.\n *\n * Steps:\n * 1. Clear the upper bits of the 12-byte value (`left`) to ensure it fits within the first 12 bytes of the result.\n * 2. Clear the upper bits of the 8-byte value (`right`) to ensure it fits within the last 8 bytes of the result.\n * 3. Combine the 12-byte value and the 8-byte value into a single 20-byte value using bitwise operations.\n *\n * Assembly Details:\n * - `and(left, shl(160, not(0)))`: Clears the upper bits of `left` to ensure it fits within the first 12 bytes.\n * - `and(right, shl(192, not(0)))`: Clears the upper bits of `right` to ensure it fits within the last 8 bytes.\n * - `or(left, shr(96, right))`: Combines `left` and `right` into a single 20-byte value.\n */"
        },
        {
            "identifier": "pack_12_10",
            "parameters": "bytes12 left, bytes10 right",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function pack_12_10(bytes12 left, bytes10 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }",
            "start": "335",
            "end": "341",
            "class": "Packing",
            "signature": "returns (bytes22 result) pack_12_10bytes12 left, bytes10 right",
            "full_signature": "function pack_12_10(bytes12 left, bytes10 right) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.pack_12_10bytes12 left, bytes10 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 12-byte value (`left`) and a 10-byte value (`right`) into a single 22-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two values.\n * - The `left` value is masked to ensure it fits within 12 bytes.\n * - The `right` value is masked to ensure it fits within 10 bytes.\n * - The `right` value is shifted to align with the `left` value.\n * - The two values are combined using a bitwise OR operation.\n *\n * @param left The 12-byte value to be packed.\n * @param right The 10-byte value to be packed.\n * @return result The resulting 22-byte packed value.\n *\n * Steps:\n * 1. Mask the `left` value to ensure it fits within 12 bytes.\n * 2. Mask the `right` value to ensure it fits within 10 bytes.\n * 3. Shift the `right` value to align it with the `left` value.\n * 4. Combine the `left` and `right` values using a bitwise OR operation.\n * 5. Return the resulting 22-byte packed value.\n */"
        },
        {
            "identifier": "pack_12_12",
            "parameters": "bytes12 left, bytes12 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_12_12(bytes12 left, bytes12 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }",
            "start": "343",
            "end": "349",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_12_12bytes12 left, bytes12 right",
            "full_signature": "function pack_12_12(bytes12 left, bytes12 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_12_12bytes12 left, bytes12 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two 12-byte values (`left` and `right`) into a single 24-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the upper 160 bits of both `left` and `right` to ensure they are 12 bytes.\n * 2. Combines the two 12-byte values into a single 24-byte value by shifting `right` \n *    by 96 bits and performing a bitwise OR operation with `left`.\n *\n * @param left The first 12-byte value to pack.\n * @param right The second 12-byte value to pack.\n * @return result The packed 24-byte value.\n */"
        },
        {
            "identifier": "pack_12_16",
            "parameters": "bytes12 left, bytes16 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_12_16(bytes12 left, bytes16 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }",
            "start": "351",
            "end": "357",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_12_16bytes12 left, bytes16 right",
            "full_signature": "function pack_12_16(bytes12 left, bytes16 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_12_16bytes12 left, bytes16 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 12-byte value and a 16-byte value into a single 28-byte value using inline assembly.\n *\n * @param left The 12-byte value to be packed.\n * @param right The 16-byte value to be packed.\n * @return result The resulting 28-byte packed value.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Mask the `left` value to ensure it fits within the first 12 bytes.\n *    - Mask the `right` value to ensure it fits within the next 16 bytes.\n *    - Combine the masked `left` and `right` values into a single 28-byte result.\n */"
        },
        {
            "identifier": "pack_12_20",
            "parameters": "bytes12 left, bytes20 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_12_20(bytes12 left, bytes20 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(160, not(0)))\n            right := and(right, shl(96, not(0)))\n            result := or(left, shr(96, right))\n        }\n    }",
            "start": "359",
            "end": "365",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_12_20bytes12 left, bytes20 right",
            "full_signature": "function pack_12_20(bytes12 left, bytes20 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_12_20bytes12 left, bytes20 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 12-byte value (`left`) and a 20-byte value (`right`) into a single 32-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two values.\n * - The `left` value is shifted left by 160 bits and masked to ensure it occupies the correct position.\n * - The `right` value is shifted left by 96 bits and masked to ensure it occupies the correct position.\n * - The two values are then combined using a bitwise OR operation.\n *\n * @param left The 12-byte value to be packed into the higher-order bits of the result.\n * @param right The 20-byte value to be packed into the lower-order bits of the result.\n * @return result The 32-byte packed value combining `left` and `right`.\n */"
        },
        {
            "identifier": "pack_16_4",
            "parameters": "bytes16 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function pack_16_4(bytes16 left, bytes4 right) internal pure returns (bytes20 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }",
            "start": "367",
            "end": "373",
            "class": "Packing",
            "signature": "returns (bytes20 result) pack_16_4bytes16 left, bytes4 right",
            "full_signature": "function pack_16_4(bytes16 left, bytes4 right) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.pack_16_4bytes16 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 16-byte value (`left`) and a 4-byte value (`right`) into a 20-byte result.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two values.\n * - The `left` value is masked to ensure it fits within 16 bytes.\n * - The `right` value is masked to ensure it fits within 4 bytes.\n * - The `right` value is shifted to align with the lower 4 bytes of the 20-byte result.\n * - The `left` and shifted `right` values are combined using a bitwise OR operation.\n *\n * @param left The 16-byte value to be packed into the higher 16 bytes of the result.\n * @param right The 4-byte value to be packed into the lower 4 bytes of the result.\n * @return result A 20-byte value combining the `left` and `right` values.\n */"
        },
        {
            "identifier": "pack_16_6",
            "parameters": "bytes16 left, bytes6 right",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function pack_16_6(bytes16 left, bytes6 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }",
            "start": "375",
            "end": "381",
            "class": "Packing",
            "signature": "returns (bytes22 result) pack_16_6bytes16 left, bytes6 right",
            "full_signature": "function pack_16_6(bytes16 left, bytes6 right) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.pack_16_6bytes16 left, bytes6 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes16` and a `bytes6` into a single `bytes22` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to pack the two values.\n * - The `bytes16` value is masked to ensure it fits within the first 16 bytes.\n * - The `bytes6` value is masked to ensure it fits within the last 6 bytes.\n * - The two values are then combined using bitwise OR and shift operations to form a `bytes22`.\n *\n * @param left The `bytes16` value to be packed into the first 16 bytes of the result.\n * @param right The `bytes6` value to be packed into the last 6 bytes of the result.\n * @return result The packed `bytes22` value combining `left` and `right`.\n *\n * Steps:\n * 1. Mask the `left` value to ensure it fits within the first 16 bytes.\n * 2. Mask the `right` value to ensure it fits within the last 6 bytes.\n * 3. Combine the masked `left` and `right` values using bitwise OR and shift operations.\n * 4. Return the resulting `bytes22` value.\n*/"
        },
        {
            "identifier": "pack_16_8",
            "parameters": "bytes16 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_16_8(bytes16 left, bytes8 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }",
            "start": "383",
            "end": "389",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_16_8bytes16 left, bytes8 right",
            "full_signature": "function pack_16_8(bytes16 left, bytes8 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_16_8bytes16 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 16-byte value (`left`) and an 8-byte value (`right`) into a 24-byte result.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 128 bits of `left` to ensure it only contains the upper 16 bytes.\n * 2. Clears the lower 192 bits of `right` to ensure it only contains the upper 8 bytes.\n * 3. Combines `left` and `right` by shifting `right` to the correct position and performing a bitwise OR operation.\n *\n * @param left The 16-byte value to be packed into the upper 16 bytes of the result.\n * @param right The 8-byte value to be packed into the lower 8 bytes of the result.\n * @return result A 24-byte value containing the packed `left` and `right` values.\n */"
        },
        {
            "identifier": "pack_16_12",
            "parameters": "bytes16 left, bytes12 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_16_12(bytes16 left, bytes12 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }",
            "start": "391",
            "end": "397",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_16_12bytes16 left, bytes12 right",
            "full_signature": "function pack_16_12(bytes16 left, bytes12 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_16_12bytes16 left, bytes12 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes16` and a `bytes12` into a single `bytes28` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two input values.\n * - The `bytes16` value is left-shifted to ensure it occupies the higher 16 bytes of the result.\n * - The `bytes12` value is right-shifted to ensure it occupies the lower 12 bytes of the result.\n * - The two values are then combined using a bitwise OR operation.\n *\n * @param left The `bytes16` value to be packed into the higher 16 bytes of the result.\n * @param right The `bytes12` value to be packed into the lower 12 bytes of the result.\n * @return result The packed `bytes28` value.\n *\n * Steps:\n * 1. Clear the lower 128 bits of the `left` value to ensure it occupies the higher 16 bytes.\n * 2. Clear the lower 160 bits of the `right` value to ensure it occupies the lower 12 bytes.\n * 3. Combine the two values using a bitwise OR operation to produce the final `bytes28` result.\n */"
        },
        {
            "identifier": "pack_16_16",
            "parameters": "bytes16 left, bytes16 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_16_16(bytes16 left, bytes16 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(128, not(0)))\n            right := and(right, shl(128, not(0)))\n            result := or(left, shr(128, right))\n        }\n    }",
            "start": "399",
            "end": "405",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_16_16bytes16 left, bytes16 right",
            "full_signature": "function pack_16_16(bytes16 left, bytes16 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_16_16bytes16 left, bytes16 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs two 16-byte values (`left` and `right`) into a single 32-byte value (`result`).\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the upper 128 bits of `left` and `right` to ensure they are 16 bytes each.\n * 2. Combines `left` and `right` into a single 32-byte value by shifting `right` and performing a bitwise OR operation.\n *\n * @param left The first 16-byte value to pack.\n * @param right The second 16-byte value to pack.\n * @return result The packed 32-byte value.\n */"
        },
        {
            "identifier": "pack_20_2",
            "parameters": "bytes20 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function pack_20_2(bytes20 left, bytes2 right) internal pure returns (bytes22 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }",
            "start": "407",
            "end": "413",
            "class": "Packing",
            "signature": "returns (bytes22 result) pack_20_2bytes20 left, bytes2 right",
            "full_signature": "function pack_20_2(bytes20 left, bytes2 right) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.pack_20_2bytes20 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 20-byte value (`left`) and a 2-byte value (`right`) into a single 22-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two values.\n * - The `left` value is masked to ensure it is 20 bytes long.\n * - The `right` value is masked to ensure it is 2 bytes long.\n * - The `right` value is shifted to align with the higher bits of the 22-byte result.\n * - The final result is a combination of the `left` and shifted `right` values using a bitwise OR operation.\n *\n * @param left A 20-byte value to be packed into the higher bits of the result.\n * @param right A 2-byte value to be packed into the lower bits of the result.\n * @return result A 22-byte value combining the `left` and `right` values.\n */"
        },
        {
            "identifier": "pack_20_4",
            "parameters": "bytes20 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_20_4(bytes20 left, bytes4 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }",
            "start": "415",
            "end": "421",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_20_4bytes20 left, bytes4 right",
            "full_signature": "function pack_20_4(bytes20 left, bytes4 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_20_4bytes20 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 20-byte value (`left`) and a 4-byte value (`right`) into a 24-byte result.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two values.\n * - `left` is a 20-byte value (e.g., an address).\n * - `right` is a 4-byte value (e.g., a function selector or small data).\n * - The result is a 24-byte value where the first 20 bytes are from `left` and the last 4 bytes are from `right`.\n *\n * Steps:\n * 1. Mask the `left` value to ensure it is 20 bytes long by shifting and applying a bitwise NOT operation.\n * 2. Mask the `right` value to ensure it is 4 bytes long by shifting and applying a bitwise NOT operation.\n * 3. Combine the two values using a bitwise OR operation, ensuring proper alignment.\n *\n * @param left The 20-byte value to be placed in the first 20 bytes of the result.\n * @param right The 4-byte value to be placed in the last 4 bytes of the result.\n * @return result The 24-byte packed result combining `left` and `right`.\n */"
        },
        {
            "identifier": "pack_20_8",
            "parameters": "bytes20 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_20_8(bytes20 left, bytes8 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }",
            "start": "423",
            "end": "429",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_20_8bytes20 left, bytes8 right",
            "full_signature": "function pack_20_8(bytes20 left, bytes8 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_20_8bytes20 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a `bytes20` and a `bytes8` into a single `bytes28` value.\n *\n * @dev This function uses inline assembly to perform bitwise operations:\n * 1. Clears the lower 96 bits of the `left` (bytes20) value.\n * 2. Clears the lower 192 bits of the `right` (bytes8) value.\n * 3. Combines the `left` and `right` values by shifting `right` to the correct position and performing a bitwise OR operation.\n *\n * @param left The `bytes20` value to be packed into the higher-order bits of the result.\n * @param right The `bytes8` value to be packed into the lower-order bits of the result.\n * @return result The packed `bytes28` value.\n */"
        },
        {
            "identifier": "pack_20_12",
            "parameters": "bytes20 left, bytes12 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_20_12(bytes20 left, bytes12 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(96, not(0)))\n            right := and(right, shl(160, not(0)))\n            result := or(left, shr(160, right))\n        }\n    }",
            "start": "431",
            "end": "437",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_20_12bytes20 left, bytes12 right",
            "full_signature": "function pack_20_12(bytes20 left, bytes12 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_20_12bytes20 left, bytes12 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 20-byte value and a 12-byte value into a single 32-byte value.\n *\n * @param left The 20-byte value to be packed into the higher-order bits of the result.\n * @param right The 12-byte value to be packed into the lower-order bits of the result.\n * @return result The 32-byte value resulting from the packing operation.\n *\n * Steps:\n * 1. Use assembly to perform bitwise operations:\n *    - Clear the lower 96 bits of `left` to ensure it fits into the higher-order 20 bytes.\n *    - Clear the higher-order 160 bits of `right` to ensure it fits into the lower-order 12 bytes.\n *    - Combine `left` and `right` using bitwise OR, shifting `right` to align it correctly.\n * 2. Return the resulting 32-byte value.\n */"
        },
        {
            "identifier": "pack_22_2",
            "parameters": "bytes22 left, bytes2 right",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function pack_22_2(bytes22 left, bytes2 right) internal pure returns (bytes24 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(240, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }",
            "start": "439",
            "end": "445",
            "class": "Packing",
            "signature": "returns (bytes24 result) pack_22_2bytes22 left, bytes2 right",
            "full_signature": "function pack_22_2(bytes22 left, bytes2 right) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.pack_22_2bytes22 left, bytes2 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 22-byte value (`left`) and a 2-byte value (`right`) into a 24-byte result.\n *\n * @param left The 22-byte value to be packed into the higher-order bits of the result.\n * @param right The 2-byte value to be packed into the lower-order bits of the result.\n * @return result The 24-byte packed value combining `left` and `right`.\n *\n * Steps:\n * 1. Clear the lower 80 bits of `left` to ensure it fits into the higher-order 22 bytes.\n * 2. Clear the higher 240 bits of `right` to ensure it fits into the lower-order 2 bytes.\n * 3. Combine `left` and `right` by shifting `right` to the correct position and performing a bitwise OR operation.\n *\n * @dev This function uses inline assembly for low-level bit manipulation to optimize gas usage.\n */"
        },
        {
            "identifier": "pack_22_6",
            "parameters": "bytes22 left, bytes6 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_22_6(bytes22 left, bytes6 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(208, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }",
            "start": "447",
            "end": "453",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_22_6bytes22 left, bytes6 right",
            "full_signature": "function pack_22_6(bytes22 left, bytes6 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_22_6bytes22 left, bytes6 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 22-byte value (`left`) and a 6-byte value (`right`) into a single 28-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations for packing:\n * 1. Clears the lower 80 bits of `left` to ensure it aligns properly.\n * 2. Clears the lower 208 bits of `right` to ensure it aligns properly.\n * 3. Combines `left` and `right` into a single 28-byte value (`result`) using bitwise OR and shift operations.\n *\n * @param left The 22-byte value to be packed.\n * @param right The 6-byte value to be packed.\n * @return result The resulting 28-byte packed value.\n */"
        },
        {
            "identifier": "pack_22_10",
            "parameters": "bytes22 left, bytes10 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_22_10(bytes22 left, bytes10 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(80, not(0)))\n            right := and(right, shl(176, not(0)))\n            result := or(left, shr(176, right))\n        }\n    }",
            "start": "455",
            "end": "461",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_22_10bytes22 left, bytes10 right",
            "full_signature": "function pack_22_10(bytes22 left, bytes10 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_22_10bytes22 left, bytes10 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 22-byte value and a 10-byte value into a single 32-byte value.\n *\n * @param left The 22-byte value to be packed.\n * @param right The 10-byte value to be packed.\n * @return result The resulting 32-byte packed value.\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Clear the lower 80 bits of the `left` value to ensure it fits within the first 22 bytes.\n *    - Clear the lower 176 bits of the `right` value to ensure it fits within the last 10 bytes.\n *    - Combine the `left` and `right` values using bitwise OR and shift operations to create the final 32-byte result.\n */"
        },
        {
            "identifier": "pack_24_4",
            "parameters": "bytes24 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function pack_24_4(bytes24 left, bytes4 right) internal pure returns (bytes28 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(64, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(192, right))\n        }\n    }",
            "start": "463",
            "end": "469",
            "class": "Packing",
            "signature": "returns (bytes28 result) pack_24_4bytes24 left, bytes4 right",
            "full_signature": "function pack_24_4(bytes24 left, bytes4 right) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.pack_24_4bytes24 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 24-byte value (`left`) and a 4-byte value (`right`) into a 28-byte result.\n *\n * @dev This function uses inline assembly to perform bitwise operations for efficient packing.\n * - The `left` value is masked to ensure it fits within 24 bytes.\n * - The `right` value is masked to ensure it fits within 4 bytes.\n * - The `right` value is shifted to align with the lower 4 bytes of the result.\n * - The `left` and shifted `right` values are combined using a bitwise OR operation.\n *\n * @param left The 24-byte value to be packed into the higher bits of the result.\n * @param right The 4-byte value to be packed into the lower bits of the result.\n * @return result The 28-byte packed result combining `left` and `right`.\n */"
        },
        {
            "identifier": "pack_24_8",
            "parameters": "bytes24 left, bytes8 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_24_8(bytes24 left, bytes8 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(64, not(0)))\n            right := and(right, shl(192, not(0)))\n            result := or(left, shr(192, right))\n        }\n    }",
            "start": "471",
            "end": "477",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_24_8bytes24 left, bytes8 right",
            "full_signature": "function pack_24_8(bytes24 left, bytes8 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_24_8bytes24 left, bytes8 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 24-byte value (`left`) and an 8-byte value (`right`) into a single 32-byte value.\n *\n * @param left The 24-byte value to be packed into the higher-order bits of the result.\n * @param right The 8-byte value to be packed into the lower-order bits of the result.\n * @return result The 32-byte value resulting from the combination of `left` and `right`.\n *\n * Steps:\n * 1. Clear the lower 64 bits of `left` to ensure it only occupies the higher 24 bytes.\n * 2. Clear the higher 192 bits of `right` to ensure it only occupies the lower 8 bytes.\n * 3. Combine `left` and `right` by shifting `right` to the correct position and performing a bitwise OR operation.\n *\n * @dev This function uses inline assembly for low-level bit manipulation.\n */"
        },
        {
            "identifier": "pack_28_4",
            "parameters": "bytes28 left, bytes4 right",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function pack_28_4(bytes28 left, bytes4 right) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            left := and(left, shl(32, not(0)))\n            right := and(right, shl(224, not(0)))\n            result := or(left, shr(224, right))\n        }\n    }",
            "start": "479",
            "end": "485",
            "class": "Packing",
            "signature": "returns (bytes32 result) pack_28_4bytes28 left, bytes4 right",
            "full_signature": "function pack_28_4(bytes28 left, bytes4 right) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.pack_28_4bytes28 left, bytes4 right",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 28-byte value and a 4-byte value into a single 32-byte value.\n *\n * @dev This function uses inline assembly to perform bitwise operations to combine the two values.\n * The `left` parameter is a 28-byte value, and the `right` parameter is a 4-byte value.\n * The function ensures that the `left` value is shifted to the correct position and combined with the `right` value.\n *\n * @param left The 28-byte value to be packed.\n * @param right The 4-byte value to be packed.\n * @return result The resulting 32-byte value after packing.\n *\n * Steps:\n * 1. Use bitwise operations to ensure the `left` value is properly aligned by shifting it left by 32 bits.\n * 2. Use bitwise operations to ensure the `right` value is properly aligned by shifting it left by 224 bits.\n * 3. Combine the `left` and `right` values using a bitwise OR operation to produce the final 32-byte result.\n */"
        },
        {
            "identifier": "extract_2_1",
            "parameters": "bytes2 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_2_1(bytes2 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 1) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "487",
            "end": "492",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_2_1bytes2 self, uint8 offset",
            "full_signature": "function extract_2_1(bytes2 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_2_1bytes2 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes2` value at a specified offset.\n *\n * @param self The `bytes2` value from which to extract the byte.\n * @param offset The position (0 or 1) of the byte to extract within the `bytes2` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is greater than 1. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes2` value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the least significant byte.\n *    - Return the extracted byte.\n *\n * @dev This function is marked as `memory-safe` and uses inline assembly for low-level byte manipulation.\n */"
        },
        {
            "identifier": "replace_2_1",
            "parameters": "bytes2 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function replace_2_1(bytes2 self, bytes1 value, uint8 offset) internal pure returns (bytes2 result) {\n        bytes1 oldValue = extract_2_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "494",
            "end": "500",
            "class": "Packing",
            "signature": "returns (bytes2 result) replace_2_1bytes2 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_2_1(bytes2 self, bytes1 value, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.replace_2_1bytes2 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte within a `bytes2` value at a given offset with a new byte.\n *\n * @param self The original `bytes2` value.\n * @param value The new byte to replace the existing byte at the specified offset.\n * @param offset The position (0 or 1) within the `bytes2` value where the replacement should occur.\n * @return result The modified `bytes2` value after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset using `extract_2_1`.\n * 2. Use inline assembly to:\n *    - Mask the new byte to ensure it is a single byte.\n *    - Calculate the new `bytes2` value by XORing the original value with the old byte and the new byte at the correct position.\n * 3. Return the modified `bytes2` value.\n */"
        },
        {
            "identifier": "extract_4_1",
            "parameters": "bytes4 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_4_1(bytes4 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 3) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "502",
            "end": "507",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_4_1bytes4 self, uint8 offset",
            "full_signature": "function extract_4_1(bytes4 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_4_1bytes4 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a 4-byte (bytes4) value at a specified offset.\n *\n * @param self The 4-byte value from which to extract the byte.\n * @param offset The position (0-3) of the byte to extract. Must be within the range [0, 3].\n * @return result The extracted byte (bytes1) at the specified offset.\n *\n * Steps:\n * 1. Check if the offset is greater than 3. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 4-byte value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the byte by applying a bitwise AND with `0xFF` (shl(248, not(0))).\n * 3. Return the extracted byte.\n */"
        },
        {
            "identifier": "replace_4_1",
            "parameters": "bytes4 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function replace_4_1(bytes4 self, bytes1 value, uint8 offset) internal pure returns (bytes4 result) {\n        bytes1 oldValue = extract_4_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "509",
            "end": "515",
            "class": "Packing",
            "signature": "returns (bytes4 result) replace_4_1bytes4 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_4_1(bytes4 self, bytes1 value, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.replace_4_1bytes4 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte within a 4-byte sequence (bytes4) with a new value.\n *\n * @param self The original 4-byte sequence (bytes4) to modify.\n * @param value The new byte value to replace the existing byte.\n * @param offset The position (0-3) within the 4-byte sequence where the replacement should occur.\n * @return result The modified 4-byte sequence after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset from the original 4-byte sequence.\n * 2. Use assembly to perform the replacement:\n *    - Ensure the new value is properly masked to fit within a single byte.\n *    - Calculate the new 4-byte sequence by XORing the original sequence with the old byte and XORing it again with the new byte at the correct position.\n * 3. Return the modified 4-byte sequence.\n */"
        },
        {
            "identifier": "extract_4_2",
            "parameters": "bytes4 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_4_2(bytes4 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "517",
            "end": "522",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_4_2bytes4 self, uint8 offset",
            "full_signature": "function extract_4_2(bytes4 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_4_2bytes4 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 4-byte input starting at a specified offset.\n *\n * @param self The 4-byte input from which to extract the 2-byte segment.\n * @param offset The starting position (0-2) within the 4-byte input to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-2). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired 2-byte segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_4_2",
            "parameters": "bytes4 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function replace_4_2(bytes4 self, bytes2 value, uint8 offset) internal pure returns (bytes4 result) {\n        bytes2 oldValue = extract_4_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "524",
            "end": "530",
            "class": "Packing",
            "signature": "returns (bytes4 result) replace_4_2bytes4 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_4_2(bytes4 self, bytes2 value, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.replace_4_2bytes4 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 4-byte value at a specified offset.\n *\n * @param self The original 4-byte value.\n * @param value The new 2-byte value to replace the segment.\n * @param offset The position (0 or 1) within the 4-byte value where the replacement should occur.\n * @return result The modified 4-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_4_2`.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 2-byte value to ensure it is properly aligned.\n *    - Calculate the result by XORing the original value with the old and new 2-byte segments.\n * 3. Return the modified 4-byte value.\n */"
        },
        {
            "identifier": "extract_6_1",
            "parameters": "bytes6 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_6_1(bytes6 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 5) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "532",
            "end": "537",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_6_1bytes6 self, uint8 offset",
            "full_signature": "function extract_6_1(bytes6 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_6_1bytes6 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes6` value at a specified offset.\n *\n * @param self The `bytes6` value from which to extract the byte.\n * @param offset The position (0-5) of the byte to extract within the `bytes6` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-5). If not, revert with an `OutOfRangeAccess` error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes6` value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the first byte using `and` with `shl(248, not(0))`.\n * 3. Return the extracted byte.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_6_1",
            "parameters": "bytes6 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function replace_6_1(bytes6 self, bytes1 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes1 oldValue = extract_6_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "539",
            "end": "545",
            "class": "Packing",
            "signature": "returns (bytes6 result) replace_6_1bytes6 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_6_1(bytes6 self, bytes1 value, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.replace_6_1bytes6 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte within a `bytes6` value at a given offset with a new byte.\n *\n * @param self The original `bytes6` value.\n * @param value The new byte to replace the existing byte at the specified offset.\n * @param offset The position (0-5) within the `bytes6` value where the byte should be replaced.\n * @return result The modified `bytes6` value after replacing the byte.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset using `extract_6_1`.\n * 2. Use inline assembly to:\n *    a. Ensure the new byte is properly masked to 8 bits.\n *    b. Calculate the new `bytes6` value by XORing the original value with the old byte and the new byte at the correct offset.\n * 3. Return the modified `bytes6` value.\n *\n * Note: This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_6_2",
            "parameters": "bytes6 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_6_2(bytes6 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "547",
            "end": "552",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_6_2bytes6 self, uint8 offset",
            "full_signature": "function extract_6_2(bytes6 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_6_2bytes6 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 6-byte input starting at a specified offset.\n *\n * @param self The 6-byte input from which to extract the segment.\n * @param offset The starting position (0-4) within the 6-byte input to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 4. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 6-byte input left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_6_2",
            "parameters": "bytes6 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function replace_6_2(bytes6 self, bytes2 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes2 oldValue = extract_6_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "554",
            "end": "560",
            "class": "Packing",
            "signature": "returns (bytes6 result) replace_6_2bytes6 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_6_2(bytes6 self, bytes2 value, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.replace_6_2bytes6 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 6-byte value at a specified offset.\n *\n * @param self The original 6-byte value.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 6-byte value where the replacement should occur.\n * @return result The modified 6-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_6_2`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new value to ensure it is only 2 bytes.\n *    - Calculate the result by XORing the original value with the old value and then XORing with the new value, shifted to the correct position.\n */"
        },
        {
            "identifier": "extract_6_4",
            "parameters": "bytes6 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_6_4(bytes6 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "562",
            "end": "567",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_6_4bytes6 self, uint8 offset",
            "full_signature": "function extract_6_4(bytes6 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_6_4bytes6 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 6-byte input starting at a specified offset.\n *\n * @param self The 6-byte input from which to extract the segment.\n * @param offset The starting position (0-2) within the 6-byte input to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 2. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 6-byte input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Return the extracted 4-byte segment.\n *\n * Note: This function is marked as `internal` and `pure`, meaning it does not modify state and can only be called internal */"
        },
        {
            "identifier": "replace_6_4",
            "parameters": "bytes6 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function replace_6_4(bytes6 self, bytes4 value, uint8 offset) internal pure returns (bytes6 result) {\n        bytes4 oldValue = extract_6_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "569",
            "end": "575",
            "class": "Packing",
            "signature": "returns (bytes6 result) replace_6_4bytes6 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_6_4(bytes6 self, bytes4 value, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.replace_6_4bytes6 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 6-byte array at a specified offset.\n *\n * @param self The original 6-byte array.\n * @param value The new 4-byte value to insert.\n * @param offset The position (in bytes) within the 6-byte array where the replacement should occur.\n * @return result The modified 6-byte array after replacement.\n *\n * Steps:\n * 1. Extract the existing 4-byte value from the 6-byte array at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new value to ensure it is 4 bytes.\n *    b. Calculate the result by XORing the original array with the old value and then XORing with the new value, shifted to the correct position.\n * 3. Return the modified 6-byte array.\n */"
        },
        {
            "identifier": "extract_8_1",
            "parameters": "bytes8 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_8_1(bytes8 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 7) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "577",
            "end": "582",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_8_1bytes8 self, uint8 offset",
            "full_signature": "function extract_8_1(bytes8 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_8_1bytes8 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes8` value at a specified offset.\n *\n * @param self The `bytes8` value from which to extract the byte.\n * @param offset The position (0-7) of the byte to extract within the `bytes8` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-7). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes8` value left by `8 * offset` to align the desired byte.\n *    - Mask the result to isolate the byte at the specified position.\n *    - Return the extracted byte.\n */"
        },
        {
            "identifier": "replace_8_1",
            "parameters": "bytes8 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function replace_8_1(bytes8 self, bytes1 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes1 oldValue = extract_8_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "584",
            "end": "590",
            "class": "Packing",
            "signature": "returns (bytes8 result) replace_8_1bytes8 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_8_1(bytes8 self, bytes1 value, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.replace_8_1bytes8 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte within a `bytes8` value at a given offset.\n *\n * @param self The original `bytes8` value.\n * @param value The new `bytes1` value to replace the existing byte.\n * @param offset The position (0-7) within the `bytes8` value where the replacement should occur.\n * @return result The modified `bytes8` value after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset from the `bytes8` value.\n * 2. Use inline assembly to:\n *    a. Ensure the `value` is properly masked to 1 byte.\n *    b. Calculate the new `bytes8` value by XORing the original value with the old byte and the new byte at the correct offset.\n * 3. Return the resulting `bytes8` value.\n */"
        },
        {
            "identifier": "extract_8_2",
            "parameters": "bytes8 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_8_2(bytes8 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "592",
            "end": "597",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_8_2bytes8 self, uint8 offset",
            "full_signature": "function extract_8_2(bytes8 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_8_2bytes8 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from an 8-byte value starting at a specified offset.\n *\n * @param self The 8-byte value from which to extract the segment.\n * @param offset The starting position (0-6) within the 8-byte value to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 6. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the 8-byte value left by `8 * offset` to align the desired segment.\n *    b. Mask the result to ensure only the first 2 bytes are retained.\n *    c. Return the extracted 2-byte segment.\n *\n * Note: The function is marked as `pure` and uses memory-safe assembly to ensure no state changes.\n */"
        },
        {
            "identifier": "replace_8_2",
            "parameters": "bytes8 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function replace_8_2(bytes8 self, bytes2 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes2 oldValue = extract_8_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "599",
            "end": "605",
            "class": "Packing",
            "signature": "returns (bytes8 result) replace_8_2bytes8 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_8_2(bytes8 self, bytes2 value, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.replace_8_2bytes8 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within an 8-byte value at a specified offset.\n *\n * @param self The original 8-byte value.\n * @param value The new 2-byte value to replace the segment.\n * @param offset The position (in bytes) within the 8-byte value where the replacement should occur.\n * @return result The modified 8-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_8_2`.\n * 2. Use inline assembly to:\n *    a. Mask the new 2-byte value to ensure it is properly aligned.\n *    b. Calculate the result by XORing the original value with the old and new 2-byte values, shifted to the correct position.\n * 3. Return the modified 8-byte value.\n */"
        },
        {
            "identifier": "extract_8_4",
            "parameters": "bytes8 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_8_4(bytes8 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "607",
            "end": "612",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_8_4bytes8 self, uint8 offset",
            "full_signature": "function extract_8_4(bytes8 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_8_4bytes8 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from an 8-byte input starting at a specified offset.\n *\n * @param self The 8-byte input from which to extract the segment.\n * @param offset The starting position (0-4) within the 8-byte input to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 4. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_8_4",
            "parameters": "bytes8 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function replace_8_4(bytes8 self, bytes4 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes4 oldValue = extract_8_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "614",
            "end": "620",
            "class": "Packing",
            "signature": "returns (bytes8 result) replace_8_4bytes8 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_8_4(bytes8 self, bytes4 value, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.replace_8_4bytes8 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within an 8-byte value at a specified offset.\n *\n * @param self The original 8-byte value.\n * @param value The new 4-byte value to replace the segment with.\n * @param offset The position (0-4) within the 8-byte value where the replacement should occur.\n * @return result The modified 8-byte value after replacement.\n *\n * Steps:\n * 1. Extract the old 4-byte value from the specified offset in the 8-byte value.\n * 2. Use assembly to:\n *    a. Mask the new 4-byte value to ensure it is properly aligned.\n *    b. Calculate the result by XORing the original 8-byte value with the old 4-byte value and then XORing it with the new 4-byte value, shifted to the correct position.\n */"
        },
        {
            "identifier": "extract_8_6",
            "parameters": "bytes8 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_8_6(bytes8 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "622",
            "end": "627",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_8_6bytes8 self, uint8 offset",
            "full_signature": "function extract_8_6(bytes8 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_8_6bytes8 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from an 8-byte input starting at a specified offset.\n *\n * @param self The 8-byte input from which to extract the segment.\n * @param offset The starting position (0-2) within the 8-byte input to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 2. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the shifted value with `shl(208, not(0))` to isolate the first 6 bytes.\n *    - Store the result in `result`.\n */"
        },
        {
            "identifier": "replace_8_6",
            "parameters": "bytes8 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function replace_8_6(bytes8 self, bytes6 value, uint8 offset) internal pure returns (bytes8 result) {\n        bytes6 oldValue = extract_8_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "629",
            "end": "635",
            "class": "Packing",
            "signature": "returns (bytes8 result) replace_8_6bytes8 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_8_6(bytes8 self, bytes6 value, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.replace_8_6bytes8 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within an 8-byte value at a specified offset.\n *\n * @param self The original 8-byte value.\n * @param value The new 6-byte value to replace the segment.\n * @param offset The position (in bytes) within the 8-byte value where the replacement should occur.\n * @return result The modified 8-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 6-byte segment from the original 8-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 6-byte value to ensure it fits within the 6-byte segment.\n *    - Calculate the modified 8-byte value by XORing the original value with the old and new segments.\n * 3. Return the resulting 8-byte value.\n */"
        },
        {
            "identifier": "extract_10_1",
            "parameters": "bytes10 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_10_1(bytes10 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 9) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "637",
            "end": "642",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_10_1bytes10 self, uint8 offset",
            "full_signature": "function extract_10_1(bytes10 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_10_1bytes10 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes10` value at a specified offset.\n *\n * @param self The `bytes10` value from which to extract the byte.\n * @param offset The position (0-9) of the byte to extract.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is greater than 9. If so, revert with an `OutOfRangeAccess` error.\n * 2. Use inline assembly to:\n *    a. Shift the `bytes10` value left by `8 * offset` bits to align the desired byte.\n *    b. Mask the result to isolate the first byte (using `shl(248, not(0))` to create a mask of `0xFF`).\n *    c. Return the extracted byte.\n *\n * @dev This function is marked as `internal pure` and uses `memory-safe` assembly to ensure safety.\n */"
        },
        {
            "identifier": "replace_10_1",
            "parameters": "bytes10 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function replace_10_1(bytes10 self, bytes1 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes1 oldValue = extract_10_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "644",
            "end": "650",
            "class": "Packing",
            "signature": "returns (bytes10 result) replace_10_1bytes10 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_10_1(bytes10 self, bytes1 value, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.replace_10_1bytes10 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a single byte in a `bytes10` value at a specified offset with a new byte value.\n *\n * @param self The original `bytes10` value.\n * @param value The new byte value to replace the existing byte.\n * @param offset The position (0-9) within the `bytes10` value where the replacement should occur.\n * @return result The modified `bytes10` value after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset from the `bytes10` value.\n * 2. Use inline assembly to:\n *    - Mask the new byte value to ensure it is a single byte.\n *    - Calculate the result by XORing the original value with the old byte and then XORing with the new byte at the correct offset.\n * 3. Return the modified `bytes10` value.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "extract_10_2",
            "parameters": "bytes10 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_10_2(bytes10 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "652",
            "end": "657",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_10_2bytes10 self, uint8 offset",
            "full_signature": "function extract_10_2(bytes10 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_10_2bytes10 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 10-byte input starting at a specified offset.\n *\n * @param self The 10-byte input from which the segment is to be extracted.\n * @param offset The starting position (0-8) within the 10-byte input from which to extract the 2-byte segment.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 8. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n *    - Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_10_2",
            "parameters": "bytes10 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function replace_10_2(bytes10 self, bytes2 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes2 oldValue = extract_10_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "659",
            "end": "665",
            "class": "Packing",
            "signature": "returns (bytes10 result) replace_10_2bytes10 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_10_2(bytes10 self, bytes2 value, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.replace_10_2bytes10 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 10-byte value at a specified offset.\n *\n * @param self The original 10-byte value where the replacement will occur.\n * @param value The 2-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 10-byte value where the replacement will start.\n * @return result The modified 10-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 2-byte segment from the original 10-byte value at the specified offset.\n * 2. Use inline assembly to perform the replacement:\n *    a. Mask the `value` to ensure it is only 2 bytes.\n *    b. Calculate the new 10-byte value by XORing the original value with the old segment and the new segment, shifted appropriately.\n * 3. Return the modified 10-byte value.\n */"
        },
        {
            "identifier": "extract_10_4",
            "parameters": "bytes10 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_10_4(bytes10 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "667",
            "end": "672",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_10_4bytes10 self, uint8 offset",
            "full_signature": "function extract_10_4(bytes10 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_10_4bytes10 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 10-byte array starting at a specified offset.\n *\n * @param self The 10-byte array from which to extract the segment.\n * @param offset The starting position (0-6) within the 10-byte array to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 6. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 10-byte array left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 4 bytes are returned by applying a bitwise AND with `0xFFFFFFFF`.\n *\n * Note: The function is marked as `internal pure`, meaning it can only be called internally and does not modify state.\n */"
        },
        {
            "identifier": "replace_10_4",
            "parameters": "bytes10 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function replace_10_4(bytes10 self, bytes4 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes4 oldValue = extract_10_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "674",
            "end": "680",
            "class": "Packing",
            "signature": "returns (bytes10 result) replace_10_4bytes10 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_10_4(bytes10 self, bytes4 value, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.replace_10_4bytes10 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 10-byte array at a specified offset.\n *\n * @param self The original 10-byte array.\n * @param value The new 4-byte value to be inserted.\n * @param offset The position (in bytes) within the 10-byte array where the replacement should occur.\n * @return result The modified 10-byte array after the replacement.\n *\n * Steps:\n * 1. Extract the 4-byte segment from the original 10-byte array at the specified offset.\n * 2. Use assembly to perform bitwise operations:\n *    - Mask the new value to ensure it is 4 bytes.\n *    - Replace the old 4-byte segment with the new value at the specified offset.\n * 3. Return the modified 10-byte array.\n */"
        },
        {
            "identifier": "extract_10_6",
            "parameters": "bytes10 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_10_6(bytes10 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "682",
            "end": "687",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_10_6bytes10 self, uint8 offset",
            "full_signature": "function extract_10_6(bytes10 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_10_6bytes10 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 10-byte input starting at a specified offset.\n *\n * @param self The 10-byte input from which to extract the segment.\n * @param offset The starting position (0-4) within the 10-byte input to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 4. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform bitwise operations:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 6 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_10_6",
            "parameters": "bytes10 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function replace_10_6(bytes10 self, bytes6 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes6 oldValue = extract_10_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "689",
            "end": "695",
            "class": "Packing",
            "signature": "returns (bytes10 result) replace_10_6bytes10 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_10_6(bytes10 self, bytes6 value, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.replace_10_6bytes10 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 10-byte array at a specified offset.\n *\n * @param self The original 10-byte array.\n * @param value The 6-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 10-byte array where the replacement should occur.\n * @return result The modified 10-byte array after the replacement.\n *\n * Steps:\n * 1. Extract the 6-byte segment from the original 10-byte array at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the `value` to ensure it is 6 bytes long.\n *    - Calculate the new 10-byte array by XORing the original array with the old segment and then XORing it with the new segment.\n * 3. Return the modified 10-byte array.\n */"
        },
        {
            "identifier": "extract_10_8",
            "parameters": "bytes10 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_10_8(bytes10 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "697",
            "end": "702",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_10_8bytes10 self, uint8 offset",
            "full_signature": "function extract_10_8(bytes10 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_10_8bytes10 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts an 8-byte segment from a 10-byte input starting at a specified offset.\n *\n * @param self The 10-byte input from which to extract the segment.\n * @param offset The starting position (0-2) within the 10-byte input to begin extraction.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 2. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only 8 bytes are retained by applying a bitmask (`shl(192, not(0))`).\n * 3. Return the extracted 8-byte segment.\n */"
        },
        {
            "identifier": "replace_10_8",
            "parameters": "bytes10 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function replace_10_8(bytes10 self, bytes8 value, uint8 offset) internal pure returns (bytes10 result) {\n        bytes8 oldValue = extract_10_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "704",
            "end": "710",
            "class": "Packing",
            "signature": "returns (bytes10 result) replace_10_8bytes10 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_10_8(bytes10 self, bytes8 value, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.replace_10_8bytes10 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 10-byte value at a given offset.\n *\n * @param self The original 10-byte value to modify.\n * @param value The new 8-byte value to insert.\n * @param offset The position (in bytes) within the 10-byte value where the replacement should occur.\n * @return result The modified 10-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte value at the specified offset from the 10-byte input (`self`).\n * 2. Use inline assembly to:\n *    a. Mask the new 8-byte value to ensure it fits within the 8-byte boundary.\n *    b. Calculate the modified 10-byte value by XORing the original value with the old and new 8-byte segments.\n * 3. Return the resulting 10-byte value.\n *\n * Note: This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_12_1",
            "parameters": "bytes12 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_12_1(bytes12 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 11) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "712",
            "end": "717",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_12_1bytes12 self, uint8 offset",
            "full_signature": "function extract_12_1(bytes12 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_12_1bytes12 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes12` value at a specified offset.\n *\n * @param self The `bytes12` value from which to extract the byte.\n * @param offset The position (0-11) of the byte to extract within the `bytes12` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is greater than 11. If so, revert with an `OutOfRangeAccess` error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes12` value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the first byte using `shl(248, not(0))`.\n *    - Return the extracted byte.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_12_1",
            "parameters": "bytes12 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function replace_12_1(bytes12 self, bytes1 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes1 oldValue = extract_12_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "719",
            "end": "725",
            "class": "Packing",
            "signature": "returns (bytes12 result) replace_12_1bytes12 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_12_1(bytes12 self, bytes1 value, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.replace_12_1bytes12 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a single byte within a 12-byte sequence at a specified offset.\n *\n * @param self The original 12-byte sequence.\n * @param value The new byte value to replace the existing byte.\n * @param offset The position (0-11) within the 12-byte sequence where the replacement should occur.\n * @return result The modified 12-byte sequence with the byte replaced at the specified offset.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset from the 12-byte sequence.\n * 2. Use assembly to:\n *    - Ensure the new byte value is properly masked to 8 bits.\n *    - Calculate the result by XORing the original sequence with the old byte and then XORing with the new byte at the correct position.\n */"
        },
        {
            "identifier": "extract_12_2",
            "parameters": "bytes12 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_12_2(bytes12 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "727",
            "end": "732",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_12_2bytes12 self, uint8 offset",
            "full_signature": "function extract_12_2(bytes12 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_12_2bytes12 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 12-byte value starting at a specified offset.\n *\n * @param self The 12-byte value from which to extract the segment.\n * @param offset The starting position (0-based index) within the 12-byte value to begin extraction.\n *              Must be less than or equal to 10 to avoid out-of-range access.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 10. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform bitwise operations:\n *    - Shift the 12-byte value left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n * 3. Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_12_2",
            "parameters": "bytes12 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function replace_12_2(bytes12 self, bytes2 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes2 oldValue = extract_12_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "734",
            "end": "740",
            "class": "Packing",
            "signature": "returns (bytes12 result) replace_12_2bytes12 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_12_2(bytes12 self, bytes2 value, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.replace_12_2bytes12 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 12-byte value at a specified offset.\n *\n * @param self The original 12-byte value.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 12-byte value where the replacement should occur.\n * @return result The modified 12-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_12_2`.\n * 2. Use assembly to:\n *    - Mask the new value to ensure it is 2 bytes.\n *    - Calculate the result by XORing the original value with the old value and then XORing with the new value, shifted to the correct position.\n * 3. Return the modified 12-byte value.\n */"
        },
        {
            "identifier": "extract_12_4",
            "parameters": "bytes12 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_12_4(bytes12 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "742",
            "end": "747",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_12_4bytes12 self, uint8 offset",
            "full_signature": "function extract_12_4(bytes12 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_12_4bytes12 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 12-byte input starting at a specified offset.\n *\n * @param self The 12-byte input from which to extract the segment.\n * @param offset The starting position (0-8) within the 12-byte input to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 8. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the input left by `offset * 8` bits to align the desired segment.\n *    b. Mask the result to ensure only 4 bytes are returned.\n *    c. Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_12_4",
            "parameters": "bytes12 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function replace_12_4(bytes12 self, bytes4 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes4 oldValue = extract_12_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "749",
            "end": "755",
            "class": "Packing",
            "signature": "returns (bytes12 result) replace_12_4bytes12 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_12_4(bytes12 self, bytes4 value, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.replace_12_4bytes12 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 12-byte value at a specified offset.\n *\n * @param self The original 12-byte value.\n * @param value The new 4-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 12-byte value where the replacement should occur.\n * @return result The modified 12-byte value after replacement.\n *\n * Steps:\n * 1. Extract the current 4-byte value at the specified offset from the 12-byte value.\n * 2. Use assembly to:\n *    a. Mask the new 4-byte value to ensure it is properly aligned.\n *    b. Calculate the modified 12-byte value by XORing the original value with the old and new 4-byte segments.\n * 3. Return the resulting 12-byte value.\n */"
        },
        {
            "identifier": "extract_12_6",
            "parameters": "bytes12 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_12_6(bytes12 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "757",
            "end": "762",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_12_6bytes12 self, uint8 offset",
            "full_signature": "function extract_12_6(bytes12 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_12_6bytes12 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 12-byte input starting at a specified offset.\n *\n * @param self The 12-byte input from which to extract the segment.\n * @param offset The starting position (0-6) within the 12-byte input to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-6). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 6 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_12_6",
            "parameters": "bytes12 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function replace_12_6(bytes12 self, bytes6 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes6 oldValue = extract_12_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "764",
            "end": "770",
            "class": "Packing",
            "signature": "returns (bytes12 result) replace_12_6bytes12 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_12_6(bytes12 self, bytes6 value, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.replace_12_6bytes12 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 12-byte value at a specified offset.\n *\n * @param self The original 12-byte value.\n * @param value The new 6-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 12-byte value where the replacement should occur.\n * @return result The modified 12-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 6-byte segment from the 12-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the new 6-byte value to ensure it fits within the 6-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 12-byte value.\n */"
        },
        {
            "identifier": "extract_12_8",
            "parameters": "bytes12 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_12_8(bytes12 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "772",
            "end": "777",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_12_8bytes12 self, uint8 offset",
            "full_signature": "function extract_12_8(bytes12 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_12_8bytes12 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts an 8-byte segment from a 12-byte input starting at a specified offset.\n *\n * @param self The 12-byte input from which to extract the segment.\n * @param offset The starting position (0-4) within the 12-byte input to begin extraction.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 4. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 8 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * Note: The function is marked as `pure` and uses `memory-safe` assembly to ensure no state changes occur.\n */"
        },
        {
            "identifier": "replace_12_8",
            "parameters": "bytes12 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function replace_12_8(bytes12 self, bytes8 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes8 oldValue = extract_12_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "779",
            "end": "785",
            "class": "Packing",
            "signature": "returns (bytes12 result) replace_12_8bytes12 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_12_8(bytes12 self, bytes8 value, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.replace_12_8bytes12 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 12-byte value at a given offset.\n *\n * @param self The original 12-byte value.\n * @param value The new 8-byte value to be inserted.\n * @param offset The position (in bytes) within the 12-byte value where the replacement should occur.\n * @return result The modified 12-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte value at the specified offset from the 12-byte input (`self`).\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new 8-byte value to ensure it fits within the 8-byte boundary.\n *    - Calculate the result by XORing the original 12-byte value with the shifted and masked new value.\n * 3. Return the modified 12-byte value.\n */"
        },
        {
            "identifier": "extract_12_10",
            "parameters": "bytes12 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_12_10(bytes12 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "787",
            "end": "792",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_12_10bytes12 self, uint8 offset",
            "full_signature": "function extract_12_10(bytes12 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_12_10bytes12 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 12-byte input starting at a specified offset.\n *\n * @param self The 12-byte input from which to extract the segment.\n * @param offset The starting position (0-2) within the 12-byte input to begin extraction.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 2. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bytes to align the desired segment.\n *    - Mask the result to ensure only 10 bytes are retained by applying a bitmask.\n *    - Return the extracted 10-byte segment.\n */"
        },
        {
            "identifier": "replace_12_10",
            "parameters": "bytes12 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function replace_12_10(bytes12 self, bytes10 value, uint8 offset) internal pure returns (bytes12 result) {\n        bytes10 oldValue = extract_12_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "794",
            "end": "800",
            "class": "Packing",
            "signature": "returns (bytes12 result) replace_12_10bytes12 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_12_10(bytes12 self, bytes10 value, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.replace_12_10bytes12 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 12-byte value at a specified offset.\n *\n * @param self The original 12-byte value.\n * @param value The new 10-byte value to replace the existing segment.\n * @param offset The byte offset (0-2) where the replacement should occur.\n * @return result The modified 12-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the original 12-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    b. Calculate the modified 12-byte value by XORing the original value with the old segment and the new segment.\n * 3. Return the modified 12-byte value.\n */"
        },
        {
            "identifier": "extract_16_1",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_16_1(bytes16 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 15) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "802",
            "end": "807",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_16_1bytes16 self, uint8 offset",
            "full_signature": "function extract_16_1(bytes16 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_16_1bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes16` value at a specified offset.\n *\n * @param self The `bytes16` value from which to extract the byte.\n * @param offset The position (0-15) of the byte to extract within the `bytes16` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-15). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes16` value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the desired byte using `and` with `shl(248, not(0))`.\n * 3. Return the extracted byte.\n */"
        },
        {
            "identifier": "replace_16_1",
            "parameters": "bytes16 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_1(bytes16 self, bytes1 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes1 oldValue = extract_16_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "809",
            "end": "815",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_1bytes16 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_16_1(bytes16 self, bytes1 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_1bytes16 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a single byte (bytes1) within a bytes16 value at a specified offset.\n *\n * @param self The original bytes16 value.\n * @param value The new bytes1 value to replace the existing byte.\n * @param offset The position (0-15) within the bytes16 where the replacement should occur.\n * @return result The modified bytes16 value after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset from the bytes16 value.\n * 2. Use inline assembly to:\n *    - Mask the new value to ensure it is a single byte.\n *    - Calculate the result by XORing the original bytes16 value with the old byte and the new byte at the correct offset.\n * 3. Return the modified bytes16 value.\n */"
        },
        {
            "identifier": "extract_16_2",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_16_2(bytes16 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "817",
            "end": "822",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_16_2bytes16 self, uint8 offset",
            "full_signature": "function extract_16_2(bytes16 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_16_2bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 16-byte array starting at a specified offset.\n *\n * @param self The 16-byte array from which to extract the segment.\n * @param offset The starting position (0-14) within the 16-byte array to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-14). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 16-byte array left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n *    - Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_16_2",
            "parameters": "bytes16 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_2(bytes16 self, bytes2 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes2 oldValue = extract_16_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "824",
            "end": "830",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_2bytes16 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_16_2(bytes16 self, bytes2 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_2bytes16 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 16-byte array at a specified offset.\n *\n * @param self The original 16-byte array.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 16-byte array where the replacement should occur.\n * @return result The modified 16-byte array after the replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_16_2`.\n * 2. Use assembly to perform the replacement:\n *    - Mask the `value` to ensure it is only 2 bytes.\n *    - Calculate the new 16-byte array by XORing the original array with the old value and the new value, shifted appropriately.\n * 3. Return the modified 16-byte array.\n */"
        },
        {
            "identifier": "extract_16_4",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_16_4(bytes16 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "832",
            "end": "837",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_16_4bytes16 self, uint8 offset",
            "full_signature": "function extract_16_4(bytes16 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_16_4bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 16-byte value starting at a specified offset.\n *\n * @param self The 16-byte value from which to extract the segment.\n * @param offset The starting position (0-12) within the 16-byte value to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 12. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 16-byte value left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Return the extracted 4-byte segment.\n *\n * @dev This function is memory-safe and uses inline assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_16_4",
            "parameters": "bytes16 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_4(bytes16 self, bytes4 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes4 oldValue = extract_16_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "839",
            "end": "845",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_4bytes16 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_16_4(bytes16 self, bytes4 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_4bytes16 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 16-byte array at a specified offset.\n *\n * @param self The original 16-byte array.\n * @param value The new 4-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 16-byte array where the replacement should occur.\n * @return result The modified 16-byte array after the replacement.\n *\n * Steps:\n * 1. Extract the existing 4-byte value at the specified offset from the 16-byte array.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new value to ensure it is 4 bytes long.\n *    - Calculate the result by XORing the original array with the old value and then XORing with the new value, shifted to the correct position.\n * 3. Return the modified 16-byte array.\n */"
        },
        {
            "identifier": "extract_16_6",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_16_6(bytes16 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "847",
            "end": "852",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_16_6bytes16 self, uint8 offset",
            "full_signature": "function extract_16_6(bytes16 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_16_6bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 16-byte value starting at a specified offset.\n *\n * @param self The 16-byte value from which to extract the segment.\n * @param offset The starting position (0-10) within the 16-byte value to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-10). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 16-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 6 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_16_6",
            "parameters": "bytes16 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_6(bytes16 self, bytes6 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes6 oldValue = extract_16_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "854",
            "end": "860",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_6bytes16 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_16_6(bytes16 self, bytes6 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_6bytes16 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 16-byte array at a specified offset.\n *\n * @param self The original 16-byte array.\n * @param value The 6-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 16-byte array where the replacement should occur.\n * @return result The modified 16-byte array after the replacement.\n *\n * Steps:\n * 1. Extract the 6-byte segment from the original 16-byte array at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the `value` to ensure it is 6 bytes long.\n *    - Calculate the new 16-byte array by XORing the original array with the old segment and the new value.\n * 3. Return the modified 16-byte array.\n */"
        },
        {
            "identifier": "extract_16_8",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_16_8(bytes16 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "862",
            "end": "867",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_16_8bytes16 self, uint8 offset",
            "full_signature": "function extract_16_8(bytes16 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_16_8bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a `bytes8` value from a `bytes16` value starting at a specified offset.\n * \n * @param self The `bytes16` value from which to extract the `bytes8` value.\n * @param offset The starting position (in bytes) within the `bytes16` value to begin extraction.\n *              Must be less than or equal to 8, otherwise the function will revert.\n * @return result The extracted `bytes8` value.\n * \n * Steps:\n * 1. Check if the offset is greater than 8. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the `bytes16` value left by `8 * offset` bits.\n *    b. Apply a mask to isolate the first 8 bytes (64 bits) of the shifted value.\n *    c. Return the extracted `bytes8` value.\n */"
        },
        {
            "identifier": "replace_16_8",
            "parameters": "bytes16 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_8(bytes16 self, bytes8 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes8 oldValue = extract_16_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "869",
            "end": "875",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_8bytes16 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_16_8(bytes16 self, bytes8 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_8bytes16 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 16-byte value at a given offset.\n *\n * @param self The original 16-byte value.\n * @param value The new 8-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 16-byte value where the replacement should occur.\n * @return result The modified 16-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte value at the specified offset from the original 16-byte value.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new value to ensure it is 8 bytes.\n *    - Calculate the modified 16-byte value by XORing the original value with the old and new values, shifted appropriately.\n * 3. Return the resulting 16-byte value.\n */"
        },
        {
            "identifier": "extract_16_10",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_16_10(bytes16 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "877",
            "end": "882",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_16_10bytes16 self, uint8 offset",
            "full_signature": "function extract_16_10(bytes16 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_16_10bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 16-byte value starting at a specified offset.\n *\n * @param self The 16-byte value from which to extract the segment.\n * @param offset The starting position (0-6) within the 16-byte value to begin extraction.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 6. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 16-byte value left by `8 * offset` to align the desired segment.\n *    - Apply a mask to isolate the first 10 bytes (176 bits) of the shifted value.\n *    - Return the extracted 10-byte segment.\n */"
        },
        {
            "identifier": "replace_16_10",
            "parameters": "bytes16 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_10(bytes16 self, bytes10 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes10 oldValue = extract_16_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "884",
            "end": "890",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_10bytes16 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_16_10(bytes16 self, bytes10 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_10bytes16 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 16-byte value at a specified offset.\n *\n * @param self The original 16-byte value.\n * @param value The new 10-byte value to replace the segment with.\n * @param offset The byte offset within the 16-byte value where the replacement should occur.\n * @return result The modified 16-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the 16-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    b. Perform bitwise operations to replace the old 10-byte segment with the new value.\n * 3. Return the modified 16-byte value.\n */"
        },
        {
            "identifier": "extract_16_12",
            "parameters": "bytes16 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function extract_16_12(bytes16 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }",
            "start": "892",
            "end": "897",
            "class": "Packing",
            "signature": "returns (bytes12 result) extract_16_12bytes16 self, uint8 offset",
            "full_signature": "function extract_16_12(bytes16 self, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.extract_16_12bytes16 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 12-byte segment from a 16-byte value starting at a specified offset.\n *\n * @param self The 16-byte value from which to extract the segment.\n * @param offset The starting position (0-4) within the 16-byte value to begin extraction.\n * @return result The extracted 12-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-4). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 16-byte value left by `8 * offset` to align the desired segment.\n *    - Apply a mask to isolate the 12-byte segment by shifting `0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF` left by 160 bits and performing a bitwise AND operation.\n * 3. Return the extracted 12-byte segment.\n */"
        },
        {
            "identifier": "replace_16_12",
            "parameters": "bytes16 self, bytes12 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function replace_16_12(bytes16 self, bytes12 value, uint8 offset) internal pure returns (bytes16 result) {\n        bytes12 oldValue = extract_16_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "899",
            "end": "905",
            "class": "Packing",
            "signature": "returns (bytes16 result) replace_16_12bytes16 self, bytes12 value, uint8 offset",
            "full_signature": "function replace_16_12(bytes16 self, bytes12 value, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.replace_16_12bytes16 self, bytes12 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 12-byte segment within a 16-byte value at a specified offset.\n *\n * @param self The original 16-byte value.\n * @param value The new 12-byte value to replace the segment with.\n * @param offset The byte offset within the 16-byte value where the replacement should occur.\n * @return result The resulting 16-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 12-byte segment from the original 16-byte value at the specified offset.\n * 2. Use inline assembly to perform the replacement:\n *    a. Mask the new 12-byte value to ensure it is properly aligned.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 16-byte value.\n */"
        },
        {
            "identifier": "extract_20_1",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_20_1(bytes20 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 19) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "907",
            "end": "912",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_20_1bytes20 self, uint8 offset",
            "full_signature": "function extract_20_1(bytes20 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_20_1bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes20` value at a specified offset.\n *\n * @param self The `bytes20` value from which to extract the byte.\n * @param offset The position (0-19) of the byte to extract within the `bytes20` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-19). If not, revert with `OutOfRangeAccess`.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes20` value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the byte by performing a bitwise AND with `0xFF` (represented as `shl(248, not(0))`).\n * 3. Return the extracted byte.\n */"
        },
        {
            "identifier": "replace_20_1",
            "parameters": "bytes20 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_1(bytes20 self, bytes1 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes1 oldValue = extract_20_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "914",
            "end": "920",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_1bytes20 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_20_1(bytes20 self, bytes1 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_1bytes20 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte in a `bytes20` value with a new byte at a given offset.\n *\n * @param self The original `bytes20` value.\n * @param value The new byte to replace the existing byte.\n * @param offset The position (0-19) in the `bytes20` value where the replacement should occur.\n * @return result The modified `bytes20` value after the byte replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset using `extract_20_1`.\n * 2. Use inline assembly to:\n *    a. Mask the new byte to ensure it is a single byte.\n *    b. Calculate the new `bytes20` value by XORing the original value with the old byte and the new byte at the correct offset.\n * 3. Return the modified `bytes20` value.\n */"
        },
        {
            "identifier": "extract_20_2",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_20_2(bytes20 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "922",
            "end": "927",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_20_2bytes20 self, uint8 offset",
            "full_signature": "function extract_20_2(bytes20 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_20_2bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 20-byte value starting at a specified offset.\n *\n * @param self The 20-byte value from which to extract the segment.\n * @param offset The starting position (0-18) within the 20-byte value to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-18). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 20-byte value left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n * 3. Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_20_2",
            "parameters": "bytes20 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_2(bytes20 self, bytes2 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes2 oldValue = extract_20_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "929",
            "end": "935",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_2bytes20 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_20_2(bytes20 self, bytes2 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_2bytes20 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 20-byte value at a specified offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_20_2`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new value to ensure it is only 2 bytes.\n *    - Calculate the result by XORing the original value with the old and new values, shifted appropriately.\n */"
        },
        {
            "identifier": "extract_20_4",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_20_4(bytes20 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "937",
            "end": "942",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_20_4bytes20 self, uint8 offset",
            "full_signature": "function extract_20_4(bytes20 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_20_4bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 20-byte input starting at a specified offset.\n *\n * @param self The 20-byte input from which to extract the 4-byte segment.\n * @param offset The starting position (0-16) within the 20-byte input to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-16). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired 4-byte segment.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Return the extracted 4-byte segment.\n */"
        },
        {
            "identifier": "replace_20_4",
            "parameters": "bytes20 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_4(bytes20 self, bytes4 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes4 oldValue = extract_20_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "944",
            "end": "950",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_4bytes20 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_20_4(bytes20 self, bytes4 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_4bytes20 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 20-byte value at a specified offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 4-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 4-byte segment from the original 20-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 4-byte value to ensure it is properly aligned.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 20-byte value.\n */"
        },
        {
            "identifier": "extract_20_6",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_20_6(bytes20 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "952",
            "end": "957",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_20_6bytes20 self, uint8 offset",
            "full_signature": "function extract_20_6(bytes20 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_20_6bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 20-byte value starting at a specified offset.\n *\n * @param self The 20-byte value from which to extract the segment.\n * @param offset The starting position (0-14) within the 20-byte value to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-14). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 20-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 6 bytes are retained.\n *    - Return the extracted 6-byte segment.\n *\n * Note: This function is marked as `internal pure`, meaning it can only be called internally and does not modify state.\n */"
        },
        {
            "identifier": "replace_20_6",
            "parameters": "bytes20 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_6(bytes20 self, bytes6 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes6 oldValue = extract_20_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "959",
            "end": "965",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_6bytes20 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_20_6(bytes20 self, bytes6 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_6bytes20 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 20-byte value at a specified offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 6-byte value to insert.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 6-byte segment from the 20-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 6-byte value to ensure it fits within the 6-byte segment.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 20-byte value.\n */"
        },
        {
            "identifier": "extract_20_8",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_20_8(bytes20 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "967",
            "end": "972",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_20_8bytes20 self, uint8 offset",
            "full_signature": "function extract_20_8(bytes20 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_20_8bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a specific 8-byte segment from a 20-byte input starting at a given offset.\n *\n * @param self The 20-byte input from which to extract the segment.\n * @param offset The starting position (0-12) within the 20-byte input to begin extraction.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 12. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 8 bytes are retained.\n *    - Return the extracted 8-byte segment.\n */"
        },
        {
            "identifier": "replace_20_8",
            "parameters": "bytes20 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_8(bytes20 self, bytes8 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes8 oldValue = extract_20_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "974",
            "end": "980",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_8bytes20 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_20_8(bytes20 self, bytes8 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_8bytes20 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 20-byte value at a given offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 8-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte segment from the 20-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 8-byte value to ensure it is properly aligned.\n *    - Compute the result by XORing the original value with the old segment and then XORing with the new segment.\n */"
        },
        {
            "identifier": "extract_20_10",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_20_10(bytes20 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "982",
            "end": "987",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_20_10bytes20 self, uint8 offset",
            "full_signature": "function extract_20_10(bytes20 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_20_10bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 20-byte input starting at a specified offset.\n *\n * @param self The 20-byte input from which to extract the segment.\n * @param offset The starting position (0-based index) within the 20-byte input to begin extraction.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 10. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 10 bytes are retained.\n *\n * Note: This function is marked as `internal` and `pure`, meaning it does not modify state and can only be called internally.\n */"
        },
        {
            "identifier": "replace_20_10",
            "parameters": "bytes20 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_10(bytes20 self, bytes10 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes10 oldValue = extract_20_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "989",
            "end": "995",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_10bytes20 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_20_10(bytes20 self, bytes10 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_10bytes20 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 20-byte value at a specified offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 10-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the original 20-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 20-byte value.\n */"
        },
        {
            "identifier": "extract_20_12",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function extract_20_12(bytes20 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }",
            "start": "997",
            "end": "1002",
            "class": "Packing",
            "signature": "returns (bytes12 result) extract_20_12bytes20 self, uint8 offset",
            "full_signature": "function extract_20_12(bytes20 self, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.extract_20_12bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 12-byte segment from a 20-byte input starting at a specified offset.\n *\n * @param self The 20-byte input from which to extract the segment.\n * @param offset The starting position (0-8) within the 20-byte input to begin extraction.\n * @return result The extracted 12-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-8). If not, revert with `OutOfRangeAccess`.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 12 bytes are retained.\n * 3. Return the extracted 12-byte segment.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_20_12",
            "parameters": "bytes20 self, bytes12 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_12(bytes20 self, bytes12 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes12 oldValue = extract_20_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1004",
            "end": "1010",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_12bytes20 self, bytes12 value, uint8 offset",
            "full_signature": "function replace_20_12(bytes20 self, bytes12 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_12bytes20 self, bytes12 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 12-byte segment within a 20-byte value at a specified offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 12-byte value to be inserted.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 12-byte segment from the original 20-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 12-byte value to ensure it fits within the 12-byte segment.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 20-byte value.\n */"
        },
        {
            "identifier": "extract_20_16",
            "parameters": "bytes20 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function extract_20_16(bytes20 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }",
            "start": "1012",
            "end": "1017",
            "class": "Packing",
            "signature": "returns (bytes16 result) extract_20_16bytes20 self, uint8 offset",
            "full_signature": "function extract_20_16(bytes20 self, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.extract_20_16bytes20 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 16-byte segment from a 20-byte value starting at a specified offset.\n *\n * @param self The 20-byte input value from which to extract the segment.\n * @param offset The starting position (0-4) within the 20-byte value to begin extraction.\n * @return result The extracted 16-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-4). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input value left by `8 * offset` to align the desired segment.\n *    - Mask the shifted value to retain only the first 16 bytes.\n * 3. Return the extracted 16-byte segment.\n */"
        },
        {
            "identifier": "replace_20_16",
            "parameters": "bytes20 self, bytes16 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function replace_20_16(bytes20 self, bytes16 value, uint8 offset) internal pure returns (bytes20 result) {\n        bytes16 oldValue = extract_20_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1019",
            "end": "1025",
            "class": "Packing",
            "signature": "returns (bytes20 result) replace_20_16bytes20 self, bytes16 value, uint8 offset",
            "full_signature": "function replace_20_16(bytes20 self, bytes16 value, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.replace_20_16bytes20 self, bytes16 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 16-byte segment within a 20-byte value at a specified offset.\n *\n * @param self The original 20-byte value.\n * @param value The new 16-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 20-byte value where the replacement should occur.\n * @return result The modified 20-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 16-byte segment from the original 20-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 16-byte value to ensure it fits within the 16-byte segment.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 20-byte value.\n */"
        },
        {
            "identifier": "extract_22_1",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_22_1(bytes22 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 21) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "1027",
            "end": "1032",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_22_1bytes22 self, uint8 offset",
            "full_signature": "function extract_22_1(bytes22 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_22_1bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes22` value at a specified offset.\n *\n * @param self The `bytes22` value from which to extract the byte.\n * @param offset The position (0-21) of the byte to extract within the `bytes22` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-21). If not, revert with an `OutOfRangeAccess` error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes22` value left by `8 * offset` to align the desired byte.\n *    - Mask the result to isolate the byte at the specified offset.\n *    - Return the extracted byte.\n *\n * @dev This function uses assembly for low-level byte manipulation, ensuring efficient execution.\n */"
        },
        {
            "identifier": "replace_22_1",
            "parameters": "bytes22 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_1(bytes22 self, bytes1 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes1 oldValue = extract_22_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1034",
            "end": "1040",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_1bytes22 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_22_1(bytes22 self, bytes1 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_1bytes22 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte within a `bytes22` value at a given offset.\n *\n * @param self The original `bytes22` value.\n * @param value The new byte value to replace the existing byte.\n * @param offset The position (0-21) within the `bytes22` where the replacement should occur.\n * @return result The modified `bytes22` value after the byte replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset using `extract_22_1`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new byte value to ensure it is a single byte.\n *    - Calculate the result by XORing the original value with the old byte and then XORing with the new byte.\n * 3. Return the modified `bytes22` value.\n */"
        },
        {
            "identifier": "extract_22_2",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_22_2(bytes22 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "1042",
            "end": "1047",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_22_2bytes22 self, uint8 offset",
            "full_signature": "function extract_22_2(bytes22 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_22_2bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 22-byte value starting at a specified offset.\n *\n * @param self The 22-byte value from which to extract the 2-byte segment.\n * @param offset The starting position (0-20) within the 22-byte value to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-20). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 22-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n *    - Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_22_2",
            "parameters": "bytes22 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_2(bytes22 self, bytes2 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes2 oldValue = extract_22_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1049",
            "end": "1055",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_2bytes22 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_22_2(bytes22 self, bytes2 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_2bytes22 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_22_2`.\n * 2. Use inline assembly to perform the replacement:\n *    a. Mask the new value to ensure it is 2 bytes long.\n *    b. Calculate the result by XORing the original value with the old and new values, shifted appropriately.\n * 3. Return the modified 22-byte value.\n */"
        },
        {
            "identifier": "extract_22_4",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_22_4(bytes22 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "1057",
            "end": "1062",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_22_4bytes22 self, uint8 offset",
            "full_signature": "function extract_22_4(bytes22 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_22_4bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 22-byte value starting at a specified offset.\n *\n * @param self The 22-byte value from which to extract the 4-byte segment.\n * @param offset The starting position (0-18) within the 22-byte value to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 18. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform bitwise operations:\n *    - Shift the 22-byte value left by `8 * offset` bits to align the desired 4-byte segment.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Return the extracted 4-byte segment.\n */"
        },
        {
            "identifier": "replace_22_4",
            "parameters": "bytes22 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_4(bytes22 self, bytes4 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes4 oldValue = extract_22_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1064",
            "end": "1070",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_4bytes22 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_22_4(bytes22 self, bytes4 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_4bytes22 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The new 4-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 4-byte segment from the original 22-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 4-byte value to ensure it is properly aligned.\n *    b. Calculate the modified 22-byte value by XORing the original value with the old and new segments.\n * 3. Return the resulting 22-byte value.\n *\n * @dev This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_22_6",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_22_6(bytes22 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "1072",
            "end": "1077",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_22_6bytes22 self, uint8 offset",
            "full_signature": "function extract_22_6(bytes22 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_22_6bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 22-byte input starting at a specified offset.\n *\n * @param self The 22-byte input from which the segment is to be extracted.\n * @param offset The starting position (0-16) within the 22-byte input from which to extract the 6-byte segment.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-16). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 6 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * Note: The function is marked as `internal pure`, meaning it can only be called internally and does not modify state.\n */"
        },
        {
            "identifier": "replace_22_6",
            "parameters": "bytes22 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_6(bytes22 self, bytes6 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes6 oldValue = extract_22_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1079",
            "end": "1085",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_6bytes22 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_22_6(bytes22 self, bytes6 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_6bytes22 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The 6-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the 6-byte segment from the original 22-byte value at the specified offset.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the `value` to ensure it is 6 bytes long.\n *    - Calculate the new 22-byte value by XORing the original value with the old segment and the new segment.\n * 3. Return the modified 22-byte value.\n *\n * @dev This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_22_8",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_22_8(bytes22 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "1087",
            "end": "1092",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_22_8bytes22 self, uint8 offset",
            "full_signature": "function extract_22_8(bytes22 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_22_8bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts an 8-byte segment from a 22-byte input starting at a specified offset.\n *\n * @param self The 22-byte input from which to extract the segment.\n * @param offset The starting position (0-14) within the 22-byte input to begin extraction.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-14). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 8 bytes are returned by applying a bitmask (`shl(192, not(0))`).\n * 3. Return the extracted 8-byte segment.\n *\n * @dev This function is marked as `memory-safe` and uses inline assembly for low-level byte manipulation.\n */"
        },
        {
            "identifier": "replace_22_8",
            "parameters": "bytes22 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_8(bytes22 self, bytes8 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes8 oldValue = extract_22_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1094",
            "end": "1100",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_8bytes22 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_22_8(bytes22 self, bytes8 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_8bytes22 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 22-byte value at a given offset.\n *\n * @param self The original 22-byte value.\n * @param value The new 8-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte segment from the 22-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the new 8-byte value to ensure it fits within the 8-byte boundary.\n *    b. Calculate the result by XORing the original 22-byte value with the shifted XOR of the old and new 8-byte values.\n */"
        },
        {
            "identifier": "extract_22_10",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_22_10(bytes22 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "1102",
            "end": "1107",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_22_10bytes22 self, uint8 offset",
            "full_signature": "function extract_22_10(bytes22 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_22_10bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 22-byte input starting at a specified offset.\n *\n * @param self The 22-byte input from which the segment is extracted.\n * @param offset The starting position (0-12) within the 22-byte input to begin extraction.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 12. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 10 bytes are retained.\n *    - Store the result in `result`.\n */"
        },
        {
            "identifier": "replace_22_10",
            "parameters": "bytes22 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_10(bytes22 self, bytes10 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes10 oldValue = extract_22_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1109",
            "end": "1115",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_10bytes22 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_22_10(bytes22 self, bytes10 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_10bytes22 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The new 10-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the 22-byte value at the specified offset.\n * 2. Use inline assembly to perform the replacement:\n *    a. Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    b. Calculate the modified 22-byte value by XORing the original value with the old segment and the new segment.\n * 3. Return the resulting 22-byte value.\n */"
        },
        {
            "identifier": "extract_22_12",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function extract_22_12(bytes22 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }",
            "start": "1117",
            "end": "1122",
            "class": "Packing",
            "signature": "returns (bytes12 result) extract_22_12bytes22 self, uint8 offset",
            "full_signature": "function extract_22_12(bytes22 self, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.extract_22_12bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 12-byte segment from a 22-byte input starting at a specified offset.\n *\n * @param self The 22-byte input from which the segment is extracted.\n * @param offset The starting position (0-10) within the 22-byte input to begin extraction.\n * @return result The extracted 12-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-10). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired segment.\n *    - Apply a mask to isolate the first 12 bytes (160 bits) of the shifted input.\n *    - Store the result in the `result` variable.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_22_12",
            "parameters": "bytes22 self, bytes12 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_12(bytes22 self, bytes12 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes12 oldValue = extract_22_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1124",
            "end": "1130",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_12bytes22 self, bytes12 value, uint8 offset",
            "full_signature": "function replace_22_12(bytes22 self, bytes12 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_12bytes22 self, bytes12 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 12-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The new 12-byte value to be inserted.\n * @param offset The byte offset (0-10) where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 12-byte value from the original 22-byte value at the specified offset.\n * 2. Use assembly to:\n *    - Mask the new 12-byte value to ensure it fits within the 12-byte segment.\n *    - Replace the old 12-byte segment with the new value at the specified offset.\n * 3. Return the modified 22-byte value.\n *\n * Note: This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_22_16",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function extract_22_16(bytes22 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }",
            "start": "1132",
            "end": "1137",
            "class": "Packing",
            "signature": "returns (bytes16 result) extract_22_16bytes22 self, uint8 offset",
            "full_signature": "function extract_22_16(bytes22 self, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.extract_22_16bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 16-byte segment from a 22-byte input starting at a specified offset.\n *\n * @param self The 22-byte input from which to extract the segment.\n * @param offset The starting position (0-6) within the 22-byte input to begin extraction.\n * @return result The extracted 16-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-6). If not, revert with `OutOfRangeAccess`.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 16 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_22_16",
            "parameters": "bytes22 self, bytes16 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_16(bytes22 self, bytes16 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes16 oldValue = extract_22_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1139",
            "end": "1145",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_16bytes22 self, bytes16 value, uint8 offset",
            "full_signature": "function replace_22_16(bytes22 self, bytes16 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_16bytes22 self, bytes16 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 16-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The new 16-byte value to replace the segment with.\n * @param offset The byte offset within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 16-byte segment from the 22-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Ensure the new value is properly masked to 16 bytes.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 22-byte value.\n */"
        },
        {
            "identifier": "extract_22_20",
            "parameters": "bytes22 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function extract_22_20(bytes22 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }",
            "start": "1147",
            "end": "1152",
            "class": "Packing",
            "signature": "returns (bytes20 result) extract_22_20bytes22 self, uint8 offset",
            "full_signature": "function extract_22_20(bytes22 self, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.extract_22_20bytes22 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 20-byte segment from a 22-byte input starting at a specified offset.\n *\n * @param self The 22-byte input from which to extract the segment.\n * @param offset The starting position (0-2) within the 22-byte input to begin extraction.\n * @return result The extracted 20-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 2. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the input left by `8 * offset` to align the desired segment.\n *    b. Mask the result to ensure only 20 bytes are retained.\n *    c. Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_22_20",
            "parameters": "bytes22 self, bytes20 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function replace_22_20(bytes22 self, bytes20 value, uint8 offset) internal pure returns (bytes22 result) {\n        bytes20 oldValue = extract_22_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1154",
            "end": "1160",
            "class": "Packing",
            "signature": "returns (bytes22 result) replace_22_20bytes22 self, bytes20 value, uint8 offset",
            "full_signature": "function replace_22_20(bytes22 self, bytes20 value, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.replace_22_20bytes22 self, bytes20 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 20-byte segment within a 22-byte value at a specified offset.\n *\n * @param self The original 22-byte value.\n * @param value The 20-byte value to replace the segment with.\n * @param offset The offset (in bytes) within the 22-byte value where the replacement should occur.\n * @return result The modified 22-byte value after replacement.\n *\n * Steps:\n * 1. Extract the 20-byte segment from the original 22-byte value at the specified offset.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the `value` to ensure it is 20 bytes long.\n *    - Calculate the new 22-byte value by XORing the original value with the old segment and the new segment.\n * 3. Return the modified 22-byte value.\n */"
        },
        {
            "identifier": "extract_24_1",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_24_1(bytes24 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 23) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "1162",
            "end": "1167",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_24_1bytes24 self, uint8 offset",
            "full_signature": "function extract_24_1(bytes24 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_24_1bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a 24-byte value at a specified offset.\n *\n * @param self The 24-byte value from which to extract the byte.\n * @param offset The position (0-23) of the byte to extract.\n * @return result The extracted byte.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-23). If not, revert with `OutOfRangeAccess`.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 24-byte value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the single byte.\n *    - Return the extracted byte.\n *\n * @dev This function uses assembly for low-level byte manipulation and ensures memory safe \n */"
        },
        {
            "identifier": "replace_24_1",
            "parameters": "bytes24 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_1(bytes24 self, bytes1 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes1 oldValue = extract_24_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1169",
            "end": "1175",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_1bytes24 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_24_1(bytes24 self, bytes1 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_1bytes24 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte within a 24-byte value at a given offset with a new byte value.\n *\n * @param self The original 24-byte value.\n * @param value The new byte value to replace the existing byte.\n * @param offset The position (0-23) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset using `extract_24_1`.\n * 2. Use inline assembly to perform the replacement:\n *    a. Mask the new byte value to ensure it is a single byte.\n *    b. Calculate the result by XORing the original value with the old byte and then XORing with the new byte.\n * 3. Return the modified 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_2",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_24_2(bytes24 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "1177",
            "end": "1182",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_24_2bytes24 self, uint8 offset",
            "full_signature": "function extract_24_2(bytes24 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_24_2bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 24-byte value starting at a specified offset.\n *\n * @param self The 24-byte value from which to extract the 2-byte segment.\n * @param offset The starting position (0-22) within the 24-byte value to begin extraction.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-22). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 24-byte value left by `8 * offset` to align the desired segment.\n *    - Apply a mask to isolate the first 2 bytes of the shifted value.\n *    - Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_24_2",
            "parameters": "bytes24 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_2(bytes24 self, bytes2 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes2 oldValue = extract_24_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1184",
            "end": "1190",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_2bytes24 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_24_2(bytes24 self, bytes2 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_2bytes24 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset from the original 24-byte value.\n * 2. Use assembly to perform the replacement:\n *    - Mask the new 2-byte value to ensure it is properly aligned.\n *    - Calculate the result by XORing the original value with the old and new 2-byte segments, shifted to the correct position.\n * 3. Return the modified 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_4",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_24_4(bytes24 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "1192",
            "end": "1197",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_24_4bytes24 self, uint8 offset",
            "full_signature": "function extract_24_4(bytes24 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_24_4bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 24-byte value starting at a specified offset.\n *\n * @param self The 24-byte value from which to extract the 4-byte segment.\n * @param offset The starting position (in bytes) within the 24-byte value to begin extraction.\n *               Must be less than or equal to 20 to avoid out-of-range access.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 20. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the 24-byte value left by `8 * offset` bits to align the desired segment.\n *    b. Mask the result to ensure only the first 4 bytes are retained.\n *    c. Return the extracted 4-byte segment.\n */"
        },
        {
            "identifier": "replace_24_4",
            "parameters": "bytes24 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_4(bytes24 self, bytes4 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes4 oldValue = extract_24_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1199",
            "end": "1205",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_4bytes24 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_24_4(bytes24 self, bytes4 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_4bytes24 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 4-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 4-byte segment from the original 24-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 4-byte value to ensure it is properly aligned.\n *    b. Calculate the modified 24-byte value by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the resulting 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_6",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_24_6(bytes24 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "1207",
            "end": "1212",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_24_6bytes24 self, uint8 offset",
            "full_signature": "function extract_24_6(bytes24 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_24_6bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 24-byte value starting at a specified offset.\n *\n * @param self The 24-byte input value from which the segment is extracted.\n * @param offset The starting position (in bytes) within the 24-byte value to begin extraction.\n *               Must be less than or equal to 18 to avoid out-of-range access.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 18. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input value (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the shifted value with `shl(208, not(0))` to isolate the first 6 bytes.\n *    - Store the result in `result`.\n */"
        },
        {
            "identifier": "replace_24_6",
            "parameters": "bytes24 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_6(bytes24 self, bytes6 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes6 oldValue = extract_24_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1214",
            "end": "1220",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_6bytes24 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_24_6(bytes24 self, bytes6 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_6bytes24 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 6-byte value to be inserted.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 6-byte value at the specified offset from the original 24-byte value.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new value to ensure it is 6 bytes long.\n *    - Calculate the result by XORing the original value with the old value and then XORing with the new value, shifted to the correct position.\n * 3. Return the modified 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_8",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_24_8(bytes24 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "1222",
            "end": "1227",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_24_8bytes24 self, uint8 offset",
            "full_signature": "function extract_24_8(bytes24 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_24_8bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts an 8-byte segment from a 24-byte value starting at a specified offset.\n *\n * @param self The 24-byte value from which to extract the segment.\n * @param offset The starting position (in bytes) within the 24-byte value to begin extraction.\n *               Must be less than or equal to 16, otherwise the function reverts.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 16. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 24-byte value left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 8 bytes are retained.\n */"
        },
        {
            "identifier": "replace_24_8",
            "parameters": "bytes24 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_8(bytes24 self, bytes8 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes8 oldValue = extract_24_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1229",
            "end": "1235",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_8bytes24 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_24_8(bytes24 self, bytes8 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_8bytes24 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 24-byte value at a given offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 8-byte value to be inserted.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte value at the specified offset from the 24-byte input (`self`).\n * 2. Use inline assembly to:\n *    a. Mask the new 8-byte value to ensure it fits within the 8-byte boundary.\n *    b. Calculate the result by XORing the original 24-byte value with the shifted and masked old and new values.\n * 3. Return the modified 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_10",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_24_10(bytes24 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 14) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "1237",
            "end": "1242",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_24_10bytes24 self, uint8 offset",
            "full_signature": "function extract_24_10(bytes24 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_24_10bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 24-byte input starting at a specified offset.\n *\n * @param self The 24-byte input from which to extract the segment.\n * @param offset The starting position (0-14) within the 24-byte input to begin extraction.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-14). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 10 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * Note: The function is marked as `internal pure`, meaning it can only be called internally and does not modify state.\n */"
        },
        {
            "identifier": "replace_24_10",
            "parameters": "bytes24 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_10(bytes24 self, bytes10 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes10 oldValue = extract_24_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1244",
            "end": "1250",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_10bytes24 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_24_10(bytes24 self, bytes10 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_10bytes24 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 10-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the 24-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_12",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function extract_24_12(bytes24 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }",
            "start": "1252",
            "end": "1257",
            "class": "Packing",
            "signature": "returns (bytes12 result) extract_24_12bytes24 self, uint8 offset",
            "full_signature": "function extract_24_12(bytes24 self, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.extract_24_12bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 12-byte segment from a 24-byte input starting at a specified offset.\n *\n * @param self The 24-byte input from which to extract the segment.\n * @param offset The starting position (in bytes) within the 24-byte input to begin extraction.\n *               Must be less than or equal to 12 to avoid out-of-range access.\n * @return result The extracted 12-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 12. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 12 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_24_12",
            "parameters": "bytes24 self, bytes12 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_12(bytes24 self, bytes12 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes12 oldValue = extract_24_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1259",
            "end": "1265",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_12bytes24 self, bytes12 value, uint8 offset",
            "full_signature": "function replace_24_12(bytes24 self, bytes12 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_12bytes24 self, bytes12 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 12-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 12-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 12-byte segment from the original 24-byte value at the specified offset.\n * 2. Use inline assembly to perform the replacement:\n *    a. Mask the new 12-byte value to ensure it fits within the 12-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_16",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function extract_24_16(bytes24 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }",
            "start": "1267",
            "end": "1272",
            "class": "Packing",
            "signature": "returns (bytes16 result) extract_24_16bytes24 self, uint8 offset",
            "full_signature": "function extract_24_16(bytes24 self, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.extract_24_16bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 16-byte segment from a 24-byte value starting at a specified offset.\n *\n * @param self The 24-byte value from which to extract the segment.\n * @param offset The starting position (0-8) within the 24-byte value to begin extraction.\n * @return result The extracted 16-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-8). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 24-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 16 bytes are retained.\n *    - Return the extracted 16-byte segment.\n */"
        },
        {
            "identifier": "replace_24_16",
            "parameters": "bytes24 self, bytes16 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_16(bytes24 self, bytes16 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes16 oldValue = extract_24_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1274",
            "end": "1280",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_16bytes24 self, bytes16 value, uint8 offset",
            "full_signature": "function replace_24_16(bytes24 self, bytes16 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_16bytes24 self, bytes16 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 16-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 16-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after replacement.\n *\n * Steps:\n * 1. Extract the 16-byte segment from the original 24-byte value at the specified offset.\n * 2. Use assembly to perform the replacement:\n *    - Mask the `value` to ensure it is 16 bytes long.\n *    - Calculate the new 24-byte value by XORing the original value with the old segment and the new segment.\n * 3. Return the resulting 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_20",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function extract_24_20(bytes24 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }",
            "start": "1282",
            "end": "1287",
            "class": "Packing",
            "signature": "returns (bytes20 result) extract_24_20bytes24 self, uint8 offset",
            "full_signature": "function extract_24_20(bytes24 self, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.extract_24_20bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 20-byte value from a 24-byte input starting at a specified offset.\n *\n * @param self The 24-byte input from which to extract the 20-byte value.\n * @param offset The starting position (0-4) within the 24-byte input to begin extraction.\n * @return result The extracted 20-byte value.\n *\n * Steps:\n * 1. Check if the offset is greater than 4. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bytes to align the desired 20-byte segment.\n *    - Mask the result to ensure only the first 20 bytes are retained.\n *    - Return the extracted 20-byte value.\n */"
        },
        {
            "identifier": "replace_24_20",
            "parameters": "bytes24 self, bytes20 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_20(bytes24 self, bytes20 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes20 oldValue = extract_24_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1289",
            "end": "1295",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_20bytes24 self, bytes20 value, uint8 offset",
            "full_signature": "function replace_24_20(bytes24 self, bytes20 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_20bytes24 self, bytes20 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 20-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The 20-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the 20-byte segment from the original 24-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the `value` to ensure it is 20 bytes.\n *    b. Calculate the new 24-byte value by XORing the original value with the old and new segments.\n * 3. Return the resulting 24-byte value.\n */"
        },
        {
            "identifier": "extract_24_22",
            "parameters": "bytes24 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function extract_24_22(bytes24 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 2) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }",
            "start": "1297",
            "end": "1302",
            "class": "Packing",
            "signature": "returns (bytes22 result) extract_24_22bytes24 self, uint8 offset",
            "full_signature": "function extract_24_22(bytes24 self, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.extract_24_22bytes24 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 22-byte segment from a 24-byte input starting at a specified offset.\n *\n * @param self The 24-byte input from which to extract the segment.\n * @param offset The starting position (0-2) within the 24-byte input to begin extraction.\n * @return result The extracted 22-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-2). If not, revert with `OutOfRangeAccess`.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` bytes to align the desired segment.\n *    - Mask the result to ensure only 22 bytes are retained.\n * 3. Return the extracted 22-byte segment.\n *\n * @dev This function is marked as `internal` and `pure`, meaning it does not modify state and is only callable within the contract.\n */"
        },
        {
            "identifier": "replace_24_22",
            "parameters": "bytes24 self, bytes22 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function replace_24_22(bytes24 self, bytes22 value, uint8 offset) internal pure returns (bytes24 result) {\n        bytes22 oldValue = extract_24_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1304",
            "end": "1310",
            "class": "Packing",
            "signature": "returns (bytes24 result) replace_24_22bytes24 self, bytes22 value, uint8 offset",
            "full_signature": "function replace_24_22(bytes24 self, bytes22 value, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.replace_24_22bytes24 self, bytes22 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 22-byte segment within a 24-byte value at a specified offset.\n *\n * @param self The original 24-byte value.\n * @param value The new 22-byte value to be inserted.\n * @param offset The position (in bytes) within the 24-byte value where the replacement should occur.\n * @return result The modified 24-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 22-byte segment from the original 24-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 22-byte value to ensure it fits within the 22-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 24-byte value.\n *\n * Note: This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_28_1",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_28_1(bytes28 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 27) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "1312",
            "end": "1317",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_28_1bytes28 self, uint8 offset",
            "full_signature": "function extract_28_1(bytes28 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_28_1bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte from a `bytes28` value at a specified offset.\n *\n * @param self The `bytes28` value from which to extract the byte.\n * @param offset The position (0-27) of the byte to extract within the `bytes28` value.\n * @return result The extracted byte as a `bytes1` value.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-27). If not, revert with an `OutOfRangeAccess` error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes28` value left by `8 * offset` bits to align the desired byte.\n *    - Mask the result to isolate the single byte using `and` with `shl(248, not(0))`.\n * 3. Return the extracted byte.\n */"
        },
        {
            "identifier": "replace_28_1",
            "parameters": "bytes28 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_1(bytes28 self, bytes1 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes1 oldValue = extract_28_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1319",
            "end": "1325",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_1bytes28 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_28_1(bytes28 self, bytes1 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_1bytes28 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific byte in a `bytes28` value with a new byte at a given offset.\n *\n * @param self The original `bytes28` value.\n * @param value The new byte to replace the existing byte.\n * @param offset The position (0-based index) in the `bytes28` value where the replacement should occur.\n * @return result The modified `bytes28` value after the replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset using `extract_28_1`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new byte to ensure it is a single byte.\n *    - Calculate the result by XORing the original value with the old byte and then XORing with the new byte.\n * 3. Return the modified `bytes28` value.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "extract_28_2",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_28_2(bytes28 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 26) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "1327",
            "end": "1332",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_28_2bytes28 self, uint8 offset",
            "full_signature": "function extract_28_2(bytes28 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_28_2bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which the 2-byte segment is to be extracted.\n * @param offset The starting position (0-based index) within the 28-byte input from which to extract the 2-byte segment.\n * @return result The extracted 2-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 26. If so, revert with an \"OutOfRangeAccess\" error since the maximum valid offset is 26 (to ensure a 2-byte segment can be extracted).\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired 2-byte segment to the leftmost position.\n *    - Mask the result to ensure only the first 2 bytes are retained by applying a bitwise AND with `0xFFFF` (represented as `shl(240, not(0))`).\n * 3. Return the extracted 2-byte segment.\n */"
        },
        {
            "identifier": "replace_28_2",
            "parameters": "bytes28 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_2(bytes28 self, bytes2 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes2 oldValue = extract_28_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1334",
            "end": "1340",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_2bytes28 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_28_2(bytes28 self, bytes2 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_2bytes28 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 2-byte value to replace the existing segment.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset using `extract_28_2`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new value to ensure it is only 2 bytes.\n *    - Calculate the result by XORing the original value with the old value and then XORing with the new value, shifted to the correct position.\n */"
        },
        {
            "identifier": "extract_28_4",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_28_4(bytes28 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 24) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "1342",
            "end": "1347",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_28_4bytes28 self, uint8 offset",
            "full_signature": "function extract_28_4(bytes28 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_28_4bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte segment from a 28-byte value starting at a specified offset.\n *\n * @param self The 28-byte value from which to extract the segment.\n * @param offset The starting position (0-24) within the 28-byte value to begin extraction.\n * @return result The extracted 4-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-24). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 28-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Return the extracted 4-byte segment.\n */"
        },
        {
            "identifier": "replace_28_4",
            "parameters": "bytes28 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_4(bytes28 self, bytes4 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes4 oldValue = extract_28_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1349",
            "end": "1355",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_4bytes28 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_28_4(bytes28 self, bytes4 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_4bytes28 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 4-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the 4-byte segment from the original 28-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the new value to ensure it is 4 bytes long.\n *    b. Calculate the result by XOR-ing the original value with the old segment and then XOR-ing it with the new segment.\n * 3. Return the modified 28-byte value.\n */"
        },
        {
            "identifier": "extract_28_6",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_28_6(bytes28 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "1357",
            "end": "1362",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_28_6bytes28 self, uint8 offset",
            "full_signature": "function extract_28_6(bytes28 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_28_6bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which to extract the segment.\n * @param offset The starting position (0-22) within the 28-byte input to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 22. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 6 bytes are returned by applying a bitmask.\n */"
        },
        {
            "identifier": "replace_28_6",
            "parameters": "bytes28 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_6(bytes28 self, bytes6 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes6 oldValue = extract_28_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1364",
            "end": "1370",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_6bytes28 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_28_6(bytes28 self, bytes6 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_6bytes28 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 6-byte value to be inserted.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 6-byte value at the specified offset using `extract_28_6`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the `value` to ensure it is 6 bytes long.\n *    - Calculate the new 28-byte value by XORing the original value with the old and new 6-byte segments.\n * 3. Return the resulting 28-byte value.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "extract_28_8",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_28_8(bytes28 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "1372",
            "end": "1377",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_28_8bytes28 self, uint8 offset",
            "full_signature": "function extract_28_8(bytes28 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_28_8bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts an 8-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which to extract the segment.\n * @param offset The starting position (in bytes) from which to extract the 8-byte segment.\n *              Must be less than or equal to 20 to avoid out-of-range access.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 20. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    b. Mask the result to ensure only the first 8 bytes are retained.\n *    c. Return the extracted 8-byte segment.\n */"
        },
        {
            "identifier": "replace_28_8",
            "parameters": "bytes28 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_8(bytes28 self, bytes8 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes8 oldValue = extract_28_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1379",
            "end": "1385",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_8bytes28 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_28_8(bytes28 self, bytes8 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_8bytes28 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 28-byte value at a given offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 8-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte value at the specified offset from the original 28-byte value.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new 8-byte value to ensure it fits within the 8-byte segment.\n *    - Calculate the result by XORing the original value with the old segment and then XORing it with the new segment.\n * 3. Return the modified 28-byte value.\n */"
        },
        {
            "identifier": "extract_28_10",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_28_10(bytes28 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 18) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "1387",
            "end": "1392",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_28_10bytes28 self, uint8 offset",
            "full_signature": "function extract_28_10(bytes28 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_28_10bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which the segment is extracted.\n * @param offset The starting position (in bytes) from which to extract the 10-byte segment.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 18. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 10 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * Note: The function is marked as `internal pure`, meaning it can only be called internally and does not modify state.\n */"
        },
        {
            "identifier": "replace_28_10",
            "parameters": "bytes28 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_10(bytes28 self, bytes10 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes10 oldValue = extract_28_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1394",
            "end": "1400",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_10bytes28 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_28_10(bytes28 self, bytes10 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_10bytes28 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 10-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the 28-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 28-byte value.\n *\n * @dev This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_28_12",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function extract_28_12(bytes28 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }",
            "start": "1402",
            "end": "1407",
            "class": "Packing",
            "signature": "returns (bytes12 result) extract_28_12bytes28 self, uint8 offset",
            "full_signature": "function extract_28_12(bytes28 self, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.extract_28_12bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 12-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which to extract the segment.\n * @param offset The starting position (in bytes) within the 28-byte input to begin extraction.\n *               Must be less than or equal to 16 to avoid out-of-range access.\n * @return result The extracted 12-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 16. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only 12 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_28_12",
            "parameters": "bytes28 self, bytes12 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_12(bytes28 self, bytes12 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes12 oldValue = extract_28_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1409",
            "end": "1415",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_12bytes28 self, bytes12 value, uint8 offset",
            "full_signature": "function replace_28_12(bytes28 self, bytes12 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_12bytes28 self, bytes12 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 12-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 12-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 12-byte segment from the original 28-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 12-byte value to ensure it fits within the 12-byte segment.\n *    b. Perform bitwise operations to replace the old 12-byte segment with the new value.\n * 3. Return the modified 28-byte value.\n *\n * @dev This function uses low-level assembly for precise byte manipulation.\n */"
        },
        {
            "identifier": "extract_28_16",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function extract_28_16(bytes28 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }",
            "start": "1417",
            "end": "1422",
            "class": "Packing",
            "signature": "returns (bytes16 result) extract_28_16bytes28 self, uint8 offset",
            "full_signature": "function extract_28_16(bytes28 self, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.extract_28_16bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 16-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which the segment is to be extracted.\n * @param offset The starting position (in bytes) within the 28-byte input from which to extract the 16-byte segment.\n * @return result The extracted 16-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 12. If so, revert with an \"OutOfRangeAccess\" error since the maximum valid offset for a 28-byte input is 12 (28 - 16 = 12).\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 16 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_28_16",
            "parameters": "bytes28 self, bytes16 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_16(bytes28 self, bytes16 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes16 oldValue = extract_28_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1424",
            "end": "1430",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_16bytes28 self, bytes16 value, uint8 offset",
            "full_signature": "function replace_28_16(bytes28 self, bytes16 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_16bytes28 self, bytes16 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 16-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 16-byte value to replace the segment.\n * @param offset The offset (in bytes) where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the 16-byte segment from the original 28-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new value to ensure it is 16 bytes.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 28-byte value.\n */"
        },
        {
            "identifier": "extract_28_20",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function extract_28_20(bytes28 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }",
            "start": "1432",
            "end": "1437",
            "class": "Packing",
            "signature": "returns (bytes20 result) extract_28_20bytes28 self, uint8 offset",
            "full_signature": "function extract_28_20(bytes28 self, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.extract_28_20bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 20-byte value from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which to extract the 20-byte value.\n * @param offset The starting position (in bytes) within the 28-byte input to begin extraction.\n *               Must be less than or equal to 8, otherwise the function reverts.\n * @return result The extracted 20-byte value.\n *\n * Steps:\n * 1. Check if the offset is greater than 8. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bytes to align the desired 20-byte segment.\n *    - Mask the result to ensure only the first 20 bytes are retained.\n *    - Return the extracted 20-byte value.\n */"
        },
        {
            "identifier": "replace_28_20",
            "parameters": "bytes28 self, bytes20 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_20(bytes28 self, bytes20 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes20 oldValue = extract_28_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1439",
            "end": "1445",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_20bytes28 self, bytes20 value, uint8 offset",
            "full_signature": "function replace_28_20(bytes28 self, bytes20 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_20bytes28 self, bytes20 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 20-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 20-byte value to replace the segment with.\n * @param offset The position within the 28-byte value where the replacement should occur (in bytes).\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 20-byte value from the 28-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Ensure the new value is properly aligned by masking it.\n *    b. Calculate the result by XORing the original value with the old and new values at the correct offset.\n */"
        },
        {
            "identifier": "extract_28_22",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function extract_28_22(bytes28 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 6) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }",
            "start": "1447",
            "end": "1452",
            "class": "Packing",
            "signature": "returns (bytes22 result) extract_28_22bytes28 self, uint8 offset",
            "full_signature": "function extract_28_22(bytes28 self, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.extract_28_22bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 22-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which to extract the segment.\n * @param offset The starting position (0-6) within the 28-byte input to begin extraction.\n * @return result The extracted 22-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-6). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    a. Shift the input (`self`) left by `8 * offset` bytes to align the desired segment.\n *    b. Mask the result to ensure only the first 22 bytes are retained.\n *    c. Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_28_22",
            "parameters": "bytes28 self, bytes22 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_22(bytes28 self, bytes22 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes22 oldValue = extract_28_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1454",
            "end": "1460",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_22bytes28 self, bytes22 value, uint8 offset",
            "full_signature": "function replace_28_22(bytes28 self, bytes22 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_22bytes28 self, bytes22 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 22-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 22-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 22-byte segment from the original 28-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 22-byte value to ensure it fits within the 22-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 28-byte value.\n */"
        },
        {
            "identifier": "extract_28_24",
            "parameters": "bytes28 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function extract_28_24(bytes28 self, uint8 offset) internal pure returns (bytes24 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(64, not(0)))\n        }\n    }",
            "start": "1462",
            "end": "1467",
            "class": "Packing",
            "signature": "returns (bytes24 result) extract_28_24bytes28 self, uint8 offset",
            "full_signature": "function extract_28_24(bytes28 self, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.extract_28_24bytes28 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 24-byte segment from a 28-byte input starting at a specified offset.\n *\n * @param self The 28-byte input from which to extract the segment.\n * @param offset The starting position (0-4) within the 28-byte input to begin extraction.\n * @return result The extracted 24-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-4). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 24 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_28_24",
            "parameters": "bytes28 self, bytes24 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function replace_28_24(bytes28 self, bytes24 value, uint8 offset) internal pure returns (bytes28 result) {\n        bytes24 oldValue = extract_28_24(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(64, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1469",
            "end": "1475",
            "class": "Packing",
            "signature": "returns (bytes28 result) replace_28_24bytes28 self, bytes24 value, uint8 offset",
            "full_signature": "function replace_28_24(bytes28 self, bytes24 value, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.replace_28_24bytes28 self, bytes24 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 24-byte segment within a 28-byte value at a specified offset.\n *\n * @param self The original 28-byte value.\n * @param value The new 24-byte value to replace the segment with.\n * @param offset The position (in bytes) within the 28-byte value where the replacement should occur.\n * @return result The modified 28-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 24-byte segment from the 28-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 24-byte value to ensure it fits within the 24-byte segment.\n *    b. Replace the old 24-byte segment with the new value at the specified offset.\n *    c. Return the modified 28-byte value.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "extract_32_1",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes1 result)",
            "body": "function extract_32_1(bytes32 self, uint8 offset) internal pure returns (bytes1 result) {\n        if (offset > 31) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(248, not(0)))\n        }\n    }",
            "start": "1477",
            "end": "1482",
            "class": "Packing",
            "signature": "returns (bytes1 result) extract_32_1bytes32 self, uint8 offset",
            "full_signature": "function extract_32_1(bytes32 self, uint8 offset) internal  pure returns (bytes1 result)",
            "class_method_signature": "Packing.extract_32_1bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a single byte (`bytes1`) from a `bytes32` value at a specified offset.\n *\n * @param self The `bytes32` value from which to extract the byte.\n * @param offset The position (0-31) within the `bytes32` value to extract the byte from.\n * @return result The extracted byte (`bytes1`) at the specified offset.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-31). If not, revert with an `OutOfRangeAccess` error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the `bytes32` value left by `8 * offset` to align the desired byte to the most significant position.\n *    - Mask the result to isolate the most significant byte using `shl(248, not(0))`.\n *    - Return the extracted byte.\n *\n * @dev This function uses low-level assembly for efficient byte manipulation.\n */"
        },
        {
            "identifier": "replace_32_1",
            "parameters": "bytes32 self, bytes1 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_1(bytes32 self, bytes1 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes1 oldValue = extract_32_1(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(248, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1484",
            "end": "1490",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_1bytes32 self, bytes1 value, uint8 offset",
            "full_signature": "function replace_32_1(bytes32 self, bytes1 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_1bytes32 self, bytes1 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a single byte (1 byte) within a 32-byte (bytes32) value at a specified offset.\n *\n * @param self The original 32-byte value where the byte will be replaced.\n * @param value The new byte (1 byte) to be inserted into the original value.\n * @param offset The position (0-31) within the 32-byte value where the replacement will occur.\n * @return result The modified 32-byte value after the byte replacement.\n *\n * Steps:\n * 1. Extract the existing byte at the specified offset from the original 32-byte value.\n * 2. Use assembly to:\n *    - Mask the new byte to ensure it is only 1 byte.\n *    - Calculate the new 32-byte value by XORing the original value with the old byte and the new byte at the correct offset.\n * 3. Return the modified 32-byte value.\n *\n * @dev This function uses low-level assembly for byte manipulation, ensuring efficient and precise replacement.\n */"
        },
        {
            "identifier": "extract_32_2",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes2 result)",
            "body": "function extract_32_2(bytes32 self, uint8 offset) internal pure returns (bytes2 result) {\n        if (offset > 30) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(240, not(0)))\n        }\n    }",
            "start": "1492",
            "end": "1497",
            "class": "Packing",
            "signature": "returns (bytes2 result) extract_32_2bytes32 self, uint8 offset",
            "full_signature": "function extract_32_2(bytes32 self, uint8 offset) internal  pure returns (bytes2 result)",
            "class_method_signature": "Packing.extract_32_2bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 2-byte (16-bit) value from a 32-byte (256-bit) input at a specified offset.\n *\n * @param self The 32-byte input from which to extract the 2-byte value.\n * @param offset The position within the 32-byte input to start the extraction (0-30, as 31 would exceed the bounds).\n * @return result The extracted 2-byte value.\n *\n * Steps:\n * 1. Check if the offset is greater than 30. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired 2 bytes.\n *    - Mask the result to ensure only the first 2 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * Note: This function is marked as `pure` and uses `memory-safe` assembly to ensure no state changes occur.\n */"
        },
        {
            "identifier": "replace_32_2",
            "parameters": "bytes32 self, bytes2 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_2(bytes32 self, bytes2 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes2 oldValue = extract_32_2(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(240, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1499",
            "end": "1505",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_2bytes32 self, bytes2 value, uint8 offset",
            "full_signature": "function replace_32_2(bytes32 self, bytes2 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_2bytes32 self, bytes2 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 2-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 2-byte value to replace the segment with.\n * @param offset The byte offset within the 32-byte value where the replacement should occur.\n * @return result The modified 32-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 2-byte value at the specified offset from the original 32-byte value.\n * 2. Use inline assembly to:\n *    a. Mask the new 2-byte value to ensure it is properly aligned.\n *    b. Calculate the new 32-byte value by XORing the original value with the old and new 2-byte values, shifted to the correct position.\n * 3. Return the modified 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_4",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes4 result)",
            "body": "function extract_32_4(bytes32 self, uint8 offset) internal pure returns (bytes4 result) {\n        if (offset > 28) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(224, not(0)))\n        }\n    }",
            "start": "1507",
            "end": "1512",
            "class": "Packing",
            "signature": "returns (bytes4 result) extract_32_4bytes32 self, uint8 offset",
            "full_signature": "function extract_32_4(bytes32 self, uint8 offset) internal  pure returns (bytes4 result)",
            "class_method_signature": "Packing.extract_32_4bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 4-byte (bytes4) value from a 32-byte (bytes32) input at a specified offset.\n *\n * @param self The 32-byte input from which to extract the 4-byte value.\n * @param offset The position within the 32-byte input to start the extraction. Must be less than or equal to 28.\n * @return result The extracted 4-byte value.\n *\n * Steps:\n * 1. Check if the offset is greater than 28. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired 4 bytes.\n *    - Mask the result to ensure only the first 4 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * @dev This function is marked as `pure` and uses `memory-safe` assembly to ensure no state changes.\n */"
        },
        {
            "identifier": "replace_32_4",
            "parameters": "bytes32 self, bytes4 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_4(bytes32 self, bytes4 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes4 oldValue = extract_32_4(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(224, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1514",
            "end": "1520",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_4bytes32 self, bytes4 value, uint8 offset",
            "full_signature": "function replace_32_4(bytes32 self, bytes4 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_4bytes32 self, bytes4 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 4-byte segment within a 32-byte word at a specified offset.\n *\n * @param self The original 32-byte word.\n * @param value The new 4-byte value to replace the existing segment.\n * @param offset The byte offset within the 32-byte word where the replacement should occur.\n * @return result The modified 32-byte word with the 4-byte segment replaced.\n *\n * Steps:\n * 1. Extract the existing 4-byte value from the original 32-byte word at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 4-byte value to ensure it is properly aligned.\n *    b. Calculate the new 32-byte word by XORing the original word with the old and new 4-byte values, shifted appropriately.\n * 3. Return the modified 32-byte word.\n */"
        },
        {
            "identifier": "extract_32_6",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes6 result)",
            "body": "function extract_32_6(bytes32 self, uint8 offset) internal pure returns (bytes6 result) {\n        if (offset > 26) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(208, not(0)))\n        }\n    }",
            "start": "1522",
            "end": "1527",
            "class": "Packing",
            "signature": "returns (bytes6 result) extract_32_6bytes32 self, uint8 offset",
            "full_signature": "function extract_32_6(bytes32 self, uint8 offset) internal  pure returns (bytes6 result)",
            "class_method_signature": "Packing.extract_32_6bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 6-byte segment from a 32-byte value starting at a specified offset.\n *\n * @param self The 32-byte value from which to extract the segment.\n * @param offset The starting position (0-26) within the 32-byte value to begin extraction.\n * @return result The extracted 6-byte segment.\n *\n * Steps:\n * 1. Revert if the offset is greater than 26, as it would exceed the valid range for a 6-byte segment.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 32-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 6 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_32_6",
            "parameters": "bytes32 self, bytes6 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_6(bytes32 self, bytes6 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes6 oldValue = extract_32_6(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(208, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1529",
            "end": "1535",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_6bytes32 self, bytes6 value, uint8 offset",
            "full_signature": "function replace_32_6(bytes32 self, bytes6 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_6bytes32 self, bytes6 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 6-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 6-byte value to replace the segment with.\n * @param offset The byte offset (0-26) where the replacement should occur.\n * @return result The modified 32-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 6-byte value at the specified offset using `extract_32_6`.\n * 2. Use inline assembly to perform the replacement:\n *    - Mask the new 6-byte value to ensure it is properly aligned.\n *    - Calculate the result by XORing the original value with the old and new 6-byte segments.\n * 3. Return the modified 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_8",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes8 result)",
            "body": "function extract_32_8(bytes32 self, uint8 offset) internal pure returns (bytes8 result) {\n        if (offset > 24) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(192, not(0)))\n        }\n    }",
            "start": "1537",
            "end": "1542",
            "class": "Packing",
            "signature": "returns (bytes8 result) extract_32_8bytes32 self, uint8 offset",
            "full_signature": "function extract_32_8(bytes32 self, uint8 offset) internal  pure returns (bytes8 result)",
            "class_method_signature": "Packing.extract_32_8bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts an 8-byte segment from a 32-byte value starting at a specified offset.\n *\n * @param self The 32-byte value from which to extract the segment.\n * @param offset The starting position (0-24) within the 32-byte value to begin extraction.\n * @return result The extracted 8-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-24). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 32-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 8 bytes are retained.\n *    - Return the extracted 8-byte segment.\n */"
        },
        {
            "identifier": "replace_32_8",
            "parameters": "bytes32 self, bytes8 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_8(bytes32 self, bytes8 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes8 oldValue = extract_32_8(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(192, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1544",
            "end": "1550",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_8bytes32 self, bytes8 value, uint8 offset",
            "full_signature": "function replace_32_8(bytes32 self, bytes8 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_8bytes32 self, bytes8 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a specific 8-byte segment within a 32-byte value at a given offset.\n *\n * @param self The original 32-byte value to modify.\n * @param value The new 8-byte value to insert into the 32-byte value.\n * @param offset The position (in bytes) within the 32-byte value where the replacement should occur.\n * @return result The modified 32-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 8-byte value at the specified offset from the original 32-byte value.\n * 2. Use inline assembly to:\n *    a. Mask the new 8-byte value to ensure it is properly aligned.\n *    b. Calculate the modified 32-byte value by XORing the original value with the old and new 8-byte values.\n * 3. Return the resulting 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_10",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes10 result)",
            "body": "function extract_32_10(bytes32 self, uint8 offset) internal pure returns (bytes10 result) {\n        if (offset > 22) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(176, not(0)))\n        }\n    }",
            "start": "1552",
            "end": "1557",
            "class": "Packing",
            "signature": "returns (bytes10 result) extract_32_10bytes32 self, uint8 offset",
            "full_signature": "function extract_32_10(bytes32 self, uint8 offset) internal  pure returns (bytes10 result)",
            "class_method_signature": "Packing.extract_32_10bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 10-byte segment from a 32-byte value starting at a specified offset.\n *\n * @param self The 32-byte value from which to extract the segment.\n * @param offset The starting position (0-22) within the 32-byte value to begin extraction.\n * @return result The extracted 10-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-22). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 32-byte value left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 10 bytes are retained.\n *    - Store the result in the `result` variable.\n *\n * Note: This function is marked as `internal pure` and uses memory-safe assembly.\n */"
        },
        {
            "identifier": "replace_32_10",
            "parameters": "bytes32 self, bytes10 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_10(bytes32 self, bytes10 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes10 oldValue = extract_32_10(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(176, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1559",
            "end": "1565",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_10bytes32 self, bytes10 value, uint8 offset",
            "full_signature": "function replace_32_10(bytes32 self, bytes10 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_10bytes32 self, bytes10 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 10-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 10-byte value to replace the segment with.\n * @param offset The byte offset within the 32-byte value where the replacement should occur.\n * @return result The modified 32-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 10-byte segment from the original 32-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 10-byte value to ensure it fits within the 10-byte segment.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_12",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes12 result)",
            "body": "function extract_32_12(bytes32 self, uint8 offset) internal pure returns (bytes12 result) {\n        if (offset > 20) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(160, not(0)))\n        }\n    }",
            "start": "1567",
            "end": "1572",
            "class": "Packing",
            "signature": "returns (bytes12 result) extract_32_12bytes32 self, uint8 offset",
            "full_signature": "function extract_32_12(bytes32 self, uint8 offset) internal  pure returns (bytes12 result)",
            "class_method_signature": "Packing.extract_32_12bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Extracts a 12-byte segment from a 32-byte value starting at a specified offset.\n *\n * @param self The 32-byte value from which to extract the segment.\n * @param offset The starting position (in bytes) within the 32-byte value to begin extraction.\n *               Must be less than or equal to 20 to avoid out-of-range access.\n * @return result The extracted 12-byte segment as a `bytes12` value.\n *\n * Steps:\n * 1. Check if the offset is greater than 20. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 32-byte value left by `8 * offset` bits to align the desired segment.\n *    - Mask the result to ensure only the first 12 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_32_12",
            "parameters": "bytes32 self, bytes12 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_12(bytes32 self, bytes12 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes12 oldValue = extract_32_12(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(160, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1574",
            "end": "1580",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_12bytes32 self, bytes12 value, uint8 offset",
            "full_signature": "function replace_32_12(bytes32 self, bytes12 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_12bytes32 self, bytes12 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 12-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 12-byte value to be inserted.\n * @param offset The byte offset (0-20) where the replacement should occur.\n * @return result The modified 32-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 12-byte value from the original 32-byte value at the specified offset.\n * 2. Use inline assembly to:\n *    a. Mask the new 12-byte value to ensure it fits within the 12-byte boundary.\n *    b. Perform bitwise operations to replace the old 12-byte value with the new one at the specified offset.\n * 3. Return the modified 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_16",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes16 result)",
            "body": "function extract_32_16(bytes32 self, uint8 offset) internal pure returns (bytes16 result) {\n        if (offset > 16) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(128, not(0)))\n        }\n    }",
            "start": "1582",
            "end": "1587",
            "class": "Packing",
            "signature": "returns (bytes16 result) extract_32_16bytes32 self, uint8 offset",
            "full_signature": "function extract_32_16(bytes32 self, uint8 offset) internal  pure returns (bytes16 result)",
            "class_method_signature": "Packing.extract_32_16bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 16-byte segment from a 32-byte value starting at a specified offset.\n *\n * @param self The 32-byte value from which to extract the segment.\n * @param offset The starting position (in bytes) within the 32-byte value to begin extraction.\n *              Must be less than or equal to 16 to avoid out-of-range access.\n * @return result The extracted 16-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 16. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the 32-byte value left by `8 * offset` bits to align the desired segment.\n *    - Apply a mask to isolate the first 16 bytes (128 bits) of the shifted value.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_32_16",
            "parameters": "bytes32 self, bytes16 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_16(bytes32 self, bytes16 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes16 oldValue = extract_32_16(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(128, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1589",
            "end": "1595",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_16bytes32 self, bytes16 value, uint8 offset",
            "full_signature": "function replace_32_16(bytes32 self, bytes16 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_16bytes32 self, bytes16 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 16-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 16-byte value to replace the segment with.\n * @param offset The byte offset (0-16) within the 32-byte value where the replacement should occur.\n * @return result The modified 32-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 16-byte segment from the original 32-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the new 16-byte value to ensure it is properly aligned.\n *    b. Replace the old 16-byte segment with the new value at the specified offset.\n *    c. Combine the modified segment back into the original 32-byte value.\n * 3. Return the resulting 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_20",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes20 result)",
            "body": "function extract_32_20(bytes32 self, uint8 offset) internal pure returns (bytes20 result) {\n        if (offset > 12) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(96, not(0)))\n        }\n    }",
            "start": "1597",
            "end": "1602",
            "class": "Packing",
            "signature": "returns (bytes20 result) extract_32_20bytes32 self, uint8 offset",
            "full_signature": "function extract_32_20(bytes32 self, uint8 offset) internal  pure returns (bytes20 result)",
            "class_method_signature": "Packing.extract_32_20bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 20-byte value from a 32-byte input starting at a specified offset.\n *\n * @param self The 32-byte input from which to extract the 20-byte value.\n * @param offset The starting position (0-12) within the 32-byte input to begin extraction.\n * @return result The extracted 20-byte value.\n *\n * Steps:\n * 1. Check if the offset is greater than 12. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input (`self`) left by `8 * offset` bits to align the desired 20-byte segment.\n *    - Mask the result to ensure only the first 20 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_32_20",
            "parameters": "bytes32 self, bytes20 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_20(bytes32 self, bytes20 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes20 oldValue = extract_32_20(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(96, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1604",
            "end": "1610",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_20bytes32 self, bytes20 value, uint8 offset",
            "full_signature": "function replace_32_20(bytes32 self, bytes20 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_20bytes32 self, bytes20 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 20-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value where the replacement will occur.\n * @param value The 20-byte value to be inserted into the 32-byte value.\n * @param offset The position (in bytes) within the 32-byte value where the replacement will start.\n * @return result The modified 32-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 20-byte value from the 32-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the `value` to ensure it is 20 bytes long.\n *    b. Calculate the new 32-byte value by XORing the original value with the old and new 20-byte values.\n * 3. Return the resulting 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_22",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes22 result)",
            "body": "function extract_32_22(bytes32 self, uint8 offset) internal pure returns (bytes22 result) {\n        if (offset > 10) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(80, not(0)))\n        }\n    }",
            "start": "1612",
            "end": "1617",
            "class": "Packing",
            "signature": "returns (bytes22 result) extract_32_22bytes32 self, uint8 offset",
            "full_signature": "function extract_32_22(bytes32 self, uint8 offset) internal  pure returns (bytes22 result)",
            "class_method_signature": "Packing.extract_32_22bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 22-byte segment from a 32-byte value starting at a specified offset.\n *\n * @param self The 32-byte value from which to extract the segment.\n * @param offset The starting position (0-10) within the 32-byte value to begin extraction.\n * @return result The extracted 22-byte segment.\n *\n * Steps:\n * 1. Check if the offset is greater than 10. If so, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the original 32-byte value left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 22 bytes are retained.\n *    - Return the extracted 22-byte segment.\n */"
        },
        {
            "identifier": "replace_32_22",
            "parameters": "bytes32 self, bytes22 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_22(bytes32 self, bytes22 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes22 oldValue = extract_32_22(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(80, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1619",
            "end": "1625",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_22bytes32 self, bytes22 value, uint8 offset",
            "full_signature": "function replace_32_22(bytes32 self, bytes22 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_22bytes32 self, bytes22 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 22-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 22-byte value to be inserted.\n * @param offset The position (in bytes) within the 32-byte value where the replacement should occur.\n * @return result The modified 32-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 22-byte segment from the original 32-byte value at the specified offset.\n * 2. Use assembly to:\n *    - Mask the new 22-byte value to ensure it fits within the 22-byte boundary.\n *    - Calculate the result by XORing the original value with the old segment and then XORing with the new segment, shifted to the correct position.\n * 3. Return the modified 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_24",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes24 result)",
            "body": "function extract_32_24(bytes32 self, uint8 offset) internal pure returns (bytes24 result) {\n        if (offset > 8) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(64, not(0)))\n        }\n    }",
            "start": "1627",
            "end": "1632",
            "class": "Packing",
            "signature": "returns (bytes24 result) extract_32_24bytes32 self, uint8 offset",
            "full_signature": "function extract_32_24(bytes32 self, uint8 offset) internal  pure returns (bytes24 result)",
            "class_method_signature": "Packing.extract_32_24bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 24-byte segment from a 32-byte input starting at a specified offset.\n *\n * @param self The 32-byte input from which to extract the segment.\n * @param offset The starting position (0-8) within the 32-byte input to begin extraction.\n * @return result The extracted 24-byte segment.\n *\n * Steps:\n * 1. Revert if the offset is greater than 8, as it would exceed the valid range for extraction.\n * 2. Use inline assembly to perform the extraction:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only the first 24 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_32_24",
            "parameters": "bytes32 self, bytes24 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_24(bytes32 self, bytes24 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes24 oldValue = extract_32_24(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(64, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1634",
            "end": "1640",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_24bytes32 self, bytes24 value, uint8 offset",
            "full_signature": "function replace_32_24(bytes32 self, bytes24 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_24bytes32 self, bytes24 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 24-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 24-byte value to insert.\n * @param offset The byte offset (0-8) where the replacement should occur.\n * @return result The modified 32-byte value after replacement.\n *\n * Steps:\n * 1. Extract the existing 24-byte segment from the original 32-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the new 24-byte value to ensure it fits within 24 bytes.\n *    b. Calculate the result by XORing the original value with the old segment and then XORing with the new segment.\n * 3. Return the modified 32-byte value.\n */"
        },
        {
            "identifier": "extract_32_28",
            "parameters": "bytes32 self, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes28 result)",
            "body": "function extract_32_28(bytes32 self, uint8 offset) internal pure returns (bytes28 result) {\n        if (offset > 4) revert OutOfRangeAccess();\n        assembly (\"memory-safe\") {\n            result := and(shl(mul(8, offset), self), shl(32, not(0)))\n        }\n    }",
            "start": "1642",
            "end": "1647",
            "class": "Packing",
            "signature": "returns (bytes28 result) extract_32_28bytes32 self, uint8 offset",
            "full_signature": "function extract_32_28(bytes32 self, uint8 offset) internal  pure returns (bytes28 result)",
            "class_method_signature": "Packing.extract_32_28bytes32 self, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Extracts a 28-byte segment from a 32-byte input starting at a specified offset.\n *\n * @param self The 32-byte input from which to extract the segment.\n * @param offset The starting position (0-4) within the 32-byte input to begin extraction.\n * @return result The extracted 28-byte segment.\n *\n * Steps:\n * 1. Check if the offset is within the valid range (0-4). If not, revert with an \"OutOfRangeAccess\" error.\n * 2. Use inline assembly to perform bitwise operations:\n *    - Shift the input left by `8 * offset` to align the desired segment.\n *    - Mask the result to ensure only 28 bytes are retained.\n *    - Store the result in the `result` variable.\n */"
        },
        {
            "identifier": "replace_32_28",
            "parameters": "bytes32 self, bytes28 value, uint8 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function replace_32_28(bytes32 self, bytes28 value, uint8 offset) internal pure returns (bytes32 result) {\n        bytes28 oldValue = extract_32_28(self, offset);\n        assembly (\"memory-safe\") {\n            value := and(value, shl(32, not(0)))\n            result := xor(self, shr(mul(8, offset), xor(oldValue, value)))\n        }\n    }",
            "start": "1649",
            "end": "1655",
            "class": "Packing",
            "signature": "returns (bytes32 result) replace_32_28bytes32 self, bytes28 value, uint8 offset",
            "full_signature": "function replace_32_28(bytes32 self, bytes28 value, uint8 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "Packing.replace_32_28bytes32 self, bytes28 value, uint8 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Replaces a 28-byte segment within a 32-byte value at a specified offset.\n *\n * @param self The original 32-byte value.\n * @param value The new 28-byte value to be inserted.\n * @param offset The position (in bytes) within the 32-byte value where the replacement should occur.\n * @return result The modified 32-byte value after the replacement.\n *\n * Steps:\n * 1. Extract the existing 28-byte segment from the original 32-byte value at the specified offset.\n * 2. Use assembly to:\n *    a. Mask the new 28-byte value to ensure it fits within the 28-byte segment.\n *    b. Replace the old 28-byte segment with the new value at the specified offset.\n *    c. Combine the modified segment back into the original 32-byte value.\n * 3. Return the resulting 32-byte value.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/SlotDerivation.sol": [
        {
            "identifier": "offset",
            "parameters": "bytes32 slot, uint256 pos",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function offset(bytes32 slot, uint256 pos) internal pure returns (bytes32 result) {\n        unchecked {\n            return bytes32(uint256(slot) + pos);\n        }\n    }",
            "start": "55",
            "end": "59",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) offsetbytes32 slot, uint256 pos",
            "full_signature": "function offset(bytes32 slot, uint256 pos) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.offsetbytes32 slot, uint256 pos",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the offset of a given slot by adding a position value.\n *\n * @param slot The base slot value to which the position will be added.\n * @param pos The position value to add to the slot.\n * @return result The resulting slot after adding the position to the base slot.\n *\n * Steps:\n * 1. Perform an unchecked addition of the `pos` value to the `slot` value.\n * 2. Return the result as a `bytes32` value.\n */"
        },
        {
            "identifier": "deriveArray",
            "parameters": "bytes32 slot",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveArray(bytes32 slot) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, slot)\n            result := keccak256(0x00, 0x20)\n        }\n    }",
            "start": "64",
            "end": "69",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveArraybytes32 slot",
            "full_signature": "function deriveArray(bytes32 slot) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveArraybytes32 slot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives a storage slot for an array based on the provided base slot.\n *\n * @param slot The base storage slot from which the array's storage slot is derived.\n * @return result The derived storage slot for the array.\n *\n * Steps:\n * 1. Store the provided `slot` value in memory at position `0x00`.\n * 2. Compute the keccak256 hash of the 32 bytes starting at memory position `0x00`.\n * 3. Return the computed hash as the derived storage slot for the array.\n *\n * @dev This function uses inline assembly to perform low-level memory operations.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, address key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, address key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, and(key, shr(96, not(0))))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "74",
            "end": "80",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, address key",
            "full_signature": "function deriveMapping(bytes32 slot, address key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives the storage slot for a mapping key in a Solidity contract.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The key for which the storage slot is being derived.\n * @return result The derived storage slot as a `bytes32` value.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level operations.\n * 2. Store the key in memory, ensuring it is properly aligned and padded.\n * 3. Store the base slot in memory.\n * 4. Compute the keccak256 hash of the concatenated key and slot to derive the storage slot.\n * 5. Return the derived storage slot.\n *\n * Note: This function is marked as `internal pure` and uses `memory-safe` assembly to ensure safety.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, bool key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, bool key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, iszero(iszero(key)))\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "85",
            "end": "91",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, bool key",
            "full_signature": "function deriveMapping(bytes32 slot, bool key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, bool key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives the storage slot for a mapping in Solidity, specifically for a boolean key.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The boolean key used to derive the storage slot.\n * @return result The derived storage slot for the given key in the mapping.\n *\n * Steps:\n * 1. Store the boolean key in memory at position 0x00, converting it to a uint256 (0 or 1).\n * 2. Store the base slot in memory at position 0x20.\n * 3. Compute the keccak256 hash of the concatenated memory (0x00 to 0x40) to derive the storage slot.\n * 4. Return the derived storage slot.\n *\n * Note: This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, bytes32 key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, bytes32 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "96",
            "end": "102",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, bytes32 key",
            "full_signature": "function deriveMapping(bytes32 slot, bytes32 key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives the storage slot for a key in a Solidity mapping.\n *\n * @dev This function calculates the storage slot for a given key in a mapping using the formula:\n *      `keccak256(abi.encodePacked(key, slot))`. This is how Solidity internally computes the storage\n *      location for mappings.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The key for which the storage slot is being derived.\n * @return result The derived storage slot as a `bytes32` value.\n *\n * Steps:\n * 1. Store the `key` in memory at position `0x00`.\n * 2. Store the `slot` in memory at position `0x20`.\n * 3. Compute the `keccak256` hash of the concatenated `key` and `slot` (0x00 to 0x40).\n * 4. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, uint256 key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, uint256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "107",
            "end": "113",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, uint256 key",
            "full_signature": "function deriveMapping(bytes32 slot, uint256 key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives the storage slot for a key in a mapping.\n *\n * @dev This function calculates the storage slot for a given key in a mapping using the formula:\n *      `keccak256(abi.encodePacked(key, slot))`. The result is the storage slot where the value\n *      associated with the key is stored in the contract's storage.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The key for which the storage slot is to be derived.\n * @return result The derived storage slot as a `bytes32` value.\n *\n * Steps:\n * 1. Store the key in memory at position 0x00.\n * 2. Store the base slot in memory at position 0x20.\n * 3. Compute the keccak256 hash of the concatenated key and slot (0x00 to 0x40).\n * 4. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, int256 key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, int256 key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, key)\n            mstore(0x20, slot)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "118",
            "end": "124",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, int256 key",
            "full_signature": "function deriveMapping(bytes32 slot, int256 key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, int256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives the storage slot for a mapping key in a Solidity contract.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The key within the mapping for which the storage slot is being derived.\n * @return result The computed storage slot for the given mapping key.\n *\n * Steps:\n * 1. Store the `key` in the first 32 bytes of memory (0x00).\n * 2. Store the `slot` in the next 32 bytes of memory (0x20).\n * 3. Compute the keccak256 hash of the concatenated 64 bytes (0x00 to 0x40).\n * 4. Return the resulting hash as the derived storage slot.\n *\n * @dev This function uses inline assembly to efficiently compute the storage slot.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, string memory key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, string memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }",
            "start": "129",
            "end": "139",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, string memory key",
            "full_signature": "function deriveMapping(bytes32 slot, string memory key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, string memory key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives a storage slot for a mapping key in Solidity.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The key for which the storage slot is being derived.\n * @return result The derived storage slot for the given key.\n *\n * Steps:\n * 1. Load the length of the key string.\n * 2. Calculate the starting and ending memory addresses for the key.\n * 3. Cache the value at the end of the key in memory.\n * 4. Store the base slot at the end of the key in memory.\n * 5. Compute the keccak256 hash of the key and slot to derive the storage slot.\n * 6. Restore the cached value at the end of the key in memory.\n * 7. Return the derived storage slot.\n */"
        },
        {
            "identifier": "deriveMapping",
            "parameters": "bytes32 slot, bytes memory key",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function deriveMapping(bytes32 slot, bytes memory key) internal pure returns (bytes32 result) {\n        assembly (\"memory-safe\") {\n            let length := mload(key)\n            let begin := add(key, 0x20)\n            let end := add(begin, length)\n            let cache := mload(end)\n            mstore(end, slot)\n            result := keccak256(begin, add(length, 0x20))\n            mstore(end, cache)\n        }\n    }",
            "start": "144",
            "end": "154",
            "class": "SlotDerivation",
            "signature": "returns (bytes32 result) deriveMappingbytes32 slot, bytes memory key",
            "full_signature": "function deriveMapping(bytes32 slot, bytes memory key) internal  pure returns (bytes32 result)",
            "class_method_signature": "SlotDerivation.deriveMappingbytes32 slot, bytes memory key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Derives a storage slot for a mapping key in Solidity.\n *\n * @param slot The base storage slot of the mapping.\n * @param key The key for which the storage slot is to be derived.\n * @return result The derived storage slot as a `bytes32` value.\n *\n * Steps:\n * 1. Load the length of the key from memory.\n * 2. Calculate the beginning and end pointers of the key in memory.\n * 3. Cache the value at the end of the key in memory.\n * 4. Store the base slot at the end of the key in memory.\n * 5. Compute the keccak256 hash of the key and the base slot to derive the storage slot.\n * 6. Restore the cached value at the end of the key in memory.\n * 7. Return the derived storage slot.\n *\n * @dev This function uses inline assembly to manipulate memory and compute the storage slot.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/ShortStrings.sol": [
        {
            "identifier": "toShortString",
            "parameters": "string memory str",
            "modifiers": "pure",
            "return": "returns (ShortString)",
            "body": "function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }",
            "start": "52",
            "end": "58",
            "class": "ShortStrings",
            "signature": "returns (ShortString) toShortStringstring memory str",
            "full_signature": "function toShortString(string memory str) internal  pure returns (ShortString)",
            "class_method_signature": "ShortStrings.toShortStringstring memory str",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a standard string into a `ShortString` type, which is optimized for storage.\n *\n * @param str The input string to be converted.\n * @return A `ShortString` representation of the input string.\n *\n * Steps:\n * 1. Convert the input string into a bytes array.\n * 2. Check if the length of the bytes array exceeds 31 bytes.\n *    - If it does, revert with an error indicating the string is too long.\n * 3. Encode the bytes array into a `bytes32` value, combining it with the length of the string.\n * 4. Return the `ShortString` representation of the encoded value.\n *\n * @dev This function is useful for optimizing storage when dealing with short strings.\n */"
        },
        {
            "identifier": "toString",
            "parameters": "ShortString sstr",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        assembly (\"memory-safe\") {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }",
            "start": "63",
            "end": "72",
            "class": "ShortStrings",
            "signature": "returns (string memory) toStringShortString sstr",
            "full_signature": "function toString(ShortString sstr) internal  pure returns (string memory)",
            "class_method_signature": "ShortStrings.toStringShortString sstr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a `ShortString` type to a `string` type.\n *\n * @param sstr The `ShortString` to be converted to a string.\n * @return str The resulting string representation of the `ShortString`.\n *\n * Steps:\n * 1. Calculate the length of the `ShortString` using `byteLength`.\n * 2. Create a new string with a fixed length of 32 bytes (memory-safe approach).\n * 3. Use inline assembly to store the length and the `ShortString` data in the string's memory.\n * 4. Return the constructed string.\n */"
        },
        {
            "identifier": "byteLength",
            "parameters": "ShortString sstr",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }",
            "start": "77",
            "end": "83",
            "class": "ShortStrings",
            "signature": "returns (uint256) byteLengthShortString sstr",
            "full_signature": "function byteLength(ShortString sstr) internal  pure returns (uint256)",
            "class_method_signature": "ShortStrings.byteLengthShortString sstr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the byte length of a `ShortString` type.\n *\n * @param sstr The `ShortString` instance whose byte length is to be determined.\n * @return result The byte length of the `ShortString`, which must be less than or equal to 31.\n *\n * Steps:\n * 1. Extract the least significant byte from the `ShortString` by performing a bitwise AND operation with 0xFF.\n * 2. Check if the extracted byte length is greater than 31.\n *    - If true, revert with an `InvalidShortString` error.\n * 3. Return the extracted byte length.\n */ "
        },
        {
            "identifier": "toShortStringWithFallback",
            "parameters": "string memory value, string storage store",
            "modifiers": "",
            "return": "returns (ShortString)",
            "body": "function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(FALLBACK_SENTINEL);\n        }\n    }",
            "start": "88",
            "end": "95",
            "class": "ShortStrings",
            "signature": "returns (ShortString) toShortStringWithFallbackstring memory value, string storage store",
            "full_signature": "function toShortStringWithFallback(string memory value, string storage store) internal   returns (ShortString)",
            "class_method_signature": "ShortStrings.toShortStringWithFallbackstring memory value, string storage store",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "{'function StringSlot()', 'function getStringSlot(bytes32 slot) internal  pure returns (StringSlot storage r)', 'function getStringSlot(string storage store) internal  pure returns (StringSlot storage r)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a string to a `ShortString` if its length is less than 32 bytes. \n *         Otherwise, stores the string in a storage slot and returns a fallback sentinel.\n *\n * @param value The string to be converted or stored.\n * @param store The storage slot where the string will be stored if it exceeds 31 bytes.\n * @return ShortString Returns a `ShortString` if the input string is short, otherwise returns a fallback sentinel.\n *\n * Steps:\n * 1. Check if the length of the input string (`value`) is less than 32 bytes.\n * 2. If true, convert the string to a `ShortString` using `toShortString`.\n * 3. If false, store the string in the provided storage slot (`store`) and return a fallback sentinel (`FALLBACK_SENTINEL`).\n */"
        },
        {
            "identifier": "toStringWithFallback",
            "parameters": "ShortString value, string storage store",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }",
            "start": "100",
            "end": "106",
            "class": "ShortStrings",
            "signature": "returns (string memory) toStringWithFallbackShortString value, string storage store",
            "full_signature": "function toStringWithFallback(ShortString value, string storage store) internal  pure returns (string memory)",
            "class_method_signature": "ShortStrings.toStringWithFallbackShortString value, string storage store",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a `ShortString` to a string, falling back to a provided storage string if the `ShortString` is a sentinel value.\n *\n * @param value The `ShortString` to convert.\n * @param store The fallback string to use if the `ShortString` is a sentinel value.\n * @return The resulting string, either from the `ShortString` or the fallback storage string.\n *\n * Steps:\n * 1. Check if the `ShortString` is not the fallback sentinel value.\n * 2. If true, convert the `ShortString` to a string using `toString`.\n * 3. If false, return the provided fallback storage string.\n */"
        },
        {
            "identifier": "byteLengthWithFallback",
            "parameters": "ShortString value, string storage store",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }",
            "start": "115",
            "end": "121",
            "class": "ShortStrings",
            "signature": "returns (uint256) byteLengthWithFallbackShortString value, string storage store",
            "full_signature": "function byteLengthWithFallback(ShortString value, string storage store) internal  view returns (uint256)",
            "class_method_signature": "ShortStrings.byteLengthWithFallbackShortString value, string storage store",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {StorageSlot} from \"./StorageSlot.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns the byte length of a `ShortString` value or falls back to the length of a provided string if the `ShortString` is a fallback sentinel.\n *\n * @param value The `ShortString` value to check.\n * @param store The fallback string storage reference to use if the `ShortString` is a fallback sentinel.\n * @return The byte length of the `ShortString` or the fallback string.\n *\n * Steps:\n * 1. Check if the `ShortString` value is not the fallback sentinel.\n * 2. If true, return the byte length of the `ShortString` using the `byteLength` function.\n * 3. If false, return the byte length of the provided fallback string (`store`).\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Create2.sol": [
        {
            "identifier": "deploy",
            "parameters": "uint256 amount, bytes32 salt, bytes memory bytecode",
            "modifiers": "",
            "return": "returns (address addr)",
            "body": "function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal returns (address addr) {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n        if (bytecode.length == 0) {\n            revert Create2EmptyBytecode();\n        }\n        assembly (\"memory-safe\") {\n            addr := create2(amount, add(bytecode, 0x20), mload(bytecode), salt)\n            // if no address was created, and returndata is not empty, bubble revert\n            if and(iszero(addr), not(iszero(returndatasize()))) {\n                let p := mload(0x40)\n                returndatacopy(p, 0, returndatasize())\n                revert(p, returndatasize())\n            }\n        }\n        if (addr == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }",
            "start": "37",
            "end": "56",
            "class": "Create2",
            "signature": "returns (address addr) deployuint256 amount, bytes32 salt, bytes memory bytecode",
            "full_signature": "function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal   returns (address addr)",
            "class_method_signature": "Create2.deployuint256 amount, bytes32 salt, bytes memory bytecode",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Errors} from \"./Errors.sol\";"
            ],
            "context": "{'function FailedDeployment()', 'function InsufficientBalance()'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Deploys a new contract using the CREATE2 opcode with the provided bytecode and salt.\n *\n * @param amount The amount of Ether to send with the deployment.\n * @param salt A unique salt to ensure deterministic address generation.\n * @param bytecode The bytecode of the contract to be deployed.\n * @return addr The address of the newly deployed contract.\n *\n * Steps:\n * 1. Check if the contract has sufficient balance to cover the deployment cost. If not, revert with `InsufficientBalance` error.\n * 2. Check if the provided bytecode is empty. If so, revert with `Create2EmptyBytecode` error.\n * 3. Use inline assembly to deploy the contract using the CREATE2 opcode:\n *    - Pass the amount of Ether, bytecode, and salt to the CREATE2 opcode.\n *    - If the deployment fails and returndata is not empty, revert with the returned error data.\n * 4. If the deployment address is `address(0)`, revert with `FailedDeployment` error.\n * 5. Return the address of the deployed contract.\n */"
        },
        {
            "identifier": "computeAddress",
            "parameters": "bytes32 salt, bytes32 bytecodeHash, address deployer",
            "modifiers": "pure",
            "return": "returns (address addr)",
            "body": "function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal pure returns (address addr) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40) // Get free memory pointer\n\n            // |                   | \u2193 ptr ...  \u2193 ptr + 0x0B (start) ...  \u2193 ptr + 0x20 ...  \u2193 ptr + 0x40 ...   |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | bytecodeHash      |                                                        CCCCCCCCCCCCC...CC |\n            // | salt              |                                      BBBBBBBBBBBBB...BB                   |\n            // | deployer          | 000000...0000AAAAAAAAAAAAAAAAAAA...AA                                     |\n            // | 0xFF              |            FF                                                             |\n            // |-------------------|---------------------------------------------------------------------------|\n            // | memory            | 000000...00FFAAAAAAAAAAAAAAAAAAA...AABBBBBBBBBBBBB...BBCCCCCCCCCCCCC...CC |\n            // | keccak(start, 85) |            \u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191\u2191 |\n\n            mstore(add(ptr, 0x40), bytecodeHash)\n            mstore(add(ptr, 0x20), salt)\n            mstore(ptr, deployer) // Right-aligned with 12 preceding garbage bytes\n            let start := add(ptr, 0x0b) // The hashed data starts at the final garbage byte which we will set to 0xff\n            mstore8(start, 0xff)\n            addr := and(keccak256(start, 85), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }",
            "start": "70",
            "end": "91",
            "class": "Create2",
            "signature": "returns (address addr) computeAddressbytes32 salt, bytes32 bytecodeHash, address deployer",
            "full_signature": "function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal  pure returns (address addr)",
            "class_method_signature": "Create2.computeAddressbytes32 salt, bytes32 bytecodeHash, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Errors} from \"./Errors.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the address of a contract that will be deployed using the CREATE2 opcode.\n * \n * @param salt A random value used to ensure the uniqueness of the deployed contract's address.\n * @param bytecodeHash The keccak256 hash of the contract's bytecode.\n * @param deployer The address of the account deploying the contract.\n * \n * @return addr The computed address of the contract that will be deployed.\n * \n * Steps:\n * 1. Load the free memory pointer to allocate memory for the computation.\n * 2. Store the bytecode hash, salt, and deployer address in memory.\n * 3. Adjust the memory pointer to include a 0xff byte, which is required for CREATE2 address computation.\n * 4. Compute the keccak256 hash of the memory region containing the deployer address, salt, and bytecode hash.\n * 5. Mask the hash to ensure it is a valid Ethereum address (160 bits).\n * 6. Return the computed address.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Arrays.sol": [
        {
            "identifier": "sort",
            "parameters": "uint256[] memory array, function(uint256, uint256) pure returns (bool) comp",
            "modifiers": "pure",
            "return": "returns (uint256[] memory)",
            "body": "function sort(\n        uint256[] memory array,\n        function(uint256, uint256) pure returns (bool) comp\n    ) internal pure returns (uint256[] memory) {\n        _quickSort(_begin(array), _end(array), comp);\n        return array;\n    }",
            "start": "32",
            "end": "38",
            "class": "Arrays",
            "signature": "returns (uint256[] memory) sortuint256[] memory array, function(uint256, uint256) pure returns (bool) comp",
            "full_signature": "function sort(uint256[] memory array, function(uint256, uint256) pure returns (bool) comp) internal  pure returns (uint256[] memory)",
            "class_method_signature": "Arrays.sortuint256[] memory array, function(uint256, uint256) pure returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of unsigned integers using a custom comparison function.\n *\n * @param array The array of unsigned integers to be sorted.\n * @param comp A comparison function that defines the sort order. It takes two uint256 values and returns a boolean indicating whether the first value should come before the second.\n *\n * @return The sorted array.\n *\n * Steps:\n * 1. Call the internal `_quickSort` function, passing the beginning and end of the array along with the comparison function.\n * 2. Return the sorted array.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "uint256[] memory array",
            "modifiers": "pure",
            "return": "returns (uint256[] memory)",
            "body": "function sort(uint256[] memory array) internal pure returns (uint256[] memory) {\n        sort(array, Comparators.lt);\n        return array;\n    }",
            "start": "43",
            "end": "46",
            "class": "Arrays",
            "signature": "returns (uint256[] memory) sortuint256[] memory array",
            "full_signature": "function sort(uint256[] memory array) internal  pure returns (uint256[] memory)",
            "class_method_signature": "Arrays.sortuint256[] memory array",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function lt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of unsigned integers in ascending order using the `Comparators.lt` function.\n *\n * @param array The array of unsigned integers to be sorted.\n * @return The sorted array of unsigned integers.\n *\n * Steps:\n * 1. Call the internal `sort` function with the provided array and the `Comparators.lt` comparator.\n * 2. Return the sorted array.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "address[] memory array, function(address, address) pure returns (bool) comp",
            "modifiers": "pure",
            "return": "returns (address[] memory)",
            "body": "function sort(\n        address[] memory array,\n        function(address, address) pure returns (bool) comp\n    ) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }",
            "start": "61",
            "end": "67",
            "class": "Arrays",
            "signature": "returns (address[] memory) sortaddress[] memory array, function(address, address) pure returns (bool) comp",
            "full_signature": "function sort(address[] memory array, function(address, address) pure returns (bool) comp) internal  pure returns (address[] memory)",
            "class_method_signature": "Arrays.sortaddress[] memory array, function(address, address) pure returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of addresses using a custom comparison function.\n *\n * @param array The array of addresses to be sorted.\n * @param comp A comparison function that takes two addresses and returns a boolean indicating\n *             whether the first address should come before the second in the sorted array.\n *\n * @return The sorted array of addresses.\n *\n * Steps:\n * 1. Convert the array of addresses to an array of uint256 using `_castToUint256Array`.\n * 2. Convert the comparison function to work with uint256 values using `_castToUint256Comp`.\n * 3. Sort the uint256 array using the converted comparison function.\n * 4. Return the sorted array of addresses.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "address[] memory array",
            "modifiers": "pure",
            "return": "returns (address[] memory)",
            "body": "function sort(address[] memory array) internal pure returns (address[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }",
            "start": "72",
            "end": "75",
            "class": "Arrays",
            "signature": "returns (address[] memory) sortaddress[] memory array",
            "full_signature": "function sort(address[] memory array) internal  pure returns (address[] memory)",
            "class_method_signature": "Arrays.sortaddress[] memory array",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function lt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of addresses in ascending order using a comparator function.\n *\n * @param array The array of addresses to be sorted.\n * @return The sorted array of addresses.\n *\n * Steps:\n * 1. Convert the array of addresses to an array of uint256 values.\n * 2. Sort the uint256 array using the `Comparators.lt` function (less-than comparator).\n * 3. Return the sorted array of addresses.\n *\n * Note: The sorting is done in-place, meaning the original array is modified.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "bytes32[] memory array, function(bytes32, bytes32) pure returns (bool) comp",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory)",
            "body": "function sort(\n        bytes32[] memory array,\n        function(bytes32, bytes32) pure returns (bool) comp\n    ) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), _castToUint256Comp(comp));\n        return array;\n    }",
            "start": "90",
            "end": "96",
            "class": "Arrays",
            "signature": "returns (bytes32[] memory) sortbytes32[] memory array, function(bytes32, bytes32) pure returns (bool) comp",
            "full_signature": "function sort(bytes32[] memory array, function(bytes32, bytes32) pure returns (bool) comp) internal  pure returns (bytes32[] memory)",
            "class_method_signature": "Arrays.sortbytes32[] memory array, function(bytes32, bytes32) pure returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of `bytes32` elements using a custom comparison function.\n *\n * @param array The array of `bytes32` elements to be sorted.\n * @param comp A comparison function that takes two `bytes32` elements and returns `true` if the first element should come before the second in the sorted array.\n *\n * @return The sorted array of `bytes32` elements.\n *\n * Steps:\n * 1. Convert the `bytes32` array to a `uint256` array using `_castToUint256Array`.\n * 2. Convert the comparison function to work with `uint256` elements using `_castToUint256Comp`.\n * 3. Sort the `uint256` array using the converted comparison function.\n * 4. Return the sorted `bytes32` array.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "bytes32[] memory array",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory)",
            "body": "function sort(bytes32[] memory array) internal pure returns (bytes32[] memory) {\n        sort(_castToUint256Array(array), Comparators.lt);\n        return array;\n    }",
            "start": "101",
            "end": "104",
            "class": "Arrays",
            "signature": "returns (bytes32[] memory) sortbytes32[] memory array",
            "full_signature": "function sort(bytes32[] memory array) internal  pure returns (bytes32[] memory)",
            "class_method_signature": "Arrays.sortbytes32[] memory array",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Comparators} from \"./Comparators.sol\";",
                "import {SlotDerivation} from \"./SlotDerivation.sol\";",
                "import {StorageSlot} from \"./StorageSlot.sol\";",
                "import {Math} from \"./math/Math.sol\";"
            ],
            "context": "{'function lt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of `bytes32` elements in ascending order using a comparator.\n *\n * @param array The array of `bytes32` elements to be sorted.\n * @return The sorted array of `bytes32` elements.\n *\n * Steps:\n * 1. Convert the `bytes32` array to a `uint256` array using `_castToUint256Array`.\n * 2. Sort the `uint256` array using the `Comparators.lt` (less than) comparator.\n * 3. Return the sorted `bytes32` array.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/Strings.sol": [
        {
            "identifier": "toString",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            assembly (\"memory-safe\") {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                assembly (\"memory-safe\") {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }",
            "start": "37",
            "end": "55",
            "class": "Strings",
            "signature": "returns (string memory) toStringuint256 value",
            "full_signature": "function toString(uint256 value) internal  pure returns (string memory)",
            "class_method_signature": "Strings.toStringuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "{'function log10(uint256 value) internal  pure returns (uint256)', 'function log10(uint256 value, Rounding rounding) internal  pure returns (uint256)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a `uint256` value to its ASCII `string` representation.\n *\n * @param value The `uint256` value to be converted to a string.\n * @return A string representation of the provided `uint256` value.\n *\n * Steps:\n * 1. Calculate the length of the string representation by taking the logarithm base 10 of the value and adding 1.\n * 2. Allocate a new string buffer with the calculated length.\n * 3. Use assembly to get a pointer to the end of the buffer.\n * 4. Loop through the value, converting each digit to its ASCII representation and storing it in the buffer.\n * 5. Decrement the pointer and divide the value by 10 in each iteration.\n * 6. Break the loop when the value becomes 0.\n * 7. Return the constructed string buffer.\n *\n * Note: This function uses unchecked arithmetic for gas optimization.\n */"
        },
        {
            "identifier": "toHexString",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }",
            "start": "67",
            "end": "71",
            "class": "Strings",
            "signature": "returns (string memory) toHexStringuint256 value",
            "full_signature": "function toHexString(uint256 value) internal  pure returns (string memory)",
            "class_method_signature": "Strings.toHexStringuint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "{'function log2(uint256 value) internal  pure returns (uint256)', 'function log256(uint256 x) internal  pure returns (uint256 r)', 'function log2(uint256 value, Rounding rounding) internal  pure returns (uint256)', 'function log256(uint256 value, Rounding rounding) internal  pure returns (uint256)', 'function log2(uint256 x) internal  pure returns (uint256 r)', 'function log256(uint256 value) internal  pure returns (uint256)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a hexadecimal string representation.\n *\n * @param value The uint256 value to be converted to a hexadecimal string.\n * @return A string representing the hexadecimal value of the input.\n *\n * Steps:\n * 1. Calculate the length of the hexadecimal string using `Math.log256(value) + 1`.\n * 2. Call the `toHexString` function with the value and the calculated length.\n * 3. Return the resulting hexadecimal string.\n *\n * Note: The function uses `unchecked` to avoid overflow checks, assuming the input is valid.\n */"
        },
        {
            "identifier": "toHexString",
            "parameters": "uint256 value, uint256 length",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }",
            "start": "76",
            "end": "89",
            "class": "Strings",
            "signature": "returns (string memory) toHexStringuint256 value, uint256 length",
            "full_signature": "function toHexString(uint256 value, uint256 length) internal  pure returns (string memory)",
            "class_method_signature": "Strings.toHexStringuint256 value, uint256 length",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a hexadecimal string representation with a specified length.\n *\n * @param value The uint256 value to be converted to a hexadecimal string.\n * @param length The desired length of the hexadecimal string (excluding the \"0x\" prefix).\n * @return A string representing the hexadecimal value of the input.\n *\n * Steps:\n * 1. Initialize a local copy of the input value.\n * 2. Create a byte array buffer to store the hexadecimal string, with a size of `2 * length + 2` (to account for the \"0x\" prefix).\n * 3. Set the first two bytes of the buffer to \"0x\".\n * 4. Iterate over the buffer from the end to the start, converting each nibble (4 bits) of the value to its corresponding hexadecimal character.\n * 5. Shift the local value right by 4 bits after each iteration.\n * 6. If the local value is not zero after the loop, revert with an error indicating insufficient length.\n * 7. Return the hexadecimal string representation of the value.\n */"
        },
        {
            "identifier": "toChecksumHexString",
            "parameters": "address addr",
            "modifiers": "pure",
            "return": "returns (string memory)",
            "body": "function toChecksumHexString(address addr) internal pure returns (string memory) {\n        bytes memory buffer = bytes(toHexString(addr));\n\n        // hash the hex part of buffer (skip length + 2 bytes, length 40)\n        uint256 hashValue;\n        assembly (\"memory-safe\") {\n            hashValue := shr(96, keccak256(add(buffer, 0x22), 40))\n        }\n\n        for (uint256 i = 41; i > 1; --i) {\n            // possible values for buffer[i] are 48 (0) to 57 (9) and 97 (a) to 102 (f)\n            if (hashValue & 0xf > 7 && uint8(buffer[i]) > 96) {\n                // case shift by xoring with 0x20\n                buffer[i] ^= 0x20;\n            }\n            hashValue >>= 4;\n        }\n        return string(buffer);\n    }",
            "start": "103",
            "end": "121",
            "class": "Strings",
            "signature": "returns (string memory) toChecksumHexStringaddress addr",
            "full_signature": "function toChecksumHexString(address addr) internal  pure returns (string memory)",
            "class_method_signature": "Strings.toChecksumHexStringaddress addr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an Ethereum address into a checksummed hexadecimal string.\n *\n * @dev This function ensures that the address string follows the EIP-55 checksum standard,\n * which helps prevent errors when manually entering addresses. The checksum is calculated\n * by hashing the address and using the hash to determine which characters should be uppercase.\n *\n * @param addr The Ethereum address to convert into a checksummed hexadecimal string.\n * @return A checksummed hexadecimal string representation of the address.\n *\n * Steps:\n * 1. Convert the address to a hexadecimal string.\n * 2. Hash the hexadecimal part of the string (excluding the \"0x\" prefix and length).\n * 3. Iterate through the hexadecimal string and adjust the case of characters based on the hash:\n *    - If the corresponding hash bit is greater than 7 and the character is lowercase, convert it to uppercase.\n * 4. Return the checksummed hexadecimal string.\n */"
        },
        {
            "identifier": "parseUint",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function parseUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }",
            "start": "149",
            "end": "153",
            "class": "Strings",
            "signature": "returns (uint256) parseUintstring memory input, uint256 begin, uint256 end",
            "full_signature": "function parseUint(string memory input, uint256 begin, uint256 end) internal  pure returns (uint256)",
            "class_method_signature": "Strings.parseUintstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a substring of a string into a `uint256` value.\n *\n * @param input The string from which to parse the substring.\n * @param begin The starting index of the substring to parse.\n * @param end The ending index of the substring to parse.\n *\n * @return The parsed `uint256` value.\n *\n * Steps:\n * 1. Attempt to parse the substring using `tryParseUint`.\n * 2. If parsing fails, revert with the error `StringsInvalidChar`.\n * 3. Return the parsed `uint256` value if successful.\n */"
        },
        {
            "identifier": "parseInt",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function parseInt(string memory input, uint256 begin, uint256 end) internal pure returns (int256) {\n        (bool success, int256 value) = tryParseInt(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }",
            "start": "219",
            "end": "223",
            "class": "Strings",
            "signature": "returns (int256) parseIntstring memory input, uint256 begin, uint256 end",
            "full_signature": "function parseInt(string memory input, uint256 begin, uint256 end) internal  pure returns (int256)",
            "class_method_signature": "Strings.parseIntstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a string into an integer within a specified range.\n *\n * @param input The string to parse.\n * @param begin The starting index of the substring to parse.\n * @param end The ending index of the substring to parse.\n * @return The parsed integer value.\n *\n * Steps:\n * 1. Attempt to parse the substring from `begin` to `end` in the input string into an integer using `tryParseInt`.\n * 2. If parsing fails, revert with the error \"StringsInvalidChar\".\n * 3. Return the parsed integer value if successful.\n */ "
        },
        {
            "identifier": "parseHexUint",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function parseHexUint(string memory input, uint256 begin, uint256 end) internal pure returns (uint256) {\n        (bool success, uint256 value) = tryParseHexUint(input, begin, end);\n        if (!success) revert StringsInvalidChar();\n        return value;\n    }",
            "start": "297",
            "end": "301",
            "class": "Strings",
            "signature": "returns (uint256) parseHexUintstring memory input, uint256 begin, uint256 end",
            "full_signature": "function parseHexUint(string memory input, uint256 begin, uint256 end) internal  pure returns (uint256)",
            "class_method_signature": "Strings.parseHexUintstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a hexadecimal string into a uint256 value within a specified range.\n *\n * @param input The hexadecimal string to parse.\n * @param begin The starting index (inclusive) of the substring to parse.\n * @param end The ending index (exclusive) of the substring to parse.\n * @return The parsed uint256 value.\n *\n * Steps:\n * 1. Attempt to parse the hexadecimal substring using `tryParseHexUint`.\n * 2. If parsing fails, revert with the error `StringsInvalidChar`.\n * 3. Return the parsed uint256 value.\n */"
        },
        {
            "identifier": "tryParseHexUint",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 value)",
            "body": "function tryParseHexUint(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, uint256 value) {\n        if (end > bytes(input).length || begin > end) return (false, 0);\n        return _tryParseHexUintUncheckedBounds(input, begin, end);\n    }",
            "start": "318",
            "end": "325",
            "class": "Strings",
            "signature": "returns (bool success, uint256 value) tryParseHexUintstring memory input, uint256 begin, uint256 end",
            "full_signature": "function tryParseHexUint(string memory input, uint256 begin, uint256 end) internal  pure returns (bool success, uint256 value)",
            "class_method_signature": "Strings.tryParseHexUintstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to parse a hexadecimal string into a uint256 value within specified bounds.\n *\n * @param input The input string containing the hexadecimal value.\n * @param begin The starting index (inclusive) of the hexadecimal substring to parse.\n * @param end The ending index (exclusive) of the hexadecimal substring to parse.\n *\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed uint256 value if successful, otherwise 0.\n *\n * Steps:\n * 1. Check if the provided `end` index is out of bounds or if `begin` is greater than `end`.\n *    - If true, return `(false, 0)`.\n * 2. Otherwise, call the internal `_tryParseHexUintUncheckedBounds` function to parse the hexadecimal substring.\n * 3. Return the result of the parsing attempt.\n */"
        },
        {
            "identifier": "parseAddress",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (address)",
            "body": "function parseAddress(string memory input, uint256 begin, uint256 end) internal pure returns (address) {\n        (bool success, address value) = tryParseAddress(input, begin, end);\n        if (!success) revert StringsInvalidAddressFormat();\n        return value;\n    }",
            "start": "373",
            "end": "377",
            "class": "Strings",
            "signature": "returns (address) parseAddressstring memory input, uint256 begin, uint256 end",
            "full_signature": "function parseAddress(string memory input, uint256 begin, uint256 end) internal  pure returns (address)",
            "class_method_signature": "Strings.parseAddressstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a string input to extract an Ethereum address within the specified range.\n *\n * @param input The string containing the address to be parsed.\n * @param begin The starting index in the string where the address extraction should begin.\n * @param end The ending index in the string where the address extraction should end.\n *\n * @return The parsed Ethereum address.\n *\n * Steps:\n * 1. Attempt to parse the address from the input string within the specified range using `tryParseAddress`.\n * 2. If parsing fails, revert with the error \"StringsInvalidAddressFormat\".\n * 3. Return the successfully parsed address.\n */"
        },
        {
            "identifier": "tryParseAddress",
            "parameters": "string memory input, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (bool success, address value)",
            "body": "function tryParseAddress(\n        string memory input,\n        uint256 begin,\n        uint256 end\n    ) internal pure returns (bool success, address value) {\n        if (end > bytes(input).length || begin > end) return (false, address(0));\n\n        bool hasPrefix = (end > begin + 1) && bytes2(_unsafeReadBytesOffset(bytes(input), begin)) == bytes2(\"0x\"); // don't do out-of-bound (possibly unsafe) read if sub-string is empty\n        uint256 expectedLength = 40 + hasPrefix.toUint() * 2;\n\n        // check that input is the correct length\n        if (end - begin == expectedLength) {\n            // length guarantees that this does not overflow, and value is at most type(uint160).max\n            (bool s, uint256 v) = _tryParseHexUintUncheckedBounds(input, begin, end);\n            return (s, address(uint160(v)));\n        } else {\n            return (false, address(0));\n        }\n    }",
            "start": "391",
            "end": "409",
            "class": "Strings",
            "signature": "returns (bool success, address value) tryParseAddressstring memory input, uint256 begin, uint256 end",
            "full_signature": "function tryParseAddress(string memory input, uint256 begin, uint256 end) internal  pure returns (bool success, address value)",
            "class_method_signature": "Strings.tryParseAddressstring memory input, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"./math/Math.sol\";",
                "import {SafeCast} from \"./math/SafeCast.sol\";",
                "import {SignedMath} from \"./math/SignedMath.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)', 'function max(uint256 a, uint256 b) internal  pure returns (uint256)', 'function max(int256 a, int256 b) internal  pure returns (int256)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to parse an Ethereum address from a substring within a given input string.\n *\n * @param input The input string containing the potential address.\n * @param begin The starting index of the substring within the input string.\n * @param end The ending index of the substring within the input string.\n * @return success A boolean indicating whether the parsing was successful.\n * @return value The parsed address if successful, otherwise `address(0)`.\n *\n * Steps:\n * 1. Check if the provided `begin` and `end` indices are valid within the input string.\n *    - If not, return `(false, address(0))`.\n * 2. Determine if the substring has a \"0x\" prefix.\n *    - This is done by checking the first two characters of the substring.\n * 3. Calculate the expected length of the address substring based on whether it has a prefix.\n *    - 40 characters for the address + 2 characters for the \"0x\" prefix if present.\n * 4. Verify that the substring length matches the expected length.\n *    - If it does, attempt to parse the substring as a hexadecimal number.\n *    - If successful, convert the parsed number to an address and return it.\n *    - If not, return `(false, address(0))`.\n * 5. If the substring length does not match the expected length, return `(false, address(0))`.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/cryptography/P256.sol": [
        {
            "identifier": "verify",
            "parameters": "bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function verify(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal view returns (bool) {\n        (bool valid, bool supported) = _tryVerifyNative(h, r, s, qx, qy);\n        return supported ? valid : verifySolidity(h, r, s, qx, qy);\n    }",
            "start": "61",
            "end": "64",
            "class": "P256",
            "signature": "returns (bool) verifybytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "full_signature": "function verify(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal  view returns (bool)",
            "class_method_signature": "P256.verifybytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Verifies a signature using either native or Solidity-based verification.\n *\n * @param h The hash of the message to be verified.\n * @param r The `r` component of the signature.\n * @param s The `s` component of the signature.\n * @param qx The x-coordinate of the public key.\n * @param qy The y-coordinate of the public key.\n * @return bool Returns `true` if the signature is valid, otherwise `false`.\n *\n * Steps:\n * 1. Attempt to verify the signature using native verification (`_tryVerifyNative`).\n * 2. If native verification is supported, return its result.\n * 3. If native verification is not supported, fall back to Solidity-based verification (`verifySolidity`).\n */"
        },
        {
            "identifier": "verifySolidity",
            "parameters": "bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function verifySolidity(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal view returns (bool) {\n        if (!_isProperSignature(r, s) || !isValidPublicKey(qx, qy)) {\n            return false;\n        }\n\n        JPoint[16] memory points = _preComputeJacobianPoints(uint256(qx), uint256(qy));\n        uint256 w = Math.invModPrime(uint256(s), N);\n        uint256 u1 = mulmod(uint256(h), w, N);\n        uint256 u2 = mulmod(uint256(r), w, N);\n        (uint256 x, ) = _jMultShamir(points, u1, u2);\n        return ((x % N) == uint256(r));\n    }",
            "start": "102",
            "end": "113",
            "class": "P256",
            "signature": "returns (bool) verifySoliditybytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "full_signature": "function verifySolidity(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal  view returns (bool)",
            "class_method_signature": "P256.verifySoliditybytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "{'function invModPrime(uint256 a, uint256 p) internal  view returns (uint256)', 'function invMod(uint256 a, uint256 n) internal  pure returns (uint256)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a Solidity-compatible ECDSA signature using the provided hash, signature components, and public key coordinates.\n *\n * @param h The hash of the message to be verified.\n * @param r The `r` component of the ECDSA signature.\n * @param s The `s` component of the ECDSA signature.\n * @param qx The x-coordinate of the public key.\n * @param qy The y-coordinate of the public key.\n *\n * @return bool Returns `true` if the signature is valid, otherwise `false`.\n *\n * Steps:\n * 1. Check if the signature components (`r` and `s`) are valid using `_isProperSignature`.\n * 2. Check if the public key coordinates (`qx` and `qy`) are valid using `isValidPublicKey`.\n * 3. If either check fails, return `false`.\n *\n * 4. Precompute Jacobian points for the public key coordinates.\n * 5. Compute the modular inverse of `s` modulo the curve order `N`.\n * 6. Calculate `u1` as the product of the hash `h` and the modular inverse `w`, modulo `N`.\n * 7. Calculate `u2` as the product of `r` and the modular inverse `w`, modulo `N`.\n * 8. Use the precomputed Jacobian points and `u1`, `u2` to compute the x-coordinate of the resulting point.\n * 9. Compare the computed x-coordinate modulo `N` with `r`. If they match, the signature is valid.\n */"
        },
        {
            "identifier": "recovery",
            "parameters": "bytes32 h, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "view",
            "return": "returns (bytes32 x, bytes32 y)",
            "body": "function recovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) internal view returns (bytes32 x, bytes32 y) {\n        if (!_isProperSignature(r, s) || v > 1) {\n            return (0, 0);\n        }\n\n        uint256 p = P; // cache P on the stack\n        uint256 rx = uint256(r);\n        uint256 ry2 = addmod(mulmod(addmod(mulmod(rx, rx, p), A, p), rx, p), B, p); // weierstrass equation y\u00b2 = x\u00b3 + a.x + b\n        uint256 ry = Math.modExp(ry2, P1DIV4, p); // This formula for sqrt work because P \u2261 3 (mod 4)\n        if (mulmod(ry, ry, p) != ry2) return (0, 0); // Sanity check\n        if (ry % 2 != v) ry = p - ry;\n\n        JPoint[16] memory points = _preComputeJacobianPoints(rx, ry);\n        uint256 w = Math.invModPrime(uint256(r), N);\n        uint256 u1 = mulmod(N - (uint256(h) % N), w, N);\n        uint256 u2 = mulmod(uint256(s), w, N);\n        (uint256 xU, uint256 yU) = _jMultShamir(points, u1, u2);\n        return (bytes32(xU), bytes32(yU));\n    }",
            "start": "126",
            "end": "144",
            "class": "P256",
            "signature": "returns (bytes32 x, bytes32 y) recoverybytes32 h, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function recovery(bytes32 h, uint8 v, bytes32 r, bytes32 s) internal  view returns (bytes32 x, bytes32 y)",
            "class_method_signature": "P256.recoverybytes32 h, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {Errors} from \"../Errors.sol\";"
            ],
            "context": "{'function invModPrime(uint256 a, uint256 p) internal  view returns (uint256)', 'function invMod(uint256 a, uint256 n) internal  pure returns (uint256)', 'function modExp(bytes memory b, bytes memory e, bytes memory m) internal  view returns (bytes memory)', 'function sqrt(uint256 a) internal  pure returns (uint256)', 'function sqrt(uint256 a, Rounding rounding) internal  pure returns (uint256)', 'function modExp(uint256 b, uint256 e, uint256 m) internal  view returns (uint256)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Recovers the public key coordinates (x, y) from a given signature and hash using elliptic curve cryptography.\n *\n * @param h The hash of the message that was signed.\n * @param v The recovery byte of the signature (must be 0 or 1).\n * @param r The r component of the ECDSA signature.\n * @param s The s component of the ECDSA signature.\n * @return x The x-coordinate of the recovered public key.\n * @return y The y-coordinate of the recovered public key.\n *\n * Steps:\n * 1. Check if the signature components (r, s) are valid and if the recovery byte (v) is within the allowed range (0 or 1).\n *    If not, return (0, 0).\n * 2. Compute the y-coordinate of the point on the elliptic curve using the Weierstrass equation: y\u00b2 = x\u00b3 + a.x + b.\n * 3. Use modular exponentiation to compute the square root of the y\u00b2 value, ensuring it satisfies the curve equation.\n * 4. Perform a sanity check to ensure the computed y-coordinate is valid.\n * 5. Adjust the y-coordinate based on the recovery byte (v) to ensure it matches the correct parity.\n * 6. Precompute Jacobian points for efficient scalar multiplication.\n * 7. Compute the modular inverse of the r component.\n * 8. Calculate the intermediate values u1 and u2 using the hash, signature components, and modular arithmetic.\n * 9. Perform scalar multiplication using the precomputed Jacobian points and the intermediate values to recover the public key coordinates.\n * 10. Return the recovered public key coordinates (x, y).\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/math/Math.sol": [
        {
            "identifier": "tryMul",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 result)",
            "body": "function tryMul(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }",
            "start": "44",
            "end": "54",
            "class": "Math",
            "signature": "returns (bool success, uint256 result) tryMuluint256 a, uint256 b",
            "full_signature": "function tryMul(uint256 a, uint256 b) internal  pure returns (bool success, uint256 result)",
            "class_method_signature": "Math.tryMuluint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Safely multiplies two unsigned integers and returns the result along with a success flag.\n *\n * @dev This function uses unchecked arithmetic to optimize gas usage. It checks for overflow by verifying\n *      that the product divided by the first operand equals the second operand. If overflow occurs, it\n *      returns `false` and `0`. If the first operand is `0`, it immediately returns `true` and `0`.\n *\n * @param a The first unsigned integer to multiply.\n * @param b The second unsigned integer to multiply.\n *\n * @return success A boolean indicating whether the multiplication was successful (true) or overflowed (false).\n * @return result The result of the multiplication if successful, otherwise `0`.\n *\n * Steps:\n * 1. If `a` is `0`, return `(true, 0)` since any number multiplied by `0` is `0`.\n * 2. Multiply `a` and `b` and store the result in `c`.\n * 3. Check for overflow by verifying if `c / a` equals `b`. If not, return `(false, 0)`.\n * 4. If no overflow, return `(true, c)`.\n */"
        },
        {
            "identifier": "tryMod",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (bool success, uint256 result)",
            "body": "function tryMod(uint256 a, uint256 b) internal pure returns (bool success, uint256 result) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }",
            "start": "69",
            "end": "74",
            "class": "Math",
            "signature": "returns (bool success, uint256 result) tryModuint256 a, uint256 b",
            "full_signature": "function tryMod(uint256 a, uint256 b) internal  pure returns (bool success, uint256 result)",
            "class_method_signature": "Math.tryModuint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to perform a modulo operation on two unsigned integers.\n * \n * @param a The dividend in the modulo operation.\n * @param b The divisor in the modulo operation.\n * \n * @return success A boolean indicating whether the modulo operation was successful (true if `b` is not zero).\n * @return result The result of the modulo operation (`a % b`), or 0 if `b` is zero.\n * \n * Steps:\n * 1. Check if `b` is zero.\n *    - If `b` is zero, return `(false, 0)` to indicate failure.\n * 2. If `b` is not zero, return `(true, a % b)` to indicate success and the result of the modulo operation.\n * \n * Note: The function uses `unchecked` to disable overflow checks, which is safe since the modulo operation\n * does not involve arithmetic that could overflow.\n */"
        },
        {
            "identifier": "ternary",
            "parameters": "bool condition, uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function ternary(bool condition, uint256 a, uint256 b) internal pure returns (uint256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * SafeCast.toUint(condition));\n        }\n    }",
            "start": "83",
            "end": "90",
            "class": "Math",
            "signature": "returns (uint256) ternarybool condition, uint256 a, uint256 b",
            "full_signature": "function ternary(bool condition, uint256 a, uint256 b) internal  pure returns (uint256)",
            "class_method_signature": "Math.ternarybool condition, uint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A branchless ternary function that returns one of two values based on a condition.\n *\n * @param condition A boolean condition that determines which value to return.\n * @param a The value to return if the condition is true.\n * @param b The value to return if the condition is false.\n * @return The result of the ternary operation, either `a` or `b`.\n *\n * Details:\n * - The function uses bitwise operations to achieve a branchless ternary operation.\n * - If `condition` is true, the function returns `a`.\n * - If `condition` is false, the function returns `b`.\n * - The operation is performed in an `unchecked` block to avoid overflow checks.\n * - The logic works as follows:\n *   - `b ^ ((a ^ b) * SafeCast.toUint(condition))`:\n *     - If `condition` is true, `SafeCast.toUint(condition)` returns 1, so the result is `b ^ (a ^ b) = a`.\n *     - If `condition` is false, `SafeCast.toUint(condition)` returns 0, so the result is `b ^ 0 = b`.\n */"
        },
        {
            "identifier": "ceilDiv",
            "parameters": "uint256 a, uint256 b",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n\n        // The following calculation ensures accurate ceiling division without overflow.\n        // Since a is non-zero, (a - 1) / b will not overflow.\n        // The largest possible result occurs when (a - 1) / b is type(uint256).max,\n        // but the largest value we can obtain is type(uint256).max - 1, which happens\n        // when a = type(uint256).max and b = 1.\n        unchecked {\n            return SafeCast.toUint(a > 0) * ((a - 1) / b + 1);\n        }\n    }",
            "start": "121",
            "end": "135",
            "class": "Math",
            "signature": "returns (uint256) ceilDivuint256 a, uint256 b",
            "full_signature": "function ceilDiv(uint256 a, uint256 b) internal  pure returns (uint256)",
            "class_method_signature": "Math.ceilDivuint256 a, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)', 'uint256 internal constant DIVISION_BY_ZERO', 'function panic(uint256 code) internal  pure'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs ceiling division of two unsigned integers.\n *\n * @param a The dividend.\n * @param b The divisor.\n * @return The result of the ceiling division of `a` by `b`.\n *\n * Steps:\n * 1. Check if `b` is zero. If true, revert with a division by zero error.\n * 2. Perform the ceiling division calculation:\n *    - Subtract 1 from `a` and divide by `b`.\n *    - Add 1 to the result to ensure the ceiling effect.\n *    - Multiply by `SafeCast.toUint(a > 0)` to handle the case where `a` is zero.\n * 3. The calculation is performed in an unchecked block to avoid overflow checks.\n *\n * Note: This function ensures accurate ceiling division without overflow, even for large values of `a` and `b`.\n */"
        },
        {
            "identifier": "mulDiv",
            "parameters": "uint256 x, uint256 y, uint256 denominator",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2\u00b2\u2075\u2076 and mod 2\u00b2\u2075\u2076 - 1, then use\n            // the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2\u00b2\u2075\u2076 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2\u00b2\u2075\u2076. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                Panic.panic(ternary(denominator == 0, Panic.DIVISION_BY_ZERO, Panic.UNDER_OVERFLOW));\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2\u00b2\u2075\u2076 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2\u00b2\u2075\u2076. Now that denominator is an odd number, it has an inverse modulo 2\u00b2\u2075\u2076 such\n            // that denominator * inv \u2261 1 mod 2\u00b2\u2075\u2076. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv \u2261 1 mod 2\u2074.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u2078\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b9\u2076\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b3\u00b2\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u2076\u2074\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b9\u00b2\u2078\n            inverse *= 2 - denominator * inverse; // inverse mod 2\u00b2\u2075\u2076\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2\u00b2\u2075\u2076. Since the preconditions guarantee that the outcome is\n            // less than 2\u00b2\u2075\u2076, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }",
            "start": "144",
            "end": "223",
            "class": "Math",
            "signature": "returns (uint256 result) mulDivuint256 x, uint256 y, uint256 denominator",
            "full_signature": "function mulDiv(uint256 x, uint256 y, uint256 denominator) internal  pure returns (uint256 result)",
            "class_method_signature": "Math.mulDivuint256 x, uint256 y, uint256 denominator",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'uint256 internal constant UNDER_OVERFLOW', 'uint256 internal constant DIVISION_BY_ZERO', 'function panic(uint256 code) internal  pure'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a multiplication and division operation on three unsigned integers (x, y, denominator) \n *         with precision and safety checks. The function ensures that the result is accurate and handles \n *         edge cases such as division by zero or overflow.\n *\n * @param x The multiplicand.\n * @param y The multiplier.\n * @param denominator The divisor.\n * @return result The result of the operation (x * y) / denominator.\n *\n * Steps:\n * 1. Compute the product of x and y, splitting it into two 256-bit parts (prod0 and prod1).\n * 2. Handle non-overflow cases where prod1 is zero by directly dividing prod0 by the denominator.\n * 3. Check for invalid cases where the denominator is zero or less than prod1, and revert with an appropriate error.\n * 4. Perform 512-bit by 256-bit division to ensure precision:\n *    - Subtract the remainder from the product to make the division exact.\n *    - Factor out powers of two from the denominator and adjust the product accordingly.\n * 5. Compute the modular inverse of the denominator using the Newton-Raphson method for high precision.\n * 6. Multiply the adjusted product by the modular inverse to get the final result.\n * 7. Return the result, ensuring it is accurate and within the bounds of 256 bits.\n *\n * Notes:\n * - The function uses assembly for low-level operations to optimize gas usage and ensure precision.\n * - It handles edge cases such as division by zero and overflow gracefully by reverting with appropriate errors.\n */"
        },
        {
            "identifier": "invMod",
            "parameters": "uint256 a, uint256 n",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function invMod(uint256 a, uint256 n) internal pure returns (uint256) {\n        unchecked {\n            if (n == 0) return 0;\n\n            // The inverse modulo is calculated using the Extended Euclidean Algorithm (iterative version)\n            // Used to compute integers x and y such that: ax + ny = gcd(a, n).\n            // When the gcd is 1, then the inverse of a modulo n exists and it's x.\n            // ax + ny = 1\n            // ax = 1 + (-y)n\n            // ax \u2261 1 (mod n) # x is the inverse of a modulo n\n\n            // If the remainder is 0 the gcd is n right away.\n            uint256 remainder = a % n;\n            uint256 gcd = n;\n\n            // Therefore the initial coefficients are:\n            // ax + ny = gcd(a, n) = n\n            // 0a + 1n = n\n            int256 x = 0;\n            int256 y = 1;\n\n            while (remainder != 0) {\n                uint256 quotient = gcd / remainder;\n\n                (gcd, remainder) = (\n                    // The old remainder is the next gcd to try.\n                    remainder,\n                    // Compute the next remainder.\n                    // Can't overflow given that (a % gcd) * (gcd // (a % gcd)) <= gcd\n                    // where gcd is at most n (capped to type(uint256).max)\n                    gcd - remainder * quotient\n                );\n\n                (x, y) = (\n                    // Increment the coefficient of a.\n                    y,\n                    // Decrement the coefficient of n.\n                    // Can overflow, but the result is casted to uint256 so that the\n                    // next value of y is \"wrapped around\" to a value between 0 and n - 1.\n                    x - y * int256(quotient)\n                );\n            }\n\n            if (gcd != 1) return 0; // No inverse exists.\n            return ternary(x < 0, n - uint256(-x), uint256(x)); // Wrap the result if it's negative.\n        }\n    }",
            "start": "243",
            "end": "289",
            "class": "Math",
            "signature": "returns (uint256) invModuint256 a, uint256 n",
            "full_signature": "function invMod(uint256 a, uint256 n) internal  pure returns (uint256)",
            "class_method_signature": "Math.invModuint256 a, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the modular inverse of `a` modulo `n` using the Extended Euclidean Algorithm.\n *\n * @param a The number for which the modular inverse is to be computed.\n * @param n The modulus.\n * @return The modular inverse of `a` modulo `n`. Returns 0 if no inverse exists (i.e., if `gcd(a, n) != 1`).\n *\n * Steps:\n * 1. Check if `n` is 0. If so, return 0 immediately as no inverse exists.\n * 2. Initialize variables for the Extended Euclidean Algorithm:\n *    - `remainder` as `a % n`.\n *    - `gcd` as `n`.\n *    - Coefficients `x` and `y` initialized to 0 and 1, respectively.\n * 3. Iterate while `remainder` is not 0:\n *    - Compute the quotient `gcd / remainder`.\n *    - Update `gcd` and `remainder` for the next iteration.\n *    - Update coefficients `x` and `y` to maintain the equation `ax + ny = gcd`.\n * 4. If `gcd` is not 1, return 0 (no inverse exists).\n * 5. If the result `x` is negative, wrap it around to a positive value within the range `[0, n-1]`.\n * 6. Return the computed modular inverse.\n */"
        },
        {
            "identifier": "modExp",
            "parameters": "uint256 b, uint256 e, uint256 m",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function modExp(uint256 b, uint256 e, uint256 m) internal view returns (uint256) {\n        (bool success, uint256 result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }",
            "start": "319",
            "end": "325",
            "class": "Math",
            "signature": "returns (uint256) modExpuint256 b, uint256 e, uint256 m",
            "full_signature": "function modExp(uint256 b, uint256 e, uint256 m) internal  view returns (uint256)",
            "class_method_signature": "Math.modExpuint256 b, uint256 e, uint256 m",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'uint256 internal constant DIVISION_BY_ZERO', 'function panic(uint256 code) internal  pure'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the modular exponentiation of `b^e % m` using the `tryModExp` function.\n * \n * @param b The base value for the exponentiation.\n * @param e The exponent value.\n * @param m The modulus value.\n * \n * @return result The result of the modular exponentiation `b^e % m`.\n * \n * Steps:\n * 1. Attempt to compute the modular exponentiation using `tryModExp`.\n * 2. If the computation fails (e.g., due to division by zero), trigger a panic with the `Panic.DIVISION_BY_ZERO` error.\n * 3. Return the computed result if successful.\n */"
        },
        {
            "identifier": "tryModExp",
            "parameters": "uint256 b, uint256 e, uint256 m",
            "modifiers": "view",
            "return": "returns (bool success, uint256 result)",
            "body": "function tryModExp(uint256 b, uint256 e, uint256 m) internal view returns (bool success, uint256 result) {\n        if (m == 0) return (false, 0);\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            // | Offset    | Content    | Content (Hex)                                                      |\n            // |-----------|------------|--------------------------------------------------------------------|\n            // | 0x00:0x1f | size of b  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x20:0x3f | size of e  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x40:0x5f | size of m  | 0x0000000000000000000000000000000000000000000000000000000000000020 |\n            // | 0x60:0x7f | value of b | 0x<.............................................................b> |\n            // | 0x80:0x9f | value of e | 0x<.............................................................e> |\n            // | 0xa0:0xbf | value of m | 0x<.............................................................m> |\n            mstore(ptr, 0x20)\n            mstore(add(ptr, 0x20), 0x20)\n            mstore(add(ptr, 0x40), 0x20)\n            mstore(add(ptr, 0x60), b)\n            mstore(add(ptr, 0x80), e)\n            mstore(add(ptr, 0xa0), m)\n\n            // Given the result < m, it's guaranteed to fit in 32 bytes,\n            // so we can use the memory scratch space located at offset 0.\n            success := staticcall(gas(), 0x05, ptr, 0xc0, 0x00, 0x20)\n            result := mload(0x00)\n        }\n    }",
            "start": "337",
            "end": "361",
            "class": "Math",
            "signature": "returns (bool success, uint256 result) tryModExpuint256 b, uint256 e, uint256 m",
            "full_signature": "function tryModExp(uint256 b, uint256 e, uint256 m) internal  view returns (bool success, uint256 result)",
            "class_method_signature": "Math.tryModExpuint256 b, uint256 e, uint256 m",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to compute the modular exponentiation of `b^e % m` using inline assembly.\n * \n * @param b The base value for the exponentiation.\n * @param e The exponent value.\n * @param m The modulus value.\n * \n * @return success A boolean indicating whether the operation was successful.\n * @return result The result of the modular exponentiation if successful, otherwise 0.\n * \n * Steps:\n * 1. Check if the modulus `m` is zero. If true, return `(false, 0)` immediately.\n * 2. Use inline assembly to perform the following:\n *    a. Load the free memory pointer.\n *    b. Store the sizes of `b`, `e`, and `m` (each 32 bytes) in memory.\n *    c. Store the values of `b`, `e`, and `m` in memory at specific offsets.\n *    d. Perform a static call to the precompiled contract at address `0x05` (modular exponentiation).\n *    e. Retrieve the result from memory and return it along with the success status.\n */"
        },
        {
            "identifier": "modExp",
            "parameters": "bytes memory b, bytes memory e, bytes memory m",
            "modifiers": "view",
            "return": "returns (bytes memory)",
            "body": "function modExp(bytes memory b, bytes memory e, bytes memory m) internal view returns (bytes memory) {\n        (bool success, bytes memory result) = tryModExp(b, e, m);\n        if (!success) {\n            Panic.panic(Panic.DIVISION_BY_ZERO);\n        }\n        return result;\n    }",
            "start": "366",
            "end": "372",
            "class": "Math",
            "signature": "returns (bytes memory) modExpbytes memory b, bytes memory e, bytes memory m",
            "full_signature": "function modExp(bytes memory b, bytes memory e, bytes memory m) internal  view returns (bytes memory)",
            "class_method_signature": "Math.modExpbytes memory b, bytes memory e, bytes memory m",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'uint256 internal constant DIVISION_BY_ZERO', 'function panic(uint256 code) internal  pure'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes modular exponentiation for given base, exponent, and modulus.\n *\n * @param b The base value as a byte array.\n * @param e The exponent value as a byte array.\n * @param m The modulus value as a byte array.\n * @return result The result of the modular exponentiation as a byte array.\n *\n * Steps:\n * 1. Attempt to compute the modular exponentiation using `tryModExp`.\n * 2. If the computation fails (e.g., due to division by zero), trigger a panic with the `Panic.DIVISION_BY_ZERO` error.\n * 3. Return the result of the successful computation.\n */"
        },
        {
            "identifier": "tryModExp",
            "parameters": "bytes memory b, bytes memory e, bytes memory m",
            "modifiers": "view",
            "return": "returns (bool success, bytes memory result)",
            "body": "function tryModExp(\n        bytes memory b,\n        bytes memory e,\n        bytes memory m\n    ) internal view returns (bool success, bytes memory result) {\n        if (_zeroBytes(m)) return (false, new bytes(0));\n\n        uint256 mLen = m.length;\n\n        // Encode call args in result and move the free memory pointer\n        result = abi.encodePacked(b.length, e.length, mLen, b, e, m);\n\n        assembly (\"memory-safe\") {\n            let dataPtr := add(result, 0x20)\n            // Write result on top of args to avoid allocating extra memory.\n            success := staticcall(gas(), 0x05, dataPtr, mload(result), dataPtr, mLen)\n            // Overwrite the length.\n            // result.length > returndatasize() is guaranteed because returndatasize() == m.length\n            mstore(result, mLen)\n            // Set the memory pointer after the returned data.\n            mstore(0x40, add(dataPtr, mLen))\n        }\n    }",
            "start": "377",
            "end": "399",
            "class": "Math",
            "signature": "returns (bool success, bytes memory result) tryModExpbytes memory b, bytes memory e, bytes memory m",
            "full_signature": "function tryModExp(bytes memory b, bytes memory e, bytes memory m) internal  view returns (bool success, bytes memory result)",
            "class_method_signature": "Math.tryModExpbytes memory b, bytes memory e, bytes memory m",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to perform modular exponentiation using the provided base, exponent, and modulus.\n *\n * @param b The base value as a byte array.\n * @param e The exponent value as a byte array.\n * @param m The modulus value as a byte array.\n *\n * @return success A boolean indicating whether the operation was successful.\n * @return result The result of the modular exponentiation as a byte array, or an empty byte array if the operation failed.\n *\n * Steps:\n * 1. Check if the modulus `m` is zero. If true, return `false` and an empty byte array.\n * 2. Calculate the length of the modulus `m`.\n * 3. Encode the lengths of `b`, `e`, and `m` along with their values into a single byte array (`result`).\n * 4. Use inline assembly to perform the modular exponentiation:\n *    - Load the encoded data into memory.\n *    - Call the `staticcall` precompiled contract (address `0x05`) to perform the operation.\n *    - Overwrite the result length to match the modulus length.\n *    - Adjust the free memory pointer to account for the returned data.\n */"
        },
        {
            "identifier": "sqrt",
            "parameters": "uint256 a",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function sqrt(uint256 a) internal pure returns (uint256) {\n        unchecked {\n            // Take care of easy edge cases when a == 0 or a == 1\n            if (a <= 1) {\n                return a;\n            }\n\n            // In this function, we use Newton's method to get a root of `f(x) := x\u00b2 - a`. It involves building a\n            // sequence x_n that converges toward sqrt(a). For each iteration x_n, we also define the error between\n            // the current value as `\u03b5_n = | x_n - sqrt(a) |`.\n            //\n            // For our first estimation, we consider `e` the smallest power of 2 which is bigger than the square root\n            // of the target. (i.e. `2**(e-1) \u2264 sqrt(a) < 2**e`). We know that `e \u2264 128` because `(2\u00b9\u00b2\u2078)\u00b2 = 2\u00b2\u2075\u2076` is\n            // bigger than any uint256.\n            //\n            // By noticing that\n            // `2**(e-1) \u2264 sqrt(a) < 2**e \u2192 (2**(e-1))\u00b2 \u2264 a < (2**e)\u00b2 \u2192 2**(2*e-2) \u2264 a < 2**(2*e)`\n            // we can deduce that `e - 1` is `log2(a) / 2`. We can thus compute `x_n = 2**(e-1)` using a method similar\n            // to the msb function.\n            uint256 aa = a;\n            uint256 xn = 1;\n\n            if (aa >= (1 << 128)) {\n                aa >>= 128;\n                xn <<= 64;\n            }\n            if (aa >= (1 << 64)) {\n                aa >>= 64;\n                xn <<= 32;\n            }\n            if (aa >= (1 << 32)) {\n                aa >>= 32;\n                xn <<= 16;\n            }\n            if (aa >= (1 << 16)) {\n                aa >>= 16;\n                xn <<= 8;\n            }\n            if (aa >= (1 << 8)) {\n                aa >>= 8;\n                xn <<= 4;\n            }\n            if (aa >= (1 << 4)) {\n                aa >>= 4;\n                xn <<= 2;\n            }\n            if (aa >= (1 << 2)) {\n                xn <<= 1;\n            }\n\n            // We now have x_n such that `x_n = 2**(e-1) \u2264 sqrt(a) < 2**e = 2 * x_n`. This implies \u03b5_n \u2264 2**(e-1).\n            //\n            // We can refine our estimation by noticing that the middle of that interval minimizes the error.\n            // If we move x_n to equal 2**(e-1) + 2**(e-2), then we reduce the error to \u03b5_n \u2264 2**(e-2).\n            // This is going to be our x_0 (and \u03b5_0)\n            xn = (3 * xn) >> 1; // \u03b5_0 := | x_0 - sqrt(a) | \u2264 2**(e-2)\n\n            // From here, Newton's method give us:\n            // x_{n+1} = (x_n + a / x_n) / 2\n            //\n            // One should note that:\n            // x_{n+1}\u00b2 - a = ((x_n + a / x_n) / 2)\u00b2 - a\n            //              = ((x_n\u00b2 + a) / (2 * x_n))\u00b2 - a\n            //              = (x_n\u2074 + 2 * a * x_n\u00b2 + a\u00b2) / (4 * x_n\u00b2) - a\n            //              = (x_n\u2074 + 2 * a * x_n\u00b2 + a\u00b2 - 4 * a * x_n\u00b2) / (4 * x_n\u00b2)\n            //              = (x_n\u2074 - 2 * a * x_n\u00b2 + a\u00b2) / (4 * x_n\u00b2)\n            //              = (x_n\u00b2 - a)\u00b2 / (2 * x_n)\u00b2\n            //              = ((x_n\u00b2 - a) / (2 * x_n))\u00b2\n            //              \u2265 0\n            // Which proves that for all n \u2265 1, sqrt(a) \u2264 x_n\n            //\n            // This gives us the proof of quadratic convergence of the sequence:\n            // \u03b5_{n+1} = | x_{n+1} - sqrt(a) |\n            //         = | (x_n + a / x_n) / 2 - sqrt(a) |\n            //         = | (x_n\u00b2 + a - 2*x_n*sqrt(a)) / (2 * x_n) |\n            //         = | (x_n - sqrt(a))\u00b2 / (2 * x_n) |\n            //         = | \u03b5_n\u00b2 / (2 * x_n) |\n            //         = \u03b5_n\u00b2 / | (2 * x_n) |\n            //\n            // For the first iteration, we have a special case where x_0 is known:\n            // \u03b5_1 = \u03b5_0\u00b2 / | (2 * x_0) |\n            //     \u2264 (2**(e-2))\u00b2 / (2 * (2**(e-1) + 2**(e-2)))\n            //     \u2264 2**(2*e-4) / (3 * 2**(e-1))\n            //     \u2264 2**(e-3) / 3\n            //     \u2264 2**(e-3-log2(3))\n            //     \u2264 2**(e-4.5)\n            //\n            // For the following iterations, we use the fact that, 2**(e-1) \u2264 sqrt(a) \u2264 x_n:\n            // \u03b5_{n+1} = \u03b5_n\u00b2 / | (2 * x_n) |\n            //         \u2264 (2**(e-k))\u00b2 / (2 * 2**(e-1))\n            //         \u2264 2**(2*e-2*k) / 2**e\n            //         \u2264 2**(e-2*k)\n            xn = (xn + a / xn) >> 1; // \u03b5_1 := | x_1 - sqrt(a) | \u2264 2**(e-4.5)  -- special case, see above\n            xn = (xn + a / xn) >> 1; // \u03b5_2 := | x_2 - sqrt(a) | \u2264 2**(e-9)    -- general case with k = 4.5\n            xn = (xn + a / xn) >> 1; // \u03b5_3 := | x_3 - sqrt(a) | \u2264 2**(e-18)   -- general case with k = 9\n            xn = (xn + a / xn) >> 1; // \u03b5_4 := | x_4 - sqrt(a) | \u2264 2**(e-36)   -- general case with k = 18\n            xn = (xn + a / xn) >> 1; // \u03b5_5 := | x_5 - sqrt(a) | \u2264 2**(e-72)   -- general case with k = 36\n            xn = (xn + a / xn) >> 1; // \u03b5_6 := | x_6 - sqrt(a) | \u2264 2**(e-144)  -- general case with k = 72\n\n            // Because e \u2264 128 (as discussed during the first estimation phase), we know have reached a precision\n            // \u03b5_6 \u2264 2**(e-144) < 1. Given we're operating on integers, then we can ensure that xn is now either\n            // sqrt(a) or sqrt(a) + 1.\n            return xn - SafeCast.toUint(xn > a / xn);\n        }\n    }",
            "start": "420",
            "end": "524",
            "class": "Math",
            "signature": "returns (uint256) sqrtuint256 a",
            "full_signature": "function sqrt(uint256 a) internal  pure returns (uint256)",
            "class_method_signature": "Math.sqrtuint256 a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the square root of a given unsigned integer `a` using Newton's method.\n *\n * @param a The unsigned integer for which the square root is to be computed.\n * @return The square root of `a`, rounded down to the nearest integer.\n *\n * Steps:\n * 1. Handle edge cases where `a` is 0 or 1, returning `a` directly.\n * 2. Use Newton's method to iteratively approximate the square root of `a`.\n * 3. Initialize `xn` (the initial guess) by finding the smallest power of 2 greater than the square root of `a`.\n * 4. Refine the initial guess by adjusting `xn` to minimize the error.\n * 5. Perform multiple iterations of Newton's method to converge towards the square root:\n *    - Each iteration updates `xn` using the formula: `xn = (xn + a / xn) >> 1`.\n *    - The error decreases quadratically with each iteration.\n * 6. After several iterations, the result is either the exact square root or the square root plus one.\n * 7. Return the final result, ensuring it is the largest integer less than or equal to the square root of `a`.\n *\n * Note: The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "sqrt",
            "parameters": "uint256 a, Rounding rounding",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && result * result < a);\n        }\n    }",
            "start": "529",
            "end": "534",
            "class": "Math",
            "signature": "returns (uint256) sqrtuint256 a, Rounding rounding",
            "full_signature": "function sqrt(uint256 a, Rounding rounding) internal  pure returns (uint256)",
            "class_method_signature": "Math.sqrtuint256 a, Rounding rounding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the square root of a given number `a` with optional rounding.\n *\n * @param a The number for which the square root is to be computed.\n * @param rounding The rounding mode to apply (e.g., round up or down).\n * @return The square root of `a`, rounded according to the specified rounding mode.\n *\n * Steps:\n * 1. Compute the square root of `a` using the `sqrt` function.\n * 2. If rounding is set to round up and the square of the result is less than `a`, increment the result by 1.\n * 3. Return the final result after applying the rounding logic.\n */"
        },
        {
            "identifier": "log2",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log2(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // If upper 8 bits of 16-bit half set, add 8 to result\n        r |= SafeCast.toUint((x >> r) > 0xff) << 3;\n        // If upper 4 bits of 8-bit half set, add 4 to result\n        r |= SafeCast.toUint((x >> r) > 0xf) << 2;\n\n        // Shifts value right by the current result and use it as an index into this lookup table:\n        //\n        // | x (4 bits) |  index  | table[index] = MSB position |\n        // |------------|---------|-----------------------------|\n        // |    0000    |    0    |        table[0] = 0         |\n        // |    0001    |    1    |        table[1] = 0         |\n        // |    0010    |    2    |        table[2] = 1         |\n        // |    0011    |    3    |        table[3] = 1         |\n        // |    0100    |    4    |        table[4] = 2         |\n        // |    0101    |    5    |        table[5] = 2         |\n        // |    0110    |    6    |        table[6] = 2         |\n        // |    0111    |    7    |        table[7] = 2         |\n        // |    1000    |    8    |        table[8] = 3         |\n        // |    1001    |    9    |        table[9] = 3         |\n        // |    1010    |   10    |        table[10] = 3        |\n        // |    1011    |   11    |        table[11] = 3        |\n        // |    1100    |   12    |        table[12] = 3        |\n        // |    1101    |   13    |        table[13] = 3        |\n        // |    1110    |   14    |        table[14] = 3        |\n        // |    1111    |   15    |        table[15] = 3        |\n        //\n        // The lookup table is represented as a 32-byte value with the MSB positions for 0-15 in the last 16 bytes.\n        assembly (\"memory-safe\") {\n            r := or(r, byte(shr(r, x), 0x0000010102020202030303030303030300000000000000000000000000000000))\n        }\n    }",
            "start": "540",
            "end": "579",
            "class": "Math",
            "signature": "returns (uint256 r) log2uint256 x",
            "full_signature": "function log2(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "Math.log2uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-2 logarithm of a given unsigned integer `x` using a bitwise approach.\n *\n * @param x The unsigned integer for which to compute the logarithm.\n * @return r The base-2 logarithm of `x`, rounded down to the nearest integer.\n *\n * Steps:\n * 1. Initialize `r` by checking if the upper 128 bits of `x` are set. If so, set `r` to 128.\n * 2. Check the upper 64 bits of the remaining 128-bit half. If set, add 64 to `r`.\n * 3. Check the upper 32 bits of the remaining 64-bit half. If set, add 32 to `r`.\n * 4. Check the upper 16 bits of the remaining 32-bit half. If set, add 16 to `r`.\n * 5. Check the upper 8 bits of the remaining 16-bit half. If set, add 8 to `r`.\n * 6. Check the upper 4 bits of the remaining 8-bit half. If set, add 4 to `r`.\n *\n * 7. Use the remaining 4 bits of `x` as an index into a lookup table to determine the final value of `r`.\n *    The lookup table is embedded in the assembly code and maps the 4-bit value to the corresponding MSB position.\n *\n * Assembly:\n * - The lookup table is represented as a 32-byte value, where the last 16 bytes contain the MSB positions for 0-15.\n * - The `byte` instruction is used to extract the appropriate value from the lookup table based on the shifted `x`.\n * - The result is combined with `r` using the `or` instruction to produce the final logarithm value.\n */"
        },
        {
            "identifier": "log2",
            "parameters": "uint256 value, Rounding rounding",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << result < value);\n        }\n    }",
            "start": "585",
            "end": "590",
            "class": "Math",
            "signature": "returns (uint256) log2uint256 value, Rounding rounding",
            "full_signature": "function log2(uint256 value, Rounding rounding) internal  pure returns (uint256)",
            "class_method_signature": "Math.log2uint256 value, Rounding rounding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-2 logarithm of a given value, with optional rounding.\n *\n * @param value The input value for which the base-2 logarithm is to be computed.\n * @param rounding The rounding mode to apply when computing the result.\n * @return The base-2 logarithm of the input value, adjusted according to the rounding mode.\n *\n * Steps:\n * 1. Compute the base-2 logarithm of the input value using the `log2` function.\n * 2. If rounding is set to round up and the result is not exact (i.e., `1 << result < value`),\n *    increment the result by 1.\n * 3. Return the final result, adjusted for rounding if necessary.\n *\n * Note: The function uses `unchecked` to avoid overflow checks, assuming the input is valid.\n */"
        },
        {
            "identifier": "log10",
            "parameters": "uint256 value",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }",
            "start": "596",
            "end": "628",
            "class": "Math",
            "signature": "returns (uint256) log10uint256 value",
            "full_signature": "function log10(uint256 value) internal  pure returns (uint256)",
            "class_method_signature": "Math.log10uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-10 logarithm of a given value.\n *\n * @param value The input value for which the logarithm is to be computed.\n * @return result The base-10 logarithm of the input value, rounded down to the nearest integer.\n *\n * Steps:\n * 1. Initialize `result` to 0.\n * 2. Check if the value is greater than or equal to 10^64, and if so, divide the value by 10^64 and add 64 to `result`.\n * 3. Repeat the process for 10^32, 10^16, 10^8, 10^4, 10^2, and 10^1, updating `result` accordingly.\n * 4. Return the computed `result`.\n *\n * Note: The function uses unchecked arithmetic to avoid overflow checks, assuming the input value is valid.\n */"
        },
        {
            "identifier": "log10",
            "parameters": "uint256 value, Rounding rounding",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 10 ** result < value);\n        }\n    }",
            "start": "634",
            "end": "639",
            "class": "Math",
            "signature": "returns (uint256) log10uint256 value, Rounding rounding",
            "full_signature": "function log10(uint256 value, Rounding rounding) internal  pure returns (uint256)",
            "class_method_signature": "Math.log10uint256 value, Rounding rounding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-10 logarithm of a given value, with optional rounding.\n *\n * @param value The value for which to compute the logarithm.\n * @param rounding The rounding mode to apply (e.g., rounding up or down).\n * @return The base-10 logarithm of the value, adjusted based on the rounding mode.\n *\n * Steps:\n * 1. Compute the base-10 logarithm of the value using the `log10` function.\n * 2. If rounding is set to round up and the value is greater than 10^result, increment the result by 1.\n * 3. Return the final result.\n *\n * Note: The function uses `unchecked` to avoid overflow checks, assuming the input is valid.\n */"
        },
        {
            "identifier": "log256",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log256(uint256 x) internal pure returns (uint256 r) {\n        // If value has upper 128 bits set, log2 result is at least 128\n        r = SafeCast.toUint(x > 0xffffffffffffffffffffffffffffffff) << 7;\n        // If upper 64 bits of 128-bit half set, add 64 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffffffffffff) << 6;\n        // If upper 32 bits of 64-bit half set, add 32 to result\n        r |= SafeCast.toUint((x >> r) > 0xffffffff) << 5;\n        // If upper 16 bits of 32-bit half set, add 16 to result\n        r |= SafeCast.toUint((x >> r) > 0xffff) << 4;\n        // Add 1 if upper 8 bits of 16-bit half set, and divide accumulated result by 8\n        return (r >> 3) | SafeCast.toUint((x >> r) > 0xff);\n    }",
            "start": "647",
            "end": "658",
            "class": "Math",
            "signature": "returns (uint256 r) log256uint256 x",
            "full_signature": "function log256(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "Math.log256uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-256 logarithm of a given 256-bit unsigned integer.\n *\n * @param x The 256-bit unsigned integer for which the logarithm is to be computed.\n * @return r The computed base-256 logarithm of `x`, represented as a 256-bit unsigned integer.\n *\n * Steps:\n * 1. Check if the upper 128 bits of `x` are set. If so, set the result `r` to at least 128.\n * 2. Check if the upper 64 bits of the remaining 128 bits are set. If so, add 64 to the result.\n * 3. Check if the upper 32 bits of the remaining 64 bits are set. If so, add 32 to the result.\n * 4. Check if the upper 16 bits of the remaining 32 bits are set. If so, add 16 to the result.\n * 5. Check if the upper 8 bits of the remaining 16 bits are set. If so, add 1 to the result.\n * 6. Return the final result, which is the accumulated value divided by 8.\n */"
        },
        {
            "identifier": "log256",
            "parameters": "uint256 value, Rounding rounding",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + SafeCast.toUint(unsignedRoundsUp(rounding) && 1 << (result << 3) < value);\n        }\n    }",
            "start": "664",
            "end": "669",
            "class": "Math",
            "signature": "returns (uint256) log256uint256 value, Rounding rounding",
            "full_signature": "function log256(uint256 value, Rounding rounding) internal  pure returns (uint256)",
            "class_method_signature": "Math.log256uint256 value, Rounding rounding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Panic} from \"../Panic.sol\";",
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-256 logarithm of a given value with optional rounding.\n *\n * @param value The value for which the base-256 logarithm is to be computed.\n * @param rounding The rounding mode to apply (e.g., rounding up or down).\n * @return The computed base-256 logarithm of the value, adjusted based on the rounding mode.\n *\n * Steps:\n * 1. Compute the base-256 logarithm of the input value.\n * 2. If rounding is set to round up and the next power of 256 is greater than the value, increment the result by 1.\n * 3. Return the adjusted result.\n *\n * @dev The function uses unchecked arithmetic to avoid overflow checks, assuming the input value is valid.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/math/SignedMath.sol": [
        {
            "identifier": "ternary",
            "parameters": "bool condition, int256 a, int256 b",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function ternary(bool condition, int256 a, int256 b) internal pure returns (int256) {\n        unchecked {\n            // branchless ternary works because:\n            // b ^ (a ^ b) == a\n            // b ^ 0 == b\n            return b ^ ((a ^ b) * int256(SafeCast.toUint(condition)));\n        }\n    }",
            "start": "19",
            "end": "26",
            "class": "SignedMath",
            "signature": "returns (int256) ternarybool condition, int256 a, int256 b",
            "full_signature": "function ternary(bool condition, int256 a, int256 b) internal  pure returns (int256)",
            "class_method_signature": "SignedMath.ternarybool condition, int256 a, int256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "{'function toUint(bool b) internal  pure returns (uint256 u)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Implements a branchless ternary operation to return one of two values based on a condition.\n *\n * @param condition The boolean condition to evaluate.\n * @param a The value to return if the condition is true.\n * @param b The value to return if the condition is false.\n * @return The result of the ternary operation, which is either `a` or `b` based on the condition.\n *\n * Details:\n * - The function uses bitwise XOR (`^`) and multiplication to achieve a branchless ternary operation.\n * - If `condition` is true, the result is `a` because `b ^ ((a ^ b) * 1) = a`.\n * - If `condition` is false, the result is `b` because `b ^ ((a ^ b) * 0) = b`.\n * - The `unchecked` block is used to avoid overflow checks, as the operation is safe within the given context.\n */"
        },
        {
            "identifier": "average",
            "parameters": "int256 a, int256 b",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }",
            "start": "46",
            "end": "50",
            "class": "SignedMath",
            "signature": "returns (int256) averageint256 a, int256 b",
            "full_signature": "function average(int256 a, int256 b) internal  pure returns (int256)",
            "class_method_signature": "SignedMath.averageint256 a, int256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the average of two signed integers using a formula from \"Hacker's Delight\".\n *\n * @param a The first signed integer.\n * @param b The second signed integer.\n * @return The average of the two integers, rounded towards zero.\n *\n * Steps:\n * 1. Compute the average using the formula: (a & b) + ((a ^ b) >> 1).\n * 2. Adjust the result to handle overflow or underflow by adding a correction term:\n *    - The correction term is derived from the sign bit of the intermediate result.\n *    - It ensures the result is accurate even when the sum of a and b overflows.\n */"
        },
        {
            "identifier": "abs",
            "parameters": "int256 n",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // Formula from the \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n            // Since `n` is a signed integer, the generated bytecode will use the SAR opcode to perform the right shift,\n            // taking advantage of the most significant (or \"sign\" bit) in two's complement representation.\n            // This opcode adds new most significant bits set to the value of the previous most significant bit. As a result,\n            // the mask will either be `bytes32(0)` (if n is positive) or `~bytes32(0)` (if n is negative).\n            int256 mask = n >> 255;\n\n            // A `bytes32(0)` mask leaves the input unchanged, while a `~bytes32(0)` mask complements it.\n            return uint256((n + mask) ^ mask);\n        }\n    }",
            "start": "55",
            "end": "67",
            "class": "SignedMath",
            "signature": "returns (uint256) absint256 n",
            "full_signature": "function abs(int256 n) internal  pure returns (uint256)",
            "class_method_signature": "SignedMath.absint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {SafeCast} from \"./SafeCast.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the absolute value of a signed integer `n` and returns it as an unsigned integer.\n *\n * @param n The signed integer for which the absolute value is to be computed.\n * @return The absolute value of `n` as an unsigned integer.\n *\n * Steps:\n * 1. Calculate the mask using the formula from \"Bit Twiddling Hacks\" by Sean Eron Anderson.\n *    - The mask is computed by shifting `n` right by 255 bits, which results in either `0` (if `n` is positive) or `~0` (if `n` is negative).\n * 2. Compute the absolute value using the formula `(n + mask) ^ mask`.\n *    - If `n` is positive, the mask is `0`, so the result is `n`.\n *    - If `n` is negative, the mask is `~0`, which effectively flips the bits of `n` and adds 1 to get the absolute value.\n * 3. Return the result as an unsigned integer.\n *\n * Note: The function uses `unchecked` to avoid overflow checks, assuming that the input `n` is within the valid range for the operation.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/structs/Checkpoints.sol": [
        {
            "identifier": "push",
            "parameters": "Trace224 storage self, uint32 key, uint224 value",
            "modifiers": "",
            "return": "returns (uint224 oldValue, uint224 newValue)",
            "body": "function push(\n        Trace224 storage self,\n        uint32 key,\n        uint224 value\n    ) internal returns (uint224 oldValue, uint224 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }",
            "start": "39",
            "end": "45",
            "class": "Checkpoints",
            "signature": "returns (uint224 oldValue, uint224 newValue) pushTrace224 storage self, uint32 key, uint224 value",
            "full_signature": "function push(Trace224 storage self, uint32 key, uint224 value) internal   returns (uint224 oldValue, uint224 newValue)",
            "class_method_signature": "Checkpoints.pushTrace224 storage self, uint32 key, uint224 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Inserts a new key-value pair into the Trace224 storage.\n *\n * @param self The storage reference to the Trace224 structure.\n * @param key The key to be inserted or updated.\n * @param value The value to be associated with the key.\n *\n * @return oldValue The previous value associated with the key (if any).\n * @return newValue The new value associated with the key after insertion.\n *\n * Steps:\n * 1. Calls the internal `_insert` function with the provided key and value.\n * 2. Returns the old and new values associated with the key.\n */"
        },
        {
            "identifier": "lowerLookup",
            "parameters": "Trace224 storage self, uint32 key",
            "modifiers": "view",
            "return": "returns (uint224)",
            "body": "function lowerLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }",
            "start": "51",
            "end": "55",
            "class": "Checkpoints",
            "signature": "returns (uint224) lowerLookupTrace224 storage self, uint32 key",
            "full_signature": "function lowerLookup(Trace224 storage self, uint32 key) internal  view returns (uint224)",
            "class_method_signature": "Checkpoints.lowerLookupTrace224 storage self, uint32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a lower-bound binary lookup on a sorted array of checkpoints to find the value associated with a given key.\n *\n * @param self The storage reference to the Trace224 struct containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The value associated with the largest checkpoint key less than or equal to the given key. Returns 0 if no such checkpoint exists.\n *\n * Steps:\n * 1. Determine the length of the checkpoints array.\n * 2. Perform a binary search to find the position of the largest checkpoint key less than or equal to the given key.\n * 3. If the position is equal to the length of the array, return 0 (no valid checkpoint found).\n * 4. Otherwise, return the value at the found position using unsafe access to avoid bounds checking.\n */"
        },
        {
            "identifier": "upperLookup",
            "parameters": "Trace224 storage self, uint32 key",
            "modifiers": "view",
            "return": "returns (uint224)",
            "body": "function upperLookup(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "61",
            "end": "65",
            "class": "Checkpoints",
            "signature": "returns (uint224) upperLookupTrace224 storage self, uint32 key",
            "full_signature": "function upperLookup(Trace224 storage self, uint32 key) internal  view returns (uint224)",
            "class_method_signature": "Checkpoints.upperLookupTrace224 storage self, uint32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a Trace224 checkpoint array to find the value associated with the given key.\n *\n * @param self The Trace224 storage reference containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The value associated with the key, or 0 if no valid checkpoint is found.\n *\n * Steps:\n * 1. Retrieve the length of the checkpoints array.\n * 2. Use `_upperBinaryLookup` to find the position of the key in the checkpoints array.\n * 3. If the position is 0, return 0 (no valid checkpoint found).\n * 4. Otherwise, return the value from the checkpoint at the position minus one using `_unsafeAccess`.\n */"
        },
        {
            "identifier": "upperLookupRecent",
            "parameters": "Trace224 storage self, uint32 key",
            "modifiers": "view",
            "return": "returns (uint224)",
            "body": "function upperLookupRecent(Trace224 storage self, uint32 key) internal view returns (uint224) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "74",
            "end": "92",
            "class": "Checkpoints",
            "signature": "returns (uint224) upperLookupRecentTrace224 storage self, uint32 key",
            "full_signature": "function upperLookupRecent(Trace224 storage self, uint32 key) internal  view returns (uint224)",
            "class_method_signature": "Checkpoints.upperLookupRecentTrace224 storage self, uint32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function sqrt(uint256 a) internal  pure returns (uint256)', 'function sqrt(uint256 a, Rounding rounding) internal  pure returns (uint256)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a Trace224 storage structure to find the most recent value associated with a given key.\n *\n * @param self The Trace224 storage structure containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The most recent value associated with the key, or 0 if no such value exists.\n *\n * Steps:\n * 1. Determine the length of the checkpoints array.\n * 2. Initialize low and high pointers for binary search.\n * 3. If the length of the checkpoints array is greater than 5, optimize the search by narrowing the range:\n *    - Calculate a midpoint using the square root of the length.\n *    - Adjust the high or low pointer based on whether the key is less than the key at the midpoint.\n * 4. Perform an upper binary lookup within the narrowed range to find the position of the key.\n * 5. Return the value at the position found, or 0 if no valid position is found.\n */"
        },
        {
            "identifier": "latest",
            "parameters": "Trace224 storage self",
            "modifiers": "view",
            "return": "returns (uint224)",
            "body": "function latest(Trace224 storage self) internal view returns (uint224) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "97",
            "end": "100",
            "class": "Checkpoints",
            "signature": "returns (uint224) latestTrace224 storage self",
            "full_signature": "function latest(Trace224 storage self) internal  view returns (uint224)",
            "class_method_signature": "Checkpoints.latestTrace224 storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the latest value from a Trace224 checkpoint array.\n *\n * @param self The Trace224 storage reference containing the checkpoints.\n * @return The latest value stored in the checkpoints. If no checkpoints exist, returns 0.\n *\n * Steps:\n * 1. Determine the length of the checkpoint array.\n * 2. If the array is empty, return 0.\n * 3. Otherwise, access the last checkpoint in the array and return its value.\n */"
        },
        {
            "identifier": "latestCheckpoint",
            "parameters": "Trace224 storage self",
            "modifiers": "view",
            "return": "returns (bool exists, uint32 _key, uint224 _value)",
            "body": "function latestCheckpoint(Trace224 storage self) internal view returns (bool exists, uint32 _key, uint224 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint224 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }",
            "start": "106",
            "end": "114",
            "class": "Checkpoints",
            "signature": "returns (bool exists, uint32 _key, uint224 _value) latestCheckpointTrace224 storage self",
            "full_signature": "function latestCheckpoint(Trace224 storage self) internal  view returns (bool exists, uint32 _key, uint224 _value)",
            "class_method_signature": "Checkpoints.latestCheckpointTrace224 storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the latest checkpoint from a Trace224 storage structure.\n *\n * @param self The Trace224 storage structure containing the checkpoints.\n * @return exists A boolean indicating whether a checkpoint exists.\n * @return _key The key (uint32) of the latest checkpoint if it exists.\n * @return _value The value (uint224) of the latest checkpoint if it exists.\n *\n * Steps:\n * 1. Determine the position of the last checkpoint in the `_checkpoints` array.\n * 2. If no checkpoints exist, return `false` with default values for `_key` and `_value`.\n * 3. If checkpoints exist, access the latest checkpoint using `_unsafeAccess`.\n * 4. Return `true` along with the key and value of the latest checkpoint.\n */ "
        },
        {
            "identifier": "push",
            "parameters": "Trace208 storage self, uint48 key, uint208 value",
            "modifiers": "",
            "return": "returns (uint208 oldValue, uint208 newValue)",
            "body": "function push(\n        Trace208 storage self,\n        uint48 key,\n        uint208 value\n    ) internal returns (uint208 oldValue, uint208 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }",
            "start": "242",
            "end": "248",
            "class": "Checkpoints",
            "signature": "returns (uint208 oldValue, uint208 newValue) pushTrace208 storage self, uint48 key, uint208 value",
            "full_signature": "function push(Trace208 storage self, uint48 key, uint208 value) internal   returns (uint208 oldValue, uint208 newValue)",
            "class_method_signature": "Checkpoints.pushTrace208 storage self, uint48 key, uint208 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Inserts a new key-value pair into the Trace208 storage structure.\n *\n * @param self The Trace208 storage structure to which the key-value pair will be added.\n * @param key The key to be inserted, represented as a uint48.\n * @param value The value to be associated with the key, represented as a uint208.\n *\n * @return oldValue The previous value associated with the key, if any.\n * @return newValue The new value that was inserted.\n *\n * Steps:\n * 1. Calls the internal `_insert` function with the provided key and value.\n * 2. Returns the old and new values associated with the key.\n */"
        },
        {
            "identifier": "lowerLookup",
            "parameters": "Trace208 storage self, uint48 key",
            "modifiers": "view",
            "return": "returns (uint208)",
            "body": "function lowerLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }",
            "start": "254",
            "end": "258",
            "class": "Checkpoints",
            "signature": "returns (uint208) lowerLookupTrace208 storage self, uint48 key",
            "full_signature": "function lowerLookup(Trace208 storage self, uint48 key) internal  view returns (uint208)",
            "class_method_signature": "Checkpoints.lowerLookupTrace208 storage self, uint48 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a lower binary lookup on a sorted list of checkpoints to find the value associated with a given key.\n *\n * @param self The storage reference to the Trace208 struct containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The value associated with the largest key less than or equal to the given key. Returns 0 if no such key exists.\n *\n * Steps:\n * 1. Determine the length of the checkpoints array.\n * 2. Perform a binary search to find the position of the largest key less than or equal to the given key.\n * 3. If the position is equal to the length of the array, return 0 (indicating no valid key was found).\n * 4. Otherwise, return the value at the found position in the checkpoints array.\n */"
        },
        {
            "identifier": "upperLookup",
            "parameters": "Trace208 storage self, uint48 key",
            "modifiers": "view",
            "return": "returns (uint208)",
            "body": "function upperLookup(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "264",
            "end": "268",
            "class": "Checkpoints",
            "signature": "returns (uint208) upperLookupTrace208 storage self, uint48 key",
            "full_signature": "function upperLookup(Trace208 storage self, uint48 key) internal  view returns (uint208)",
            "class_method_signature": "Checkpoints.upperLookupTrace208 storage self, uint48 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a sorted list of checkpoints to find the value associated with the given key.\n *\n * @param self The storage reference to the Trace208 struct containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The value associated with the largest checkpoint key that is less than or equal to the provided key.\n *         If no such checkpoint exists, returns 0.\n *\n * Steps:\n * 1. Retrieve the length of the checkpoints array.\n * 2. Perform an upper binary lookup to find the position of the checkpoint with the largest key less than or equal to the provided key.\n * 3. If the position is 0, return 0 (no valid checkpoint found).\n * 4. Otherwise, return the value of the checkpoint at the position immediately before the found position.\n */"
        },
        {
            "identifier": "upperLookupRecent",
            "parameters": "Trace208 storage self, uint48 key",
            "modifiers": "view",
            "return": "returns (uint208)",
            "body": "function upperLookupRecent(Trace208 storage self, uint48 key) internal view returns (uint208) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "277",
            "end": "295",
            "class": "Checkpoints",
            "signature": "returns (uint208) upperLookupRecentTrace208 storage self, uint48 key",
            "full_signature": "function upperLookupRecent(Trace208 storage self, uint48 key) internal  view returns (uint208)",
            "class_method_signature": "Checkpoints.upperLookupRecentTrace208 storage self, uint48 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function sqrt(uint256 a) internal  pure returns (uint256)', 'function sqrt(uint256 a, Rounding rounding) internal  pure returns (uint256)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an upper-bound lookup for a given key in a sorted list of checkpoints.\n *\n * @dev This function uses a combination of binary search and a heuristic to optimize the search process.\n * If the checkpoint list is large (more than 5 elements), it uses a heuristic to narrow down the search range\n * by checking a midpoint derived from the square root of the list length. This reduces the number of iterations\n * required for the binary search.\n *\n * @param self The storage reference to the Trace208 checkpoint list.\n * @param key The key to search for in the checkpoint list.\n *\n * @return The value associated with the highest checkpoint key that is less than or equal to the provided key.\n * If no such checkpoint exists, returns 0.\n *\n * Steps:\n * 1. Determine the length of the checkpoint list.\n * 2. Initialize low and high pointers for binary search.\n * 3. If the list has more than 5 elements, calculate a midpoint using the square root of the list length.\n *    - If the key is less than the midpoint key, adjust the high pointer to the midpoint.\n *    - Otherwise, adjust the low pointer to the midpoint + 1.\n * 4. Perform a binary search within the adjusted range to find the position of the upper-bound key.\n * 5. Return the value of the checkpoint at the position just before the upper-bound key.\n *    - If no valid position is found, return 0.\n */"
        },
        {
            "identifier": "latest",
            "parameters": "Trace208 storage self",
            "modifiers": "view",
            "return": "returns (uint208)",
            "body": "function latest(Trace208 storage self) internal view returns (uint208) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "300",
            "end": "303",
            "class": "Checkpoints",
            "signature": "returns (uint208) latestTrace208 storage self",
            "full_signature": "function latest(Trace208 storage self) internal  view returns (uint208)",
            "class_method_signature": "Checkpoints.latestTrace208 storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the latest value from a `Trace208` storage structure.\n *\n * @param self The `Trace208` storage structure containing the checkpoints.\n * @return The latest value stored in the checkpoints. If no checkpoints exist, returns 0.\n *\n * Steps:\n * 1. Determine the length of the `_checkpoints` array in the `Trace208` structure.\n * 2. If the length is 0, return 0.\n * 3. Otherwise, access the last checkpoint in the array and return its value.\n */"
        },
        {
            "identifier": "latestCheckpoint",
            "parameters": "Trace208 storage self",
            "modifiers": "view",
            "return": "returns (bool exists, uint48 _key, uint208 _value)",
            "body": "function latestCheckpoint(Trace208 storage self) internal view returns (bool exists, uint48 _key, uint208 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint208 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }",
            "start": "309",
            "end": "317",
            "class": "Checkpoints",
            "signature": "returns (bool exists, uint48 _key, uint208 _value) latestCheckpointTrace208 storage self",
            "full_signature": "function latestCheckpoint(Trace208 storage self) internal  view returns (bool exists, uint48 _key, uint208 _value)",
            "class_method_signature": "Checkpoints.latestCheckpointTrace208 storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the latest checkpoint from a Trace208 storage structure.\n *\n * @param self The Trace208 storage structure containing the checkpoints.\n * @return exists A boolean indicating whether a checkpoint exists.\n * @return _key The key (timestamp or block number) of the latest checkpoint.\n * @return _value The value associated with the latest checkpoint.\n *\n * Steps:\n * 1. Determine the position of the last checkpoint in the `_checkpoints` array.\n * 2. If no checkpoints exist, return `(false, 0, 0)`.\n * 3. Otherwise, access the latest checkpoint using `_unsafeAccess` and return its key and value.\n */"
        },
        {
            "identifier": "push",
            "parameters": "Trace160 storage self, uint96 key, uint160 value",
            "modifiers": "",
            "return": "returns (uint160 oldValue, uint160 newValue)",
            "body": "function push(\n        Trace160 storage self,\n        uint96 key,\n        uint160 value\n    ) internal returns (uint160 oldValue, uint160 newValue) {\n        return _insert(self._checkpoints, key, value);\n    }",
            "start": "445",
            "end": "451",
            "class": "Checkpoints",
            "signature": "returns (uint160 oldValue, uint160 newValue) pushTrace160 storage self, uint96 key, uint160 value",
            "full_signature": "function push(Trace160 storage self, uint96 key, uint160 value) internal   returns (uint160 oldValue, uint160 newValue)",
            "class_method_signature": "Checkpoints.pushTrace160 storage self, uint96 key, uint160 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Inserts a new key-value pair into the Trace160 storage structure.\n *\n * @param self The Trace160 storage structure to which the key-value pair will be added.\n * @param key The key to be inserted into the storage structure.\n * @param value The value associated with the key to be inserted.\n *\n * @return oldValue The previous value associated with the key, if any.\n * @return newValue The new value that was inserted into the storage structure.\n *\n * Steps:\n * 1. Call the internal `_insert` function with the provided key and value.\n * 2. Return the old value (if any) and the new value after insertion.\n */"
        },
        {
            "identifier": "lowerLookup",
            "parameters": "Trace160 storage self, uint96 key",
            "modifiers": "view",
            "return": "returns (uint160)",
            "body": "function lowerLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _lowerBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == len ? 0 : _unsafeAccess(self._checkpoints, pos)._value;\n    }",
            "start": "457",
            "end": "461",
            "class": "Checkpoints",
            "signature": "returns (uint160) lowerLookupTrace160 storage self, uint96 key",
            "full_signature": "function lowerLookup(Trace160 storage self, uint96 key) internal  view returns (uint160)",
            "class_method_signature": "Checkpoints.lowerLookupTrace160 storage self, uint96 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a lower-bound binary lookup on a sorted list of checkpoints to find the value associated with the given key.\n *\n * @param self The storage reference to the Trace160 structure containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The value associated with the key if found, otherwise returns 0.\n *\n * Steps:\n * 1. Determine the length of the checkpoints array.\n * 2. Perform a binary search to find the position of the key in the checkpoints array.\n * 3. If the key is found, return the associated value from the checkpoint.\n * 4. If the key is not found, return 0.\n */"
        },
        {
            "identifier": "upperLookup",
            "parameters": "Trace160 storage self, uint96 key",
            "modifiers": "view",
            "return": "returns (uint160)",
            "body": "function upperLookup(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, 0, len);\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "467",
            "end": "471",
            "class": "Checkpoints",
            "signature": "returns (uint160) upperLookupTrace160 storage self, uint96 key",
            "full_signature": "function upperLookup(Trace160 storage self, uint96 key) internal  view returns (uint160)",
            "class_method_signature": "Checkpoints.upperLookupTrace160 storage self, uint96 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a sorted list of checkpoints to find the value associated with the given key.\n *\n * @param self The storage reference to the Trace160 struct containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The value associated with the largest checkpoint key that is less than or equal to the provided key. \n *         Returns 0 if no such checkpoint exists.\n *\n * Steps:\n * 1. Determine the length of the checkpoints array.\n * 2. Use a binary search to find the position of the largest checkpoint key that is less than or equal to the provided key.\n * 3. If no such checkpoint exists (pos == 0), return 0.\n * 4. Otherwise, return the value of the checkpoint at the position immediately before the found position.\n */"
        },
        {
            "identifier": "upperLookupRecent",
            "parameters": "Trace160 storage self, uint96 key",
            "modifiers": "view",
            "return": "returns (uint160)",
            "body": "function upperLookupRecent(Trace160 storage self, uint96 key) internal view returns (uint160) {\n        uint256 len = self._checkpoints.length;\n\n        uint256 low = 0;\n        uint256 high = len;\n\n        if (len > 5) {\n            uint256 mid = len - Math.sqrt(len);\n            if (key < _unsafeAccess(self._checkpoints, mid)._key) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        uint256 pos = _upperBinaryLookup(self._checkpoints, key, low, high);\n\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "480",
            "end": "498",
            "class": "Checkpoints",
            "signature": "returns (uint160) upperLookupRecentTrace160 storage self, uint96 key",
            "full_signature": "function upperLookupRecent(Trace160 storage self, uint96 key) internal  view returns (uint160)",
            "class_method_signature": "Checkpoints.upperLookupRecentTrace160 storage self, uint96 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "{'function sqrt(uint256 a) internal  pure returns (uint256)', 'function sqrt(uint256 a, Rounding rounding) internal  pure returns (uint256)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an upper binary lookup on a sorted list of checkpoints to find the most recent value associated with a given key.\n *\n * @param self The storage reference to the Trace160 struct containing the checkpoints.\n * @param key The key to search for in the checkpoints.\n * @return The most recent value associated with the key, or 0 if no such value exists.\n *\n * Steps:\n * 1. Determine the length of the checkpoints array.\n * 2. Initialize low and high pointers for binary search.\n * 3. If the length of the checkpoints array is greater than 5, optimize the search by narrowing the range using a midpoint calculation based on the square root of the length.\n * 4. Perform a binary search within the narrowed range to find the position of the key.\n * 5. If the key is found, return the corresponding value from the checkpoint. If not found, return 0.\n */"
        },
        {
            "identifier": "latest",
            "parameters": "Trace160 storage self",
            "modifiers": "view",
            "return": "returns (uint160)",
            "body": "function latest(Trace160 storage self) internal view returns (uint160) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : _unsafeAccess(self._checkpoints, pos - 1)._value;\n    }",
            "start": "503",
            "end": "506",
            "class": "Checkpoints",
            "signature": "returns (uint160) latestTrace160 storage self",
            "full_signature": "function latest(Trace160 storage self) internal  view returns (uint160)",
            "class_method_signature": "Checkpoints.latestTrace160 storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the latest value from a Trace160 checkpoint array.\n *\n * @param self The storage reference to the Trace160 checkpoint array.\n * @return The latest value stored in the checkpoint array. If no checkpoints exist, returns 0.\n *\n * Steps:\n * 1. Determine the length of the checkpoint array.\n * 2. If the array is empty, return 0.\n * 3. Otherwise, access the last checkpoint in the array and return its value.\n */"
        },
        {
            "identifier": "latestCheckpoint",
            "parameters": "Trace160 storage self",
            "modifiers": "view",
            "return": "returns (bool exists, uint96 _key, uint160 _value)",
            "body": "function latestCheckpoint(Trace160 storage self) internal view returns (bool exists, uint96 _key, uint160 _value) {\n        uint256 pos = self._checkpoints.length;\n        if (pos == 0) {\n            return (false, 0, 0);\n        } else {\n            Checkpoint160 storage ckpt = _unsafeAccess(self._checkpoints, pos - 1);\n            return (true, ckpt._key, ckpt._value);\n        }\n    }",
            "start": "512",
            "end": "520",
            "class": "Checkpoints",
            "signature": "returns (bool exists, uint96 _key, uint160 _value) latestCheckpointTrace160 storage self",
            "full_signature": "function latestCheckpoint(Trace160 storage self) internal  view returns (bool exists, uint96 _key, uint160 _value)",
            "class_method_signature": "Checkpoints.latestCheckpointTrace160 storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the latest checkpoint from a Trace160 storage structure.\n *\n * @param self The Trace160 storage structure containing the checkpoints.\n * @return exists A boolean indicating whether a checkpoint exists.\n * @return _key The key (uint96) of the latest checkpoint.\n * @return _value The value (uint160) of the latest checkpoint.\n *\n * Steps:\n * 1. Determine the position of the last checkpoint in the `_checkpoints` array.\n * 2. If no checkpoints exist, return `(false, 0, 0)`.\n * 3. Otherwise, access the latest checkpoint using `_unsafeAccess`.\n * 4. Return `(true, ckpt._key, ckpt._value)` where `ckpt` is the latest checkpoint.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/utils/structs/Heap.sol": [
        {
            "identifier": "peek",
            "parameters": "Uint256Heap storage self",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function peek(Uint256Heap storage self) internal view returns (uint256) {\n        // self.tree[0] will `ARRAY_ACCESS_OUT_OF_BOUNDS` panic if heap is empty.\n        return self.tree[0];\n    }",
            "start": "57",
            "end": "60",
            "class": "Heap",
            "signature": "returns (uint256) peekUint256Heap storage self",
            "full_signature": "function peek(Uint256Heap storage self) internal  view returns (uint256)",
            "class_method_signature": "Heap.peekUint256Heap storage self",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function panic(uint256 code) internal  pure'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns the smallest element in the heap without removing it.\n *\n * @dev This function accesses the first element of the heap's underlying array (`self.tree[0]`),\n * which represents the smallest element in a min-heap. If the heap is empty, accessing `self.tree[0]`\n * will result in an `ARRAY_ACCESS_OUT_OF_BOUNDS` panic.\n *\n * @param self The heap storage reference.\n * @return The smallest element in the heap.\n */"
        },
        {
            "identifier": "pop",
            "parameters": "Uint256Heap storage self, function(uint256, uint256) view returns (bool) comp",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function pop(\n        Uint256Heap storage self,\n        function(uint256, uint256) view returns (bool) comp\n    ) internal returns (uint256) {\n        unchecked {\n            uint256 size = length(self);\n            if (size == 0) Panic.panic(Panic.EMPTY_ARRAY_POP);\n\n            // cache\n            uint256 rootValue = self.tree.unsafeAccess(0).value;\n            uint256 lastValue = self.tree.unsafeAccess(size - 1).value;\n\n            // swap last leaf with root, shrink tree and re-heapify\n            self.tree.pop();\n            self.tree.unsafeAccess(0).value = lastValue;\n            _siftDown(self, size - 1, 0, lastValue, comp);\n\n            return rootValue;\n        }\n    }",
            "start": "78",
            "end": "97",
            "class": "Heap",
            "signature": "returns (uint256) popUint256Heap storage self, function(uint256, uint256) view returns (bool) comp",
            "full_signature": "function pop(Uint256Heap storage self, function(uint256, uint256) view returns (bool) comp) internal   returns (uint256)",
            "class_method_signature": "Heap.popUint256Heap storage self, function(uint256, uint256) view returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function unsafeAccess(uint256[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Uint256Slot storage)', 'function panic(uint256 code) internal  pure', 'function gt(uint256 a, uint256 b) internal  pure returns (bool)', 'function unsafeAccess(address[] storage arr, uint256 pos) internal  pure returns (StorageSlot.AddressSlot storage)', 'function unsafeAccess(bytes32[] storage arr, uint256 pos) internal  pure returns (StorageSlot.Bytes32Slot storage)', 'uint256 internal constant EMPTY_ARRAY_POP'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes and returns the root element from a heap, then re-heapifies the structure.\n *\n * @param self The heap storage reference.\n * @param comp The comparison function used to maintain heap order.\n * @return The value of the root element that was removed.\n *\n * Steps:\n * 1. Check the size of the heap. If it is empty, revert with a panic error (EMPTY_ARRAY_POP).\n * 2. Cache the value of the root element and the last element in the heap.\n * 3. Swap the last element with the root element and shrink the heap by removing the last element.\n * 4. Re-heapify the heap by sifting down the new root element to maintain the heap property.\n * 5. Return the original root value.\n *\n * @dev This function uses unchecked arithmetic for gas optimization.\n */"
        },
        {
            "identifier": "insert",
            "parameters": "Uint256Heap storage self, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "modifiers": "",
            "return": "",
            "body": "function insert(\n        Uint256Heap storage self,\n        uint256 value,\n        function(uint256, uint256) view returns (bool) comp\n    ) internal {\n        uint256 size = length(self);\n\n        // push new item and re-heapify\n        self.tree.push(value);\n        _siftUp(self, size, value, comp);\n    }",
            "start": "115",
            "end": "125",
            "class": "Heap",
            "signature": " insertUint256Heap storage self, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "full_signature": "function insert(Uint256Heap storage self, uint256 value, function(uint256, uint256) view returns (bool) comp) internal",
            "class_method_signature": "Heap.insertUint256Heap storage self, uint256 value, function(uint256, uint256) view returns (bool) comp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Math} from \"../math/Math.sol\";",
                "import {SafeCast} from \"../math/SafeCast.sol\";",
                "import {Comparators} from \"../Comparators.sol\";",
                "import {Arrays} from \"../Arrays.sol\";",
                "import {Panic} from \"../Panic.sol\";",
                "import {StorageSlot} from \"../StorageSlot.sol\";"
            ],
            "context": "{'function gt(uint256 a, uint256 b) internal  pure returns (bool)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Inserts a new value into the heap and maintains the heap property.\n *\n * @param self The storage reference to the heap.\n * @param value The value to be inserted into the heap.\n * @param comp A comparison function used to determine the order of elements in the heap.\n *\n * Steps:\n * 1. Retrieve the current size of the heap.\n * 2. Push the new value onto the heap.\n * 3. Re-heapify the heap by sifting up the newly inserted value to maintain the heap property.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/metatx/ERC2771Forwarder.sol": [
        {
            "identifier": "ForwardRequestData",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct ForwardRequestData {\n        address from;\n        address to;\n        uint256 value;\n        uint256 gas;\n        uint48 deadline;\n        bytes data;\n        bytes signature;\n    }",
            "start": "54",
            "end": "62",
            "class": "ERC2771Forwarder",
            "signature": " ForwardRequestData",
            "full_signature": "function ForwardRequestData()",
            "class_method_signature": "ERC2771Forwarder.ForwardRequestData",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct `ForwardRequestData` used for forwarding transactions.\n *\n * @param from The address initiating the transaction (sender).\n * @param to The address receiving the transaction (recipient).\n * @param value The amount of Ether (in wei) to be sent with the transaction.\n * @param gas The amount of gas allocated for the transaction.\n * @param deadline The timestamp until which the transaction is valid.\n * @param data The encoded function call data to be executed.\n * @param signature The signature of the transaction for verification purposes.\n */"
        },
        {
            "identifier": "_FORWARD_REQUEST_TYPEHASH",
            "parameters": "",
            "modifiers": "",
            "return": "bytes32",
            "body": "bytes32 internal constant _FORWARD_REQUEST_TYPEHASH =\n        keccak256(\n            \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\"\n        );",
            "start": "64",
            "end": "67",
            "class": "ERC2771Forwarder",
            "signature": "bytes32 _FORWARD_REQUEST_TYPEHASH",
            "full_signature": "bytes32 internal constant _FORWARD_REQUEST_TYPEHASH",
            "class_method_signature": "ERC2771Forwarder._FORWARD_REQUEST_TYPEHASH",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "constant",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {ERC2771Context} from \"./ERC2771Context.sol\";",
                "import {ECDSA} from \"../utils/cryptography/ECDSA.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines the type hash for the ForwardRequest struct, used in EIP-712 typed data signing.\n *\n * The type hash is computed as the keccak256 hash of the string representation of the ForwardRequest struct:\n * \"ForwardRequest(address from,address to,uint256 value,uint256 gas,uint256 nonce,uint48 deadline,bytes data)\"\n *\n * This type hash is used to ensure consistency and integrity when signing and verifying ForwardRequest messages.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/governance/Governor.sol": [
        {
            "identifier": "_countVote",
            "parameters": "uint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory params",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 totalWeight,\n        bytes memory params\n    ) internal virtual returns (uint256);",
            "start": "255",
            "end": "261",
            "class": "Governor",
            "signature": "returns (uint256) _countVoteuint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory params",
            "full_signature": "function _countVote(uint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory params) internal virtual  returns (uint256)",
            "class_method_signature": "Governor._countVoteuint256 proposalId, address account, uint8 support, uint256 totalWeight, bytes memory params",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";",
                "import {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\";",
                "import {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";",
                "import {SafeCast} from \"../utils/math/SafeCast.sol\";",
                "import {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Context} from \"../utils/Context.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Strings} from \"../utils/Strings.sol\";",
                "import {IGovernor, IERC6372} from \"./IGovernor.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to count a vote for a specific proposal.\n *\n * @param proposalId The ID of the proposal for which the vote is being counted.\n * @param account The address of the account casting the vote.\n * @param support The level of support for the proposal (e.g., 0 = against, 1 = for, 2 = abstain).\n * @param totalWeight The total weight of the vote, which may be influenced by delegation or other factors.\n * @param params Additional parameters that may be required for the vote counting logic.\n *\n * @return uint256 The updated weight of the vote after counting.\n *\n * This function is intended to be overridden by derived contracts to implement custom vote counting logic.\n */"
        },
        {
            "identifier": "propose",
            "parameters": "address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description",
            "modifiers": "",
            "return": "returns (uint256)",
            "body": "function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256) {\n        address proposer = _msgSender();\n\n        // check description restriction\n        if (!_isValidDescriptionForProposer(proposer, description)) {\n            revert GovernorRestrictedProposer(proposer);\n        }\n\n        // check proposal threshold\n        uint256 votesThreshold = proposalThreshold();\n        if (votesThreshold > 0) {\n            uint256 proposerVotes = getVotes(proposer, clock() - 1);\n            if (proposerVotes < votesThreshold) {\n                revert GovernorInsufficientProposerVotes(proposer, proposerVotes, votesThreshold);\n            }\n        }\n\n        return _propose(targets, values, calldatas, description, proposer);\n    }",
            "start": "283",
            "end": "306",
            "class": "Governor",
            "signature": "returns (uint256) proposeaddress[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description",
            "full_signature": "function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) public virtual  returns (uint256)",
            "class_method_signature": "Governor.proposeaddress[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";",
                "import {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\";",
                "import {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";",
                "import {SafeCast} from \"../utils/math/SafeCast.sol\";",
                "import {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Context} from \"../utils/Context.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Strings} from \"../utils/Strings.sol\";",
                "import {IGovernor, IERC6372} from \"./IGovernor.sol\";"
            ],
            "context": "{'function clock() public virtual override returns (uint48)', 'function at(Bytes32Deque storage deque, uint256 index) internal  view returns (bytes32 value)', 'function _msgSender() internal virtual view returns (address)', 'function getVotes(address account, uint256 timepoint) external  view returns (uint256)', 'function proposalThreshold() external  view returns (uint256)', 'function GovernorRestrictedProposer()', 'function GovernorInsufficientProposerVotes()', 'function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) public virtual  returns (uint256 proposalId)', 'function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) external   returns (uint256 proposalId)', 'function getVotes(address account, uint256 timepoint) public virtual view returns (uint256)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Proposes a new governance proposal with specified targets, values, calldatas, and description.\n *\n * @param targets The addresses of the contracts to be called as part of the proposal.\n * @param values The amounts of Ether (in wei) to be sent with each call.\n * @param calldatas The encoded function calls to be executed on the target contracts.\n * @param description A human-readable description of the proposal.\n *\n * @return proposalId The unique identifier for the newly created proposal.\n *\n * Steps:\n * 1. Retrieve the address of the proposer (`msg.sender`).\n * 2. Check if the description is valid for the proposer. If not, revert with `GovernorRestrictedProposer`.\n * 3. Check if the proposer meets the required voting threshold. If not, revert with `GovernorInsufficientProposerVotes`.\n * 4. If all checks pass, call the internal `_propose` function to create the proposal and return the proposal ID.\n *\n * Reverts:\n * - If the proposer is restricted from proposing with the given description.\n * - If the proposer does not meet the required voting threshold.\n */"
        },
        {
            "identifier": "_isValidDescriptionForProposer",
            "parameters": "address proposer, string memory description",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function _isValidDescriptionForProposer(\n        address proposer,\n        string memory description\n    ) internal view virtual returns (bool) {\n        unchecked {\n            uint256 length = bytes(description).length;\n\n            // Length is too short to contain a valid proposer suffix\n            if (length < 52) {\n                return true;\n            }\n\n            // Extract what would be the `#proposer=` marker beginning the suffix\n            bytes10 marker = bytes10(_unsafeReadBytesOffset(bytes(description), length - 52));\n\n            // If the marker is not found, there is no proposer suffix to check\n            if (marker != bytes10(\"#proposer=\")) {\n                return true;\n            }\n\n            // Check that the last 42 characters (after the marker) are a properly formatted address.\n            (bool success, address recovered) = Strings.tryParseAddress(description, length - 42, length);\n            return !success || recovered == proposer;\n        }\n    }",
            "start": "769",
            "end": "793",
            "class": "Governor",
            "signature": "returns (bool) _isValidDescriptionForProposeraddress proposer, string memory description",
            "full_signature": "function _isValidDescriptionForProposer(address proposer, string memory description) internal virtual view returns (bool)",
            "class_method_signature": "Governor._isValidDescriptionForProposeraddress proposer, string memory description",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC721Receiver} from \"../token/ERC721/IERC721Receiver.sol\";",
                "import {IERC1155Receiver} from \"../token/ERC1155/IERC1155Receiver.sol\";",
                "import {EIP712} from \"../utils/cryptography/EIP712.sol\";",
                "import {SignatureChecker} from \"../utils/cryptography/SignatureChecker.sol\";",
                "import {IERC165, ERC165} from \"../utils/introspection/ERC165.sol\";",
                "import {SafeCast} from \"../utils/math/SafeCast.sol\";",
                "import {DoubleEndedQueue} from \"../utils/structs/DoubleEndedQueue.sol\";",
                "import {Address} from \"../utils/Address.sol\";",
                "import {Context} from \"../utils/Context.sol\";",
                "import {Nonces} from \"../utils/Nonces.sol\";",
                "import {Strings} from \"../utils/Strings.sol\";",
                "import {IGovernor, IERC6372} from \"./IGovernor.sol\";"
            ],
            "context": "{'function tryParseAddress(string memory input) internal  pure returns (bool success, address value)', 'function _unsafeReadBytesOffset(bytes memory buffer, uint256 offset) private  pure returns (bytes32 value)', 'function length(Bytes32Deque storage deque) internal  view returns (uint256)', 'function at(Bytes32Deque storage deque, uint256 index) internal  view returns (bytes32 value)', 'function tryParseAddress(string memory input, uint256 begin, uint256 end) internal  pure returns (bool success, address value)', 'function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) public virtual  returns (uint256 proposalId)', 'function propose(address[] memory targets, uint256[] memory values, bytes[] memory calldatas, string memory description) external   returns (uint256 proposalId)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if the provided description is valid for the given proposer by verifying the presence and correctness of a proposer suffix.\n *\n * @param proposer The address of the proposer to validate against the description.\n * @param description The description string to be validated.\n * @return bool Returns `true` if the description is valid for the proposer, otherwise `false`.\n *\n * Steps:\n * 1. Calculate the length of the description.\n * 2. If the description length is less than 52 characters, it is considered valid (no suffix to check).\n * 3. Extract the last 52 characters of the description to check for the `#proposer=` marker.\n * 4. If the marker is not found, the description is considered valid.\n * 5. If the marker is found, attempt to parse the last 42 characters as an Ethereum address.\n * 6. Return `true` if the parsed address matches the proposer's address, otherwise `false`.\n *\n * @dev The function uses unchecked arithmetic for gas optimization and assumes the description is a valid UTF-8 string.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/token/ERC721/ERC721.sol": [
        {
            "identifier": "",
            "parameters": "string memory name_, string memory symbol_",
            "modifiers": "",
            "return": "",
            "body": "constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }",
            "start": "39",
            "end": "42",
            "class": "ERC721",
            "signature": " string memory name_, string memory symbol_",
            "full_signature": "constructor (string memory name_, string memory symbol_)",
            "class_method_signature": "ERC721.string memory name_, string memory symbol_",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC721} from \"./IERC721.sol\";",
                "import {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";",
                "import {ERC721Utils} from \"./utils/ERC721Utils.sol\";",
                "import {Context} from \"../../utils/Context.sol\";",
                "import {Strings} from \"../../utils/Strings.sol\";",
                "import {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";",
                "import {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";"
            ],
            "context": "{'function name() external  view returns (string memory)', 'function symbol() external  view returns (string memory _symbol)', 'function symbol() external  view returns (string memory)', 'function name() external  view returns (string memory _name)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with a name and symbol.\n *\n * @param name_ The name of the contract or token.\n * @param symbol_ The symbol representing the contract or token.\n *\n * Steps:\n * 1. Assign the provided name to the `_name` state variable.\n * 2. Assign the provided symbol to the `_symbol` state variable.\n */"
        },
        {
            "identifier": "_mint",
            "parameters": "address to, uint256 tokenId",
            "modifiers": "",
            "return": "",
            "body": "function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }",
            "start": "285",
            "end": "293",
            "class": "ERC721",
            "signature": " _mintaddress to, uint256 tokenId",
            "full_signature": "function _mint(address to, uint256 tokenId) internal",
            "class_method_signature": "ERC721._mintaddress to, uint256 tokenId",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC721} from \"./IERC721.sol\";",
                "import {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";",
                "import {ERC721Utils} from \"./utils/ERC721Utils.sol\";",
                "import {Context} from \"../../utils/Context.sol\";",
                "import {Strings} from \"../../utils/Strings.sol\";",
                "import {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";",
                "import {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";"
            ],
            "context": "{'function ERC721InvalidSender()', 'function ERC721InvalidReceiver()'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Mints a new ERC721 token to the specified address.\n *\n * @param to The address to which the token will be minted.\n * @param tokenId The ID of the token to be minted.\n *\n * Steps:\n * 1. Check if the `to` address is the zero address. If so, revert with an error indicating an invalid receiver.\n * 2. Update the token's ownership by calling `_update` with the `to` address, `tokenId`, and the zero address as the previous owner.\n * 3. If the `previousOwner` is not the zero address, revert with an error indicating an invalid sender.\n *\n * @dev This function is internal and can only be called within the contract or derived contracts.\n */"
        },
        {
            "identifier": "_burn",
            "parameters": "uint256 tokenId",
            "modifiers": "",
            "return": "",
            "body": "function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }",
            "start": "329",
            "end": "334",
            "class": "ERC721",
            "signature": " _burnuint256 tokenId",
            "full_signature": "function _burn(uint256 tokenId) internal",
            "class_method_signature": "ERC721._burnuint256 tokenId",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC721} from \"./IERC721.sol\";",
                "import {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";",
                "import {ERC721Utils} from \"./utils/ERC721Utils.sol\";",
                "import {Context} from \"../../utils/Context.sol\";",
                "import {Strings} from \"../../utils/Strings.sol\";",
                "import {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";",
                "import {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";"
            ],
            "context": "{'function ERC721NonexistentToken()'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to burn (destroy) a specific token.\n *\n * @param tokenId The ID of the token to be burned.\n *\n * Steps:\n * 1. Call `_update` to set the owner of the token to `address(0)` (indicating it is burned).\n * 2. If the token did not exist (i.e., `previousOwner` is `address(0)`), revert with an error indicating the token does not exist.\n *\n * Reverts:\n * - If the token does not exist, reverts with `ERC721NonexistentToken`.\n */"
        }
    ],
    "/root/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC4626.sol": [
        {
            "identifier": "",
            "parameters": "IERC20 asset_",
            "modifiers": "",
            "return": "",
            "body": "constructor(IERC20 asset_) {\n        (bool success, uint8 assetDecimals) = _tryGetAssetDecimals(asset_);\n        _underlyingDecimals = success ? assetDecimals : 18;\n        _asset = asset_;\n    }",
            "start": "77",
            "end": "81",
            "class": "ERC4626",
            "signature": " IERC20 asset_",
            "full_signature": "constructor (IERC20 asset_)",
            "class_method_signature": "ERC4626.IERC20 asset_",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {IERC20, IERC20Metadata, ERC20} from \"../ERC20.sol\";",
                "import {SafeERC20} from \"../utils/SafeERC20.sol\";",
                "import {IERC4626} from \"../../../interfaces/IERC4626.sol\";",
                "import {Math} from \"../../../utils/math/Math.sol\";"
            ],
            "context": "{'function asset() external  view returns (address assetTokenAddress)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with an ERC20 asset and attempts to retrieve its decimals.\n *\n * @param asset_ The ERC20 token asset to be associated with this contract.\n *\n * Steps:\n * 1. Attempt to retrieve the decimals of the provided ERC20 asset using `_tryGetAssetDecimals`.\n * 2. If successful, store the retrieved decimals in `_underlyingDecimals`. Otherwise, default to 18.\n * 3. Assign the provided ERC20 asset to the `_asset` state variable.\n */ "
        }
    ],
    "/root/openzeppelin-contracts/contracts/proxy/Clones.sol": [
        {
            "identifier": "clone",
            "parameters": "address implementation, uint256 value",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function clone(address implementation, uint256 value) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(value, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }",
            "start": "39",
            "end": "54",
            "class": "Clones",
            "signature": "returns (address instance) cloneaddress implementation, uint256 value",
            "full_signature": "function clone(address implementation, uint256 value) internal   returns (address instance)",
            "class_method_signature": "Clones.cloneaddress implementation, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function FailedDeployment()', 'function InsufficientBalance()'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract implementation by deploying a new instance using the provided implementation address and value.\n *\n * @param implementation The address of the contract implementation to clone.\n * @param value The amount of Ether to send with the deployment.\n * @return instance The address of the newly deployed contract instance.\n *\n * Steps:\n * 1. Check if the contract's balance is sufficient to cover the provided value. If not, revert with an `InsufficientBalance` error.\n * 2. Use inline assembly to:\n *    - Clean the upper 96 bits of the `implementation` address.\n *    - Pack the first 3 bytes of the `implementation` address with the bytecode before the address.\n *    - Pack the remaining 17 bytes of the `implementation` address with the bytecode after the address.\n *    - Deploy the new contract instance using the `create` opcode with the provided value and bytecode.\n * 3. If the deployment fails (i.e., the instance address is 0), revert with a `FailedDeployment` error.\n * 4. Return the address of the newly deployed contract instance.\n */"
        },
        {
            "identifier": "cloneDeterministic",
            "parameters": "address implementation, bytes32 salt, uint256 value",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic(\n        address implementation,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        assembly (\"memory-safe\") {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(value, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }",
            "start": "74",
            "end": "93",
            "class": "Clones",
            "signature": "returns (address instance) cloneDeterministicaddress implementation, bytes32 salt, uint256 value",
            "full_signature": "function cloneDeterministic(address implementation, bytes32 salt, uint256 value) internal   returns (address instance)",
            "class_method_signature": "Clones.cloneDeterministicaddress implementation, bytes32 salt, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function FailedDeployment()', 'function InsufficientBalance()'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using the `create2` opcode.\n *\n * @param implementation The address of the contract implementation to clone.\n * @param salt A unique salt value to ensure deterministic address generation.\n * @param value The amount of Ether to send with the deployment.\n * @return instance The address of the newly deployed contract instance.\n *\n * Steps:\n * 1. Check if the contract has sufficient balance to cover the `value`. If not, revert with an `InsufficientBalance` error.\n * 2. Use inline assembly to:\n *    - Clean the upper 96 bits of the `implementation` address.\n *    - Pack the first 3 bytes of the `implementation` address with the bytecode before the address.\n *    - Pack the remaining 17 bytes of the `implementation` address with the bytecode after the address.\n *    - Deploy the contract using `create2` with the provided `value`, bytecode, and `salt`.\n * 3. If the deployment fails (i.e., `instance` is `address(0)`), revert with a `FailedDeployment` error.\n * 4. Return the address of the newly deployed contract instance.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "address implementation, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := and(keccak256(add(ptr, 0x43), 0x55), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }",
            "start": "98",
            "end": "113",
            "class": "Clones",
            "signature": "returns (address predicted) predictDeterministicAddressaddress implementation, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "Clones.predictDeterministicAddressaddress implementation, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal   returns (address addr)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using the CREATE2 opcode.\n *\n * @param implementation The address of the implementation contract.\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer (typically the contract deploying the new instance).\n * @return predicted The predicted deterministic address for the contract deployment.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the deployer address, implementation address, and salt in memory.\n * 3. Use the CREATE2 opcode formula to compute the deterministic address:\n *    - The formula involves hashing the deployer address, implementation address, and salt.\n *    - The result is masked to ensure it is a valid Ethereum address.\n * 4. Return the predicted address.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "view",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }",
            "start": "118",
            "end": "123",
            "class": "Clones",
            "signature": "returns (address predicted) predictDeterministicAddressaddress implementation, bytes32 salt",
            "full_signature": "function predictDeterministicAddress(address implementation, bytes32 salt) internal  view returns (address predicted)",
            "class_method_signature": "Clones.predictDeterministicAddressaddress implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using the given implementation and salt.\n *\n * @param implementation The address of the implementation contract.\n * @param salt A unique bytes32 value used to generate the deterministic address.\n * @return predicted The predicted address of the contract that would be deployed with the given implementation and salt.\n *\n * Steps:\n * 1. Calls an internal function `predictDeterministicAddress` with the provided implementation, salt, and the address of the current contract (`address(this)`).\n * 2. Returns the predicted address based on the inputs.\n */"
        },
        {
            "identifier": "cloneWithImmutableArgs",
            "parameters": "address implementation, bytes memory args, uint256 value",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        uint256 value\n    ) internal returns (address instance) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        assembly (\"memory-safe\") {\n            instance := create(value, add(bytecode, 0x20), mload(bytecode))\n        }\n        if (instance == address(0)) {\n            revert Errors.FailedDeployment();\n        }\n    }",
            "start": "143",
            "end": "158",
            "class": "Clones",
            "signature": "returns (address instance) cloneWithImmutableArgsaddress implementation, bytes memory args, uint256 value",
            "full_signature": "function cloneWithImmutableArgs(address implementation, bytes memory args, uint256 value) internal   returns (address instance)",
            "class_method_signature": "Clones.cloneWithImmutableArgsaddress implementation, bytes memory args, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function FailedDeployment()', 'function InsufficientBalance()'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clones a contract with immutable arguments and deploys it using the provided implementation and arguments.\n *\n * @param implementation The address of the contract implementation to clone.\n * @param args The immutable arguments to be passed to the cloned contract.\n * @param value The amount of Ether to send with the deployment.\n * @return instance The address of the newly deployed contract instance.\n *\n * Steps:\n * 1. Check if the contract has sufficient balance to cover the `value` sent with the deployment.\n *    - If not, revert with an `InsufficientBalance` error.\n * 2. Generate the bytecode for the cloned contract with the provided implementation and immutable arguments.\n * 3. Use assembly to deploy the contract with the generated bytecode and the specified `value`.\n * 4. Check if the deployment was successful (i.e., `instance` is not `address(0)`).\n *    - If not, revert with a `FailedDeployment` error.\n * 5. Return the address of the deployed contract instance.\n */"
        },
        {
            "identifier": "cloneDeterministicWithImmutableArgs",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        return cloneDeterministicWithImmutableArgs(implementation, args, salt, 0);\n    }",
            "start": "169",
            "end": "175",
            "class": "Clones",
            "signature": "returns (address instance) cloneDeterministicWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt",
            "full_signature": "function cloneDeterministicWithImmutableArgs(address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "Clones.cloneDeterministicWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically with immutable arguments using a specified salt.\n *\n * @param implementation The address of the implementation contract to clone.\n * @param args The immutable arguments to be passed to the cloned contract.\n * @param salt A unique salt value to ensure deterministic deployment.\n * @return instance The address of the newly cloned contract instance.\n *\n * Steps:\n * 1. Calls an internal function `cloneDeterministicWithImmutableArgs` with the provided implementation, args, salt, and an additional parameter set to 0.\n * 2. Returns the address of the cloned contract instance.\n */"
        },
        {
            "identifier": "cloneDeterministicWithImmutableArgs",
            "parameters": "address implementation, bytes memory args, bytes32 salt, uint256 value",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministicWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        uint256 value\n    ) internal returns (address instance) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.deploy(value, salt, bytecode);\n    }",
            "start": "184",
            "end": "192",
            "class": "Clones",
            "signature": "returns (address instance) cloneDeterministicWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt, uint256 value",
            "full_signature": "function cloneDeterministicWithImmutableArgs(address implementation, bytes memory args, bytes32 salt, uint256 value) internal   returns (address instance)",
            "class_method_signature": "Clones.cloneDeterministicWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal   returns (address addr)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Deploys a new contract instance deterministically using Create2 with immutable arguments.\n *\n * @param implementation The address of the implementation contract to clone.\n * @param args The immutable arguments to be passed to the cloned contract.\n * @param salt A unique salt value to ensure deterministic deployment.\n * @param value The amount of Ether to send with the deployment.\n *\n * @return instance The address of the newly deployed contract instance.\n *\n * Steps:\n * 1. Generate the bytecode for the clone with the provided implementation and immutable arguments.\n * 2. Use Create2 to deploy the contract with the generated bytecode, salt, and specified Ether value.\n * 3. Return the address of the deployed contract instance.\n */"
        },
        {
            "identifier": "predictDeterministicAddressWithImmutableArgs",
            "parameters": "address implementation, bytes memory args, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes memory bytecode = _cloneCodeWithImmutableArgs(implementation, args);\n        return Create2.computeAddress(salt, keccak256(bytecode), deployer);\n    }",
            "start": "197",
            "end": "205",
            "class": "Clones",
            "signature": "returns (address predicted) predictDeterministicAddressWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressWithImmutableArgs(address implementation, bytes memory args, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "Clones.predictDeterministicAddressWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "{'function computeAddress(bytes32 salt, bytes32 bytecodeHash) internal  view returns (address)', 'function computeAddress(bytes32 salt, bytes32 bytecodeHash, address deployer) internal  pure returns (address addr)', 'function deploy(uint256 amount, bytes32 salt, bytes memory bytecode) internal   returns (address addr)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address of a contract to be deployed using Create2 with immutable arguments.\n *\n * @param implementation The address of the implementation contract.\n * @param args The immutable arguments to be encoded into the contract bytecode.\n * @param salt A unique salt used to determine the deployment address.\n * @param deployer The address of the deployer who will deploy the contract.\n *\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Generate the contract bytecode with the provided immutable arguments using `_cloneCodeWithImmutableArgs`.\n * 2. Compute the deterministic address using Create2's `computeAddress` function, which takes the salt, the keccak256 hash of the bytecode, and the deployer's address.\n * 3. Return the predicted address.\n */"
        },
        {
            "identifier": "predictDeterministicAddressWithImmutableArgs",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "view",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressWithImmutableArgs(\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddressWithImmutableArgs(implementation, args, salt, address(this));\n    }",
            "start": "210",
            "end": "216",
            "class": "Clones",
            "signature": "returns (address predicted) predictDeterministicAddressWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt",
            "full_signature": "function predictDeterministicAddressWithImmutableArgs(address implementation, bytes memory args, bytes32 salt) internal  view returns (address predicted)",
            "class_method_signature": "Clones.predictDeterministicAddressWithImmutableArgsaddress implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using immutable arguments.\n *\n * @param implementation The address of the implementation contract.\n * @param args The immutable arguments to be passed to the contract.\n * @param salt The salt used to generate the deterministic address.\n * @return predicted The predicted address of the contract deployment.\n *\n * Steps:\n * 1. Calls an internal function `predictDeterministicAddressWithImmutableArgs` with the provided implementation, args, salt, and the current contract's address (`address(this)`).\n * 2. Returns the predicted address based on the provided parameters.\n */"
        },
        {
            "identifier": "fetchCloneArgs",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (bytes memory)",
            "body": "function fetchCloneArgs(address instance) internal view returns (bytes memory) {\n        bytes memory result = new bytes(instance.code.length - 45); // revert if length is too short\n        assembly (\"memory-safe\") {\n            extcodecopy(instance, add(result, 32), 45, mload(result))\n        }\n        return result;\n    }",
            "start": "229",
            "end": "235",
            "class": "Clones",
            "signature": "returns (bytes memory) fetchCloneArgsaddress instance",
            "full_signature": "function fetchCloneArgs(address instance) internal  view returns (bytes memory)",
            "class_method_signature": "Clones.fetchCloneArgsaddress instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": [
                "import {Create2} from \"../utils/Create2.sol\";",
                "import {Errors} from \"../utils/Errors.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Fetches the clone arguments from the given instance's bytecode.\n *\n * @param instance The address of the contract instance from which to fetch the clone arguments.\n * @return result A bytes array containing the clone arguments extracted from the instance's bytecode.\n *\n * Steps:\n * 1. Allocate a new bytes array (`result`) with a length equal to the instance's bytecode length minus 45 bytes.\n *    - This assumes that the first 45 bytes of the bytecode are not part of the clone arguments.\n *    - If the bytecode is too short, the function will revert.\n * 2. Use inline assembly to copy the relevant portion of the instance's bytecode into the `result` array.\n *    - `extcodecopy` is used to copy the bytecode starting from byte 45 to the end of the bytecode.\n * 3. Return the `result` array containing the extracted clone arguments.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/metrics/Statistics.sol": [
        {
            "identifier": "Level",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Level {\n        uint256 noOfInstancesCreated;\n        uint256 noOfInstancesSubmitted_Success;\n        uint256 noOfSubmissions_Failed;\n    }",
            "start": "22",
            "end": "26",
            "class": "Statistics",
            "signature": " Level",
            "full_signature": "function Level()",
            "class_method_signature": "Statistics.Level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct to store statistics related to a level in the Ethernaut game.\n *\n * Fields:\n * - `noOfInstancesCreated`: The total number of instances created for this level.\n * - `noOfInstancesSubmitted_Success`: The total number of instances successfully submitted for this level.\n * - `noOfSubmissions_Failed`: The total number of failed submissions for this level.\n */ "
        },
        {
            "identifier": "createNewInstance",
            "parameters": "address instance, address level, address player",
            "modifiers": "levelExistsCheck(level)",
            "return": "",
            "body": "function createNewInstance(address instance, address level, address player)\n        external\n        onlyEthernaut\n        levelExistsCheck(level)\n    {\n        if (!doesPlayerExist(player)) {\n            players.push(player);\n            playerExists[player] = true;\n        }\n        // If it is the first instance of the level\n        if (playerStats[player][level].instance == address(0)) {\n            levelFirstInstanceCreationTime[player][level] = block.timestamp;\n        }\n        playerStats[player][level] = LevelInstance(\n            instance,\n            false,\n            block.timestamp,\n            0,\n            playerStats[player][level].timeSubmitted.length != 0\n                ? playerStats[player][level].timeSubmitted\n                : new uint256[](0)\n        );\n        levelStats[level].noOfInstancesCreated++;\n        globalNoOfInstancesCreated++;\n        globalNoOfInstancesCreatedByPlayer[player]++;\n    }",
            "start": "69",
            "end": "94",
            "class": "Statistics",
            "signature": " createNewInstanceaddress instance, address level, address player",
            "full_signature": "function createNewInstance(address instance, address level, address player) external  levelExistsCheck(level)",
            "class_method_signature": "Statistics.createNewInstanceaddress instance, address level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Creates a new instance of a level for a player. This function is restricted to the Ethernaut contract and ensures the level exists.\n *\n * @param instance The address of the new level instance being created.\n * @param level The address of the level contract.\n * @param player The address of the player for whom the instance is being created.\n *\n * Steps:\n * 1. Check if the player exists in the system. If not, add the player to the `players` array and mark them as existing.\n * 2. If this is the first instance of the level for the player, record the creation timestamp.\n * 3. Update the player's stats for the level, including the instance address, completion status, creation timestamp, and submission history.\n * 4. Increment the global and level-specific counters for the number of instances created.\n * 5. Increment the player-specific counter for the number of instances created.\n *\n * Requirements:\n * - The function can only be called by the Ethernaut contract (`onlyEthernaut` modifier).\n * - The level must exist (`levelExistsCheck` modifier).\n */"
        },
        {
            "identifier": "submitSuccess",
            "parameters": "address instance, address level, address player",
            "modifiers": "playerExistsCheck(player)",
            "return": "",
            "body": "function submitSuccess(address instance, address level, address player)\n        external\n        onlyEthernaut\n        levelExistsCheck(level)\n        playerExistsCheck(player)\n    {\n        require(playerStats[player][level].instance != address(0), \"Instance for the level is not created\");\n        require(playerStats[player][level].instance == instance, \"Submitted instance is not the created one\");\n        require(playerStats[player][level].isCompleted == false, \"Level already completed\");\n        // If it is the first submission in the level\n        if (levelFirstCompletionTime[player][level] == 0) {\n            globalNoOfLevelsCompletedByPlayer[player]++;\n            levelFirstCompletionTime[player][level] = block.timestamp;\n            uint256 totalNoOfLevelsCompletedByPlayer = globalNoOfLevelsCompletedByPlayer[player];\n            uint256 newAverageTimeTakenToCompleteLevels =\n                updateAverageTimeTakenToCompleteLevelsByPlayer(player, level, totalNoOfLevelsCompletedByPlayer);\n            emit playerScoreProfile(player, newAverageTimeTakenToCompleteLevels, totalNoOfLevelsCompletedByPlayer);\n        }\n        playerStats[player][level].timeSubmitted.push(block.timestamp);\n        playerStats[player][level].timeCompleted = block.timestamp;\n        playerStats[player][level].isCompleted = true;\n        levelStats[level].noOfInstancesSubmitted_Success++;\n        globalNoOfInstancesCompleted++;\n        globalNoOfInstancesCompletedByPlayer[player]++;\n    }",
            "start": "96",
            "end": "120",
            "class": "Statistics",
            "signature": " submitSuccessaddress instance, address level, address player",
            "full_signature": "function submitSuccess(address instance, address level, address player) external  playerExistsCheck(player)",
            "class_method_signature": "Statistics.submitSuccessaddress instance, address level, address player",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Submits a successful level completion for a player.\n *\n * @dev This function is restricted to be called only by the Ethernaut contract and performs several checks:\n * 1. Ensures the instance for the level has been created.\n * 2. Verifies that the submitted instance matches the created one.\n * 3. Checks that the level has not already been completed.\n *\n * If it is the first submission for the level:\n * 1. Increments the global count of levels completed by the player.\n * 2. Records the first completion time for the level.\n * 3. Updates the average time taken to complete levels by the player.\n * 4. Emits a `playerScoreProfile` event with the updated player's score profile.\n *\n * Additionally, it:\n * 1. Records the submission and completion timestamps.\n * 2. Marks the level as completed.\n * 3. Updates the number of successful submissions for the level and globally.\n * 4. Increments the global count of instances completed by the player.\n *\n * @param instance The address of the level instance being submitted.\n * @param level The address of the level contract.\n * @param player The address of the player submitting the level.\n *\n * Requirements:\n * - The instance must have been created for the level.\n * - The submitted instance must match the created one.\n * - The level must not have been completed already.\n */"
        },
        {
            "identifier": "saveNewLevel",
            "parameters": "address level",
            "modifiers": "onlyEthernaut",
            "return": "",
            "body": "function saveNewLevel(address level) external levelDoesntExistCheck(level) onlyEthernaut {\n        levelExists[level] = true;\n        levels.push(level);\n    }",
            "start": "137",
            "end": "140",
            "class": "Statistics",
            "signature": " saveNewLeveladdress level",
            "full_signature": "function saveNewLevel(address level) external  onlyEthernaut",
            "class_method_signature": "Statistics.saveNewLeveladdress level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Saves a new level address to the list of registered levels.\n * \n * @param level The address of the level to be registered.\n *\n * Requirements:\n * - The level must not already exist in the registry (enforced by `levelDoesntExistCheck` modifier).\n * - Only the Ethernaut contract can call this function (enforced by `onlyEthernaut` modifier).\n *\n * Steps:\n * 1. Mark the level as existing by setting `levelExists[level]` to `true`.\n * 2. Add the level address to the `levels` array.\n */"
        },
        {
            "identifier": "getTimeElapsedForCompletionOfLevel",
            "parameters": "address player, address level",
            "modifiers": "levelExistsCheck(level)",
            "return": "returns (uint256)",
            "body": "function getTimeElapsedForCompletionOfLevel(address player, address level)\n        public\n        view\n        playerExistsCheck(player)\n        levelExistsCheck(level)\n        returns (uint256)\n    {\n        require(levelFirstCompletionTime[player][level] != 0, \"Level not completed\");\n        return levelFirstCompletionTime[player][level] - levelFirstInstanceCreationTime[player][level];\n    }",
            "start": "205",
            "end": "214",
            "class": "Statistics",
            "signature": "returns (uint256) getTimeElapsedForCompletionOfLeveladdress player, address level",
            "full_signature": "function getTimeElapsedForCompletionOfLevel(address player, address level) public  levelExistsCheck(level) returns (uint256)",
            "class_method_signature": "Statistics.getTimeElapsedForCompletionOfLeveladdress player, address level",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the time elapsed between the creation and completion of a level instance for a specific player.\n *\n * @param player The address of the player whose level completion time is being queried.\n * @param level The address of the level contract for which the completion time is being queried.\n *\n * @return uint256 The time elapsed (in seconds) between the creation and completion of the level instance.\n *\n * Requirements:\n * - The player must exist (checked via `playerExistsCheck` modifier).\n * - The level must exist (checked via `levelExistsCheck` modifier).\n * - The level must have been completed by the player, otherwise the function reverts with the message \"Level not completed\".\n *\n * Steps:\n * 1. Check if the player and level exist using the respective modifiers.\n * 2. Ensure the level has been completed by the player by checking if `levelFirstCompletionTime[player][level]` is not zero.\n * 3. Calculate the time elapsed by subtracting the level creation time (`levelFirstInstanceCreationTime[player][level]`) from the level completion time (`levelFirstCompletionTime[player][level]`).\n * 4. Return the calculated time elapsed.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/attacks/CoinFlipAttack.sol": [
        {
            "identifier": "attack",
            "parameters": "address _victim",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function attack(address _victim) public returns (bool) {\n        CoinFlip coinflip = CoinFlip(_victim);\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n        uint256 coinFlip = uint256(uint256(blockValue) / FACTOR);\n        bool side = coinFlip == 1 ? true : false;\n        coinflip.flip(side);\n        return side;\n    }",
            "start": "10",
            "end": "17",
            "class": "CoinFlipAttack",
            "signature": "returns (bool) attackaddress _victim",
            "full_signature": "function attack(address _victim) public   returns (bool)",
            "class_method_signature": "CoinFlipAttack.attackaddress _victim",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"../levels/CoinFlip.sol\";"
            ],
            "context": "{'uint256   FACTOR', 'function flip(bool _guess) public   returns (bool)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an attack on a CoinFlip contract by predicting the outcome of a coin flip.\n *\n * @param _victim The address of the CoinFlip contract to attack.\n * @return side The predicted side of the coin flip (true or false).\n *\n * Steps:\n * 1. Create an instance of the CoinFlip contract using the provided victim address.\n * 2. Retrieve the blockhash of the previous block and convert it to a uint256 value.\n * 3. Calculate the coin flip outcome by dividing the block value by a predefined FACTOR.\n * 4. Determine the side of the coin flip (true or false) based on the calculated value.\n * 5. Call the `flip` function on the CoinFlip contract with the predicted side.\n * 6. Return the predicted side.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Dex.sol": [
        {
            "identifier": "swap",
            "parameters": "address from, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function swap(address from, address to, uint256 amount) public {\n        require((from == token1 && to == token2) || (from == token2 && to == token1), \"Invalid tokens\");\n        require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n        uint256 swapAmount = getSwapPrice(from, to, amount);\n        IERC20(from).transferFrom(msg.sender, address(this), amount);\n        IERC20(to).approve(address(this), swapAmount);\n        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);\n    }",
            "start": "23",
            "end": "30",
            "class": "Dex",
            "signature": " swapaddress from, address to, uint256 amount",
            "full_signature": "function swap(address from, address to, uint256 amount) public",
            "class_method_signature": "Dex.swapaddress from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Swaps tokens between two supported token pairs.\n *\n * @param from The address of the token to swap from.\n * @param to The address of the token to swap to.\n * @param amount The amount of tokens to swap.\n *\n * Requirements:\n * 1. The `from` and `to` tokens must be one of the supported pairs (`token1` and `token2`).\n * 2. The caller must have a sufficient balance of the `from` token to perform the swap.\n *\n * Steps:\n * 1. Calculate the swap amount using the `getSwapPrice` function.\n * 2. Transfer the `amount` of `from` tokens from the caller to this contract.\n * 3. Approve the contract to transfer the calculated `swapAmount` of `to` tokens.\n * 4. Transfer the `swapAmount` of `to` tokens from the contract to the caller.\n *\n * Reverts:\n * - If the `from` and `to` tokens are not a valid pair, with the message \"Invalid tokens\".\n * - If the caller does not have enough `from` tokens, with the message \"Not enough to swap\".\n */"
        },
        {
            "identifier": "approve",
            "parameters": "address spender, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function approve(address spender, uint256 amount) public {\n        SwappableToken(token1).approve(msg.sender, spender, amount);\n        SwappableToken(token2).approve(msg.sender, spender, amount);\n    }",
            "start": "36",
            "end": "39",
            "class": "Dex",
            "signature": " approveaddress spender, uint256 amount",
            "full_signature": "function approve(address spender, uint256 amount) public",
            "class_method_signature": "Dex.approveaddress spender, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Approves a spender to spend a specified amount of tokens on behalf of the caller for both token1 and token2.\n *\n * @param spender The address of the spender to be approved.\n * @param amount The amount of tokens the spender is allowed to spend.\n *\n * Steps:\n * 1. Call the `approve` function of `SwappableToken` for `token1`, approving the spender to spend the specified amount on behalf of the caller (`msg.sender`).\n * 2. Call the `approve` function of `SwappableToken` for `token2`, approving the spender to spend the specified amount on behalf of the caller (`msg.sender`).\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/DexTwo.sol": [
        {
            "identifier": "swap",
            "parameters": "address from, address to, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function swap(address from, address to, uint256 amount) public {\n        require(IERC20(from).balanceOf(msg.sender) >= amount, \"Not enough to swap\");\n        uint256 swapAmount = getSwapAmount(from, to, amount);\n        IERC20(from).transferFrom(msg.sender, address(this), amount);\n        IERC20(to).approve(address(this), swapAmount);\n        IERC20(to).transferFrom(address(this), msg.sender, swapAmount);\n    }",
            "start": "23",
            "end": "29",
            "class": "DexTwo",
            "signature": " swapaddress from, address to, uint256 amount",
            "full_signature": "function swap(address from, address to, uint256 amount) public",
            "class_method_signature": "DexTwo.swapaddress from, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/IERC20.sol\";",
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";",
                "import \"openzeppelin-contracts-08/access/Ownable.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Swaps tokens from one address to another.\n *\n * @param from The address of the token to swap from.\n * @param to The address of the token to swap to.\n * @param amount The amount of tokens to swap.\n *\n * Steps:\n * 1. Check if the sender has enough tokens to swap (revert if not).\n * 2. Calculate the swap amount using the `getSwapAmount` function.\n * 3. Transfer the `amount` of tokens from the sender to this contract.\n * 4. Approve the contract to spend the `swapAmount` of the target token.\n * 5. Transfer the `swapAmount` of the target token from the contract to the sender.\n *\n * Reverts:\n * - If the sender does not have enough tokens to swap.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Instance.sol": [
        {
            "identifier": "authenticate",
            "parameters": "string memory passkey",
            "modifiers": "",
            "return": "",
            "body": "function authenticate(string memory passkey) public {\n        if (keccak256(abi.encodePacked(passkey)) == keccak256(abi.encodePacked(password))) {\n            cleared = true;\n        }\n    }",
            "start": "38",
            "end": "42",
            "class": "Instance",
            "signature": " authenticatestring memory passkey",
            "full_signature": "function authenticate(string memory passkey) public",
            "class_method_signature": "Instance.authenticatestring memory passkey",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Authenticates a user by comparing the provided passkey with the stored password.\n *\n * @param passkey The passkey provided by the user for authentication.\n *\n * Steps:\n * 1. Hash the provided passkey using keccak256 and compare it with the hashed stored password.\n * 2. If the hashes match, set the `cleared` state variable to `true`, indicating successful authentication.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/CoinFlip.sol": [
        {
            "identifier": "flip",
            "parameters": "bool _guess",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function flip(bool _guess) public returns (bool) {\n        uint256 blockValue = uint256(blockhash(block.number - 1));\n\n        if (lastHash == blockValue) {\n            revert();\n        }\n\n        lastHash = blockValue;\n        uint256 coinFlip = blockValue / FACTOR;\n        bool side = coinFlip == 1 ? true : false;\n\n        if (side == _guess) {\n            consecutiveWins++;\n            return true;\n        } else {\n            consecutiveWins = 0;\n            return false;\n        }\n    }",
            "start": "13",
            "end": "31",
            "class": "CoinFlip",
            "signature": "returns (bool) flipbool _guess",
            "full_signature": "function flip(bool _guess) public   returns (bool)",
            "class_method_signature": "CoinFlip.flipbool _guess",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Simulates a coin flip game where the outcome is determined by the previous block's hash.\n *\n * @param _guess The player's guess (true or false) for the coin flip outcome.\n * @return bool Returns true if the guess matches the outcome, otherwise false.\n *\n * Steps:\n * 1. Retrieve the hash of the previous block and convert it to a uint256 value.\n * 2. Check if the previous block's hash matches the last recorded hash. If it does, revert the transaction to prevent replay attacks.\n * 3. Store the current block's hash as the last recorded hash.\n * 4. Calculate the coin flip outcome by dividing the block hash by a predefined factor (`FACTOR`).\n * 5. Determine the side of the coin flip (true or false) based on the calculated value.\n * 6. Compare the player's guess with the calculated outcome:\n *    - If they match, increment the consecutive wins counter and return true.\n *    - If they don't match, reset the consecutive wins counter to 0 and return false.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/HigherOrder.sol": [
        {
            "identifier": "registerTreasury",
            "parameters": "uint8",
            "modifiers": "",
            "return": "",
            "body": "function registerTreasury(uint8) public {\n        assembly {\n            sstore(treasury_slot, calldataload(4))\n        }\n    }",
            "start": "9",
            "end": "13",
            "class": "HigherOrder",
            "signature": " registerTreasuryuint8",
            "full_signature": "function registerTreasury(uint8) public",
            "class_method_signature": "HigherOrder.registerTreasuryuint8",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity 0.6.12;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Registers a treasury address by storing it in the contract's storage.\n *\n * @dev This function uses inline assembly to directly store the treasury address \n *      from the calldata into the contract's storage slot.\n *\n * Steps:\n * 1. Use inline assembly to load the treasury address from the calldata (starting at byte 4).\n * 2. Store the loaded address in the designated storage slot (`treasury_slot`).\n */"
        },
        {
            "identifier": "claimLeadership",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "function claimLeadership() public {\n        if (treasury > 255) commander = msg.sender;\n        else revert(\"Only members of the Higher Order can become Commander\");\n    }",
            "start": "15",
            "end": "18",
            "class": "HigherOrder",
            "signature": " claimLeadership",
            "full_signature": "function claimLeadership() public",
            "class_method_signature": "HigherOrder.claimLeadership",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity 0.6.12;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Allows a user to claim leadership (Commander role) if the treasury balance exceeds 255.\n *\n * Steps:\n * 1. Check if the treasury balance is greater than 255.\n * 2. If true, assign the caller (`msg.sender`) as the new Commander.\n * 3. If false, revert with the message \"Only members of the Higher Order can become Commander\".\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Preservation.sol": [
        {
            "identifier": "",
            "parameters": "address _timeZone1LibraryAddress, address _timeZone2LibraryAddress",
            "modifiers": "",
            "return": "",
            "body": "constructor(address _timeZone1LibraryAddress, address _timeZone2LibraryAddress) {\n        timeZone1Library = _timeZone1LibraryAddress;\n        timeZone2Library = _timeZone2LibraryAddress;\n        owner = msg.sender;\n    }",
            "start": "13",
            "end": "17",
            "class": "Preservation",
            "signature": " address _timeZone1LibraryAddress, address _timeZone2LibraryAddress",
            "full_signature": "constructor (address _timeZone1LibraryAddress, address _timeZone2LibraryAddress)",
            "class_method_signature": "Preservation.address _timeZone1LibraryAddress, address _timeZone2LibraryAddress",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with the addresses of two time zone libraries and sets the deployer as the owner.\n *\n * @param _timeZone1LibraryAddress The address of the first time zone library.\n * @param _timeZone2LibraryAddress The address of the second time zone library.\n *\n * Steps:\n * 1. Assign the provided `_timeZone1LibraryAddress` to the `timeZone1Library` state variable.\n * 2. Assign the provided `_timeZone2LibraryAddress` to the `timeZone2Library` state variable.\n * 3. Set the deployer (`msg.sender`) as the owner of the contract.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Privacy.sol": [
        {
            "identifier": "unlock",
            "parameters": "bytes16 _key",
            "modifiers": "",
            "return": "",
            "body": "function unlock(bytes16 _key) public {\n        require(_key == bytes16(data[2]));\n        locked = false;\n    }",
            "start": "16",
            "end": "19",
            "class": "Privacy",
            "signature": " unlockbytes16 _key",
            "full_signature": "function unlock(bytes16 _key) public",
            "class_method_signature": "Privacy.unlockbytes16 _key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Unlocks the contract if the provided key matches the stored key.\n *\n * @param _key The key to be checked against the stored key.\n *\n * Steps:\n * 1. Require that the provided `_key` matches the key stored in `data[2]`.\n * 2. If the keys match, set the `locked` state variable to `false`, unlocking the contract.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Fallback.sol": [
        {
            "identifier": "",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "constructor() {\n        owner = msg.sender;\n        contributions[msg.sender] = 1000 * (1 ether);\n    }",
            "start": "8",
            "end": "11",
            "class": "Fallback",
            "signature": " ",
            "full_signature": "constructor ()",
            "class_method_signature": "Fallback.",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract by setting the deployer as the owner and assigning them an initial contribution.\n *\n * Steps:\n * 1. Assign the deployer's address (`msg.sender`) as the owner of the contract.\n * 2. Set the deployer's initial contribution to 1000 ether.\n */"
        },
        {
            "identifier": "contribute",
            "parameters": "",
            "modifiers": "payable",
            "return": "",
            "body": "function contribute() public payable {\n        require(msg.value < 0.001 ether);\n        contributions[msg.sender] += msg.value;\n        if (contributions[msg.sender] > contributions[owner]) {\n            owner = msg.sender;\n        }\n    }",
            "start": "18",
            "end": "24",
            "class": "Fallback",
            "signature": " contribute",
            "full_signature": "function contribute() public  payable",
            "class_method_signature": "Fallback.contribute",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Allows users to contribute Ether to the contract, with a maximum contribution of less than 0.001 Ether per transaction.\n *         If a user's total contribution exceeds the current owner's contribution, the user becomes the new owner.\n *\n * Steps:\n * 1. Require that the sent Ether (`msg.value`) is less than 0.001 Ether.\n * 2. Add the sent Ether to the user's total contribution in the `contributions` mapping.\n * 3. Check if the user's total contribution now exceeds the current owner's contribution.\n * 4. If the user's contribution is greater, update the `owner` to the user's address (`msg.sender`).\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/GoodSamaritan.sol": [
        {
            "identifier": "",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "constructor() {\n        wallet = new Wallet();\n        coin = new Coin(address(wallet));\n\n        wallet.setCoin(coin);\n    }",
            "start": "10",
            "end": "15",
            "class": "GoodSamaritan",
            "signature": " ",
            "full_signature": "constructor ()",
            "class_method_signature": "GoodSamaritan.",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity >=0.8.0 <0.9.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/utils/Address.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract by deploying a new Wallet and Coin instance, and linking them together.\n *\n * Steps:\n * 1. Deploy a new Wallet instance and assign it to the `wallet` state variable.\n * 2. Deploy a new Coin instance, passing the address of the deployed Wallet as an argument.\n * 3. Set the deployed Coin instance in the Wallet by calling `setCoin` on the Wallet.\n */"
        },
        {
            "identifier": "requestDonation",
            "parameters": "",
            "modifiers": "",
            "return": "returns (bool enoughBalance)",
            "body": "function requestDonation() external returns (bool enoughBalance) {\n        // donate 10 coins to requester\n        try wallet.donate10(msg.sender) {\n            return true;\n        } catch (bytes memory err) {\n            if (keccak256(abi.encodeWithSignature(\"NotEnoughBalance()\")) == keccak256(err)) {\n                // send the coins left\n                wallet.transferRemainder(msg.sender);\n                return false;\n            }\n        }\n    }",
            "start": "17",
            "end": "28",
            "class": "GoodSamaritan",
            "signature": "returns (bool enoughBalance) requestDonation",
            "full_signature": "function requestDonation() external   returns (bool enoughBalance)",
            "class_method_signature": "GoodSamaritan.requestDonation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity >=0.8.0 <0.9.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/utils/Address.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Requests a donation of 10 coins from the wallet to the caller.\n *\n * Steps:\n * 1. Attempt to donate 10 coins to the caller using the `donate10` function of the wallet.\n * 2. If the donation is successful, return `true`.\n * 3. If the donation fails due to insufficient balance, catch the error and check if it matches the \"NotEnoughBalance()\" error signature.\n * 4. If the error matches, transfer the remaining balance to the caller using the `transferRemainder` function of the wallet.\n * 5. Return `false` to indicate that the full donation could not be completed.\n *\n * @return enoughBalance A boolean indicating whether the full donation of 10 coins was successful (`true`) or not (`false`).\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/PuzzleWallet.sol": [
        {
            "identifier": "",
            "parameters": "address _admin, address _implementation, bytes memory _initData",
            "modifiers": "UpgradeableProxy(_implementation, _initData)",
            "return": "",
            "body": "constructor(address _admin, address _implementation, bytes memory _initData)\n        UpgradeableProxy(_implementation, _initData)\n    {\n        admin = _admin;\n    }",
            "start": "11",
            "end": "15",
            "class": "PuzzleProxy",
            "signature": " address _admin, address _implementation, bytes memory _initData",
            "full_signature": "constructor (address _admin, address _implementation, bytes memory _initData)   UpgradeableProxy(_implementation, _initData)",
            "class_method_signature": "PuzzleProxy.address _admin, address _implementation, bytes memory _initData",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;",
                "pragma experimental ABIEncoderV2;"
            ],
            "import_directive": [
                "import \"../helpers/UpgradeableProxy-08.sol\";"
            ],
            "context": "{'function _implementation() internal  override returns (address impl)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the UpgradeableProxy contract with an admin, implementation address, and initialization data.\n *\n * @param _admin The address of the admin who will manage the proxy.\n * @param _implementation The address of the implementation contract that the proxy will delegate calls to.\n * @param _initData The initialization data to be passed to the implementation contract during setup.\n *\n * Steps:\n * 1. Call the `UpgradeableProxy` constructor with the provided implementation address and initialization data.\n * 2. Assign the provided admin address to the `admin` state variable.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Vault.sol": [
        {
            "identifier": "",
            "parameters": "bytes32 _password",
            "modifiers": "",
            "return": "",
            "body": "constructor(bytes32 _password) {\n        locked = true;\n        password = _password;\n    }",
            "start": "8",
            "end": "11",
            "class": "Vault",
            "signature": " bytes32 _password",
            "full_signature": "constructor (bytes32 _password)",
            "class_method_signature": "Vault.bytes32 _password",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with a password and locks it by default.\n *\n * @param _password The password to be stored in the contract, used for unlocking.\n *\n * Steps:\n * 1. Set the `locked` state variable to `true` to lock the contract.\n * 2. Store the provided password in the `password` state variable.\n */ "
        },
        {
            "identifier": "unlock",
            "parameters": "bytes32 _password",
            "modifiers": "",
            "return": "",
            "body": "function unlock(bytes32 _password) public {\n        if (password == _password) {\n            locked = false;\n        }\n    }",
            "start": "13",
            "end": "17",
            "class": "Vault",
            "signature": " unlockbytes32 _password",
            "full_signature": "function unlock(bytes32 _password) public",
            "class_method_signature": "Vault.unlockbytes32 _password",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Unlocks the contract if the provided password matches the stored password.\n *\n * @param _password The password to be checked against the stored password.\n *\n * Steps:\n * 1. Check if the provided `_password` matches the stored `password`.\n * 2. If the passwords match, set the `locked` state variable to `false`, unlocking the contract.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/King.sol": [
        {
            "identifier": "",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "constructor() payable {\n        owner = msg.sender;\n        king = msg.sender;\n        prize = msg.value;\n    }",
            "start": "9",
            "end": "13",
            "class": "King",
            "signature": " ",
            "full_signature": "constructor ()",
            "class_method_signature": "King.",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with the deployer as the owner and king, and sets the initial prize amount.\n *\n * Steps:\n * 1. Assign the deployer's address (`msg.sender`) as the owner.\n * 2. Assign the deployer's address (`msg.sender`) as the king.\n * 3. Set the initial prize amount to the value sent with the transaction (`msg.value`).\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/NaughtCoin.sol": [
        {
            "identifier": "",
            "parameters": "address _player",
            "modifiers": "ERC20(\"NaughtCoin\", \"0x0\")",
            "return": "",
            "body": "constructor(address _player) ERC20(\"NaughtCoin\", \"0x0\") {\n        player = _player;\n        INITIAL_SUPPLY = 1000000 * (10 ** uint256(decimals()));\n        // _totalSupply = INITIAL_SUPPLY;\n        // _balances[player] = INITIAL_SUPPLY;\n        _mint(player, INITIAL_SUPPLY);\n        emit Transfer(address(0), player, INITIAL_SUPPLY);\n    }",
            "start": "14",
            "end": "21",
            "class": "NaughtCoin",
            "signature": " address _player",
            "full_signature": "constructor (address _player)   ERC20(\"NaughtCoin\", \"0x0\")",
            "class_method_signature": "NaughtCoin.address _player",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-08/token/ERC20/ERC20.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the ERC20 token with a custom name, symbol, and initial supply, and assigns the initial supply to the specified player.\n *\n * @param _player The address of the player who will receive the initial supply of tokens.\n *\n * Steps:\n * 1. Call the ERC20 constructor with the name \"NaughtCoin\" and symbol \"0x0\".\n * 2. Set the `player` state variable to the provided `_player` address.\n * 3. Calculate the initial supply as 1,000,000 tokens multiplied by 10^decimals (to account for token precision).\n * 4. Mint the initial supply of tokens to the `player` address.\n * 5. Emit a `Transfer` event from the zero address to the `player` address with the initial supply.\n */ "
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Motorbike.sol": [
        {
            "identifier": "",
            "parameters": "address _logic",
            "modifiers": "",
            "return": "",
            "body": "constructor(address _logic) public {\n        require(Address.isContract(_logic), \"ERC1967: new implementation is not a contract\");\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success,) = _logic.delegatecall(abi.encodeWithSignature(\"initialize()\"));\n        require(success, \"Call failed\");\n    }",
            "start": "17",
            "end": "22",
            "class": "Motorbike",
            "signature": " address _logic",
            "full_signature": "constructor (address _logic)",
            "class_method_signature": "Motorbike.address _logic",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity <0.7.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/utils/Address.sol\";",
                "import \"openzeppelin-contracts-06/proxy/Initializable.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract by setting the logic implementation and initializing it.\n *\n * @param _logic The address of the logic contract to be used as the implementation.\n *\n * Steps:\n * 1. Ensure that the provided `_logic` address is a valid contract.\n * 2. Store the `_logic` address in the implementation slot.\n * 3. Delegatecall the `initialize()` function on the `_logic` contract.\n * 4. Ensure that the delegatecall was successful.\n *\n * Reverts:\n * - If `_logic` is not a contract, reverts with \"ERC1967: new implementation is not a contract\".\n * - If the delegatecall to `initialize()` fails, reverts with \"Call failed\".\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Switch.sol": [
        {
            "identifier": "flipSwitch",
            "parameters": "bytes memory _data",
            "modifiers": "onlyOff",
            "return": "",
            "body": "function flipSwitch(bytes memory _data) public onlyOff {\n        (bool success,) = address(this).call(_data);\n        require(success, \"call failed :(\");\n    }",
            "start": "24",
            "end": "27",
            "class": "Switch",
            "signature": " flipSwitchbytes memory _data",
            "full_signature": "function flipSwitch(bytes memory _data) public  onlyOff",
            "class_method_signature": "Switch.flipSwitchbytes memory _data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Flips the switch by executing a low-level call with the provided data.\n * @dev This function can only be called when the switch is in the \"off\" state (enforced by `onlyOff` modifier).\n * @param _data The encoded function call data to be executed.\n *\n * Steps:\n * 1. Perform a low-level call to the contract itself with the provided `_data`.\n * 2. Require that the call is successful; otherwise, revert with the message \"call failed :(\".\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Token.sol": [
        {
            "identifier": "transfer",
            "parameters": "address _to, uint256 _value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function transfer(address _to, uint256 _value) public returns (bool) {\n        require(balances[msg.sender] - _value >= 0);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        return true;\n    }",
            "start": "12",
            "end": "17",
            "class": "Token",
            "signature": "returns (bool) transferaddress _to, uint256 _value",
            "full_signature": "function transfer(address _to, uint256 _value) public   returns (bool)",
            "class_method_signature": "Token.transferaddress _to, uint256 _value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Transfers tokens from the caller's address to the specified recipient.\n *\n * @param _to The address of the recipient to receive the tokens.\n * @param _value The amount of tokens to transfer.\n * @return A boolean indicating whether the transfer was successful.\n *\n * Steps:\n * 1. Ensure the caller has sufficient balance to transfer the specified amount.\n * 2. Deduct the transferred amount from the caller's balance.\n * 3. Add the transferred amount to the recipient's balance.\n * 4. Return `true` to indicate a successful transfer.\n *\n * @dev This function uses a simple balance check and does not handle underflow explicitly.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/MagicAnimalCarousel.sol": [
        {
            "identifier": "setAnimalAndSpin",
            "parameters": "string calldata animal",
            "modifiers": "",
            "return": "",
            "body": "function setAnimalAndSpin(string calldata animal) external {\n        uint256 encodedAnimal = encodeAnimalName(animal) >> 16;\n        uint256 nextCrateId = (carousel[currentCrateId] & NEXT_ID_MASK) >> 160;\n\n        require(encodedAnimal <= uint256(type(uint80).max), AnimalNameTooLong());\n        carousel[nextCrateId] = (carousel[nextCrateId] & ~NEXT_ID_MASK) ^ (encodedAnimal << 160 + 16)\n            | ((nextCrateId + 1) % MAX_CAPACITY) << 160 | uint160(msg.sender);\n\n        currentCrateId = nextCrateId;\n    }",
            "start": "19",
            "end": "28",
            "class": "MagicAnimalCarousel",
            "signature": " setAnimalAndSpinstring calldata animal",
            "full_signature": "function setAnimalAndSpin(string calldata animal) external",
            "class_method_signature": "MagicAnimalCarousel.setAnimalAndSpinstring calldata animal",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets an animal name and updates the carousel state.\n *\n * @param animal The animal name to be encoded and set in the carousel.\n *\n * Steps:\n * 1. Encode the provided animal name and shift it right by 16 bits.\n * 2. Retrieve the next crate ID from the current carousel state.\n *\n * 3. Ensure the encoded animal name does not exceed the maximum allowed size (uint80).\n * 4. Update the carousel state for the next crate ID:\n *    - Clear the existing animal name and set the new encoded animal name.\n *    - Update the next crate ID to the next slot in the carousel (modulo MAX_CAPACITY).\n *    - Set the caller's address (`msg.sender`) in the carousel state.\n *\n * 5. Update the `currentCrateId` to the next crate ID.\n *\n * Reverts:\n * - If the encoded animal name exceeds the maximum allowed size (uint80).\n */"
        },
        {
            "identifier": "changeAnimal",
            "parameters": "string calldata animal, uint256 crateId",
            "modifiers": "",
            "return": "",
            "body": "function changeAnimal(string calldata animal, uint256 crateId) external {\n        address owner = address(uint160(carousel[crateId] & OWNER_MASK));\n        if (owner != address(0)) {\n            require(msg.sender == owner);\n        }\n        uint256 encodedAnimal = encodeAnimalName(animal);\n        if (encodedAnimal != 0) {\n            // Replace animal\n            carousel[crateId] =\n                (encodedAnimal << 160) | (carousel[crateId] & NEXT_ID_MASK) | uint160(msg.sender); \n        } else {\n            // If no animal specified keep same animal but clear owner slot\n            carousel[crateId]= (carousel[crateId] & (ANIMAL_MASK | NEXT_ID_MASK));\n        }\n    }",
            "start": "30",
            "end": "44",
            "class": "MagicAnimalCarousel",
            "signature": " changeAnimalstring calldata animal, uint256 crateId",
            "full_signature": "function changeAnimal(string calldata animal, uint256 crateId) external",
            "class_method_signature": "MagicAnimalCarousel.changeAnimalstring calldata animal, uint256 crateId",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.28;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Allows the owner of a crate to change the animal associated with it or clear the owner slot if no animal is specified.\n *\n * @param animal The name of the new animal to associate with the crate.\n * @param crateId The ID of the crate whose animal is being changed.\n *\n * Steps:\n * 1. Retrieve the owner of the crate using the `crateId` and the `OWNER_MASK`.\n * 2. If the crate has an owner, ensure that the caller (`msg.sender`) is the owner.\n * 3. Encode the provided animal name into a uint256 value using `encodeAnimalName`.\n * 4. If the encoded animal is valid (non-zero):\n *    - Replace the animal in the crate by updating the `carousel` mapping with the new encoded animal, preserving the `NEXT_ID_MASK` and setting the owner to the caller.\n * 5. If no animal is specified (encoded animal is zero):\n *    - Clear the owner slot while preserving the existing animal and `NEXT_ID_MASK`.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Stake.sol": [
        {
            "identifier": "",
            "parameters": "address _weth",
            "modifiers": "",
            "return": "",
            "body": "constructor(address _weth) payable{\n        totalStaked += msg.value;\n        WETH = _weth;\n    }",
            "start": "10",
            "end": "13",
            "class": "Stake",
            "signature": " address _weth",
            "full_signature": "constructor (address _weth)",
            "class_method_signature": "Stake.address _weth",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with the WETH token address and accepts an initial ETH deposit.\n *\n * @param _weth The address of the WETH (Wrapped Ether) token contract.\n *\n * Steps:\n * 1. Increment the `totalStaked` state variable by the amount of ETH sent with the transaction (`msg.value`).\n * 2. Assign the provided WETH token address to the `WETH` state variable.\n */ "
        },
        {
            "identifier": "StakeWETH",
            "parameters": "uint256 amount",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function StakeWETH(uint256 amount) public returns (bool){\n        require(amount >  0.001 ether, \"Don't be cheap\");\n        (,bytes memory allowance) = WETH.call(abi.encodeWithSelector(0xdd62ed3e, msg.sender,address(this)));\n        require(bytesToUint(allowance) >= amount,\"How am I moving the funds honey?\");\n        totalStaked += amount;\n        UserStake[msg.sender] += amount;\n        (bool transfered, ) = WETH.call(abi.encodeWithSelector(0x23b872dd, msg.sender,address(this),amount));\n        Stakers[msg.sender] = true;\n        return transfered;\n    }",
            "start": "21",
            "end": "30",
            "class": "Stake",
            "signature": "returns (bool) StakeWETHuint256 amount",
            "full_signature": "function StakeWETH(uint256 amount) public   returns (bool)",
            "class_method_signature": "Stake.StakeWETHuint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Allows a user to stake WETH (Wrapped Ether) tokens.\n *\n * @param amount The amount of WETH tokens to stake. Must be greater than 0.001 ether.\n * @return bool Returns `true` if the staking operation is successful, otherwise reverts.\n *\n * Steps:\n * 1. Ensure the staking amount is greater than 0.001 ether, otherwise revert with \"Don't be cheap\".\n * 2. Check the allowance of WETH tokens for the caller (`msg.sender`) to this contract.\n * 3. Ensure the allowance is greater than or equal to the staking amount, otherwise revert with \"How am I moving the funds honey?\".\n * 4. Update the total staked amount by adding the staked amount.\n * 5. Update the user's staked amount in the `UserStake` mapping.\n * 6. Transfer the WETH tokens from the caller to this contract using the `transferFrom` function.\n * 7. Mark the caller as a staker in the `Stakers` mapping.\n * 8. Return `true` if the transfer is successful.\n */"
        },
        {
            "identifier": "Unstake",
            "parameters": "uint256 amount",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function Unstake(uint256 amount) public returns (bool){\n        require(UserStake[msg.sender] >= amount,\"Don't be greedy\");\n        UserStake[msg.sender] -= amount;\n        totalStaked -= amount;\n        (bool success, ) = payable(msg.sender).call{value : amount}(\"\");\n        return success;\n    }",
            "start": "32",
            "end": "38",
            "class": "Stake",
            "signature": "returns (bool) Unstakeuint256 amount",
            "full_signature": "function Unstake(uint256 amount) public   returns (bool)",
            "class_method_signature": "Stake.Unstakeuint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Allows a user to unstake a specified amount of tokens.\n *\n * @param amount The amount of tokens to unstake.\n * @return success A boolean indicating whether the unstaking operation was successful.\n *\n * Steps:\n * 1. Check that the user has staked at least the specified amount of tokens.\n * 2. Deduct the unstaked amount from the user's staked balance.\n * 3. Deduct the unstaked amount from the total staked amount.\n * 4. Transfer the unstaked amount back to the user's address.\n * 5. Return a boolean indicating the success of the transfer operation.\n */"
        }
    ],
    "/root/ethernaut/lib/ethernaut.git/contracts/src/levels/Fallout.sol": [
        {
            "identifier": "Fal1out",
            "parameters": "",
            "modifiers": "payable",
            "return": "",
            "body": "function Fal1out() public payable {\n        owner = msg.sender;\n        allocations[owner] = msg.value;\n    }",
            "start": "13",
            "end": "16",
            "class": "Fallout",
            "signature": " Fal1out",
            "full_signature": "function Fal1out() public  payable",
            "class_method_signature": "Fallout.Fal1out",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.6.0;"
            ],
            "import_directive": [
                "import \"openzeppelin-contracts-06/math/SafeMath.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A function that allows the caller to claim ownership by sending Ether.\n *\n * Steps:\n * 1. Assign the caller's address (`msg.sender`) as the owner.\n * 2. Record the amount of Ether sent (`msg.value`) in the `allocations` mapping under the owner's address.\n *\n * @dev This function is payable, meaning it can receive Ether when called.\n */ "
        }
    ],
    "/root/openzeppelin-community-contracts/lib/openzeppelin-community-contracts/contracts/utils/Masks.sol": [
        {
            "identifier": "toMask",
            "parameters": "uint8[] memory groups",
            "modifiers": "pure",
            "return": "returns (Mask)",
            "body": "function toMask(uint8[] memory groups) internal pure returns (Mask) {\n        Masks.Mask set = Mask.wrap(0);\n        for (uint256 i = 0; i < groups.length; ++i) {\n            set = set.union(groups[i].toMask());\n        }\n        return set;\n    }",
            "start": "17",
            "end": "23",
            "class": "Masks",
            "signature": "returns (Mask) toMaskuint8[] memory groups",
            "full_signature": "function toMask(uint8[] memory groups) internal  pure returns (Mask)",
            "class_method_signature": "Masks.toMaskuint8[] memory groups",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.20;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an array of uint8 values into a combined Mask.\n *\n * @param groups An array of uint8 values representing individual masks.\n * @return A Mask that is the union of all individual masks in the `groups` array.\n *\n * Steps:\n * 1. Initialize an empty Mask (`set`) with a value of 0.\n * 2. Iterate through each uint8 value in the `groups` array.\n * 3. Convert each uint8 value to a Mask using `toMask()`.\n * 4. Combine the current Mask (`set`) with the new Mask using the `union` operation.\n * 5. Return the final combined Mask.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/LegacyUpgrades.sol": [
        {
            "identifier": "upgradeProxy",
            "parameters": "address proxy, string memory contractName, bytes memory data",
            "modifiers": "",
            "return": "",
            "body": "function upgradeProxy(address proxy, string memory contractName, bytes memory data) internal {\n        Options memory opts;\n        Core.upgradeProxy(proxy, contractName, data, opts);\n    }",
            "start": "37",
            "end": "40",
            "class": "Upgrades",
            "signature": " upgradeProxyaddress proxy, string memory contractName, bytes memory data",
            "full_signature": "function upgradeProxy(address proxy, string memory contractName, bytes memory data) internal",
            "class_method_signature": "Upgrades.upgradeProxyaddress proxy, string memory contractName, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal', 'function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param contractName The name of the new contract implementation.\n * @param data Additional data to be passed to the upgrade function.\n *\n * Steps:\n * 1. Initialize an empty `Options` struct.\n * 2. Call the `upgradeProxy` function from the `Core` contract, passing the proxy address, contract name, data, and options.\n */"
        },
        {
            "identifier": "upgradeProxy",
            "parameters": "address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller",
            "modifiers": "",
            "return": "",
            "body": "function upgradeProxy(\n        address proxy,\n        string memory contractName,\n        bytes memory data,\n        Options memory opts,\n        address tryCaller\n    ) internal {\n        Core.upgradeProxy(proxy, contractName, data, opts, tryCaller);\n    }",
            "start": "58",
            "end": "66",
            "class": "Upgrades",
            "signature": " upgradeProxyaddress proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller",
            "full_signature": "function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller) internal",
            "class_method_signature": "Upgrades.upgradeProxyaddress proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal', 'function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation using the provided contract name, data, and options.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param contractName The name of the new contract implementation.\n * @param data Additional data to be passed during the upgrade process.\n * @param opts Options for the upgrade process.\n * @param tryCaller The address of the caller attempting the upgrade.\n *\n * Steps:\n * 1. Calls the `upgradeProxy` function from the `Core` contract, passing the proxy address, contract name, data, options, and caller address.\n */"
        },
        {
            "identifier": "upgradeProxy",
            "parameters": "address proxy, string memory contractName, bytes memory data, address tryCaller",
            "modifiers": "",
            "return": "",
            "body": "function upgradeProxy(address proxy, string memory contractName, bytes memory data, address tryCaller) internal {\n        Options memory opts;\n        Core.upgradeProxy(proxy, contractName, data, opts, tryCaller);\n    }",
            "start": "83",
            "end": "86",
            "class": "Upgrades",
            "signature": " upgradeProxyaddress proxy, string memory contractName, bytes memory data, address tryCaller",
            "full_signature": "function upgradeProxy(address proxy, string memory contractName, bytes memory data, address tryCaller) internal",
            "class_method_signature": "Upgrades.upgradeProxyaddress proxy, string memory contractName, bytes memory data, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts) internal', 'function upgradeProxy(address proxy, string memory contractName, bytes memory data, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades a proxy contract to a new implementation.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param contractName The name of the new contract implementation.\n * @param data Additional data to be passed to the upgrade function.\n * @param tryCaller The address of the caller attempting the upgrade.\n *\n * Steps:\n * 1. Create an empty `Options` struct.\n * 2. Call the `upgradeProxy` function from the `Core` contract, passing the proxy address, contract name, data, options, and caller address.\n */"
        },
        {
            "identifier": "upgradeBeacon",
            "parameters": "address beacon, string memory contractName",
            "modifiers": "",
            "return": "",
            "body": "function upgradeBeacon(address beacon, string memory contractName) internal {\n        Options memory opts;\n        Core.upgradeBeacon(beacon, contractName, opts);\n    }",
            "start": "109",
            "end": "112",
            "class": "Upgrades",
            "signature": " upgradeBeaconaddress beacon, string memory contractName",
            "full_signature": "function upgradeBeacon(address beacon, string memory contractName) internal",
            "class_method_signature": "Upgrades.upgradeBeaconaddress beacon, string memory contractName",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function upgradeBeacon(address beacon, string memory contractName, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)', 'function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades the beacon contract to a new implementation specified by the contract name.\n *\n * @param beacon The address of the beacon contract to be upgraded.\n * @param contractName The name of the new contract implementation to upgrade the beacon to.\n *\n * Steps:\n * 1. Initialize an empty `Options` struct.\n * 2. Call the `Core.upgradeBeacon` function with the provided beacon address, contract name, and empty options.\n */"
        },
        {
            "identifier": "upgradeBeacon",
            "parameters": "address beacon, string memory contractName, Options memory opts, address tryCaller",
            "modifiers": "",
            "return": "",
            "body": "function upgradeBeacon(\n        address beacon,\n        string memory contractName,\n        Options memory opts,\n        address tryCaller\n    ) internal {\n        Core.upgradeBeacon(beacon, contractName, opts, tryCaller);\n    }",
            "start": "129",
            "end": "136",
            "class": "Upgrades",
            "signature": " upgradeBeaconaddress beacon, string memory contractName, Options memory opts, address tryCaller",
            "full_signature": "function upgradeBeacon(address beacon, string memory contractName, Options memory opts, address tryCaller) internal",
            "class_method_signature": "Upgrades.upgradeBeaconaddress beacon, string memory contractName, Options memory opts, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function upgradeBeacon(address beacon, string memory contractName, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)', 'function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades the beacon contract with a new implementation.\n *\n * @param beacon The address of the beacon contract to be upgraded.\n * @param contractName The name of the contract associated with the beacon.\n * @param opts Options for the upgrade process, such as gas limits or other configurations.\n * @param tryCaller The address of the caller attempting the upgrade.\n *\n * Steps:\n * 1. Call the `upgradeBeacon` function from the `Core` contract, passing the beacon address, contract name, options, and caller address.\n * 2. The `Core` contract handles the actual upgrade logic, including validation and deployment of the new implementation.\n */"
        },
        {
            "identifier": "upgradeBeacon",
            "parameters": "address beacon, string memory contractName, address tryCaller",
            "modifiers": "",
            "return": "",
            "body": "function upgradeBeacon(address beacon, string memory contractName, address tryCaller) internal {\n        Options memory opts;\n        Core.upgradeBeacon(beacon, contractName, opts, tryCaller);\n    }",
            "start": "152",
            "end": "155",
            "class": "Upgrades",
            "signature": " upgradeBeaconaddress beacon, string memory contractName, address tryCaller",
            "full_signature": "function upgradeBeacon(address beacon, string memory contractName, address tryCaller) internal",
            "class_method_signature": "Upgrades.upgradeBeaconaddress beacon, string memory contractName, address tryCaller",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Options} from \"../src/Options.sol\";",
                "import {Core} from \"../src/internal/Core.sol\";"
            ],
            "context": "{'function upgradeBeacon(address beacon, string memory contractName, Options memory opts, address tryCaller) internal  tryPrank(tryCaller)', 'function upgradeBeacon(address beacon, string memory contractName, Options memory opts) internal'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades a beacon contract with a new implementation.\n *\n * @param beacon The address of the beacon contract to be upgraded.\n * @param contractName The name of the contract associated with the beacon.\n * @param tryCaller The address of the caller attempting the upgrade.\n *\n * Steps:\n * 1. Initialize an empty `Options` struct.\n * 2. Call the `upgradeBeacon` function from the `Core` contract, passing the beacon address, contract name, options, and caller address.\n *\n * This function is internal and is used to manage the upgrade process for beacon contracts.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/internal/Utils.sol": [
        {
            "identifier": "getFullyQualifiedName",
            "parameters": "string memory contractName, string memory outDir",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function getFullyQualifiedName(\n        string memory contractName,\n        string memory outDir\n    ) internal view returns (string memory) {\n        ContractInfo memory info = getContractInfo(contractName, outDir);\n        return string(abi.encodePacked(info.contractPath, \":\", info.shortName));\n    }",
            "start": "44",
            "end": "50",
            "class": "Utils",
            "signature": "returns (string memory) getFullyQualifiedNamestring memory contractName, string memory outDir",
            "full_signature": "function getFullyQualifiedName(string memory contractName, string memory outDir) internal  view returns (string memory)",
            "class_method_signature": "Utils.getFullyQualifiedNamestring memory contractName, string memory outDir",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Constructs the fully qualified name of a contract by combining its path and short name.\n *\n * @param contractName The name of the contract.\n * @param outDir The directory where the contract artifacts are stored.\n *\n * @return A string representing the fully qualified name of the contract in the format \"contractPath:shortName\".\n *\n * Steps:\n * 1. Retrieve the contract information (path and short name) using `getContractInfo`.\n * 2. Concatenate the contract path and short name with a colon separator.\n * 3. Return the fully qualified name as a string.\n */"
        },
        {
            "identifier": "getContractInfo",
            "parameters": "string memory contractName, string memory outDir",
            "modifiers": "view",
            "return": "returns (ContractInfo memory)",
            "body": "function getContractInfo(\n        string memory contractName,\n        string memory outDir\n    ) internal view returns (ContractInfo memory) {\n        Vm vm = Vm(CHEATCODE_ADDRESS);\n\n        ContractInfo memory info;\n\n        info.shortName = _toShortName(contractName);\n\n        string memory fileName = _toFileName(contractName);\n\n        string memory artifactPath = string(\n            abi.encodePacked(vm.projectRoot(), \"/\", outDir, \"/\", fileName, \"/\", info.shortName, \".json\")\n        );\n        string memory artifactJson = vm.readFile(artifactPath);\n\n        if (!vm.keyExistsJson(artifactJson, \".ast\")) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Could not find AST in artifact \",\n                        artifactPath,\n                        \". Set `ast = true` in foundry.toml\"\n                    )\n                )\n            );\n        }\n        info.contractPath = vm.parseJsonString(artifactJson, \".ast.absolutePath\");\n        if (vm.keyExistsJson(artifactJson, \".ast.license\")) {\n            info.license = vm.parseJsonString(artifactJson, \".ast.license\");\n        }\n        info.sourceCodeHash = vm.parseJsonString(\n            artifactJson,\n            string(abi.encodePacked(\".metadata.sources.['\", info.contractPath, \"'].keccak256\"))\n        );\n        info.artifactPath = artifactPath;\n\n        return info;\n    }",
            "start": "59",
            "end": "98",
            "class": "Utils",
            "signature": "returns (ContractInfo memory) getContractInfostring memory contractName, string memory outDir",
            "full_signature": "function getContractInfo(string memory contractName, string memory outDir) internal  view returns (ContractInfo memory)",
            "class_method_signature": "Utils.getContractInfostring memory contractName, string memory outDir",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function parseJson(string calldata json) external  pure returns (bytes memory abiEncodedData)', 'function parseJsonString(string calldata json, string calldata key) external  pure returns (string memory)', 'function keyExistsJson(string calldata json, string calldata key) external  view returns (bool)', 'function projectRoot() external  view returns (string memory path)', 'function parseJson(string calldata json, string calldata key) external  pure returns (bytes memory abiEncodedData)', 'function readFile(string calldata path) external  view returns (string memory data)', 'function keyExists(string calldata json, string calldata key) external  view returns (bool)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves contract information from the artifact file, including the contract's short name, file name, path, license, source code hash, and artifact path.\n *\n * @param contractName The name of the contract to retrieve information for.\n * @param outDir The directory where the contract artifacts are stored.\n * @return info A `ContractInfo` struct containing the contract's details.\n *\n * Steps:\n * 1. Initialize a `Vm` instance using the `CHEATCODE_ADDRESS`.\n * 2. Create a `ContractInfo` struct to store the contract's details.\n * 3. Derive the short name and file name from the `contractName`.\n * 4. Construct the artifact file path using the project root, output directory, file name, and short name.\n * 5. Read the artifact JSON file from the constructed path.\n * 6. Check if the AST (Abstract Syntax Tree) exists in the artifact JSON. If not, revert with an error message.\n * 7. Parse the contract's absolute path from the artifact JSON.\n * 8. If a license exists in the artifact JSON, parse and store it.\n * 9. Parse and store the source code hash from the artifact JSON.\n * 10. Store the artifact path in the `ContractInfo` struct.\n * 11. Return the `ContractInfo` struct containing all the parsed details.\n */"
        },
        {
            "identifier": "getBuildInfoFile",
            "parameters": "string memory sourceCodeHash, string memory contractName, string memory outDir",
            "modifiers": "",
            "return": "returns (string memory)",
            "body": "function getBuildInfoFile(\n        string memory sourceCodeHash,\n        string memory contractName,\n        string memory outDir\n    ) internal returns (string memory) {\n        string[] memory inputs = new string[](4);\n        inputs[0] = \"grep\";\n        inputs[1] = \"-rl\";\n        inputs[2] = string(abi.encodePacked('\"', sourceCodeHash, '\"'));\n        inputs[3] = string(abi.encodePacked(outDir, \"/build-info\"));\n\n        Vm.FfiResult memory result = runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (!stdout.toSlice().endsWith(\".json\".toSlice())) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Could not find build-info file with matching source code hash for contract \",\n                        contractName\n                    )\n                )\n            );\n        }\n\n        return stdout;\n    }",
            "start": "110",
            "end": "136",
            "class": "Utils",
            "signature": "returns (string memory) getBuildInfoFilestring memory sourceCodeHash, string memory contractName, string memory outDir",
            "full_signature": "function getBuildInfoFile(string memory sourceCodeHash, string memory contractName, string memory outDir) internal   returns (string memory)",
            "class_method_signature": "Utils.getBuildInfoFilestring memory sourceCodeHash, string memory contractName, string memory outDir",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function FfiResult()'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the build-info file for a contract based on its source code hash.\n *\n * @param sourceCodeHash The hash of the contract's source code.\n * @param contractName The name of the contract.\n * @param outDir The directory where the build-info files are located.\n * @return The path to the build-info file matching the source code hash.\n *\n * Steps:\n * 1. Prepare a command to search for the build-info file using the source code hash.\n * 2. Execute the command using a bash shell.\n * 3. Retrieve the output of the command.\n * 4. Check if the output ends with \".json\" to ensure it is a valid build-info file.\n * 5. If the output is not a valid build-info file, revert with an error message.\n * 6. Return the path to the build-info file.\n */"
        },
        {
            "identifier": "getOutDir",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function getOutDir() internal view returns (string memory) {\n        Vm vm = Vm(CHEATCODE_ADDRESS);\n\n        string memory defaultOutDir = \"out\";\n        return vm.envOr(\"FOUNDRY_OUT\", defaultOutDir);\n    }",
            "start": "141",
            "end": "146",
            "class": "Utils",
            "signature": "returns (string memory) getOutDir",
            "full_signature": "function getOutDir() internal  view returns (string memory)",
            "class_method_signature": "Utils.getOutDir",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "{'function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue) external  view returns (bytes[] memory value)', 'function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue) external  view returns (bytes32[] memory value)', 'function envOr(string calldata name, bytes calldata defaultValue) external  view returns (bytes memory value)', 'function envOr(string calldata name, bool defaultValue) external  view returns (bool value)', 'function envOr(string calldata name, int256 defaultValue) external  view returns (int256 value)', 'function envOr(string calldata name, string calldata defaultValue) external  view returns (string memory value)', 'function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue) external  view returns (bool[] memory value)', 'function envOr(string calldata name, string calldata delim, address[] calldata defaultValue) external  view returns (address[] memory value)', 'function envOr(string calldata name, string calldata delim, string[] calldata defaultValue) external  view returns (string[] memory value)', 'function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue) external  view returns (int256[] memory value)', 'function envOr(string calldata name, bytes32 defaultValue) external  view returns (bytes32 value)', 'function envOr(string calldata name, address defaultValue) external  view returns (address value)', 'function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue) external  view returns (uint256[] memory value)', 'function envOr(string calldata name, uint256 defaultValue) external  view returns (uint256 value)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the output directory for Foundry, with a fallback to the default directory if not specified.\n *\n * Steps:\n * 1. Initialize a Vm instance using the cheatcode address.\n * 2. Define a default output directory as \"out\".\n * 3. Attempt to retrieve the output directory from the environment variable \"FOUNDRY_OUT\".\n * 4. If the environment variable is not set, return the default output directory.\n *\n * @return The output directory path as a string.\n */"
        },
        {
            "identifier": "toBashCommand",
            "parameters": "string[] memory inputs, string memory bashPath",
            "modifiers": "pure",
            "return": "returns (string[] memory)",
            "body": "function toBashCommand(string[] memory inputs, string memory bashPath) internal pure returns (string[] memory) {\n        string memory commandString;\n        for (uint i = 0; i < inputs.length; i++) {\n            commandString = string(abi.encodePacked(commandString, inputs[i]));\n            if (i != inputs.length - 1) {\n                commandString = string(abi.encodePacked(commandString, \" \"));\n            }\n        }\n\n        string[] memory result = new string[](3);\n        result[0] = bashPath;\n        result[1] = \"-c\";\n        result[2] = commandString;\n        return result;\n    }",
            "start": "215",
            "end": "229",
            "class": "Utils",
            "signature": "returns (string[] memory) toBashCommandstring[] memory inputs, string memory bashPath",
            "full_signature": "function toBashCommand(string[] memory inputs, string memory bashPath) internal  pure returns (string[] memory)",
            "class_method_signature": "Utils.toBashCommandstring[] memory inputs, string memory bashPath",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts an array of input strings into a Bash command format.\n *\n * @param inputs An array of strings representing the command inputs.\n * @param bashPath The path to the Bash executable.\n *\n * @return result An array of strings formatted as a Bash command:\n * - result[0]: The Bash executable path.\n * - result[1]: The \"-c\" flag to execute the command.\n * - result[2]: The concatenated command string from the inputs.\n *\n * Steps:\n * 1. Initialize an empty string `commandString`.\n * 2. Iterate through the `inputs` array and concatenate each input into `commandString`, separated by spaces.\n * 3. Create a new string array `result` with a length of 3.\n * 4. Assign the Bash path, \"-c\" flag, and the concatenated command string to the `result` array.\n * 5. Return the formatted Bash command array.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/internal/DefenderDeploy.sol": [
        {
            "identifier": "deploy",
            "parameters": "string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts",
            "modifiers": "",
            "return": "returns (address)",
            "body": "function deploy(\n        string memory contractName,\n        bytes memory constructorData,\n        DefenderOptions memory defenderOpts\n    ) internal returns (address) {\n        string memory outDir = Utils.getOutDir();\n        ContractInfo memory contractInfo = Utils.getContractInfo(contractName, outDir);\n        string memory buildInfoFile = Utils.getBuildInfoFile(\n            contractInfo.sourceCodeHash,\n            contractInfo.shortName,\n            outDir\n        );\n\n        string[] memory inputs = buildDeployCommand(contractInfo, buildInfoFile, constructorData, defenderOpts);\n\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (result.exitCode != 0) {\n            revert(string(abi.encodePacked(\"Failed to deploy contract \", contractName, \": \", string(result.stderr))));\n        }\n\n        string memory deployedAddress = _parseLine(\"Deployed to address: \", stdout, true);\n        return Vm(Utils.CHEATCODE_ADDRESS).parseAddress(deployedAddress);\n    }",
            "start": "23",
            "end": "47",
            "class": "DefenderDeploy",
            "signature": "returns (address) deploystring memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts",
            "full_signature": "function deploy(string memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts) internal   returns (address)",
            "class_method_signature": "DefenderDeploy.deploystring memory contractName, bytes memory constructorData, DefenderOptions memory defenderOpts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function FfiResult()', 'address  constant CHEATCODE_ADDRESS', 'function parseAddress(string calldata stringifiedValue) external  pure returns (address parsedValue)', 'function runAsBashCommand(string[] memory inputs) internal   returns (Vm.FfiResult memory)', 'function getOutDir() internal  view returns (string memory)', 'function getContractInfo(string memory contractName, string memory outDir) internal  view returns (ContractInfo memory)', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function getBuildInfoFile(string memory sourceCodeHash, string memory contractName, string memory outDir) internal   returns (string memory)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Deploys a contract using the provided contract name, constructor data, and deployment options.\n *\n * @param contractName The name of the contract to be deployed.\n * @param constructorData The encoded constructor arguments for the contract.\n * @param defenderOpts The deployment options, including any specific configurations for the Defender service.\n *\n * @return The address of the deployed contract.\n *\n * Steps:\n * 1. Retrieve the output directory where the contract artifacts are stored.\n * 2. Fetch the contract information (e.g., source code hash, short name) using the contract name and output directory.\n * 3. Construct the build info file path using the contract's source code hash, short name, and output directory.\n *\n * 4. Build the deployment command using the contract information, build info file, constructor data, and deployment options.\n * 5. Execute the deployment command as a bash command using FFI (Foreign Function Interface).\n *\n * 6. Check the exit code of the deployment command:\n *    - If the exit code is not 0, revert with an error message indicating the deployment failure.\n *    - If the exit code is 0, parse the deployed contract address from the command's standard output.\n *\n * 7. Return the parsed deployed contract address.\n */"
        },
        {
            "identifier": "buildDeployCommand",
            "parameters": "ContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts",
            "modifiers": "view",
            "return": "returns (string[] memory)",
            "body": "function buildDeployCommand(\n        ContractInfo memory contractInfo,\n        string memory buildInfoFile,\n        bytes memory constructorData,\n        DefenderOptions memory defenderOpts\n    ) internal view returns (string[] memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        if (!(defenderOpts.licenseType).toSlice().empty()) {\n            if (defenderOpts.skipVerifySourceCode) {\n                revert(\"The `licenseType` option cannot be used when the `skipVerifySourceCode` option is `true`\");\n            } else if (defenderOpts.skipLicenseType) {\n                revert(\"The `licenseType` option cannot be used when the `skipLicenseType` option is `true`\");\n            }\n        }\n\n        string[] memory inputBuilder = new string[](255);\n\n        uint8 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\n        );\n        inputBuilder[i++] = \"deploy\";\n        inputBuilder[i++] = \"--contractName\";\n        inputBuilder[i++] = contractInfo.shortName;\n        inputBuilder[i++] = \"--contractPath\";\n        inputBuilder[i++] = contractInfo.contractPath;\n        inputBuilder[i++] = \"--chainId\";\n        inputBuilder[i++] = Strings.toString(block.chainid);\n        inputBuilder[i++] = \"--buildInfoFile\";\n        inputBuilder[i++] = buildInfoFile;\n        if (constructorData.length > 0) {\n            inputBuilder[i++] = \"--constructorBytecode\";\n            inputBuilder[i++] = vm.toString(constructorData);\n        }\n        if (defenderOpts.skipVerifySourceCode) {\n            inputBuilder[i++] = \"--verifySourceCode\";\n            inputBuilder[i++] = \"false\";\n        } else if (!(defenderOpts.licenseType).toSlice().empty()) {\n            inputBuilder[i++] = \"--licenseType\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', defenderOpts.licenseType, '\"'));\n        } else if (!defenderOpts.skipLicenseType && !(contractInfo.license).toSlice().empty()) {\n            inputBuilder[i++] = \"--licenseType\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', _toLicenseType(contractInfo), '\"'));\n        }\n        if (!(defenderOpts.relayerId).toSlice().empty()) {\n            inputBuilder[i++] = \"--relayerId\";\n            inputBuilder[i++] = defenderOpts.relayerId;\n        }\n        if (defenderOpts.salt != 0) {\n            inputBuilder[i++] = \"--salt\";\n            inputBuilder[i++] = vm.toString(defenderOpts.salt);\n        }\n        if (defenderOpts.txOverrides.gasLimit != 0) {\n            inputBuilder[i++] = \"--gasLimit\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasLimit);\n        }\n        if (defenderOpts.txOverrides.gasPrice != 0) {\n            inputBuilder[i++] = \"--gasPrice\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.gasPrice);\n        }\n        if (defenderOpts.txOverrides.maxFeePerGas != 0) {\n            inputBuilder[i++] = \"--maxFeePerGas\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxFeePerGas);\n        }\n        if (defenderOpts.txOverrides.maxPriorityFeePerGas != 0) {\n            inputBuilder[i++] = \"--maxPriorityFeePerGas\";\n            inputBuilder[i++] = Strings.toString(defenderOpts.txOverrides.maxPriorityFeePerGas);\n        }\n        if (!(defenderOpts.metadata).toSlice().empty()) {\n            inputBuilder[i++] = \"--metadata\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', vm.replace(defenderOpts.metadata, '\"', '\\\\\"'), '\"'));\n        }\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint8 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
            "start": "49",
            "end": "132",
            "class": "DefenderDeploy",
            "signature": "returns (string[] memory) buildDeployCommandContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts",
            "full_signature": "function buildDeployCommand(ContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts) internal  view returns (string[] memory)",
            "class_method_signature": "DefenderDeploy.buildDeployCommandContractInfo memory contractInfo, string memory buildInfoFile, bytes memory constructorData, DefenderOptions memory defenderOpts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function skip(bool skipTest) external', 'string  constant DEFENDER_DEPLOY_CLIENT_CLI', 'address  constant CHEATCODE_ADDRESS', 'function maxPriorityFeePerGas(PackedUserOperation calldata self) internal  pure returns (uint256)', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'VmSafe private constant vm', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)', 'function maxFeePerGas(PackedUserOperation calldata self) internal  pure returns (uint256)', 'function gasPrice(PackedUserOperation calldata self) internal  view returns (uint256)', 'function chainId(uint256 newChainId) external', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function replace(string calldata input, string calldata from, string calldata to) external  pure returns (string memory output)', 'function toString(uint256 value) internal  pure returns (string memory)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Constructs a deploy command for deploying a contract using OpenZeppelin Defender.\n *\n * @param contractInfo Contains details about the contract, such as its name, path, and license.\n * @param buildInfoFile The file containing build information for the contract.\n * @param constructorData Bytecode for the contract's constructor, if any.\n * @param defenderOpts Configuration options for the Defender deployment, including license type, relayer ID, and transaction overrides.\n *\n * Steps:\n * 1. Initialize a Vm instance for cheatcode operations.\n * 2. Validate the `licenseType` option against `skipVerifySourceCode` and `skipLicenseType` options, reverting if invalid.\n * 3. Initialize an array to store the command inputs.\n * 4. Populate the command inputs with the following:\n *    - Base command (`npx` and OpenZeppelin Defender CLI).\n *    - Contract name and path.\n *    - Chain ID and build info file.\n *    - Constructor bytecode, if provided.\n *    - License type, if applicable.\n *    - Relayer ID, if provided.\n *    - Salt, if provided.\n *    - Gas limit, gas price, max fee per gas, and max priority fee per gas, if provided.\n *    - Metadata, if provided.\n * 5. Create a correctly sized copy of the inputs array to avoid empty slots.\n * 6. Return the constructed command inputs.\n *\n * @return inputs The array of strings representing the deploy command.\n */"
        },
        {
            "identifier": "proposeUpgrade",
            "parameters": "address proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts",
            "modifiers": "",
            "return": "returns (ProposeUpgradeResponse memory)",
            "body": "function proposeUpgrade(\n        address proxyAddress,\n        address proxyAdminAddress,\n        address newImplementationAddress,\n        string memory newImplementationContractName,\n        Options memory opts\n    ) internal returns (ProposeUpgradeResponse memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        string memory outDir = Utils.getOutDir();\n        ContractInfo memory contractInfo = Utils.getContractInfo(newImplementationContractName, outDir);\n\n        string[] memory inputs = buildProposeUpgradeCommand(\n            proxyAddress,\n            proxyAdminAddress,\n            newImplementationAddress,\n            contractInfo,\n            opts\n        );\n\n        Vm.FfiResult memory result = Utils.runAsBashCommand(inputs);\n        string memory stdout = string(result.stdout);\n\n        if (result.exitCode != 0) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"Failed to propose upgrade for proxy \",\n                        vm.toString(proxyAddress),\n                        \": \",\n                        string(result.stderr)\n                    )\n                )\n            );\n        }\n\n        return parseProposeUpgradeResponse(stdout);\n    }",
            "start": "179",
            "end": "216",
            "class": "DefenderDeploy",
            "signature": "returns (ProposeUpgradeResponse memory) proposeUpgradeaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts",
            "full_signature": "function proposeUpgrade(address proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts) internal   returns (ProposeUpgradeResponse memory)",
            "class_method_signature": "DefenderDeploy.proposeUpgradeaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, string memory newImplementationContractName, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function getContractInfo(string memory contractName, string memory outDir) internal  view returns (ContractInfo memory)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function proposeUpgrade(address proxyAddress, string memory newImplementationContractName, Options memory opts) internal   returns (ProposeUpgradeResponse memory)', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'address  constant CHEATCODE_ADDRESS', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'VmSafe private constant vm', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)', 'function runAsBashCommand(string[] memory inputs) internal   returns (Vm.FfiResult memory)', 'function getOutDir() internal  view returns (string memory)', 'function FfiResult()', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) internal  pure returns (string memory)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Proposes an upgrade for a proxy contract by deploying a new implementation and submitting the upgrade proposal.\n *\n * @param proxyAddress The address of the proxy contract to be upgraded.\n * @param proxyAdminAddress The address of the proxy admin contract that manages the proxy.\n * @param newImplementationAddress The address of the new implementation contract.\n * @param newImplementationContractName The name of the new implementation contract.\n * @param opts Additional options for the upgrade proposal.\n *\n * @return ProposeUpgradeResponse A struct containing the response from the upgrade proposal process.\n *\n * Steps:\n * 1. Initialize the Vm (cheatcode) instance for interacting with the environment.\n * 2. Retrieve the output directory and contract information for the new implementation contract.\n * 3. Build the command to propose the upgrade using the provided parameters and contract info.\n * 4. Execute the command as a bash command using the Vm's FFI (Foreign Function Interface).\n * 5. Check the exit code of the command:\n *    - If the exit code is not 0, revert with an error message indicating the failure.\n *    - If successful, parse the stdout into a `ProposeUpgradeResponse` struct and return it.\n *\n * Reverts:\n * - If the command execution fails (exit code != 0), the function reverts with an error message.\n */"
        },
        {
            "identifier": "parseProposeUpgradeResponse",
            "parameters": "string memory stdout",
            "modifiers": "pure",
            "return": "returns (ProposeUpgradeResponse memory)",
            "body": "function parseProposeUpgradeResponse(string memory stdout) internal pure returns (ProposeUpgradeResponse memory) {\n        ProposeUpgradeResponse memory response;\n        response.proposalId = _parseLine(\"Proposal ID: \", stdout, true);\n        response.url = _parseLine(\"Proposal URL: \", stdout, false);\n        return response;\n    }",
            "start": "218",
            "end": "223",
            "class": "DefenderDeploy",
            "signature": "returns (ProposeUpgradeResponse memory) parseProposeUpgradeResponsestring memory stdout",
            "full_signature": "function parseProposeUpgradeResponse(string memory stdout) internal  pure returns (ProposeUpgradeResponse memory)",
            "class_method_signature": "DefenderDeploy.parseProposeUpgradeResponsestring memory stdout",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses the response from a propose upgrade command and extracts the proposal ID and URL.\n *\n * @param stdout The raw string output from the propose upgrade command.\n * @return response A `ProposeUpgradeResponse` struct containing the parsed proposal ID and URL.\n *\n * Steps:\n * 1. Initialize an empty `ProposeUpgradeResponse` struct.\n * 2. Extract the proposal ID by parsing the line starting with \"Proposal ID: \" from the stdout.\n * 3. Extract the proposal URL by parsing the line starting with \"Proposal URL: \" from the stdout.\n * 4. Return the populated `ProposeUpgradeResponse` struct.\n */"
        },
        {
            "identifier": "buildProposeUpgradeCommand",
            "parameters": "address proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts",
            "modifiers": "view",
            "return": "returns (string[] memory)",
            "body": "function buildProposeUpgradeCommand(\n        address proxyAddress,\n        address proxyAdminAddress,\n        address newImplementationAddress,\n        ContractInfo memory contractInfo,\n        Options memory opts\n    ) internal view returns (string[] memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        string[] memory inputBuilder = new string[](255);\n\n        uint8 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\n        );\n        inputBuilder[i++] = \"proposeUpgrade\";\n        inputBuilder[i++] = \"--proxyAddress\";\n        inputBuilder[i++] = vm.toString(proxyAddress);\n        inputBuilder[i++] = \"--newImplementationAddress\";\n        inputBuilder[i++] = vm.toString(newImplementationAddress);\n        inputBuilder[i++] = \"--chainId\";\n        inputBuilder[i++] = Strings.toString(block.chainid);\n        inputBuilder[i++] = \"--contractArtifactFile\";\n        inputBuilder[i++] = string(abi.encodePacked('\"', contractInfo.artifactPath, '\"'));\n        if (proxyAdminAddress != address(0)) {\n            inputBuilder[i++] = \"--proxyAdminAddress\";\n            inputBuilder[i++] = vm.toString(proxyAdminAddress);\n        }\n        if (!(opts.defender.upgradeApprovalProcessId).toSlice().empty()) {\n            inputBuilder[i++] = \"--approvalProcessId\";\n            inputBuilder[i++] = opts.defender.upgradeApprovalProcessId;\n        }\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint8 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
            "start": "247",
            "end": "289",
            "class": "DefenderDeploy",
            "signature": "returns (string[] memory) buildProposeUpgradeCommandaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts",
            "full_signature": "function buildProposeUpgradeCommand(address proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts) internal  view returns (string[] memory)",
            "class_method_signature": "DefenderDeploy.buildProposeUpgradeCommandaddress proxyAddress, address proxyAdminAddress, address newImplementationAddress, ContractInfo memory contractInfo, Options memory opts",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'string  constant DEFENDER_DEPLOY_CLIENT_CLI', 'address  constant CHEATCODE_ADDRESS', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'VmSafe private constant vm', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)', 'function proposeUpgrade(address proxyAddress, string memory newImplementationContractName, Options memory opts) internal   returns (ProposeUpgradeResponse memory)', 'function chainId(uint256 newChainId) external', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) internal  pure returns (string memory)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Builds a command to propose an upgrade for a proxy contract using OpenZeppelin Defender.\n *\n * @param proxyAddress The address of the proxy contract to be upgraded.\n * @param proxyAdminAddress The address of the proxy admin contract (optional, can be zero address).\n * @param newImplementationAddress The address of the new implementation contract.\n * @param contractInfo Contains the path to the contract artifact file.\n * @param opts Contains additional options, such as the upgrade approval process ID.\n *\n * Steps:\n * 1. Initialize a Vm instance for cheatcode operations.\n * 2. Create an array to hold the command inputs, with a maximum length of 255.\n * 3. Populate the array with the necessary command components:\n *    - Command to run the OpenZeppelin Defender CLI.\n *    - Proxy address and new implementation address.\n *    - Chain ID of the current blockchain.\n *    - Path to the contract artifact file.\n *    - Proxy admin address (if provided).\n *    - Upgrade approval process ID (if provided).\n * 4. Create a correctly sized array to hold the command inputs.\n * 5. Copy the populated inputs into the correctly sized array.\n * 6. Return the array of command inputs.\n *\n * @return inputs The array of strings representing the command to propose the upgrade.\n */"
        },
        {
            "identifier": "parseApprovalProcessResponse",
            "parameters": "string memory stdout",
            "modifiers": "pure",
            "return": "returns (ApprovalProcessResponse memory)",
            "body": "function parseApprovalProcessResponse(string memory stdout) internal pure returns (ApprovalProcessResponse memory) {\n        Vm vm = Vm(Utils.CHEATCODE_ADDRESS);\n\n        ApprovalProcessResponse memory response;\n\n        response.approvalProcessId = _parseLine(\"Approval process ID: \", stdout, true);\n\n        string memory viaString = _parseLine(\"Via: \", stdout, false);\n        if (viaString.toSlice().len() != 0) {\n            response.via = vm.parseAddress(viaString);\n        }\n\n        response.viaType = _parseLine(\"Via type: \", stdout, false);\n\n        return response;\n    }",
            "start": "304",
            "end": "319",
            "class": "DefenderDeploy",
            "signature": "returns (ApprovalProcessResponse memory) parseApprovalProcessResponsestring memory stdout",
            "full_signature": "function parseApprovalProcessResponse(string memory stdout) internal  pure returns (ApprovalProcessResponse memory)",
            "class_method_signature": "DefenderDeploy.parseApprovalProcessResponsestring memory stdout",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'address  constant CHEATCODE_ADDRESS', 'VmSafe private constant vm', 'function parseAddress(string calldata stringifiedValue) external  pure returns (address parsedValue)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses the approval process response from a given stdout string and returns an `ApprovalProcessResponse` struct.\n *\n * @param stdout The string containing the output from which the approval process response is to be parsed.\n * @return response An `ApprovalProcessResponse` struct containing the parsed data.\n *\n * Steps:\n * 1. Initialize a `Vm` instance using the cheatcode address.\n * 2. Create an empty `ApprovalProcessResponse` struct.\n * 3. Parse the \"Approval process ID\" from the stdout string and assign it to the response.\n * 4. Parse the \"Via\" field from the stdout string. If it exists, convert it to an address and assign it to the response.\n * 5. Parse the \"Via type\" from the stdout string and assign it to the response.\n * 6. Return the populated `ApprovalProcessResponse` struct.\n */"
        },
        {
            "identifier": "buildGetApprovalProcessCommand",
            "parameters": "string memory command",
            "modifiers": "view",
            "return": "returns (string[] memory)",
            "body": "function buildGetApprovalProcessCommand(string memory command) internal view returns (string[] memory) {\n        string[] memory inputBuilder = new string[](255);\n\n        uint8 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(\n            abi.encodePacked(\"@openzeppelin/defender-deploy-client-cli@\", Versions.DEFENDER_DEPLOY_CLIENT_CLI)\n        );\n        inputBuilder[i++] = command;\n        inputBuilder[i++] = \"--chainId\";\n        inputBuilder[i++] = Strings.toString(block.chainid);\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint8 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
            "start": "321",
            "end": "341",
            "class": "DefenderDeploy",
            "signature": "returns (string[] memory) buildGetApprovalProcessCommandstring memory command",
            "full_signature": "function buildGetApprovalProcessCommand(string memory command) internal  view returns (string[] memory)",
            "class_method_signature": "DefenderDeploy.buildGetApprovalProcessCommandstring memory command",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Strings} from \"@openzeppelin/contracts/utils/Strings.sol\";",
                "import {Utils, ContractInfo} from \"./Utils.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Options, DefenderOptions} from \"../Options.sol\";",
                "import {ProposeUpgradeResponse, ApprovalProcessResponse} from \"../Defender.sol\";"
            ],
            "context": "{'function toString(address value) external  pure returns (string memory stringifiedValue)', 'function toString(bool value) external  pure returns (string memory stringifiedValue)', 'string  constant DEFENDER_DEPLOY_CLIENT_CLI', 'function toString(bytes calldata value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) external  pure returns (string memory stringifiedValue)', 'function toString(bytes32 value) external  pure returns (string memory stringifiedValue)', 'function chainId(uint256 newChainId) external', 'function toString(int256 value) external  pure returns (string memory stringifiedValue)', 'function toString(uint256 value) internal  pure returns (string memory)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Constructs a command for the OpenZeppelin Defender Deploy Client CLI to get approval process details.\n *\n * @param command The base command to be executed (e.g., \"approval-process:get\").\n * @return inputs An array of strings representing the full CLI command with arguments.\n *\n * Steps:\n * 1. Initialize a string array `inputBuilder` with a size of 255 to temporarily store command components.\n * 2. Add the base command components:\n *    - \"npx\" (Node Package Executor).\n *    - The OpenZeppelin Defender Deploy Client CLI package with its version.\n *    - The provided `command` (e.g., \"approval-process:get\").\n *    - The `--chainId` flag followed by the current blockchain's chain ID.\n * 3. Create a new string array `inputs` with the correct length (number of components added).\n * 4. Copy the components from `inputBuilder` to `inputs` to avoid empty slots.\n * 5. Return the `inputs` array as the final command.\n */"
        }
    ],
    "/root/openzeppelin-foundry-upgrades/lib/openzeppelin-foundry-upgrades/src/internal/Core.sol": [
        {
            "identifier": "getUpgradeInterfaceVersion",
            "parameters": "address addr",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function getUpgradeInterfaceVersion(address addr) internal view returns (string memory) {\n        // Use staticcall to prevent forge from broadcasting it, and to ensure no state changes\n        (bool success, bytes memory returndata) = addr.staticcall(\n            abi.encodeWithSignature(\"UPGRADE_INTERFACE_VERSION()\")\n        );\n        if (success && returndata.length > 32) {\n            return abi.decode(returndata, (string));\n        } else {\n            return \"\";\n        }\n    }",
            "start": "309",
            "end": "319",
            "class": "Core",
            "signature": "returns (string memory) getUpgradeInterfaceVersionaddress addr",
            "full_signature": "function getUpgradeInterfaceVersion(address addr) internal  view returns (string memory)",
            "class_method_signature": "Core.getUpgradeInterfaceVersionaddress addr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function UPGRADE_INTERFACE_VERSION() external  pure', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function broadcast() external', 'string public constant UPGRADE_INTERFACE_VERSION', 'function broadcast(uint256 privateKey) external', 'uint256 public constant UPGRADE_INTERFACE_VERSION', 'function broadcast(address signer) external'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the upgrade interface version of a contract at the specified address.\n *\n * @param addr The address of the contract to query for the upgrade interface version.\n * @return The upgrade interface version as a string, or an empty string if the call fails or returns invalid data.\n *\n * Steps:\n * 1. Use `staticcall` to query the contract at the given address for the `UPGRADE_INTERFACE_VERSION` function.\n * 2. If the call is successful and the returned data is valid (length greater than 32 bytes), decode and return the version string.\n * 3. If the call fails or the returned data is invalid, return an empty string.\n */"
        },
        {
            "identifier": "_hasOwner",
            "parameters": "address addr",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function _hasOwner(address addr) private view returns (bool) {\n        // Use staticcall to prevent forge from broadcasting it, and to ensure no state changes\n        (bool success, bytes memory returndata) = addr.staticcall(abi.encodeWithSignature(\"owner()\"));\n        return (success && returndata.length == 32);\n    }",
            "start": "332",
            "end": "336",
            "class": "Core",
            "signature": "returns (bool) _hasOwneraddress addr",
            "full_signature": "function _hasOwner(address addr) private  view returns (bool)",
            "class_method_signature": "Core._hasOwneraddress addr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function broadcast() external', 'function broadcast(address signer) external', 'function addr(uint256 privateKey) external  pure returns (address keyAddr)', 'function broadcast(uint256 privateKey) external'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if the given address has an owner by performing a static call to the `owner()` function.\n *\n * @param addr The address to check for an owner.\n * @return bool Returns `true` if the address has an owner (i.e., the static call to `owner()` is successful and returns 32 bytes of data), otherwise `false`.\n *\n * Steps:\n * 1. Perform a static call to the `owner()` function at the given address.\n * 2. Return `true` if the call is successful and the returned data length is 32 bytes, otherwise return `false`.\n */"
        },
        {
            "identifier": "buildValidateCommand",
            "parameters": "string memory contractName, Options memory opts, bool requireReference",
            "modifiers": "view",
            "return": "returns (string[] memory)",
            "body": "function buildValidateCommand(\n        string memory contractName,\n        Options memory opts,\n        bool requireReference\n    ) internal view returns (string[] memory) {\n        string memory outDir = Utils.getOutDir();\n\n        string[] memory inputBuilder = new string[](2 ** 16);\n\n        uint16 i = 0;\n\n        inputBuilder[i++] = \"npx\";\n        inputBuilder[i++] = string(abi.encodePacked(\"@openzeppelin/upgrades-core@\", Versions.UPGRADES_CORE));\n        inputBuilder[i++] = \"validate\";\n        inputBuilder[i++] = string(abi.encodePacked(outDir, \"/build-info\"));\n        inputBuilder[i++] = \"--contract\";\n        inputBuilder[i++] = Utils.getFullyQualifiedName(contractName, outDir);\n\n        bool hasReferenceContract = bytes(opts.referenceContract).length != 0;\n        bool hasReferenceBuildInfoDir = bytes(opts.referenceBuildInfoDir).length != 0;\n\n        if (hasReferenceContract) {\n            string memory referenceArg = hasReferenceBuildInfoDir\n                ? opts.referenceContract\n                : Utils.getFullyQualifiedName(opts.referenceContract, outDir);\n            inputBuilder[i++] = \"--reference\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', referenceArg, '\"'));\n        }\n\n        if (hasReferenceBuildInfoDir) {\n            inputBuilder[i++] = \"--referenceBuildInfoDirs\";\n            inputBuilder[i++] = string(abi.encodePacked('\"', opts.referenceBuildInfoDir, '\"'));\n        }\n\n        for (uint8 j = 0; j < opts.exclude.length; j++) {\n            string memory exclude = opts.exclude[j];\n            if (bytes(exclude).length != 0) {\n                inputBuilder[i++] = \"--exclude\";\n                inputBuilder[i++] = string(abi.encodePacked('\"', exclude, '\"'));\n            }\n        }\n\n        if (opts.unsafeSkipStorageCheck) {\n            inputBuilder[i++] = \"--unsafeSkipStorageCheck\";\n        } else if (requireReference) {\n            inputBuilder[i++] = \"--requireReference\";\n        }\n\n        if (bytes(opts.unsafeAllow).length != 0) {\n            inputBuilder[i++] = \"--unsafeAllow\";\n            inputBuilder[i++] = opts.unsafeAllow;\n        }\n\n        if (opts.unsafeAllowRenames) {\n            inputBuilder[i++] = \"--unsafeAllowRenames\";\n        }\n\n        // Create a copy of inputs but with the correct length\n        string[] memory inputs = new string[](i);\n        for (uint16 j = 0; j < i; j++) {\n            inputs[j] = inputBuilder[j];\n        }\n\n        return inputs;\n    }",
            "start": "360",
            "end": "424",
            "class": "Core",
            "signature": "returns (string[] memory) buildValidateCommandstring memory contractName, Options memory opts, bool requireReference",
            "full_signature": "function buildValidateCommand(string memory contractName, Options memory opts, bool requireReference) internal  view returns (string[] memory)",
            "class_method_signature": "Core.buildValidateCommandstring memory contractName, Options memory opts, bool requireReference",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.0;"
            ],
            "import_directive": [
                "import {Vm} from \"forge-std/Vm.sol\";",
                "import {console} from \"forge-std/console.sol\";",
                "import {strings} from \"solidity-stringutils/src/strings.sol\";",
                "import {Options} from \"../Options.sol\";",
                "import {Versions} from \"./Versions.sol\";",
                "import {Utils} from \"./Utils.sol\";",
                "import {DefenderDeploy} from \"./DefenderDeploy.sol\";",
                "import {IUpgradeableProxy} from \"./interfaces/IUpgradeableProxy.sol\";",
                "import {IProxyAdmin} from \"./interfaces/IProxyAdmin.sol\";",
                "import {IUpgradeableBeacon} from \"./interfaces/IUpgradeableBeacon.sol\";"
            ],
            "context": "{'function getOutDir() internal  view returns (string memory)', 'string  constant UPGRADES_CORE', 'function getFullyQualifiedName(string memory contractName, string memory outDir) internal  view returns (string memory)', 'function upgrade(address, address) external'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Constructs a command for validating a contract using OpenZeppelin's upgrades-core tool.\n *\n * @param contractName The name of the contract to be validated.\n * @param opts A struct containing various options for the validation process.\n * @param requireReference A boolean flag indicating whether a reference contract is required for validation.\n *\n * @return inputs An array of strings representing the command and its arguments.\n *\n * Steps:\n * 1. Retrieve the output directory for the build artifacts.\n * 2. Initialize an array to store the command arguments.\n * 3. Add the base command and its arguments:\n *    - Use `npx` to run the OpenZeppelin upgrades-core tool.\n *    - Specify the version of the upgrades-core tool.\n *    - Add the `validate` command.\n *    - Specify the build info directory.\n *    - Add the fully qualified name of the contract to be validated.\n *\n * 4. Check if a reference contract or build info directory is provided in the options:\n *    - If a reference contract is provided, add the `--reference` argument.\n *    - If a reference build info directory is provided, add the `--referenceBuildInfoDirs` argument.\n *\n * 5. Add any exclusion patterns specified in the options:\n *    - For each exclusion pattern, add the `--exclude` argument.\n *\n * 6. Add additional flags based on the options:\n *    - If `unsafeSkipStorageCheck` is enabled, add the `--unsafeSkipStorageCheck` flag.\n *    - If `requireReference` is true, add the `--requireReference` flag.\n *    - If `unsafeAllow` is specified, add the `--unsafeAllow` argument.\n *    - If `unsafeAllowRenames` is enabled, add the `--unsafeAllowRenames` flag.\n *\n * 7. Create a correctly sized array of inputs by copying the relevant portion of the input builder array.\n * 8. Return the constructed command arguments.\n */"
        }
    ],
    "/root/Account2/lib/Account2/src/Greeter.sol": [
        {
            "identifier": "",
            "parameters": "string memory newGreeting",
            "modifiers": "",
            "return": "",
            "body": "constructor(string memory newGreeting) {\n    greeting = newGreeting;\n    owner = msg.sender;\n  }",
            "start": "15",
            "end": "18",
            "class": "Greeter",
            "signature": " string memory newGreeting",
            "full_signature": "constructor (string memory newGreeting)",
            "class_method_signature": "Greeter.string memory newGreeting",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.15;"
            ],
            "import_directive": [
                "import { ERC20 } from \"solmate/tokens/ERC20.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with a new greeting and sets the deployer as the owner.\n *\n * @param newGreeting The greeting string to be stored in the contract.\n *\n * Steps:\n * 1. Assign the provided `newGreeting` to the `greeting` state variable.\n * 2. Set the deployer's address (`msg.sender`) as the owner of the contract.\n */"
        },
        {
            "identifier": "gm",
            "parameters": "string memory myGm",
            "modifiers": "",
            "return": "returns(string memory greet)",
            "body": "function gm(string memory myGm) external returns(string memory greet) {\n    if (keccak256(abi.encodePacked((myGm))) != keccak256(abi.encodePacked((greet = greeting)))) revert BadGm();\n    emit GMEverybodyGM();\n  }",
            "start": "20",
            "end": "23",
            "class": "Greeter",
            "signature": "returns(string memory greet) gmstring memory myGm",
            "full_signature": "function gm(string memory myGm) external   returns(string memory greet)",
            "class_method_signature": "Greeter.gmstring memory myGm",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "external",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.15;"
            ],
            "import_directive": [
                "import { ERC20 } from \"solmate/tokens/ERC20.sol\";"
            ],
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A function that checks if the provided greeting matches the expected greeting.\n * If the greeting matches, it emits a `GMEverybodyGM` event. Otherwise, it reverts with `BadGm`.\n *\n * @param myGm The greeting string to be checked against the expected greeting.\n * @return greet The expected greeting string.\n *\n * Steps:\n * 1. Compare the provided greeting (`myGm`) with the expected greeting (`greeting`) using keccak256 hashing.\n * 2. If the greetings do not match, revert with the error `BadGm`.\n * 3. If the greetings match, emit the `GMEverybodyGM` event.\n * 4. Return the expected greeting string.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DateTimeLib.sol": [
        {
            "identifier": "dateToEpochDay",
            "parameters": "uint256 year, uint256 month, uint256 day",
            "modifiers": "pure",
            "return": "returns (uint256 epochDay)",
            "body": "function dateToEpochDay(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 epochDay)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            year := sub(year, lt(month, 3))\n            let doy := add(shr(11, add(mul(62719, mod(add(month, 9), 12)), 769)), day)\n            let yoe := mod(year, 400)\n            let doe := sub(add(add(mul(yoe, 365), shr(2, yoe)), doy), div(yoe, 100))\n            epochDay := sub(add(mul(div(year, 400), 146097), doe), 719469)\n        }\n    }",
            "start": "65",
            "end": "78",
            "class": "DateTimeLib",
            "signature": "returns (uint256 epochDay) dateToEpochDayuint256 year, uint256 month, uint256 day",
            "full_signature": "function dateToEpochDay(uint256 year, uint256 month, uint256 day) internal  pure returns (uint256 epochDay)",
            "class_method_signature": "DateTimeLib.dateToEpochDayuint256 year, uint256 month, uint256 day",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a given date (year, month, day) into the number of days since the Unix epoch (January 1, 1970).\n *\n * @param year The year component of the date.\n * @param month The month component of the date.\n * @param day The day component of the date.\n *\n * @return epochDay The number of days since the Unix epoch corresponding to the given date.\n *\n * Steps:\n * 1. Adjust the year if the month is before March (to account for leap years).\n * 2. Calculate the day of the year (doy) based on the month and day.\n * 3. Calculate the year of the era (yoe) by taking the year modulo 400.\n * 4. Calculate the day of the era (doe) by combining the year of the era, leap years, and the day of the year.\n * 5. Compute the total number of days since the Unix epoch by combining the number of full 400-year cycles and the day of the era, then adjust for the epoch offset.\n *\n * @dev This function uses low-level assembly for efficient date-to-epoch conversion.\n */"
        },
        {
            "identifier": "epochDayToDate",
            "parameters": "uint256 epochDay",
            "modifiers": "pure",
            "return": "returns (uint256 year, uint256 month, uint256 day)",
            "body": "function epochDayToDate(uint256 epochDay)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            epochDay := add(epochDay, 719468)\n            let doe := mod(epochDay, 146097)\n            let yoe :=\n                div(sub(sub(add(doe, div(doe, 36524)), div(doe, 1460)), eq(doe, 146096)), 365)\n            let doy := sub(doe, sub(add(mul(365, yoe), shr(2, yoe)), div(yoe, 100)))\n            let mp := div(add(mul(5, doy), 2), 153)\n            day := add(sub(doy, shr(11, add(mul(mp, 62719), 769))), 1)\n            month := byte(mp, shl(160, 0x030405060708090a0b0c0102))\n            year := add(add(yoe, mul(div(epochDay, 146097), 400)), lt(month, 3))\n        }\n    }",
            "start": "83",
            "end": "100",
            "class": "DateTimeLib",
            "signature": "returns (uint256 year, uint256 month, uint256 day) epochDayToDateuint256 epochDay",
            "full_signature": "function epochDayToDate(uint256 epochDay) internal  pure returns (uint256 year, uint256 month, uint256 day)",
            "class_method_signature": "DateTimeLib.epochDayToDateuint256 epochDay",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a given epoch day (days since 1970-01-01) to a date in the format of year, month, and day.\n * @dev This function uses low-level assembly for efficient date calculation. It handles leap years and month lengths.\n *\n * @param epochDay The number of days since 1970-01-01 (Unix epoch).\n * @return year The calculated year.\n * @return month The calculated month (1-12).\n * @return day The calculated day of the month (1-31).\n *\n * Steps:\n * 1. Adjust the epoch day by adding 719468 to align with the Gregorian calendar.\n * 2. Calculate the day of the era (doe) by taking the modulo of the adjusted epoch day with 146097 (400 years in days).\n * 3. Compute the year of the era (yoe) by dividing and adjusting for leap years.\n * 4. Calculate the day of the year (doy) by subtracting the days accounted for by the year of the era.\n * 5. Determine the month (mp) and day by dividing and adjusting the day of the year.\n * 6. Extract the month and day from precomputed values using bitwise operations.\n * 7. Calculate the final year by adding the year of the era and adjusting for the month.\n */ "
        },
        {
            "identifier": "dateToTimestamp",
            "parameters": "uint256 year, uint256 month, uint256 day",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function dateToTimestamp(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400;\n        }\n    }",
            "start": "105",
            "end": "113",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) dateToTimestampuint256 year, uint256 month, uint256 day",
            "full_signature": "function dateToTimestamp(uint256 year, uint256 month, uint256 day) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.dateToTimestampuint256 year, uint256 month, uint256 day",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a given date (year, month, day) into a Unix timestamp.\n *\n * @param year The year component of the date.\n * @param month The month component of the date.\n * @param day The day component of the date.\n * @return result The Unix timestamp corresponding to the provided date.\n *\n * Steps:\n * 1. Calculate the number of days since the Unix epoch (January 1, 1970) using `dateToEpochDay`.\n * 2. Multiply the result by 86400 (the number of seconds in a day) to convert days into seconds.\n * 3. Return the resulting Unix timestamp.\n *\n * Note: The function uses `unchecked` to disable overflow checks, assuming the inputs are valid.\n */"
        },
        {
            "identifier": "timestampToDate",
            "parameters": "uint256 timestamp",
            "modifiers": "pure",
            "return": "returns (uint256 year, uint256 month, uint256 day)",
            "body": "function timestampToDate(uint256 timestamp)\n        internal\n        pure\n        returns (uint256 year, uint256 month, uint256 day)\n    {\n        (year, month, day) = epochDayToDate(timestamp / 86400);\n    }",
            "start": "118",
            "end": "124",
            "class": "DateTimeLib",
            "signature": "returns (uint256 year, uint256 month, uint256 day) timestampToDateuint256 timestamp",
            "full_signature": "function timestampToDate(uint256 timestamp) internal  pure returns (uint256 year, uint256 month, uint256 day)",
            "class_method_signature": "DateTimeLib.timestampToDateuint256 timestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a Unix timestamp to a date (year, month, day).\n *\n * @param timestamp The Unix timestamp to convert.\n * @return year The year corresponding to the timestamp.\n * @return month The month corresponding to the timestamp.\n * @return day The day corresponding to the timestamp.\n *\n * Steps:\n * 1. Divide the timestamp by 86400 (seconds in a day) to get the number of days since the Unix epoch.\n * 2. Pass the result to `epochDayToDate` to convert it into a year, month, and day.\n */"
        },
        {
            "identifier": "dateTimeToTimestamp",
            "parameters": "uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function dateTimeToTimestamp(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = dateToEpochDay(year, month, day) * 86400 + hour * 3600 + minute * 60 + second;\n        }\n    }",
            "start": "130",
            "end": "141",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) dateTimeToTimestampuint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second",
            "full_signature": "function dateTimeToTimestamp(uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.dateTimeToTimestampuint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a given date and time into a Unix timestamp.\n *\n * @param year The year component of the date.\n * @param month The month component of the date.\n * @param day The day component of the date.\n * @param hour The hour component of the time.\n * @param minute The minute component of the time.\n * @param second The second component of the time.\n *\n * @return result The Unix timestamp representing the given date and time.\n *\n * Steps:\n * 1. Calculate the number of days since the Unix epoch (January 1, 1970) using the `dateToEpochDay` function.\n * 2. Multiply the number of days by 86400 (seconds in a day) to get the total seconds for the days.\n * 3. Add the seconds equivalent of the hour, minute, and second components.\n * 4. Return the resulting Unix timestamp.\n *\n * Note: The function uses `unchecked` to avoid overflow checks, assuming the inputs are valid.\n */"
        },
        {
            "identifier": "timestampToDateTime",
            "parameters": "uint256 timestamp",
            "modifiers": "pure",
            "return": "returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )",
            "body": "function timestampToDateTime(uint256 timestamp)\n        internal\n        pure\n        returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )\n    {\n        unchecked {\n            (year, month, day) = epochDayToDate(timestamp / 86400);\n            uint256 secs = timestamp % 86400;\n            hour = secs / 3600;\n            secs = secs % 3600;\n            minute = secs / 60;\n            second = secs % 60;\n        }\n    }",
            "start": "147",
            "end": "167",
            "class": "DateTimeLib",
            "signature": "returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        ) timestampToDateTimeuint256 timestamp",
            "full_signature": "function timestampToDateTime(uint256 timestamp) internal  pure returns (\n            uint256 year,\n            uint256 month,\n            uint256 day,\n            uint256 hour,\n            uint256 minute,\n            uint256 second\n        )",
            "class_method_signature": "DateTimeLib.timestampToDateTimeuint256 timestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a Unix timestamp into a human-readable date and time format.\n *\n * @param timestamp The Unix timestamp to be converted.\n * @return year The year component of the timestamp.\n * @return month The month component of the timestamp.\n * @return day The day component of the timestamp.\n * @return hour The hour component of the timestamp.\n * @return minute The minute component of the timestamp.\n * @return second The second component of the timestamp.\n *\n * Steps:\n * 1. Divide the timestamp by 86400 (seconds in a day) to get the number of days since the epoch.\n * 2. Use the `epochDayToDate` function to convert the number of days into year, month, and day.\n * 3. Calculate the remaining seconds after extracting the days.\n * 4. Convert the remaining seconds into hours, minutes, and seconds.\n * 5. Return the calculated year, month, day, hour, minute, and second.\n */"
        },
        {
            "identifier": "isLeapYear",
            "parameters": "uint256 year",
            "modifiers": "pure",
            "return": "returns (bool leap)",
            "body": "function isLeapYear(uint256 year) internal pure returns (bool leap) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leap := iszero(and(add(mul(iszero(mod(year, 25)), 12), 3), year))\n        }\n    }",
            "start": "170",
            "end": "175",
            "class": "DateTimeLib",
            "signature": "returns (bool leap) isLeapYearuint256 year",
            "full_signature": "function isLeapYear(uint256 year) internal  pure returns (bool leap)",
            "class_method_signature": "DateTimeLib.isLeapYearuint256 year",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Determines if a given year is a leap year using low-level assembly for efficiency.\n *\n * @param year The year to check for leap year status.\n * @return leap A boolean indicating whether the year is a leap year (true) or not (false).\n *\n * Steps:\n * 1. Use inline assembly to perform the leap year calculation:\n *    - Check if the year is divisible by 25.\n *    - Perform bitwise operations to determine if the year is a leap year.\n * 2. Return the result of the calculation.\n *\n * Note: This function uses Solidity's assembly block for low-level optimization.\n */"
        },
        {
            "identifier": "daysInMonth",
            "parameters": "uint256 year, uint256 month",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function daysInMonth(uint256 year, uint256 month) internal pure returns (uint256 result) {\n        bool flag = isLeapYear(year);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `daysInMonths = [31,28,31,30,31,30,31,31,30,31,30,31]`.\n            // `result = daysInMonths[month - 1] + isLeapYear(year)`.\n            result :=\n                add(byte(month, shl(152, 0x1f1c1f1e1f1e1f1f1e1f1e1f)), and(eq(month, 2), flag))\n        }\n    }",
            "start": "178",
            "end": "187",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) daysInMonthuint256 year, uint256 month",
            "full_signature": "function daysInMonth(uint256 year, uint256 month) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.daysInMonthuint256 year, uint256 month",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the number of days in a given month and year, taking leap years into account.\n *\n * @param year The year for which the calculation is performed.\n * @param month The month for which the number of days is calculated.\n * @return result The number of days in the specified month and year.\n *\n * Steps:\n * 1. Check if the provided year is a leap year using the `isLeapYear` function.\n * 2. Use inline assembly to efficiently calculate the number of days:\n *    - A lookup table for the number of days in each month is embedded in the assembly code.\n *    - Adjust for February in leap years by adding 1 if the month is February and the year is a leap year.\n * 3. Return the calculated number of days.\n *\n * @dev The assembly code uses a packed representation of the days in each month and adjusts for leap years.\n */"
        },
        {
            "identifier": "weekday",
            "parameters": "uint256 timestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function weekday(uint256 timestamp) internal pure returns (uint256 result) {\n        unchecked {\n            result = ((timestamp / 86400 + 3) % 7) + 1;\n        }\n    }",
            "start": "191",
            "end": "195",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) weekdayuint256 timestamp",
            "full_signature": "function weekday(uint256 timestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.weekdayuint256 timestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the day of the week (1-7) for a given Unix timestamp.\n *\n * @param timestamp The Unix timestamp for which to determine the weekday.\n * @return result The day of the week, where 1 = Monday, 2 = Tuesday, ..., 7 = Sunday.\n *\n * Steps:\n * 1. Divide the timestamp by the number of seconds in a day (86400) to get the number of days since the Unix epoch.\n * 2. Add 3 to the result to adjust for the fact that January 1, 1970, was a Thursday.\n * 3. Take modulo 7 to get the day of the week (0-6).\n * 4. Add 1 to convert the range from 0-6 to 1-7, where 1 represents Monday and 7 represents Sunday.\n *\n * Note: The `unchecked` block is used to disable overflow checks for better gas efficiency.\n */"
        },
        {
            "identifier": "isSupportedDate",
            "parameters": "uint256 year, uint256 month, uint256 day",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSupportedDate(uint256 year, uint256 month, uint256 day)\n        internal\n        pure\n        returns (bool result)\n    {\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result :=\n                and(\n                    lt(sub(year, 1970), sub(MAX_SUPPORTED_YEAR, 1969)),\n                    and(lt(sub(month, 1), 12), lt(sub(day, 1), md))\n                )\n        }\n    }",
            "start": "201",
            "end": "215",
            "class": "DateTimeLib",
            "signature": "returns (bool result) isSupportedDateuint256 year, uint256 month, uint256 day",
            "full_signature": "function isSupportedDate(uint256 year, uint256 month, uint256 day) internal  pure returns (bool result)",
            "class_method_signature": "DateTimeLib.isSupportedDateuint256 year, uint256 month, uint256 day",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if the provided date (year, month, day) is supported by the system.\n *\n * @param year The year to check.\n * @param month The month to check.\n * @param day The day to check.\n * @return result A boolean indicating whether the date is supported.\n *\n * Steps:\n * 1. Calculate the number of days in the provided month and year using `daysInMonth`.\n * 2. Use inline assembly to perform the following checks:\n *    - Ensure the year is within the supported range (1970 to MAX_SUPPORTED_YEAR).\n *    - Ensure the month is within the range of 1 to 12.\n *    - Ensure the day is within the range of 1 to the number of days in the month.\n * 3. Return `true` if all checks pass, otherwise `false`.\n */"
        },
        {
            "identifier": "isSupportedDateTime",
            "parameters": "uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSupportedDateTime(\n        uint256 year,\n        uint256 month,\n        uint256 day,\n        uint256 hour,\n        uint256 minute,\n        uint256 second\n    ) internal pure returns (bool result) {\n        if (isSupportedDate(year, month, day)) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := and(lt(hour, 24), and(lt(minute, 60), lt(second, 60)))\n            }\n        }\n    }",
            "start": "224",
            "end": "238",
            "class": "DateTimeLib",
            "signature": "returns (bool result) isSupportedDateTimeuint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second",
            "full_signature": "function isSupportedDateTime(uint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second) internal  pure returns (bool result)",
            "class_method_signature": "DateTimeLib.isSupportedDateTimeuint256 year, uint256 month, uint256 day, uint256 hour, uint256 minute, uint256 second",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if the provided date and time values are supported.\n *\n * @param year The year value to check.\n * @param month The month value to check.\n * @param day The day value to check.\n * @param hour The hour value to check.\n * @param minute The minute value to check.\n * @param second The second value to check.\n *\n * @return result A boolean indicating whether the provided date and time values are valid.\n *\n * Steps:\n * 1. First, check if the provided date (year, month, day) is valid using the `isSupportedDate` function.\n * 2. If the date is valid, use inline assembly to check if the time values (hour, minute, second) are within valid ranges:\n *    - Hour must be less than 24.\n *    - Minute must be less than 60.\n *    - Second must be less than 60.\n * 3. Return `true` if all values are valid, otherwise return `false`.\n */"
        },
        {
            "identifier": "isSupportedEpochDay",
            "parameters": "uint256 epochDay",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSupportedEpochDay(uint256 epochDay) internal pure returns (bool result) {\n        unchecked {\n            result = epochDay < MAX_SUPPORTED_EPOCH_DAY + 1;\n        }\n    }",
            "start": "241",
            "end": "245",
            "class": "DateTimeLib",
            "signature": "returns (bool result) isSupportedEpochDayuint256 epochDay",
            "full_signature": "function isSupportedEpochDay(uint256 epochDay) internal  pure returns (bool result)",
            "class_method_signature": "DateTimeLib.isSupportedEpochDayuint256 epochDay",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if the provided epoch day is within the supported range.\n *\n * @param epochDay The epoch day to check.\n * @return result A boolean indicating whether the epoch day is supported (true if supported, false otherwise).\n *\n * Steps:\n * 1. Perform an unchecked operation to avoid overflow/underflow checks.\n * 2. Compare the provided `epochDay` with the maximum supported epoch day (`MAX_SUPPORTED_EPOCH_DAY`).\n * 3. Return `true` if the `epochDay` is less than or equal to `MAX_SUPPORTED_EPOCH_DAY`, otherwise return `false`.\n */"
        },
        {
            "identifier": "isSupportedTimestamp",
            "parameters": "uint256 timestamp",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSupportedTimestamp(uint256 timestamp) internal pure returns (bool result) {\n        unchecked {\n            result = timestamp < MAX_SUPPORTED_TIMESTAMP + 1;\n        }\n    }",
            "start": "248",
            "end": "252",
            "class": "DateTimeLib",
            "signature": "returns (bool result) isSupportedTimestampuint256 timestamp",
            "full_signature": "function isSupportedTimestamp(uint256 timestamp) internal  pure returns (bool result)",
            "class_method_signature": "DateTimeLib.isSupportedTimestampuint256 timestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given timestamp is within the supported range.\n *\n * @param timestamp The timestamp to be checked.\n * @return result A boolean indicating whether the timestamp is supported (true) or not (false).\n *\n * Steps:\n * 1. Perform an unchecked operation to avoid overflow/underflow checks.\n * 2. Compare the provided timestamp against the maximum supported timestamp.\n * 3. Return true if the timestamp is less than or equal to the maximum supported timestamp, otherwise return false.\n */"
        },
        {
            "identifier": "nthWeekdayInMonthOfYearTimestamp",
            "parameters": "uint256 year, uint256 month, uint256 n, uint256 wd",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        uint256 d = dateToEpochDay(year, month, 1);\n        uint256 md = daysInMonth(year, month);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let diff := sub(wd, add(mod(add(d, 3), 7), 1))\n            let date := add(mul(sub(n, 1), 7), add(mul(gt(diff, 6), 7), diff))\n            result := mul(mul(86400, add(date, d)), and(lt(date, md), iszero(iszero(n))))\n        }\n    }",
            "start": "258",
            "end": "271",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) nthWeekdayInMonthOfYearTimestampuint256 year, uint256 month, uint256 n, uint256 wd",
            "full_signature": "function nthWeekdayInMonthOfYearTimestamp(uint256 year, uint256 month, uint256 n, uint256 wd) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.nthWeekdayInMonthOfYearTimestampuint256 year, uint256 month, uint256 n, uint256 wd",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the Unix timestamp for the nth occurrence of a specific weekday in a given month and year.\n *\n * @param year The year for which the calculation is performed.\n * @param month The month for which the calculation is performed.\n * @param n The nth occurrence of the weekday (e.g., 1st, 2nd, 3rd, etc.).\n * @param wd The weekday to find (0 = Sunday, 1 = Monday, ..., 6 = Saturday).\n *\n * @return result The Unix timestamp for the nth occurrence of the specified weekday in the given month and year.\n *                Returns 0 if the nth occurrence does not exist (e.g., if `n` is too large for the month).\n *\n * Steps:\n * 1. Calculate the epoch day for the first day of the given month and year.\n * 2. Determine the number of days in the given month.\n * 3. Use assembly to compute the date of the nth weekday:\n *    - Calculate the difference between the desired weekday and the weekday of the first day of the month.\n *    - Adjust the date based on the difference and the nth occurrence.\n *    - Ensure the calculated date is within the bounds of the month.\n * 4. Convert the calculated date to a Unix timestamp by multiplying by 86400 (seconds in a day).\n * 5. Return the result, or 0 if the nth occurrence does not exist.\n */"
        },
        {
            "identifier": "mondayTimestamp",
            "parameters": "uint256 timestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function mondayTimestamp(uint256 timestamp) internal pure returns (uint256 result) {\n        uint256 t = timestamp;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let day := div(t, 86400)\n            result := mul(mul(sub(day, mod(add(day, 3), 7)), 86400), gt(t, 345599))\n        }\n    }",
            "start": "274",
            "end": "281",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) mondayTimestampuint256 timestamp",
            "full_signature": "function mondayTimestamp(uint256 timestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.mondayTimestampuint256 timestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the timestamp of the most recent Monday at 00:00:00 UTC based on the given timestamp.\n *\n * @param timestamp The input timestamp from which to calculate the most recent Monday.\n * @return result The timestamp of the most recent Monday at 00:00:00 UTC.\n *\n * Steps:\n * 1. Divide the input timestamp by the number of seconds in a day (86400) to get the number of days since the Unix epoch.\n * 2. Calculate the day of the week by taking the modulus of the day count plus 3 (to align with Monday as the start of the week) and 7.\n * 3. Subtract the day of the week from the total day count to get the most recent Monday.\n * 4. Multiply the result by 86400 to convert it back to a timestamp.\n * 5. Ensure the result is valid by checking if the input timestamp is greater than 345599 (4 days in seconds, to handle edge cases).\n *\n * @dev This function uses inline assembly for efficient computation.\n */"
        },
        {
            "identifier": "addYears",
            "parameters": "uint256 timestamp, uint256 numYears",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function addYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year + numYears, month, day, timestamp);\n    }",
            "start": "300",
            "end": "303",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) addYearsuint256 timestamp, uint256 numYears",
            "full_signature": "function addYears(uint256 timestamp, uint256 numYears) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.addYearsuint256 timestamp, uint256 numYears",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Adds a specified number of years to a given timestamp and returns the new timestamp.\n *\n * @param timestamp The original timestamp to which years will be added.\n * @param numYears The number of years to add to the timestamp.\n * @return result The new timestamp after adding the specified number of years.\n *\n * Steps:\n * 1. Convert the timestamp into a date format (year, month, day) using `epochDayToDate`.\n * 2. Add the specified number of years to the year component.\n * 3. Calculate the new timestamp using the `_offsetted` function with the updated year, month, day, and original timestamp.\n */"
        },
        {
            "identifier": "addMonths",
            "parameters": "uint256 timestamp, uint256 numMonths",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function addMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        month = _sub(month + numMonths, 1);\n        result = _offsetted(year + month / 12, _add(month % 12, 1), day, timestamp);\n    }",
            "start": "310",
            "end": "318",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) addMonthsuint256 timestamp, uint256 numMonths",
            "full_signature": "function addMonths(uint256 timestamp, uint256 numMonths) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.addMonthsuint256 timestamp, uint256 numMonths",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Adds a specified number of months to a given timestamp and returns the resulting timestamp.\n *\n * @param timestamp The initial timestamp to which months will be added.\n * @param numMonths The number of months to add to the timestamp.\n * @return result The resulting timestamp after adding the specified number of months.\n *\n * Steps:\n * 1. Convert the timestamp into a date format (year, month, day) using `epochDayToDate`.\n * 2. Calculate the new month by adding `numMonths` to the current month and adjusting for overflow.\n * 3. Calculate the resulting timestamp by converting the updated date back into a timestamp using `_offsetted`.\n */"
        },
        {
            "identifier": "addMinutes",
            "parameters": "uint256 timestamp, uint256 numMinutes",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function addMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numMinutes * 60;\n    }",
            "start": "331",
            "end": "337",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) addMinutesuint256 timestamp, uint256 numMinutes",
            "full_signature": "function addMinutes(uint256 timestamp, uint256 numMinutes) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.addMinutesuint256 timestamp, uint256 numMinutes",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Adds a specified number of minutes to a given timestamp.\n *\n * @param timestamp The initial timestamp to which minutes will be added.\n * @param numMinutes The number of minutes to add to the timestamp.\n * @return result The new timestamp after adding the specified minutes.\n *\n * Steps:\n * 1. Calculate the result by adding the product of `numMinutes` and 60 (seconds) to the `timestamp`.\n * 2. Return the resulting timestamp.\n */"
        },
        {
            "identifier": "addSeconds",
            "parameters": "uint256 timestamp, uint256 numSeconds",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function addSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp + numSeconds;\n    }",
            "start": "340",
            "end": "346",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) addSecondsuint256 timestamp, uint256 numSeconds",
            "full_signature": "function addSeconds(uint256 timestamp, uint256 numSeconds) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.addSecondsuint256 timestamp, uint256 numSeconds",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Adds a specified number of seconds to a given timestamp.\n *\n * @param timestamp The initial timestamp to which seconds will be added.\n * @param numSeconds The number of seconds to add to the timestamp.\n * @return result The new timestamp after adding the specified number of seconds.\n *\n * Steps:\n * 1. Calculate the result by adding `numSeconds` to the `timestamp`.\n * 2. Return the resulting timestamp.\n */"
        },
        {
            "identifier": "subYears",
            "parameters": "uint256 timestamp, uint256 numYears",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function subYears(uint256 timestamp, uint256 numYears) internal pure returns (uint256 result) {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        result = _offsetted(year - numYears, month, day, timestamp);\n    }",
            "start": "355",
            "end": "358",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) subYearsuint256 timestamp, uint256 numYears",
            "full_signature": "function subYears(uint256 timestamp, uint256 numYears) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.subYearsuint256 timestamp, uint256 numYears",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Subtracts a specified number of years from a given timestamp and returns the resulting timestamp.\n *\n * @param timestamp The original timestamp from which years are to be subtracted.\n * @param numYears The number of years to subtract from the timestamp.\n * @return result The new timestamp after subtracting the specified number of years.\n *\n * Steps:\n * 1. Convert the given timestamp into a date format (year, month, day) using the `epochDayToDate` function.\n * 2. Subtract the specified number of years from the year component.\n * 3. Calculate the new timestamp by adjusting the year, month, and day components using the `_offsetted` function.\n */"
        },
        {
            "identifier": "subMonths",
            "parameters": "uint256 timestamp, uint256 numMonths",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function subMonths(uint256 timestamp, uint256 numMonths)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        (uint256 year, uint256 month, uint256 day) = epochDayToDate(timestamp / 86400);\n        uint256 yearMonth = _totalMonths(year, month) - _add(numMonths, 1);\n        result = _offsetted(yearMonth / 12, _add(yearMonth % 12, 1), day, timestamp);\n    }",
            "start": "365",
            "end": "373",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) subMonthsuint256 timestamp, uint256 numMonths",
            "full_signature": "function subMonths(uint256 timestamp, uint256 numMonths) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.subMonthsuint256 timestamp, uint256 numMonths",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Subtracts a specified number of months from a given timestamp.\n *\n * @param timestamp The starting timestamp from which months will be subtracted.\n * @param numMonths The number of months to subtract from the timestamp.\n * @return result The resulting timestamp after subtracting the specified number of months.\n *\n * Steps:\n * 1. Convert the timestamp into a date format (year, month, day) using `epochDayToDate`.\n * 2. Calculate the total months since epoch by calling `_totalMonths` and subtract the specified number of months.\n * 3. Adjust the year and month values based on the subtraction result.\n * 4. Calculate the resulting timestamp by calling `_offsetted` with the adjusted year, month, day, and original timestamp.\n */"
        },
        {
            "identifier": "subMinutes",
            "parameters": "uint256 timestamp, uint256 numMinutes",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function subMinutes(uint256 timestamp, uint256 numMinutes)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numMinutes * 60;\n    }",
            "start": "386",
            "end": "392",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) subMinutesuint256 timestamp, uint256 numMinutes",
            "full_signature": "function subMinutes(uint256 timestamp, uint256 numMinutes) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.subMinutesuint256 timestamp, uint256 numMinutes",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Subtracts a specified number of minutes from a given timestamp.\n *\n * @param timestamp The original timestamp from which minutes will be subtracted.\n * @param numMinutes The number of minutes to subtract from the timestamp.\n * @return result The resulting timestamp after subtracting the specified minutes.\n *\n * Steps:\n * 1. Calculate the result by subtracting the total seconds equivalent of `numMinutes` from the `timestamp`.\n * 2. Return the resulting timestamp.\n */"
        },
        {
            "identifier": "subSeconds",
            "parameters": "uint256 timestamp, uint256 numSeconds",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function subSeconds(uint256 timestamp, uint256 numSeconds)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = timestamp - numSeconds;\n    }",
            "start": "395",
            "end": "401",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) subSecondsuint256 timestamp, uint256 numSeconds",
            "full_signature": "function subSeconds(uint256 timestamp, uint256 numSeconds) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.subSecondsuint256 timestamp, uint256 numSeconds",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Subtracts a specified number of seconds from a given timestamp.\n *\n * @param timestamp The initial timestamp from which seconds will be subtracted.\n * @param numSeconds The number of seconds to subtract from the timestamp.\n * @return result The resulting timestamp after subtracting the specified number of seconds.\n *\n * Steps:\n * 1. Subtract `numSeconds` from `timestamp`.\n * 2. Return the resulting timestamp.\n */"
        },
        {
            "identifier": "diffYears",
            "parameters": "uint256 fromTimestamp, uint256 toTimestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function diffYears(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear,,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear,,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(toYear, fromYear);\n    }",
            "start": "408",
            "end": "417",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) diffYearsuint256 fromTimestamp, uint256 toTimestamp",
            "full_signature": "function diffYears(uint256 fromTimestamp, uint256 toTimestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.diffYearsuint256 fromTimestamp, uint256 toTimestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the difference in years between two timestamps.\n *\n * @param fromTimestamp The starting timestamp.\n * @param toTimestamp The ending timestamp.\n * @return result The difference in years between the two timestamps.\n *\n * Steps:\n * 1. Convert both timestamps to days since the epoch by dividing by 86400 (seconds in a day).\n * 2. Convert the days since the epoch to a date (year, month, day) using `epochDayToDate`.\n * 3. Extract the year from the date for both timestamps.\n * 4. Calculate the difference in years between the two extracted years using `_sub`.\n */"
        },
        {
            "identifier": "diffMonths",
            "parameters": "uint256 fromTimestamp, uint256 toTimestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function diffMonths(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        toTimestamp - fromTimestamp;\n        (uint256 fromYear, uint256 fromMonth,) = epochDayToDate(fromTimestamp / 86400);\n        (uint256 toYear, uint256 toMonth,) = epochDayToDate(toTimestamp / 86400);\n        result = _sub(_totalMonths(toYear, toMonth), _totalMonths(fromYear, fromMonth));\n    }",
            "start": "424",
            "end": "433",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) diffMonthsuint256 fromTimestamp, uint256 toTimestamp",
            "full_signature": "function diffMonths(uint256 fromTimestamp, uint256 toTimestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.diffMonthsuint256 fromTimestamp, uint256 toTimestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the difference in months between two timestamps.\n *\n * @param fromTimestamp The starting timestamp.\n * @param toTimestamp The ending timestamp.\n * @return result The number of months between the two timestamps.\n *\n * Steps:\n * 1. Convert the timestamps to days by dividing by 86400 (seconds in a day).\n * 2. Extract the year and month from the starting timestamp using `epochDayToDate`.\n * 3. Extract the year and month from the ending timestamp using `epochDayToDate`.\n * 4. Calculate the total months for both the starting and ending timestamps using `_totalMonths`.\n * 5. Subtract the total months of the starting timestamp from the total months of the ending timestamp to get the result.\n */"
        },
        {
            "identifier": "diffDays",
            "parameters": "uint256 fromTimestamp, uint256 toTimestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function diffDays(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 86400;\n    }",
            "start": "436",
            "end": "442",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) diffDaysuint256 fromTimestamp, uint256 toTimestamp",
            "full_signature": "function diffDays(uint256 fromTimestamp, uint256 toTimestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.diffDaysuint256 fromTimestamp, uint256 toTimestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the difference in days between two timestamps.\n *\n * @param fromTimestamp The starting timestamp.\n * @param toTimestamp The ending timestamp.\n * @return result The number of days between the two timestamps.\n *\n * Steps:\n * 1. Subtract the starting timestamp (`fromTimestamp`) from the ending timestamp (`toTimestamp`).\n * 2. Divide the result by 86400 (the number of seconds in a day) to get the difference in days.\n * 3. Return the calculated number of days.\n */"
        },
        {
            "identifier": "diffHours",
            "parameters": "uint256 fromTimestamp, uint256 toTimestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function diffHours(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 3600;\n    }",
            "start": "445",
            "end": "451",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) diffHoursuint256 fromTimestamp, uint256 toTimestamp",
            "full_signature": "function diffHours(uint256 fromTimestamp, uint256 toTimestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.diffHoursuint256 fromTimestamp, uint256 toTimestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the difference in hours between two timestamps.\n *\n * @param fromTimestamp The starting timestamp (in seconds).\n * @param toTimestamp The ending timestamp (in seconds).\n * @return result The difference in hours between the two timestamps.\n *\n * Steps:\n * 1. Subtract the `fromTimestamp` from the `toTimestamp` to get the difference in seconds.\n * 2. Divide the difference by 3600 (seconds in an hour) to convert it to hours.\n * 3. Return the result as an unsigned integer.\n */"
        },
        {
            "identifier": "diffMinutes",
            "parameters": "uint256 fromTimestamp, uint256 toTimestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = (toTimestamp - fromTimestamp) / 60;\n    }",
            "start": "454",
            "end": "460",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) diffMinutesuint256 fromTimestamp, uint256 toTimestamp",
            "full_signature": "function diffMinutes(uint256 fromTimestamp, uint256 toTimestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.diffMinutesuint256 fromTimestamp, uint256 toTimestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the difference in minutes between two timestamps.\n *\n * @param fromTimestamp The starting timestamp.\n * @param toTimestamp The ending timestamp.\n * @return result The difference in minutes between the two timestamps.\n *\n * Steps:\n * 1. Subtract the `fromTimestamp` from the `toTimestamp` to get the difference in seconds.\n * 2. Divide the result by 60 to convert the difference from seconds to minutes.\n * 3. Return the result as an unsigned integer.\n */"
        },
        {
            "identifier": "diffSeconds",
            "parameters": "uint256 fromTimestamp, uint256 toTimestamp",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = toTimestamp - fromTimestamp;\n    }",
            "start": "463",
            "end": "469",
            "class": "DateTimeLib",
            "signature": "returns (uint256 result) diffSecondsuint256 fromTimestamp, uint256 toTimestamp",
            "full_signature": "function diffSeconds(uint256 fromTimestamp, uint256 toTimestamp) internal  pure returns (uint256 result)",
            "class_method_signature": "DateTimeLib.diffSecondsuint256 fromTimestamp, uint256 toTimestamp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the difference in seconds between two timestamps.\n *\n * @param fromTimestamp The starting timestamp.\n * @param toTimestamp The ending timestamp.\n * @return result The difference in seconds between `toTimestamp` and `fromTimestamp`.\n *\n * Steps:\n * 1. Subtract `fromTimestamp` from `toTimestamp` to get the difference in seconds.\n * 2. Return the result.\n */ "
        }
    ],
    "/root/solady/lib/solady/src/utils/ERC1967Factory.sol": [
        {
            "identifier": "adminOf",
            "parameters": "address proxy",
            "modifiers": "view",
            "return": "returns (address admin)",
            "body": "function adminOf(address proxy) public view returns (address admin) {\n        assembly {\n            admin := sload(shl(96, proxy))\n        }\n    }",
            "start": "77",
            "end": "81",
            "class": "ERC1967Factory",
            "signature": "returns (address admin) adminOfaddress proxy",
            "full_signature": "function adminOf(address proxy) public  view returns (address admin)",
            "class_method_signature": "ERC1967Factory.adminOfaddress proxy",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the admin address associated with a given proxy address.\n *\n * @param proxy The address of the proxy contract.\n * @return admin The address of the admin associated with the proxy.\n *\n * Steps:\n * 1. Use inline assembly to load the admin address from storage.\n * 2. The storage slot is calculated by shifting the proxy address left by 96 bits.\n * 3. Return the retrieved admin address.\n */"
        },
        {
            "identifier": "changeAdmin",
            "parameters": "address proxy, address admin",
            "modifiers": "",
            "return": "",
            "body": "function changeAdmin(address proxy, address admin) public {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Store the admin for the proxy.\n            sstore(shl(96, proxy), admin)\n            // Emit the {AdminChanged} event.\n            log3(0, 0, _ADMIN_CHANGED_EVENT_SIGNATURE, proxy, admin)\n        }\n    }",
            "start": "85",
            "end": "97",
            "class": "ERC1967Factory",
            "signature": " changeAdminaddress proxy, address admin",
            "full_signature": "function changeAdmin(address proxy, address admin) public",
            "class_method_signature": "ERC1967Factory.changeAdminaddress proxy, address admin",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Changes the admin of a proxy contract. Only the current admin can call this function.\n *\n * @param proxy The address of the proxy contract whose admin is to be changed.\n * @param admin The address of the new admin.\n *\n * Steps:\n * 1. Check if the caller is the current admin of the proxy.\n *    - If not, revert with an unauthorized error.\n * 2. Store the new admin address in the proxy's storage.\n * 3. Emit an `AdminChanged` event with the proxy and new admin addresses.\n *\n * @dev This function uses inline assembly to directly interact with storage and emit events.\n */"
        },
        {
            "identifier": "upgradeAndCall",
            "parameters": "address proxy, address implementation, bytes calldata data",
            "modifiers": "payable",
            "return": "",
            "body": "function upgradeAndCall(address proxy, address implementation, bytes calldata data)\n        public\n        payable\n    {\n        assembly {\n            // Check if the caller is the admin of the proxy.\n            if iszero(eq(sload(shl(96, proxy)), caller())) {\n                mstore(0x00, _UNAUTHORIZED_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n            // Set up the calldata to upgrade the proxy.\n            let m := mload(0x40)\n            mstore(m, implementation)\n            mstore(add(m, 0x20), _IMPLEMENTATION_SLOT)\n            calldatacopy(add(m, 0x40), data.offset, data.length)\n            // Try upgrading the proxy and revert upon failure.\n            if iszero(call(gas(), proxy, callvalue(), m, add(0x40, data.length), 0x00, 0x00)) {\n                // Revert with the `UpgradeFailed` selector if there is no error returndata.\n                if iszero(returndatasize()) {\n                    mstore(0x00, _UPGRADE_FAILED_ERROR_SELECTOR)\n                    revert(0x1c, 0x04)\n                }\n                // Otherwise, bubble up the returned error.\n                returndatacopy(0x00, 0x00, returndatasize())\n                revert(0x00, returndatasize())\n            }\n            // Emit the {Upgraded} event.\n            log3(0, 0, _UPGRADED_EVENT_SIGNATURE, proxy, implementation)\n        }\n    }",
            "start": "112",
            "end": "141",
            "class": "ERC1967Factory",
            "signature": " upgradeAndCalladdress proxy, address implementation, bytes calldata data",
            "full_signature": "function upgradeAndCall(address proxy, address implementation, bytes calldata data) public  payable",
            "class_method_signature": "ERC1967Factory.upgradeAndCalladdress proxy, address implementation, bytes calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Upgrades the implementation of a proxy contract and calls a function on the new implementation.\n *\n * @param proxy The address of the proxy contract to be upgraded.\n * @param implementation The address of the new implementation contract.\n * @param data The calldata to be passed to the new implementation after the upgrade.\n *\n * Steps:\n * 1. Check if the caller is the admin of the proxy by comparing the stored admin address with the caller's address.\n * 2. If the caller is not the admin, revert with an unauthorized error.\n * 3. Prepare the calldata for the upgrade by storing the implementation address and the implementation slot in memory.\n * 4. Copy the provided data into memory for the call.\n * 5. Attempt to upgrade the proxy by calling the proxy with the prepared calldata.\n * 6. If the call fails:\n *    - If there is no returndata, revert with an `UpgradeFailed` error.\n *    - Otherwise, revert with the returned error data.\n * 7. If the call succeeds, emit an `Upgraded` event with the proxy and implementation addresses.\n *\n * @dev This function uses inline assembly to perform low-level operations and checks.\n */"
        },
        {
            "identifier": "deployAndCall",
            "parameters": "address implementation, address admin, bytes calldata data",
            "modifiers": "payable",
            "return": "returns (address proxy)",
            "body": "function deployAndCall(address implementation, address admin, bytes calldata data)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = _deploy(implementation, admin, bytes32(0), false, data);\n    }",
            "start": "158",
            "end": "164",
            "class": "ERC1967Factory",
            "signature": "returns (address proxy) deployAndCalladdress implementation, address admin, bytes calldata data",
            "full_signature": "function deployAndCall(address implementation, address admin, bytes calldata data) public  payable returns (address proxy)",
            "class_method_signature": "ERC1967Factory.deployAndCalladdress implementation, address admin, bytes calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a proxy contract and calls a function on it with the provided data.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param admin The address of the admin who will manage the proxy.\n * @param data The calldata to be passed to the proxy after deployment.\n * @return proxy The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Deploy a proxy contract using the `_deploy` function, passing the implementation address, admin address, \n *    an empty bytes32 value (salt), and the provided data.\n * 2. Return the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministic",
            "parameters": "address implementation, address admin, bytes32 salt",
            "modifiers": "payable",
            "return": "returns (address proxy)",
            "body": "function deployDeterministic(address implementation, address admin, bytes32 salt)\n        public\n        payable\n        returns (address proxy)\n    {\n        proxy = deployDeterministicAndCall(implementation, admin, salt, _emptyData());\n    }",
            "start": "169",
            "end": "175",
            "class": "ERC1967Factory",
            "signature": "returns (address proxy) deployDeterministicaddress implementation, address admin, bytes32 salt",
            "full_signature": "function deployDeterministic(address implementation, address admin, bytes32 salt) public  payable returns (address proxy)",
            "class_method_signature": "ERC1967Factory.deployDeterministicaddress implementation, address admin, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic proxy contract using the provided implementation, admin, and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param admin The address of the admin who will manage the proxy.\n * @param salt A unique salt value to ensure deterministic deployment.\n *\n * @return proxy The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls `deployDeterministicAndCall` with the provided implementation, admin, salt, and empty data.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicAndCall",
            "parameters": "address implementation, address admin, bytes32 salt, bytes calldata data",
            "modifiers": "payable",
            "return": "returns (address proxy)",
            "body": "function deployDeterministicAndCall(\n        address implementation,\n        address admin,\n        bytes32 salt,\n        bytes calldata data\n    ) public payable returns (address proxy) {\n        assembly {\n            // If the salt does not start with the zero address or the caller.\n            if iszero(or(iszero(shr(96, salt)), eq(caller(), shr(96, salt)))) {\n                mstore(0x00, _SALT_DOES_NOT_START_WITH_CALLER_ERROR_SELECTOR)\n                revert(0x1c, 0x04)\n            }\n        }\n        proxy = _deploy(implementation, admin, salt, true, data);\n    }",
            "start": "181",
            "end": "195",
            "class": "ERC1967Factory",
            "signature": "returns (address proxy) deployDeterministicAndCalladdress implementation, address admin, bytes32 salt, bytes calldata data",
            "full_signature": "function deployDeterministicAndCall(address implementation, address admin, bytes32 salt, bytes calldata data) public  payable returns (address proxy)",
            "class_method_signature": "ERC1967Factory.deployDeterministicAndCalladdress implementation, address admin, bytes32 salt, bytes calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic proxy contract with a given implementation, admin, salt, and optional initialization data.\n *\n * @param implementation The address of the implementation contract.\n * @param admin The address of the admin for the proxy contract.\n * @param salt A unique salt value used to deterministically generate the proxy address.\n * @param data Optional initialization data to be passed to the proxy after deployment.\n * @return proxy The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Check if the salt starts with the zero address or matches the caller's address.\n *    - If not, revert with an error indicating the salt does not start with the caller.\n * 2. Deploy the proxy contract using the provided implementation, admin, salt, and initialization data.\n * 3. Return the address of the deployed proxy contract.\n *\n * @dev The function uses assembly to perform low-level checks and revert if the salt condition is not met.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "bytes32 salt",
            "modifiers": "view",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress(bytes32 salt) public view returns (address predicted) {\n        bytes32 hash = initCodeHash();\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            // Note: `predicted` has dirty upper 96 bits. We won't clean it here\n            // as it will be automatically cleaned when it is copied into the returndata.\n            // Please clean as needed if used in other inline assembly blocks.\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }",
            "start": "242",
            "end": "257",
            "class": "ERC1967Factory",
            "signature": "returns (address predicted) predictDeterministicAddressbytes32 salt",
            "full_signature": "function predictDeterministicAddress(bytes32 salt) public  view returns (address predicted)",
            "class_method_signature": "ERC1967Factory.predictDeterministicAddressbytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using the CREATE2 opcode.\n *\n * @param salt A unique salt value used to generate the deterministic address.\n * @return predicted The predicted address of the contract that would be deployed with the given salt.\n *\n * Steps:\n * 1. Compute the bytecode hash of the contract to be deployed.\n * 2. Use inline assembly to calculate the deterministic address:\n *    - Write the prefix `0xff` to memory.\n *    - Store the bytecode hash, deployer address, and salt in memory.\n *    - Compute the keccak256 hash of the concatenated data to derive the predicted address.\n * 3. Restore the overwritten memory to its original state.\n * 4. Return the predicted address.\n *\n * Note: The upper 96 bits of the predicted address may be dirty and should be cleaned if used in other assembly blocks.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/UUPSUpgradeable.sol": [
        {
            "identifier": "proxiableUUID",
            "parameters": "",
            "modifiers": "notDelegated",
            "return": "returns (bytes32)",
            "body": "function proxiableUUID() public view virtual notDelegated returns (bytes32) {\n        // This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to comply with ERC1967.\n        return _ERC1967_IMPLEMENTATION_SLOT;\n    }",
            "start": "68",
            "end": "71",
            "class": "UUPSUpgradeable",
            "signature": "returns (bytes32) proxiableUUID",
            "full_signature": "function proxiableUUID() public virtual notDelegated returns (bytes32)",
            "class_method_signature": "UUPSUpgradeable.proxiableUUID",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns the UUID (slot) for the ERC1967 implementation. This function is used to comply with the ERC1967 standard.\n *\n * @dev This function must always return `_ERC1967_IMPLEMENTATION_SLOT` to ensure compatibility with the ERC1967 proxy pattern.\n * It is marked as `virtual` to allow overriding in derived contracts, and `notDelegated` to prevent delegation calls.\n *\n * @return bytes32 The storage slot for the ERC1967 implementation.\n */"
        },
        {
            "identifier": "upgradeToAndCall",
            "parameters": "address newImplementation, bytes calldata data",
            "modifiers": "onlyProxy",
            "return": "",
            "body": "function upgradeToAndCall(address newImplementation, bytes calldata data)\n        public\n        payable\n        virtual\n        onlyProxy\n    {\n        _authorizeUpgrade(newImplementation);\n        /// @solidity memory-safe-assembly\n        assembly {\n            newImplementation := shr(96, shl(96, newImplementation)) // Clears upper 96 bits.\n            mstore(0x01, 0x52d1902d) // `proxiableUUID()`.\n            let s := _ERC1967_IMPLEMENTATION_SLOT\n            // Check if `newImplementation` implements `proxiableUUID` correctly.\n            if iszero(eq(mload(staticcall(gas(), newImplementation, 0x1d, 0x04, 0x01, 0x20)), s)) {\n                mstore(0x01, 0x55299b49) // `UpgradeFailed()`.\n                revert(0x1d, 0x04)\n            }\n            // Emit the {Upgraded} event.\n            log2(codesize(), 0x00, _UPGRADED_EVENT_SIGNATURE, newImplementation)\n            sstore(s, newImplementation) // Updates the implementation.\n\n            // Perform a delegatecall to `newImplementation` if `data` is non-empty.\n            if data.length {\n                // Forwards the `data` to `newImplementation` via delegatecall.\n                let m := mload(0x40)\n                calldatacopy(m, data.offset, data.length)\n                if iszero(delegatecall(gas(), newImplementation, m, data.length, codesize(), 0x00))\n                {\n                    // Bubble up the revert if the call reverts.\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n            }\n        }\n    }",
            "start": "77",
            "end": "111",
            "class": "UUPSUpgradeable",
            "signature": " upgradeToAndCalladdress newImplementation, bytes calldata data",
            "full_signature": "function upgradeToAndCall(address newImplementation, bytes calldata data) public virtual onlyProxy",
            "class_method_signature": "UUPSUpgradeable.upgradeToAndCalladdress newImplementation, bytes calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Upgrades the contract's implementation to a new address and optionally performs a delegatecall with provided data.\n * @dev This function is restricted to be called only by the proxy contract (`onlyProxy` modifier).\n * \n * Steps:\n * 1. Authorize the upgrade by calling `_authorizeUpgrade` with the new implementation address.\n * 2. Use inline assembly to:\n *    a. Clear the upper 96 bits of the `newImplementation` address.\n *    b. Check if the `newImplementation` correctly implements the `proxiableUUID` function by comparing the returned value with the expected slot.\n *    c. If the check fails, revert with the `UpgradeFailed` error.\n *    d. Emit the `Upgraded` event with the new implementation address.\n *    e. Update the implementation slot in storage with the new address.\n * 3. If `data` is provided, perform a delegatecall to the new implementation with the provided data:\n *    a. Copy the `data` into memory.\n *    b. Execute the delegatecall to the new implementation.\n *    c. If the delegatecall fails, revert with the returned data.\n *\n * @param newImplementation The address of the new implementation contract.\n * @param data Optional data to be passed to the new implementation via delegatecall.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/Multicallable.sol": [
        {
            "identifier": "multicall",
            "parameters": "bytes[] calldata data",
            "modifiers": "payable",
            "return": "returns (bytes[] memory)",
            "body": "function multicall(bytes[] calldata data) public payable virtual returns (bytes[] memory) {\n        // Revert if `msg.value` is non-zero by default to guard against double-spending.\n        // (See: https://www.paradigm.xyz/2021/08/two-rights-might-make-a-wrong)\n        //\n        // If you really need to pass in a `msg.value`, then you will have to\n        // override this function and add in any relevant before and after checks.\n        if (msg.value != 0) revert();\n        // `_multicallDirectReturn` returns the results directly and terminates the call context.\n        _multicallDirectReturn(_multicall(data));\n    }",
            "start": "28",
            "end": "37",
            "class": "Multicallable",
            "signature": "returns (bytes[] memory) multicallbytes[] calldata data",
            "full_signature": "function multicall(bytes[] calldata data) public virtual payable returns (bytes[] memory)",
            "class_method_signature": "Multicallable.multicallbytes[] calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Executes multiple function calls in a single transaction.\n *\n * @dev This function is designed to handle multiple calls in a single transaction, \n * but it reverts if `msg.value` is non-zero to prevent potential double-spending issues.\n * If you need to send Ether with the calls, you must override this function and \n * implement the necessary checks.\n *\n * @param data An array of encoded function calls to be executed.\n * @return An array of bytes containing the return data from each function call.\n *\n * Steps:\n * 1. Revert if `msg.value` is non-zero to prevent double-spending.\n * 2. Call the internal `_multicall` function to execute the provided data.\n * 3. Return the results directly using `_multicallDirectReturn`.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibMap.sol": [
        {
            "identifier": "get",
            "parameters": "Uint8Map storage map, uint256 index",
            "modifiers": "view",
            "return": "returns (uint8 result)",
            "body": "function get(Uint8Map storage map, uint256 index) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            result := byte(and(31, not(index)), sload(keccak256(0x00, 0x40)))\n        }\n    }",
            "start": "46",
            "end": "53",
            "class": "LibMap",
            "signature": "returns (uint8 result) getUint8Map storage map, uint256 index",
            "full_signature": "function get(Uint8Map storage map, uint256 index) internal  view returns (uint8 result)",
            "class_method_signature": "LibMap.getUint8Map storage map, uint256 index",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves a value from a Uint8Map storage at a specific index.\n *\n * @param map The storage map from which to retrieve the value.\n * @param index The index in the map where the value is stored.\n * @return result The value stored at the specified index.\n *\n * Steps:\n * 1. Store the slot of the map in memory at position 0x20.\n * 2. Store the shifted index (divided by 32) in memory at position 0x00.\n * 3. Calculate the storage slot using `keccak256` with the memory range 0x00 to 0x40.\n * 4. Load the value from the calculated storage slot.\n * 5. Extract the specific byte from the loaded value using bitwise operations.\n * 6. Return the extracted byte as the result.\n *\n * @dev This function uses inline assembly for low-level memory manipulation to efficiently retrieve the value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint8Map storage map, uint256 index, uint8 value",
            "modifiers": "",
            "return": "",
            "body": "function set(Uint8Map storage map, uint256 index, uint8 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(5, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            mstore(0x00, sload(s))\n            mstore8(and(31, not(index)), value)\n            sstore(s, mload(0x00))\n        }\n    }",
            "start": "56",
            "end": "66",
            "class": "LibMap",
            "signature": " setUint8Map storage map, uint256 index, uint8 value",
            "full_signature": "function set(Uint8Map storage map, uint256 index, uint8 value) internal",
            "class_method_signature": "LibMap.setUint8Map storage map, uint256 index, uint8 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value at a specific index in a Uint8Map storage map.\n *\n * @param map The storage map where the value will be set.\n * @param index The index in the map where the value will be stored.\n * @param value The 8-bit unsigned integer value to be stored at the specified index.\n *\n * Steps:\n * 1. Calculate the storage slot for the given index in the map.\n * 2. Load the current value from the calculated storage slot.\n * 3. Update the specific byte within the loaded value corresponding to the index.\n * 4. Store the updated value back into the storage slot.\n *\n * @dev This function uses inline assembly to manipulate storage directly for efficiency.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint16Map storage map, uint256 index, uint16 value",
            "modifiers": "",
            "return": "",
            "body": "function set(Uint16Map storage map, uint256 index, uint16 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(4, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(4, and(index, 15)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "start": "74",
            "end": "85",
            "class": "LibMap",
            "signature": " setUint16Map storage map, uint256 index, uint16 value",
            "full_signature": "function set(Uint16Map storage map, uint256 index, uint16 value) internal",
            "class_method_signature": "LibMap.setUint16Map storage map, uint256 index, uint16 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value in a Uint16Map at a specific index using low-level assembly for efficiency.\n *\n * @param map The storage reference to the Uint16Map where the value will be set.\n * @param index The index in the map where the value will be stored.\n * @param value The 16-bit unsigned integer value to be stored at the specified index.\n *\n * Steps:\n * 1. Calculate the storage slot and offset for the given index.\n * 2. Load the current value from the storage slot.\n * 3. Compute the new value by masking and shifting the input value.\n * 4. Store the updated value back into the storage slot.\n *\n * Assembly Details:\n * - `mstore(0x20, map.slot)`: Store the map's storage slot at memory location 0x20.\n * - `mstore(0x00, shr(4, index))`: Store the index shifted right by 4 bits at memory location 0x00.\n * - `keccak256(0x00, 0x40)`: Compute the storage slot using the keccak256 hash of the memory range 0x00 to 0x40.\n * - `shl(4, and(index, 15))`: Calculate the offset within the storage slot by shifting the lower 4 bits of the index.\n * - `sload(s)`: Load the current value from the storage slot.\n * - `xor(v, shl(o, and(m, xor(shr(o, v), value))))`: Compute the new value by XORing the current value with the masked and shifted input value.\n * - `sstore(s, ...)`: Store the updated value back into the storage slot.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint32Map storage map, uint256 index, uint32 value",
            "modifiers": "",
            "return": "",
            "body": "function set(Uint32Map storage map, uint256 index, uint32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(3, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(5, and(index, 7)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "start": "93",
            "end": "104",
            "class": "LibMap",
            "signature": " setUint32Map storage map, uint256 index, uint32 value",
            "full_signature": "function set(Uint32Map storage map, uint256 index, uint32 value) internal",
            "class_method_signature": "LibMap.setUint32Map storage map, uint256 index, uint32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value in a `Uint32Map` at a specific index using low-level assembly for efficiency.\n *\n * @param map The storage map where the value will be set.\n * @param index The index in the map where the value will be stored.\n * @param value The 32-bit unsigned integer value to store at the specified index.\n *\n * Steps:\n * 1. Calculate the storage slot for the given index by combining the map's slot and the index.\n * 2. Determine the offset within the storage slot where the value will be stored.\n * 3. Load the current value from the storage slot.\n * 4. Apply a mask to ensure the value is within the 32-bit range.\n * 5. Update the storage slot with the new value, preserving other bits in the slot.\n *\n * @dev This function uses inline assembly to directly manipulate storage for gas efficiency.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Uint40Map storage map, uint256 index",
            "modifiers": "view",
            "return": "returns (uint40 result)",
            "body": "function get(Uint40Map storage map, uint256 index) internal view returns (uint40 result) {\n        unchecked {\n            result = uint40(map.map[index / 6] >> ((index % 6) * 40));\n        }\n    }",
            "start": "107",
            "end": "111",
            "class": "LibMap",
            "signature": "returns (uint40 result) getUint40Map storage map, uint256 index",
            "full_signature": "function get(Uint40Map storage map, uint256 index) internal  view returns (uint40 result)",
            "class_method_signature": "LibMap.getUint40Map storage map, uint256 index",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves a 40-bit unsigned integer value from a specific index in a Uint40Map storage map.\n *\n * @param map The Uint40Map storage map from which to retrieve the value.\n * @param index The index of the value to retrieve within the map.\n * @return result The 40-bit unsigned integer value stored at the specified index.\n *\n * Steps:\n * 1. Calculate the position of the value within the map by dividing the index by 6.\n * 2. Extract the 40-bit value by shifting the stored value at the calculated position.\n * 3. Return the extracted 40-bit value.\n *\n * Note: The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint40Map storage map, uint256 index, uint40 value",
            "modifiers": "",
            "return": "",
            "body": "function set(Uint40Map storage map, uint256 index, uint40 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, div(index, 6))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := mul(40, mod(index, 6)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "start": "114",
            "end": "125",
            "class": "LibMap",
            "signature": " setUint40Map storage map, uint256 index, uint40 value",
            "full_signature": "function set(Uint40Map storage map, uint256 index, uint40 value) internal",
            "class_method_signature": "LibMap.setUint40Map storage map, uint256 index, uint40 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value in a Uint40Map at a specific index using low-level assembly for efficiency.\n *\n * @param map The storage reference to the Uint40Map.\n * @param index The index in the map where the value should be set.\n * @param value The 40-bit unsigned integer value to store at the specified index.\n *\n * Steps:\n * 1. Calculate the storage slot for the given index by dividing the index by 6 (since each slot holds 6 values).\n * 2. Calculate the offset within the storage slot by taking the modulo of the index with 6 and multiplying by 40 (bits per value).\n * 3. Load the current value from the storage slot.\n * 4. Create a mask (`0xffffffffff`) to isolate the 40-bit value.\n * 5. Update the storage slot by XORing the current value with the new value, shifted to the correct offset, and masked to ensure only the target bits are modified.\n * 6. Store the updated value back into the storage slot.\n *\n * @dev This function uses inline assembly for gas optimization and precise control over storage operations.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint64Map storage map, uint256 index, uint64 value",
            "modifiers": "",
            "return": "",
            "body": "function set(Uint64Map storage map, uint256 index, uint64 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(2, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(6, and(index, 3)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "start": "133",
            "end": "144",
            "class": "LibMap",
            "signature": " setUint64Map storage map, uint256 index, uint64 value",
            "full_signature": "function set(Uint64Map storage map, uint256 index, uint64 value) internal",
            "class_method_signature": "LibMap.setUint64Map storage map, uint256 index, uint64 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value in a Uint64Map at a specific index using low-level assembly for efficiency.\n *\n * @param map The storage reference to the Uint64Map where the value will be set.\n * @param index The index in the map where the value will be stored.\n * @param value The 64-bit unsigned integer value to be stored at the specified index.\n *\n * Steps:\n * 1. Calculate the storage slot and offset for the given index.\n * 2. Load the current value from the storage slot.\n * 3. Compute the new value by masking and shifting the input value.\n * 4. Store the updated value back into the storage slot.\n *\n * @dev This function uses inline assembly to directly manipulate storage slots, ensuring efficient memory usage.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint128Map storage map, uint256 index, uint128 value",
            "modifiers": "",
            "return": "",
            "body": "function set(Uint128Map storage map, uint256 index, uint128 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, map.slot)\n            mstore(0x00, shr(1, index))\n            let s := keccak256(0x00, 0x40) // Storage slot.\n            let o := shl(7, and(index, 1)) // Storage slot offset (bits).\n            let v := sload(s) // Storage slot value.\n            let m := 0xffffffffffffffffffffffffffffffff // Value mask.\n            sstore(s, xor(v, shl(o, and(m, xor(shr(o, v), value)))))\n        }\n    }",
            "start": "152",
            "end": "163",
            "class": "LibMap",
            "signature": " setUint128Map storage map, uint256 index, uint128 value",
            "full_signature": "function set(Uint128Map storage map, uint256 index, uint128 value) internal",
            "class_method_signature": "LibMap.setUint128Map storage map, uint256 index, uint128 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value in a `Uint128Map` at a specific index.\n *\n * @param map The storage reference to the `Uint128Map` where the value will be set.\n * @param index The index in the map where the value will be stored.\n * @param value The `uint128` value to be stored at the specified index.\n *\n * Steps:\n * 1. Calculate the storage slot and offset for the given index.\n * 2. Load the current value from the storage slot.\n * 3. Apply a mask to ensure the value fits within 128 bits.\n * 4. Update the storage slot with the new value, preserving other bits in the slot.\n *\n * @dev This function uses inline assembly for low-level storage manipulation.\n */"
        },
        {
            "identifier": "get",
            "parameters": "mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth)\n        internal\n        view\n        returns (uint256 result)\n    {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            result = (map[_rawDiv(index, d)] >> (_rawMod(index, d) * bitWidth)) & m;\n        }\n    }",
            "start": "166",
            "end": "176",
            "class": "LibMap",
            "signature": "returns (uint256 result) getmapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth",
            "full_signature": "function get(mapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth) internal  view returns (uint256 result)",
            "class_method_signature": "LibMap.getmapping(uint256 => uint256) storage map, uint256 index, uint256 bitWidth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves a value from a packed mapping storage structure.\n *\n * @param map The mapping storage structure where values are packed.\n * @param index The index of the value to retrieve.\n * @param bitWidth The bit width of each value in the packed mapping.\n *\n * @return result The retrieved value from the packed mapping.\n *\n * Steps:\n * 1. Calculate the bucket size (`d`) by dividing 256 by the bit width.\n * 2. Create a mask (`m`) to extract the value based on the bit width.\n * 3. Retrieve the value by:\n *    a. Calculating the bucket index using `_rawDiv(index, d)`.\n *    b. Calculating the bit offset within the bucket using `_rawMod(index, d) * bitWidth`.\n *    c. Applying the mask to extract the value.\n *\n * Note: The function uses `unchecked` to avoid overflow checks for gas optimization.\n */"
        },
        {
            "identifier": "set",
            "parameters": "mapping(uint256 => uint256) storage map, uint256 index, uint256 value, uint256 bitWidth",
            "modifiers": "",
            "return": "",
            "body": "function set(\n        mapping(uint256 => uint256) storage map,\n        uint256 index,\n        uint256 value,\n        uint256 bitWidth\n    ) internal {\n        unchecked {\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 o = _rawMod(index, d) * bitWidth; // Storage slot offset (bits).\n            map[_rawDiv(index, d)] ^= (((map[_rawDiv(index, d)] >> o) ^ value) & m) << o;\n        }\n    }",
            "start": "179",
            "end": "191",
            "class": "LibMap",
            "signature": " setmapping(uint256 => uint256) storage map, uint256 index, uint256 value, uint256 bitWidth",
            "full_signature": "function set(mapping(uint256 => uint256) storage map, uint256 index, uint256 value, uint256 bitWidth) internal",
            "class_method_signature": "LibMap.setmapping(uint256 => uint256) storage map, uint256 index, uint256 value, uint256 bitWidth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value in a packed storage mapping at a specific index.\n *\n * @param map The storage mapping where the value will be set.\n * @param index The index in the mapping where the value will be stored.\n * @param value The value to be stored at the specified index.\n * @param bitWidth The number of bits used to represent the value.\n *\n * Steps:\n * 1. Calculate the bucket size (`d`) based on the bit width.\n * 2. Create a mask (`m`) to isolate the value within the bit width.\n * 3. Calculate the offset (`o`) within the storage slot where the value will be stored.\n * 4. Update the storage slot by XORing the existing value with the new value, masked and shifted appropriately.\n *\n * Note: The function uses unchecked arithmetic for gas optimization.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "Uint8Map storage map, uint8 needle, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 8);\n    }",
            "start": "204",
            "end": "210",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedUint8Map storage map, uint8 needle, uint256 start, uint256 end",
            "full_signature": "function searchSorted(Uint8Map storage map, uint8 needle, uint256 start, uint256 end) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedUint8Map storage map, uint8 needle, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) within a sorted `Uint8Map` storage map.\n * The search is performed within a specified range (`start` to `end`) using binary search.\n *\n * @param map The storage map of type `Uint8Map` to search within.\n * @param needle The value to search for within the map.\n * @param start The starting index of the range to search within.\n * @param end The ending index of the range to search within.\n *\n * @return found A boolean indicating whether the value was found.\n * @return index The index of the value if found, or the index where it should be inserted to maintain order.\n *\n * Steps:\n * 1. Calls an internal `searchSorted` function with the map's underlying data, the value to search for,\n *    the start and end indices, and the bit length (8 bits for `uint8`).\n * 2. Returns the result of the internal search, which includes whether the value was found and its index.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "Uint16Map storage map, uint16 needle, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 16);\n    }",
            "start": "213",
            "end": "219",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedUint16Map storage map, uint16 needle, uint256 start, uint256 end",
            "full_signature": "function searchSorted(Uint16Map storage map, uint16 needle, uint256 start, uint256 end) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedUint16Map storage map, uint16 needle, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) within a sorted `Uint16Map` storage structure.\n *\n * @param map The `Uint16Map` storage structure to search within.\n * @param needle The value to search for within the map.\n * @param start The starting index of the search range.\n * @param end The ending index of the search range.\n *\n * @return found A boolean indicating whether the value was found.\n * @return index The index where the value was found or where it should be inserted to maintain order.\n *\n * Steps:\n * 1. Calls an internal `searchSorted` function, passing the underlying map data, the `needle`, the search range (`start` and `end`), and the bit size (16 for `uint16`).\n * 2. Returns the result of the search, including whether the value was found and its position.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "Uint32Map storage map, uint32 needle, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 32);\n    }",
            "start": "222",
            "end": "228",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedUint32Map storage map, uint32 needle, uint256 start, uint256 end",
            "full_signature": "function searchSorted(Uint32Map storage map, uint32 needle, uint256 start, uint256 end) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedUint32Map storage map, uint32 needle, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) within a sorted Uint32Map.\n *\n * @param map The Uint32Map storage reference where the search is performed.\n * @param needle The value to search for within the map.\n * @param start The starting index of the search range.\n * @param end The ending index of the search range.\n *\n * @return found A boolean indicating whether the value was found.\n * @return index The index of the found value or the position where it should be inserted to maintain order.\n *\n * Steps:\n * 1. Calls the internal `searchSorted` function with the map's underlying storage, the needle, start, end, and a fixed key size of 32.\n * 2. Returns the result of the search, including whether the value was found and its index.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "Uint40Map storage map, uint40 needle, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 40);\n    }",
            "start": "231",
            "end": "237",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedUint40Map storage map, uint40 needle, uint256 start, uint256 end",
            "full_signature": "function searchSorted(Uint40Map storage map, uint40 needle, uint256 start, uint256 end) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedUint40Map storage map, uint40 needle, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a `needle` value within a sorted `Uint40Map` storage map between the specified `start` and `end` indices.\n *\n * @param map The `Uint40Map` storage map to search within.\n * @param needle The value to search for within the map.\n * @param start The starting index of the search range.\n * @param end The ending index of the search range.\n *\n * @return found A boolean indicating whether the `needle` was found in the map.\n * @return index The index where the `needle` is located (if found) or the appropriate insertion point (if not found).\n *\n * Steps:\n * 1. Calls the internal `searchSorted` function with the `map.map` storage, `needle`, `start`, `end`, and a bit length of 40.\n * 2. Returns the result of the search, including whether the `needle` was found and its index.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "Uint64Map storage map, uint64 needle, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 64);\n    }",
            "start": "240",
            "end": "246",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedUint64Map storage map, uint64 needle, uint256 start, uint256 end",
            "full_signature": "function searchSorted(Uint64Map storage map, uint64 needle, uint256 start, uint256 end) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedUint64Map storage map, uint64 needle, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) within a sorted `Uint64Map` within a given range.\n *\n * @param map The storage reference to the `Uint64Map` to search within.\n * @param needle The value to search for within the map.\n * @param start The starting index of the search range.\n * @param end The ending index of the search range.\n *\n * @return found A boolean indicating whether the value was found.\n * @return index The index where the value was found or where it should be inserted to maintain order.\n *\n * Steps:\n * 1. Calls an internal `searchSorted` function with the map's underlying data, the `needle`, the search range, and a bit length of 64.\n * 2. Returns the result of the internal search, which includes whether the value was found and its position.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "Uint128Map storage map, uint128 needle, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end)\n        internal\n        view\n        returns (bool found, uint256 index)\n    {\n        return searchSorted(map.map, needle, start, end, 128);\n    }",
            "start": "249",
            "end": "255",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedUint128Map storage map, uint128 needle, uint256 start, uint256 end",
            "full_signature": "function searchSorted(Uint128Map storage map, uint128 needle, uint256 start, uint256 end) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedUint128Map storage map, uint128 needle, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) within a sorted `Uint128Map` within a given range.\n *\n * @param map The storage reference to the `Uint128Map` to search within.\n * @param needle The value to search for within the map.\n * @param start The starting index of the range to search within.\n * @param end The ending index of the range to search within.\n *\n * @return found A boolean indicating whether the value was found.\n * @return index The index where the value is located (if found) or the position where it should be inserted (if not found).\n *\n * Steps:\n * 1. Calls an internal `searchSorted` function with the map's underlying data, the `needle`, the range (`start` to `end`), and the bit length (128).\n * 2. Returns the result of the search, including whether the value was found and its index.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "mapping(uint256 => uint256) storage map, uint256 needle, uint256 start, uint256 end, uint256 bitWidth",
            "modifiers": "view",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(\n        mapping(uint256 => uint256) storage map,\n        uint256 needle,\n        uint256 start,\n        uint256 end,\n        uint256 bitWidth\n    ) internal view returns (bool found, uint256 index) {\n        unchecked {\n            if (start >= end) end = start;\n            uint256 t;\n            uint256 o = start - 1; // Offset to derive the actual index.\n            uint256 l = 1; // Low.\n            uint256 d = _rawDiv(256, bitWidth); // Bucket size.\n            uint256 m = (1 << bitWidth) - 1; // Value mask.\n            uint256 h = end - start; // High.\n            while (true) {\n                index = (l & h) + ((l ^ h) >> 1);\n                if (l > h) break;\n                t = (map[_rawDiv(index + o, d)] >> (_rawMod(index + o, d) * bitWidth)) & m;\n                if (t == needle) break;\n                if (needle <= t) h = index - 1;\n                else l = index + 1;\n            }\n            /// @solidity memory-safe-assembly\n            assembly {\n                m := or(iszero(index), iszero(bitWidth))\n                found := iszero(or(xor(t, needle), m))\n                index := add(o, xor(index, mul(xor(index, 1), m)))\n            }\n        }\n    }",
            "start": "258",
            "end": "288",
            "class": "LibMap",
            "signature": "returns (bool found, uint256 index) searchSortedmapping(uint256 => uint256) storage map, uint256 needle, uint256 start, uint256 end, uint256 bitWidth",
            "full_signature": "function searchSorted(mapping(uint256 => uint256) storage map, uint256 needle, uint256 start, uint256 end, uint256 bitWidth) internal  view returns (bool found, uint256 index)",
            "class_method_signature": "LibMap.searchSortedmapping(uint256 => uint256) storage map, uint256 needle, uint256 start, uint256 end, uint256 bitWidth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) within a sorted mapping of integers.\n * The mapping is treated as a sorted array with a specific bit-width for each element.\n *\n * @param map The storage mapping representing the sorted array.\n * @param needle The value to search for within the mapping.\n * @param start The starting index of the search range.\n * @param end The ending index of the search range.\n * @param bitWidth The bit-width of each element in the mapping.\n *\n * @return found A boolean indicating whether the value was found.\n * @return index The index of the found value or the insertion point if not found.\n *\n * Steps:\n * 1. Initialize variables for the search algorithm, including bucket size, value mask, and search bounds.\n * 2. Perform a binary search within the specified range:\n *    - Calculate the midpoint index.\n *    - Retrieve the value at the midpoint index using bit manipulation.\n *    - Compare the retrieved value with the `needle`.\n *    - Adjust the search bounds based on the comparison.\n * 3. Use assembly to determine if the value was found and calculate the final index.\n * 4. Return the results indicating whether the value was found and its index.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/SSTORE2.sol": [
        {
            "identifier": "write",
            "parameters": "bytes memory data",
            "modifiers": "",
            "return": "returns (address pointer)",
            "body": "function write(bytes memory data) internal returns (address pointer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data) // Let `l` be `n + 1`. +1 as we prefix a STOP opcode.\n            /**\n             * ---------------------------------------------------+\n             * Opcode | Mnemonic       | Stack     | Memory       |\n             * ---------------------------------------------------|\n             * 61 l   | PUSH2 l        | l         |              |\n             * 80     | DUP1           | l l       |              |\n             * 60 0xa | PUSH1 0xa      | 0xa l l   |              |\n             * 3D     | RETURNDATASIZE | 0 0xa l l |              |\n             * 39     | CODECOPY       | l         | [0..l): code |\n             * 3D     | RETURNDATASIZE | 0 l       | [0..l): code |\n             * F3     | RETURN         |           | [0..l): code |\n             * 00     | STOP           |           |              |\n             * ---------------------------------------------------+\n             * @dev Prefix the bytecode with a STOP opcode to ensure it cannot be called.\n             * Also PUSH2 is used since max contract size cap is 24,576 bytes which is less than 2 ** 16.\n             */\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create(0, add(data, 0x15), add(n, 0xb))\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "start": "35",
            "end": "65",
            "class": "SSTORE2",
            "signature": "returns (address pointer) writebytes memory data",
            "full_signature": "function write(bytes memory data) internal   returns (address pointer)",
            "class_method_signature": "SSTORE2.writebytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Writes the provided data to a new contract and returns the contract's address.\n *\n * @dev This function uses inline assembly to deploy a new contract with the provided data.\n * The data is prefixed with a STOP opcode to ensure the contract cannot be called directly.\n * The function also handles edge cases, such as ensuring the data length does not exceed the maximum allowed size.\n * If the deployment fails, the function reverts with a custom error `DeploymentFailed()`.\n *\n * @param data The bytecode data to be written to the new contract.\n * @return pointer The address of the newly deployed contract.\n *\n * Steps:\n * 1. Load the length of the data into `n`.\n * 2. Prefix the data with a STOP opcode and additional assembly instructions to ensure the contract cannot be called.\n * 3. Deploy a new contract using the modified data.\n * 4. If the deployment fails, revert with the `DeploymentFailed()` error.\n * 5. Restore the original length of the data in memory.\n * 6. Return the address of the newly deployed contract.\n */"
        },
        {
            "identifier": "writeCounterfactual",
            "parameters": "bytes memory data, bytes32 salt",
            "modifiers": "",
            "return": "returns (address pointer)",
            "body": "function writeCounterfactual(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            // Deploy a new contract with the generated creation code.\n            pointer := create2(0, add(data, 0x15), add(n, 0xb), salt)\n            if iszero(pointer) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "start": "69",
            "end": "86",
            "class": "SSTORE2",
            "signature": "returns (address pointer) writeCounterfactualbytes memory data, bytes32 salt",
            "full_signature": "function writeCounterfactual(bytes memory data, bytes32 salt) internal   returns (address pointer)",
            "class_method_signature": "SSTORE2.writeCounterfactualbytes memory data, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Deploys a new contract using the `create2` opcode with the provided data and salt.\n * @dev This function is used to deploy a contract counterfactually, meaning the contract's address \n *      can be computed before deployment. The function uses inline assembly for low-level operations.\n *\n * @param data The bytecode and constructor arguments for the contract to be deployed.\n * @param salt A unique value used to determine the contract's address.\n * @return pointer The address of the newly deployed contract.\n *\n * Steps:\n * 1. Load the length of the `data` into `n`.\n * 2. Perform a gas check to ensure the data length is within bounds (less than or equal to 0xfffe).\n * 3. Modify the data to include the necessary creation code for the contract.\n * 4. Use the `create2` opcode to deploy the contract with the provided data and salt.\n * 5. If the deployment fails, revert with the `DeploymentFailed()` error.\n * 6. Restore the original length of `data` in memory.\n * 7. Return the address of the deployed contract.\n *\n * Notes:\n * - The function uses inline assembly for low-level memory manipulation and contract deployment.\n * - The `create2` opcode allows deterministic contract address generation based on the salt.\n */"
        },
        {
            "identifier": "writeDeterministic",
            "parameters": "bytes memory data, bytes32 salt",
            "modifiers": "",
            "return": "returns (address pointer)",
            "body": "function writeDeterministic(bytes memory data, bytes32 salt)\n        internal\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(0x00, _CREATE3_PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n\n            // Do a out-of-gas revert if `n + 1` is more than 2 bytes.\n            mstore(add(data, gt(n, 0xfffe)), add(0xfe61000180600a3d393df300, shl(0x40, n)))\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(pointer),\n                    call(gas(), proxy, 0, add(data, 0x15), add(n, 0xb), codesize(), 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "start": "91",
            "end": "124",
            "class": "SSTORE2",
            "signature": "returns (address pointer) writeDeterministicbytes memory data, bytes32 salt",
            "full_signature": "function writeDeterministic(bytes memory data, bytes32 salt) internal   returns (address pointer)",
            "class_method_signature": "SSTORE2.writeDeterministicbytes memory data, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic proxy contract using CREATE2 and initializes it with the provided data.\n *\n * @param data The data to be passed to the proxy contract for initialization.\n * @param salt A unique salt value used to determine the address of the deployed proxy contract.\n * @return pointer The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Load the length of the data into `n`.\n * 2. Store the `_CREATE3_PROXY_INITCODE` in memory.\n * 3. Deploy the proxy contract using `create2` with the provided salt.\n * 4. If the deployment fails, revert with the `DeploymentFailed()` error.\n * 5. Store the proxy contract's address in memory.\n * 6. Calculate the address of the proxy contract using `keccak256`.\n * 7. Ensure that the length of the data (`n + 1`) does not exceed 2 bytes, otherwise revert.\n * 8. Initialize the proxy contract by calling it with the provided data.\n * 9. If the initialization fails, revert with the `DeploymentFailed()` error.\n * 10. Restore the original length of the data in memory.\n */"
        },
        {
            "identifier": "predictCounterfactualAddress",
            "parameters": "bytes memory data, bytes32 salt",
            "modifiers": "view",
            "return": "returns (address pointer)",
            "body": "function predictCounterfactualAddress(bytes memory data, bytes32 salt)\n        internal\n        view\n        returns (address pointer)\n    {\n        pointer = predictCounterfactualAddress(data, salt, address(this));\n    }",
            "start": "145",
            "end": "151",
            "class": "SSTORE2",
            "signature": "returns (address pointer) predictCounterfactualAddressbytes memory data, bytes32 salt",
            "full_signature": "function predictCounterfactualAddress(bytes memory data, bytes32 salt) internal  view returns (address pointer)",
            "class_method_signature": "SSTORE2.predictCounterfactualAddressbytes memory data, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the counterfactual address for a contract deployment using the provided data and salt.\n *\n * @param data The bytecode or initialization data for the contract.\n * @param salt A unique value used to influence the resulting address.\n * @return pointer The predicted address of the contract if deployed with the given data and salt.\n *\n * Steps:\n * 1. Calls an internal helper function `predictCounterfactualAddress` with the provided data, salt, and the current contract's address (`address(this)`).\n * 2. Returns the predicted address.\n */"
        },
        {
            "identifier": "predictCounterfactualAddress",
            "parameters": "bytes memory data, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(data);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            // Restore the part of the free memory pointer that has been overwritten.\n            mstore(0x35, 0)\n        }\n    }",
            "start": "156",
            "end": "173",
            "class": "SSTORE2",
            "signature": "returns (address predicted) predictCounterfactualAddressbytes memory data, bytes32 salt, address deployer",
            "full_signature": "function predictCounterfactualAddress(bytes memory data, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "SSTORE2.predictCounterfactualAddressbytes memory data, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the counterfactual address for a contract deployment using CREATE2.\n *\n * @param data The initialization code for the contract.\n * @param salt A unique salt to ensure deterministic address generation.\n * @param deployer The address of the deployer who will deploy the contract.\n * @return predicted The predicted address of the contract if deployed using CREATE2.\n *\n * Steps:\n * 1. Compute the hash of the initialization code using `initCodeHash`.\n * 2. Use inline assembly to calculate the CREATE2 address:\n *    - Write the prefix `0xff` to memory.\n *    - Store the deployer address, salt, and initialization code hash in memory.\n *    - Compute the keccak256 hash of the concatenated data to derive the predicted address.\n * 3. Restore the overwritten memory slot to avoid memory corruption.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address pointer)",
            "body": "function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address pointer)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, CREATE3_PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            pointer := keccak256(0x1e, 0x17)\n        }\n    }",
            "start": "181",
            "end": "202",
            "class": "SSTORE2",
            "signature": "returns (address pointer) predictDeterministicAddressbytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress(bytes32 salt, address deployer) internal  pure returns (address pointer)",
            "class_method_signature": "SSTORE2.predictDeterministicAddressbytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using CREATE3.\n *\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer that will deploy the contract.\n * @return pointer The predicted deterministic address for the contract deployment.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the deployer address in memory.\n * 3. Store the prefix byte (0xff) in memory.\n * 4. Store the salt value in memory.\n * 5. Store the CREATE3 proxy's initialization code hash in memory.\n * 6. Compute the proxy's address by hashing the relevant memory region.\n * 7. Restore the free memory pointer.\n * 8. Prepare the RLP-encoded data for the deterministic address calculation.\n * 9. Store the nonce of the proxy contract (1) in memory.\n * 10. Compute the deterministic address by hashing the RLP-encoded data.\n */"
        },
        {
            "identifier": "read",
            "parameters": "address pointer",
            "modifiers": "view",
            "return": "returns (bytes memory data)",
            "body": "function read(address pointer) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            extcodecopy(pointer, add(data, 0x1f), 0x00, add(n, 0x21))\n            mstore(data, n) // Store the length.\n            mstore(0x40, add(n, add(data, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "209",
            "end": "218",
            "class": "SSTORE2",
            "signature": "returns (bytes memory data) readaddress pointer",
            "full_signature": "function read(address pointer) internal  view returns (bytes memory data)",
            "class_method_signature": "SSTORE2.readaddress pointer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads the code of a contract at the given address and returns it as a byte array.\n *\n * @param pointer The address of the contract whose code is to be read.\n * @return data A byte array containing the contract's code.\n *\n * Steps:\n * 1. Allocate memory for the byte array using `mload(0x40)`.\n * 2. Calculate the length of the code to be copied, ensuring it is within bounds.\n * 3. Copy the contract's code into the allocated memory using `extcodecopy`.\n * 4. Store the length of the code in the first 32 bytes of the allocated memory.\n * 5. Update the free memory pointer (`0x40`) to allocate memory for the next operation.\n *\n * @dev This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "read",
            "parameters": "address pointer, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes memory data)",
            "body": "function read(address pointer, uint256 start) internal view returns (bytes memory data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(pointer), 0x01))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(pointer, add(data, 0x1f), start, add(l, 0x21))\n            mstore(data, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(data, add(0x40, mload(data)))) // Allocate memory.\n        }\n    }",
            "start": "221",
            "end": "231",
            "class": "SSTORE2",
            "signature": "returns (bytes memory data) readaddress pointer, uint256 start",
            "full_signature": "function read(address pointer, uint256 start) internal  view returns (bytes memory data)",
            "class_method_signature": "SSTORE2.readaddress pointer, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads a portion of the code from a given contract address starting at a specified position.\n *\n * @param pointer The address of the contract from which to read the code.\n * @param start The starting position in the contract's code from which to begin reading.\n * @return data The bytes of code read from the contract, starting at the specified position.\n *\n * Steps:\n * 1. Allocate memory for the data to be read.\n * 2. Calculate the length of the code to be read, ensuring it does not exceed the contract's code size.\n * 3. Copy the code from the contract's address into the allocated memory, starting at the specified position.\n * 4. Store the length of the read data in memory.\n * 5. Update the free memory pointer to account for the newly allocated memory.\n *\n * @dev This function uses low-level assembly to directly interact with the contract's code.\n */"
        },
        {
            "identifier": "read",
            "parameters": "address pointer, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes memory data)",
            "body": "function read(address pointer, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory data)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            data := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(pointer, add(data, 0x1f), start, add(d, 0x01))\n            if iszero(and(0xff, mload(add(data, d)))) {\n                let n := sub(extcodesize(pointer), 0x01)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(data, d) // Store the length.\n            mstore(add(add(data, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(data, 0x40), d)) // Allocate memory.\n        }\n    }",
            "start": "238",
            "end": "258",
            "class": "SSTORE2",
            "signature": "returns (bytes memory data) readaddress pointer, uint256 start, uint256 end",
            "full_signature": "function read(address pointer, uint256 start, uint256 end) internal  view returns (bytes memory data)",
            "class_method_signature": "SSTORE2.readaddress pointer, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads a segment of code from a given contract address and returns it as bytes.\n *\n * @param pointer The address of the contract from which to read the code.\n * @param start The starting position in the contract's code to begin reading.\n * @param end The ending position in the contract's code to stop reading.\n * @return data The bytes of code read from the contract.\n *\n * Steps:\n * 1. Allocate memory for the data using `mload(0x40)`.\n * 2. Ensure the `end` value does not exceed the maximum limit (`0xffff`).\n * 3. Calculate the length of the data to be read (`d`).\n * 4. Use `extcodecopy` to copy the code from the contract's address into the allocated memory.\n * 5. Handle edge cases where the data length might need adjustment based on the contract's code size.\n * 6. Store the length of the data in memory.\n * 7. Zeroize the memory slot after the data to ensure no residual data remains.\n * 8. Update the free memory pointer (`0x40`) to allocate memory for the next operation.\n *\n * @dev This function uses low-level assembly to directly interact with the EVM memory and contract code.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/CREATE3.sol": [
        {
            "identifier": "deployDeterministic",
            "parameters": "bytes memory initCode, bytes32 salt",
            "modifiers": "",
            "return": "returns (address deployed)",
            "body": "function deployDeterministic(bytes memory initCode, bytes32 salt)\n        internal\n        returns (address deployed)\n    {\n        deployed = deployDeterministic(0, initCode, salt);\n    }",
            "start": "59",
            "end": "64",
            "class": "CREATE3",
            "signature": "returns (address deployed) deployDeterministicbytes memory initCode, bytes32 salt",
            "full_signature": "function deployDeterministic(bytes memory initCode, bytes32 salt) internal   returns (address deployed)",
            "class_method_signature": "CREATE3.deployDeterministicbytes memory initCode, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a contract deterministically using the provided initialization code and salt.\n *\n * @param initCode The bytecode of the contract to be deployed, including the constructor arguments.\n * @param salt A unique value used to ensure deterministic deployment.\n * @return deployed The address of the deployed contract.\n *\n * Steps:\n * 1. Calls the `deployDeterministic` function with a value of 0, the provided `initCode`, and `salt`.\n * 2. Returns the address of the deployed contract.\n */"
        },
        {
            "identifier": "deployDeterministic",
            "parameters": "uint256 value, bytes memory initCode, bytes32 salt",
            "modifiers": "",
            "return": "returns (address deployed)",
            "body": "function deployDeterministic(uint256 value, bytes memory initCode, bytes32 salt)\n        internal\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, _PROXY_INITCODE) // Store the `_PROXY_INITCODE`.\n            let proxy := create2(0, 0x10, 0x10, salt)\n            if iszero(proxy) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x14, proxy) // Store the proxy's address.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            deployed := keccak256(0x1e, 0x17)\n            if iszero(\n                mul( // The arguments of `mul` are evaluated last to first.\n                    extcodesize(deployed),\n                    call(gas(), proxy, value, add(initCode, 0x20), mload(initCode), 0x00, 0x00)\n                )\n            ) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "70",
            "end": "98",
            "class": "CREATE3",
            "signature": "returns (address deployed) deployDeterministicuint256 value, bytes memory initCode, bytes32 salt",
            "full_signature": "function deployDeterministic(uint256 value, bytes memory initCode, bytes32 salt) internal   returns (address deployed)",
            "class_method_signature": "CREATE3.deployDeterministicuint256 value, bytes memory initCode, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a contract deterministically using the `create2` opcode and initializes it with the provided init code.\n *\n * @param value The amount of Ether to send with the deployment call.\n * @param initCode The initialization code for the contract being deployed.\n * @param salt A unique salt value used to determine the contract's address.\n * @return deployed The address of the deployed contract.\n *\n * Steps:\n * 1. Store the `_PROXY_INITCODE` in memory.\n * 2. Use `create2` to deploy a proxy contract with the provided salt.\n * 3. If the deployment fails, revert with the `DeploymentFailed()` error.\n * 4. Store the proxy's address in memory.\n * 5. Compute the deployed contract's address using the proxy's address and nonce.\n * 6. If the deployed contract's code size is zero or the initialization call fails, revert with the `DeploymentFailed()` error.\n * 7. Return the address of the deployed contract.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address deployed)",
            "body": "function predictDeterministicAddress(bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, deployer) // Store `deployer`.\n            mstore8(0x0b, 0xff) // Store the prefix.\n            mstore(0x20, salt) // Store the salt.\n            mstore(0x40, PROXY_INITCODE_HASH) // Store the bytecode hash.\n\n            mstore(0x14, keccak256(0x0b, 0x55)) // Store the proxy's address.\n            mstore(0x40, m) // Restore the free memory pointer.\n            // 0xd6 = 0xc0 (short RLP prefix) + 0x16 (length of: 0x94 ++ proxy ++ 0x01).\n            // 0x94 = 0x80 + 0x14 (0x14 = the length of an address, 20 bytes, in hex).\n            mstore(0x00, 0xd694)\n            mstore8(0x34, 0x01) // Nonce of the proxy contract (1).\n            deployed := keccak256(0x1e, 0x17)\n        }\n    }",
            "start": "106",
            "end": "127",
            "class": "CREATE3",
            "signature": "returns (address deployed) predictDeterministicAddressbytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress(bytes32 salt, address deployer) internal  pure returns (address deployed)",
            "class_method_signature": "CREATE3.predictDeterministicAddressbytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address of a contract to be deployed using CREATE2.\n *\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the contract.\n * @return deployed The predicted address of the contract to be deployed.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the deployer's address in memory.\n * 3. Store the prefix byte (0xff) in memory.\n * 4. Store the salt value in memory.\n * 5. Store the bytecode hash of the proxy contract in memory.\n *\n * 6. Compute the keccak256 hash of the deployer, prefix, salt, and bytecode hash to derive the proxy's address.\n * 7. Restore the free memory pointer.\n * 8. Store the RLP prefix and length of the address in memory.\n * 9. Store the nonce of the proxy contract (1) in memory.\n * 10. Compute the final deterministic address using keccak256 and return it.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DeploylessPredeployQueryer.sol": [
        {
            "identifier": "",
            "parameters": "address target, bytes[] memory targetQueryCalldata, address factory, bytes memory factoryCalldata",
            "modifiers": "",
            "return": "",
            "body": "constructor(\n        address target,\n        bytes[] memory targetQueryCalldata,\n        address factory,\n        bytes memory factoryCalldata\n    ) payable {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // If the target does not exist, deploy it.\n            if iszero(extcodesize(target)) {\n                if iszero(\n                    call(\n                        gas(),\n                        factory,\n                        selfbalance(),\n                        add(factoryCalldata, 0x20),\n                        mload(factoryCalldata),\n                        m,\n                        0x20\n                    )\n                ) {\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                if iszero(and(gt(returndatasize(), 0x1f), eq(mload(m), target))) {\n                    mstore(0x00, 0xd1f6b812) // `ReturnedAddressMismatch()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            let l := mload(targetQueryCalldata)\n            let n := shl(5, l)\n            let r := add(m, 0x40)\n            let o := add(r, n)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(0x20, i) } {\n                let j := mload(add(add(targetQueryCalldata, 0x20), i))\n                if iszero(\n                    call(gas(), target, selfbalance(), add(j, 0x20), mload(j), codesize(), 0x00)\n                ) {\n                    returndatacopy(m, 0x00, returndatasize())\n                    revert(m, returndatasize())\n                }\n                mstore(add(r, i), sub(o, r))\n                mstore(o, returndatasize())\n                returndatacopy(add(o, 0x20), 0x00, returndatasize())\n                o := and(add(add(o, returndatasize()), 0x3f), not(0x1f))\n            }\n            mstore(m, 0x20)\n            mstore(add(m, 0x20), l)\n            return(m, sub(o, m))\n        }\n    }",
            "start": "39",
            "end": "90",
            "class": "DeploylessPredeployQueryer",
            "signature": " address target, bytes[] memory targetQueryCalldata, address factory, bytes memory factoryCalldata",
            "full_signature": "constructor (address target, bytes[] memory targetQueryCalldata, address factory, bytes memory factoryCalldata)",
            "class_method_signature": "DeploylessPredeployQueryer.address target, bytes[] memory targetQueryCalldata, address factory, bytes memory factoryCalldata",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Constructor that initializes the contract with a target address, target query calldata, factory address, and factory calldata.\n *\n * @param target The address of the target contract to interact with.\n * @param targetQueryCalldata An array of calldata bytes to be used in calls to the target contract.\n * @param factory The address of the factory contract used to deploy the target if it does not exist.\n * @param factoryCalldata The calldata bytes to be used in the call to the factory contract for deploying the target.\n *\n * Steps:\n * 1. Check if the target contract exists by checking its code size.\n * 2. If the target does not exist, deploy it using the factory contract and the provided factory calldata.\n * 3. Verify that the deployed contract's address matches the expected target address.\n * 4. Iterate over the provided target query calldata and execute each call to the target contract.\n * 5. Handle any reverts or errors during the calls and revert the transaction if necessary.\n * 6. Store the results of the calls in memory and return them as a structured output.\n *\n * Assembly Details:\n * - Uses low-level assembly for memory management and contract calls.\n * - Handles memory allocation, calldata execution, and return data storage.\n * - Ensures memory safety and proper error handling during contract interactions.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibBytes.sol": [
        {
            "identifier": "length",
            "parameters": "BytesStorage storage $",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function length(BytesStorage storage $) internal view returns (uint256 result) {\n        result = uint256($._spacer);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := and(0xff, result)\n            result := or(mul(shr(8, result), eq(0xff, n)), mul(n, iszero(eq(0xff, n))))\n        }\n    }",
            "start": "88",
            "end": "95",
            "class": "LibBytes",
            "signature": "returns (uint256 result) lengthBytesStorage storage $",
            "full_signature": "function length(BytesStorage storage $) internal  view returns (uint256 result)",
            "class_method_signature": "LibBytes.lengthBytesStorage storage $",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the length of the BytesStorage data structure.\n *\n * @dev This function calculates the length of the BytesStorage by interpreting the `_spacer` value.\n * The `_spacer` is assumed to encode the length in a specific way:\n * - If the last byte of `_spacer` is 0xff, the length is derived from the higher bytes.\n * - Otherwise, the length is derived from the last byte.\n *\n * @param $ The BytesStorage data structure to query.\n * @return result The calculated length of the BytesStorage.\n *\n * Steps:\n * 1. Retrieve the `_spacer` value and cast it to a uint256.\n * 2. Use inline assembly to:\n *    a. Extract the last byte of `_spacer` and check if it is 0xff.\n *    b. If the last byte is 0xff, shift the higher bytes to derive the length.\n *    c. If the last byte is not 0xff, use the last byte as the length.\n * 3. Return the calculated length.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "bytes memory subject, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function slice(bytes memory subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let l := mload(subject) // Subject length.\n            if iszero(gt(l, end)) { end := l }\n            if iszero(gt(l, start)) { start := l }\n            if lt(start, end) {\n                result := mload(0x40)\n                let n := sub(end, start)\n                let i := add(subject, start)\n                let w := not(0x1f)\n                // Copy the `subject` one word at a time, backwards.\n                for { let j := and(add(n, 0x1f), w) } 1 {} {\n                    mstore(add(result, j), mload(add(i, j)))\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    if iszero(j) { break }\n                }\n                let o := add(add(result, 0x20), n)\n                mstore(o, 0) // Zeroize the slot after the bytes.\n                mstore(0x40, add(o, 0x20)) // Allocate memory.\n                mstore(result, n) // Store the length.\n            }\n        }\n    }",
            "start": "369",
            "end": "396",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) slicebytes memory subject, uint256 start, uint256 end",
            "full_signature": "function slice(bytes memory subject, uint256 start, uint256 end) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibBytes.slicebytes memory subject, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Slices a portion of a bytes array from a specified start index to an end index.\n *\n * @param subject The original bytes array from which to slice.\n * @param start The starting index of the slice (inclusive).\n * @param end The ending index of the slice (exclusive).\n * @return result A new bytes array containing the sliced portion.\n *\n * Steps:\n * 1. Load the length of the `subject` bytes array.\n * 2. Adjust the `end` index to ensure it does not exceed the length of the `subject`.\n * 3. Adjust the `start` index to ensure it does not exceed the length of the `subject`.\n * 4. If `start` is less than `end`, proceed with slicing:\n *    a. Allocate memory for the result.\n *    b. Calculate the length of the slice (`n`).\n *    c. Calculate the starting memory address of the slice (`i`).\n *    d. Use a loop to copy the `subject` bytes array one word at a time, backwards.\n *    e. Zeroize the slot after the bytes in the result.\n *    f. Allocate memory for the result and store the length of the slice.\n * 5. Return the sliced bytes array.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "bytes memory subject, uint256 start",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function slice(bytes memory subject, uint256 start)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        result = slice(subject, start, type(uint256).max);\n    }",
            "start": "400",
            "end": "406",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) slicebytes memory subject, uint256 start",
            "full_signature": "function slice(bytes memory subject, uint256 start) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibBytes.slicebytes memory subject, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Slices a portion of a byte array starting from a specified index until the end.\n *\n * @param subject The byte array to be sliced.\n * @param start The starting index from which to slice the byte array.\n * @return result A new byte array containing the sliced portion of the original array.\n *\n * Steps:\n * 1. Calls an overloaded `slice` function with the provided `subject`, `start`, and `type(uint256).max` (maximum possible value for uint256) as parameters.\n * 2. Returns the sliced portion of the byte array starting from `start` until the end of the array.\n */ "
        },
        {
            "identifier": "sliceCalldata",
            "parameters": "bytes calldata subject, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (bytes calldata result)",
            "body": "function sliceCalldata(bytes calldata subject, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, subject.length), lt(subject.length, end)))\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, end), sub(end, start))\n        }\n    }",
            "start": "410",
            "end": "422",
            "class": "LibBytes",
            "signature": "returns (bytes calldata result) sliceCalldatabytes calldata subject, uint256 start, uint256 end",
            "full_signature": "function sliceCalldata(bytes calldata subject, uint256 start, uint256 end) internal  pure returns (bytes calldata result)",
            "class_method_signature": "LibBytes.sliceCalldatabytes calldata subject, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Slices a portion of the calldata based on the provided start and end indices.\n *\n * @param subject The original calldata to be sliced.\n * @param start The starting index of the slice.\n * @param end The ending index of the slice.\n * @return result The sliced portion of the calldata.\n *\n * Steps:\n * 1. Adjust the `end` index to ensure it does not exceed the length of the calldata.\n * 2. Adjust the `start` index to ensure it does not exceed the length of the calldata.\n * 3. Calculate the offset of the result by adding the `start` index to the original calldata offset.\n * 4. Calculate the length of the result by ensuring `start` is less than `end` and then subtracting `start` from `end`.\n *\n * @dev This function uses inline assembly to perform low-level operations on calldata.\n */"
        },
        {
            "identifier": "sliceCalldata",
            "parameters": "bytes calldata subject, uint256 start",
            "modifiers": "pure",
            "return": "returns (bytes calldata result)",
            "body": "function sliceCalldata(bytes calldata subject, uint256 start)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, subject.length), lt(subject.length, start)))\n            result.offset := add(subject.offset, start)\n            result.length := mul(lt(start, subject.length), sub(subject.length, start))\n        }\n    }",
            "start": "426",
            "end": "437",
            "class": "LibBytes",
            "signature": "returns (bytes calldata result) sliceCalldatabytes calldata subject, uint256 start",
            "full_signature": "function sliceCalldata(bytes calldata subject, uint256 start) internal  pure returns (bytes calldata result)",
            "class_method_signature": "LibBytes.sliceCalldatabytes calldata subject, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Slices a portion of the calldata starting from a specified index.\n *\n * @param subject The calldata to be sliced.\n * @param start The starting index from which to slice the calldata.\n * @return result The sliced portion of the calldata.\n *\n * Steps:\n * 1. Adjust the `start` index to ensure it does not exceed the length of the calldata.\n * 2. Calculate the offset of the result by adding the `start` index to the original calldata offset.\n * 3. Calculate the length of the result by ensuring it does not exceed the remaining length of the calldata.\n *\n * @dev This function uses inline assembly to perform low-level operations on the calldata.\n */ "
        },
        {
            "identifier": "truncate",
            "parameters": "bytes memory subject, uint256 n",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function truncate(bytes memory subject, uint256 n)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := subject\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }",
            "start": "441",
            "end": "451",
            "class": "LibBytes",
            "signature": "returns (bytes memory result) truncatebytes memory subject, uint256 n",
            "full_signature": "function truncate(bytes memory subject, uint256 n) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibBytes.truncatebytes memory subject, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Truncates a byte array to a specified length `n`.\n *\n * @param subject The byte array to be truncated.\n * @param n The desired length of the truncated byte array.\n * @return result The truncated byte array.\n *\n * Steps:\n * 1. Assign the input byte array `subject` to `result`.\n * 2. Use inline assembly to safely truncate the byte array:\n *    - Check if `n` is less than the length of `result`.\n *    - If true, update the length of `result` to `n` by modifying the memory slot.\n * 3. Return the truncated byte array.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "truncatedCalldata",
            "parameters": "bytes calldata subject, uint256 n",
            "modifiers": "pure",
            "return": "returns (bytes calldata result)",
            "body": "function truncatedCalldata(bytes calldata subject, uint256 n)\n        internal\n        pure\n        returns (bytes calldata result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.offset := subject.offset\n            result.length := xor(n, mul(xor(n, subject.length), lt(subject.length, n)))\n        }\n    }",
            "start": "455",
            "end": "465",
            "class": "LibBytes",
            "signature": "returns (bytes calldata result) truncatedCalldatabytes calldata subject, uint256 n",
            "full_signature": "function truncatedCalldata(bytes calldata subject, uint256 n) internal  pure returns (bytes calldata result)",
            "class_method_signature": "LibBytes.truncatedCalldatabytes calldata subject, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Truncates the given calldata to a specified length `n`.\n *\n * @param subject The original calldata to be truncated.\n * @param n The desired length to truncate the calldata to.\n * @return result The truncated calldata.\n *\n * Steps:\n * 1. Use inline assembly to manipulate the calldata.\n * 2. Set the offset of the result to match the offset of the original calldata.\n * 3. Calculate the length of the result:\n *    - If the original length is less than `n`, the result length is set to the original length.\n *    - Otherwise, the result length is set to `n`.\n * 4. Return the truncated calldata.\n */"
        },
        {
            "identifier": "cmp",
            "parameters": "bytes memory a, bytes memory b",
            "modifiers": "pure",
            "return": "returns (int256 result)",
            "body": "function cmp(bytes memory a, bytes memory b) internal pure returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let aLen := mload(a)\n            let bLen := mload(b)\n            let n := and(xor(aLen, mul(xor(aLen, bLen), lt(bLen, aLen))), not(0x1f))\n            if n {\n                for { let i := 0x20 } 1 {} {\n                    let x := mload(add(a, i))\n                    let y := mload(add(b, i))\n                    if or(xor(x, y), eq(i, n)) {\n                        result := sub(gt(x, y), lt(x, y))\n                        break\n                    }\n                    i := add(i, 0x20)\n                }\n            }\n            // forgefmt: disable-next-item\n            if iszero(result) {\n                let x := and(mload(add(add(a, 0x20), n)),\n                    not(shr(mul(7, sub(aLen, n)), shr(sub(aLen, n), not(result)))))\n                let y := and(mload(add(add(b, 0x20), n)),\n                    not(shr(mul(7, sub(bLen, n)), shr(sub(bLen, n), not(result)))))\n                result := sub(gt(x, y), lt(x, y))\n                if iszero(result) { result := sub(gt(aLen, bLen), lt(aLen, bLen)) }\n            }\n        }\n    }",
            "start": "617",
            "end": "644",
            "class": "LibBytes",
            "signature": "returns (int256 result) cmpbytes memory a, bytes memory b",
            "full_signature": "function cmp(bytes memory a, bytes memory b) internal  pure returns (int256 result)",
            "class_method_signature": "LibBytes.cmpbytes memory a, bytes memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Compares two byte arrays and returns an integer indicating their relative order.\n *\n * @dev This function uses low-level assembly to efficiently compare byte arrays.\n * The function returns:\n * - `1` if `a` is greater than `b`.\n * - `-1` if `a` is less than `b`.\n * - `0` if `a` and `b` are equal.\n *\n * @param a The first byte array to compare.\n * @param b The second byte array to compare.\n * @return result An integer indicating the comparison result:\n *               - `1` if `a > b`\n *               - `-1` if `a < b`\n *               - `0` if `a == b`\n *\n * Steps:\n * 1. Load the lengths of `a` and `b` into `aLen` and `bLen`.\n * 2. Calculate the minimum length `n` to compare, ensuring it is a multiple of 32 bytes.\n * 3. Iterate over the byte arrays in 32-byte chunks:\n *    - Compare the chunks at each step.\n *    - If a difference is found, return the result (`1` or `-1`).\n * 4. If no difference is found in the chunks, compare the remaining bytes:\n *    - Mask and compare the remaining bytes.\n *    - If still no difference, compare the lengths of `a` and `b` to determine the result.\n */\n"
        },
        {
            "identifier": "directReturn",
            "parameters": "bytes memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function directReturn(bytes memory a) internal pure {\n        assembly {\n            // Assumes that the bytes does not start from the scratch space.\n            let retStart := sub(a, 0x20)\n            let retUnpaddedSize := add(mload(a), 0x40)\n            // Right pad with zeroes. Just in case the bytes is produced\n            // by a method that doesn't zero right pad.\n            mstore(add(retStart, retUnpaddedSize), 0)\n            mstore(retStart, 0x20) // Store the return offset.\n            // End the transaction, returning the bytes.\n            return(retStart, and(not(0x1f), add(0x1f, retUnpaddedSize)))\n        }\n    }",
            "start": "647",
            "end": "659",
            "class": "LibBytes",
            "signature": " directReturnbytes memory a",
            "full_signature": "function directReturn(bytes memory a) internal  pure",
            "class_method_signature": "LibBytes.directReturnbytes memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to directly return a bytes array from a Solidity assembly block.\n *\n * @param a The bytes array to be returned.\n *\n * Steps:\n * 1. Calculate the starting position of the return data by subtracting 0x20 (32 bytes) from the start of the bytes array.\n * 2. Calculate the unpadded size of the return data by adding 0x40 (64 bytes) to the length of the bytes array.\n * 3. Right-pad the return data with zeroes to ensure proper alignment and avoid potential issues with non-zero-padded bytes.\n * 4. Store the return offset (0x20) at the beginning of the return data.\n * 5. Use the `return` opcode to end the transaction and return the bytes array, ensuring the size is properly aligned to 32 bytes.\n *\n * Note: This function assumes that the bytes array does not start from the scratch space.\n */"
        },
        {
            "identifier": "directReturn",
            "parameters": "bytes[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function directReturn(bytes[] memory a) internal pure {\n        assembly {\n            let n := mload(a) // `a.length`.\n            let o := add(a, 0x20) // Start of elements in `a`.\n            let u := a // Highest memory slot.\n            let w := not(0x1f)\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                let c := add(o, shl(5, i)) // Location of pointer to `a[i]`.\n                let s := mload(c) // `a[i]`.\n                let l := mload(s) // `a[i].length`.\n                let r := and(l, 0x1f) // `a[i].length % 32`.\n                let z := add(0x20, and(l, w)) // Offset of last word in `a[i]` from `s`.\n                // If `s` comes before `o`, or `s` is not zero right padded.\n                if iszero(lt(lt(s, o), or(iszero(r), iszero(shl(shl(3, r), mload(add(s, z))))))) {\n                    let m := mload(0x40)\n                    mstore(m, l) // Copy `a[i].length`.\n                    for {} 1 {} {\n                        mstore(add(m, z), mload(add(s, z))) // Copy `a[i]`, backwards.\n                        z := add(z, w) // `sub(z, 0x20)`.\n                        if iszero(z) { break }\n                    }\n                    let e := add(add(m, 0x20), l)\n                    mstore(e, 0) // Zeroize the slot after the copied bytes.\n                    mstore(0x40, add(e, 0x20)) // Allocate memory.\n                    s := m\n                }\n                mstore(c, sub(s, o)) // Convert to calldata offset.\n                let t := add(l, add(s, 0x20))\n                if iszero(lt(t, u)) { u := t }\n            }\n            let retStart := add(a, w) // Assumes `a` doesn't start from scratch space.\n            mstore(retStart, 0x20) // Store the return offset.\n            return(retStart, add(0x40, sub(u, retStart))) // End the transaction.\n        }\n    }",
            "start": "662",
            "end": "696",
            "class": "LibBytes",
            "signature": " directReturnbytes[] memory a",
            "full_signature": "function directReturn(bytes[] memory a) internal  pure",
            "class_method_signature": "LibBytes.directReturnbytes[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to process and return an array of byte arrays (`bytes[]`) in a specific format.\n *\n * @dev This function uses inline assembly to manipulate memory and optimize gas usage. It processes each byte array in the input array `a` and ensures proper memory alignment and padding.\n *\n * Steps:\n * 1. Load the length of the input array `a` into `n`.\n * 2. Calculate the starting memory location of the elements in `a` and store it in `o`.\n * 3. Initialize `u` to track the highest memory slot used.\n * 4. Iterate over each element in the array `a`:\n *    - Calculate the memory location of the pointer to `a[i]` and load its value into `s`.\n *    - Load the length of `a[i]` into `l`.\n *    - Calculate the offset of the last word in `a[i]` from `s` and store it in `z`.\n *    - Check if `s` is properly aligned and padded. If not, copy `a[i]` to a new memory location and update `s`.\n *    - Convert the pointer to `a[i]` into a calldata offset and store it back in `c`.\n *    - Update `u` to track the highest memory slot used.\n * 5. Calculate the return start position and store the return offset.\n * 6. End the transaction by returning the processed data.\n *\n * @param a An array of byte arrays (`bytes[]`) to be processed and returned.\n */"
        },
        {
            "identifier": "load",
            "parameters": "bytes memory a, uint256 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function load(bytes memory a, uint256 offset) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), offset))\n        }\n    }",
            "start": "700",
            "end": "705",
            "class": "LibBytes",
            "signature": "returns (bytes32 result) loadbytes memory a, uint256 offset",
            "full_signature": "function load(bytes memory a, uint256 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibBytes.loadbytes memory a, uint256 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Loads a bytes32 value from a specific offset within a bytes array.\n *\n * @param a The bytes array from which to load the value.\n * @param offset The position within the bytes array from which to load the value.\n * @return result The bytes32 value loaded from the specified offset.\n *\n * Steps:\n * 1. Use inline assembly to perform a low-level memory load operation.\n * 2. Calculate the memory address by adding the base address of the bytes array (`a`) and the offset.\n * 3. Load the bytes32 value from the calculated memory address.\n *\n * Note: This function is marked as `internal pure`, meaning it can only be called internally and does not modify the state.\n */"
        },
        {
            "identifier": "loadCalldata",
            "parameters": "bytes calldata a, uint256 offset",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function loadCalldata(bytes calldata a, uint256 offset)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := calldataload(add(a.offset, offset))\n        }\n    }",
            "start": "709",
            "end": "718",
            "class": "LibBytes",
            "signature": "returns (bytes32 result) loadCalldatabytes calldata a, uint256 offset",
            "full_signature": "function loadCalldata(bytes calldata a, uint256 offset) internal  pure returns (bytes32 result)",
            "class_method_signature": "LibBytes.loadCalldatabytes calldata a, uint256 offset",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Loads a 32-byte word from the calldata at a specified offset.\n *\n * @param a The calldata bytes from which to load the data.\n * @param offset The offset within the calldata to start loading the 32-byte word.\n * @return result The 32-byte word loaded from the calldata.\n *\n * Steps:\n * 1. Use inline assembly to safely load a 32-byte word from the calldata.\n * 2. Calculate the memory address by adding the offset to the calldata's offset.\n * 3. Load the 32-byte word from the calculated address and return it.\n */"
        },
        {
            "identifier": "emptyCalldata",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes calldata result)",
            "body": "function emptyCalldata() internal pure returns (bytes calldata result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result.length := 0\n        }\n    }",
            "start": "721",
            "end": "726",
            "class": "LibBytes",
            "signature": "returns (bytes calldata result) emptyCalldata",
            "full_signature": "function emptyCalldata() internal  pure returns (bytes calldata result)",
            "class_method_signature": "LibBytes.emptyCalldata",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns an empty calldata bytes object.\n *\n * @dev This function uses inline assembly to create a calldata bytes object with a length of 0.\n * \n * @return result An empty calldata bytes object.\n *\n * Steps:\n * 1. Use inline assembly to set the length of the calldata bytes object to 0.\n * 2. Return the empty calldata bytes object.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/SignatureCheckerLib.sol": [
        {
            "identifier": "isValidSignatureNow",
            "parameters": "address signer, bytes32 hash, bytes memory signature",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n            if iszero(isValid) {\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                // Copy the `signature` over.\n                let n := add(0x20, mload(signature))\n                pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n                isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n            }\n        }\n    }",
            "start": "32",
            "end": "74",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidSignatureNowaddress signer, bytes32 hash, bytes memory signature",
            "full_signature": "function isValidSignatureNow(address signer, bytes32 hash, bytes memory signature) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidSignatureNowaddress signer, bytes32 hash, bytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Validates if a given signature is valid for a specific signer and hash.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param signature The signature to be validated.\n * @return isValid A boolean indicating whether the signature is valid for the given signer and hash.\n *\n * Steps:\n * 1. If the signer is the zero address, return `false` immediately.\n * 2. Use inline assembly to handle low-level memory operations for efficiency.\n * 3. Depending on the length of the signature (64 or 65 bytes), extract the `v`, `r`, and `s` components.\n * 4. Recover the signer's address from the signature using the `ecrecover` precompiled contract.\n * 5. Compare the recovered address with the provided signer address to determine validity.\n * 6. If the signature is invalid, attempt to validate it using the `isValidSignature` method of the signer contract.\n * 7. Return the result of the validation.\n *\n * Notes:\n * - The function handles both EIP-2098 compact signatures (64 bytes) and traditional EIP-712 signatures (65 bytes).\n * - The function restores the zero slot and free memory pointer after operations to maintain memory safety.\n */"
        },
        {
            "identifier": "isValidSignatureNowCalldata",
            "parameters": "address signer, bytes32 hash, bytes calldata signature",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            for {} 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // `r`, `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n            if iszero(isValid) {\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), signature.length)\n                // Copy the `signature` over.\n                calldatacopy(add(m, 0x64), signature.offset, signature.length)\n                isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n            }\n        }\n    }",
            "start": "79",
            "end": "121",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidSignatureNowCalldataaddress signer, bytes32 hash, bytes calldata signature",
            "full_signature": "function isValidSignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidSignatureNowCalldataaddress signer, bytes32 hash, bytes calldata signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Validates a signature for a given hash using the provided signer and signature.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param signature The signature to be validated, provided as calldata.\n * @return isValid A boolean indicating whether the signature is valid for the given hash and signer.\n *\n * Steps:\n * 1. If the signer is the zero address, return `false` immediately.\n * 2. Use inline assembly to handle low-level memory operations for efficiency.\n * 3. Depending on the length of the signature (64 or 65 bytes), extract the `v`, `r`, and `s` components.\n * 4. Recover the signer's address from the signature and compare it with the provided signer address.\n * 5. If the recovered address matches the provided signer, the signature is valid.\n * 6. If the signature length is neither 64 nor 65 bytes, or if the recovered address does not match, \n *    attempt to validate the signature using the `isValidSignature(bytes32,bytes)` method (EIP-1271).\n * 7. Return the result of the validation.\n *\n * Note: This function uses low-level assembly for performance optimization and handles both standard \n * ECDSA signatures and EIP-1271 compliant contract signatures.\n */"
        },
        {
            "identifier": "isValidSignatureNow",
            "parameters": "address signer, bytes32 hash, bytes32 r, bytes32 vs",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r) // `r`.\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n\n            if iszero(isValid) {\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), mload(0x60)) // `s`.\n                mstore8(add(m, 0xa4), mload(0x20)) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "126",
            "end": "158",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidSignatureNowaddress signer, bytes32 hash, bytes32 r, bytes32 vs",
            "full_signature": "function isValidSignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidSignatureNowaddress signer, bytes32 hash, bytes32 r, bytes32 vs",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Validates if a given signature is valid for a specific signer and hash.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param r The `r` component of the ECDSA signature.\n * @param vs The `vs` component of the ECDSA signature (contains both `v` and `s`).\n * @return isValid A boolean indicating whether the signature is valid for the given signer and hash.\n *\n * Steps:\n * 1. If the signer address is zero, return `false` immediately.\n * 2. Use inline assembly to perform low-level operations:\n *    - Load the free memory pointer.\n *    - Store the hash, `v`, `r`, and `s` components in memory.\n *    - Perform a static call to the `ecrecover` precompiled contract to recover the signer from the signature.\n *    - Compare the recovered signer with the provided signer address.\n *    - If the recovered signer does not match, attempt to validate the signature using the `isValidSignature` method (EIP-1271).\n *    - Restore the zero slot and free memory pointer after the operation.\n * 3. Return the validation result.\n */"
        },
        {
            "identifier": "isValidSignatureNow",
            "parameters": "address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        if (signer == address(0)) return isValid;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff)) // `v`.\n            mstore(0x40, r) // `r`.\n            mstore(0x60, s) // `s`.\n            let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n\n            if iszero(isValid) {\n                let f := shl(224, 0x1626ba7e)\n                mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m, 0x04), hash)\n                let d := add(m, 0x24)\n                mstore(d, 0x40) // The offset of the `signature` in the calldata.\n                mstore(add(m, 0x44), 65) // Length of the signature.\n                mstore(add(m, 0x64), r) // `r`.\n                mstore(add(m, 0x84), s) // `s`.\n                mstore8(add(m, 0xa4), v) // `v`.\n                isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n                isValid := and(eq(mload(d), f), isValid)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "163",
            "end": "195",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidSignatureNowaddress signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function isValidSignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidSignatureNowaddress signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Validates if a given signature is valid for a specific signer and hash.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the message that was signed.\n * @param v The recovery byte of the signature.\n * @param r The first 32 bytes of the signature.\n * @param s The second 32 bytes of the signature.\n * @return isValid A boolean indicating whether the signature is valid for the given signer and hash.\n *\n * Steps:\n * 1. If the signer address is zero, return `false` immediately.\n * 2. Use inline assembly to perform low-level operations:\n *    - Load the free memory pointer.\n *    - Store the hash, `v`, `r`, and `s` in memory.\n *    - Perform a static call to the `ecrecover` precompiled contract to recover the signer address from the signature.\n *    - Compare the recovered address with the provided signer address.\n *    - If the addresses do not match, attempt to validate the signature using the `isValidSignature` method of the signer contract.\n *    - Restore the zero slot and free memory pointer to their original states.\n * 3. Return the result of the validation.\n */"
        },
        {
            "identifier": "isValidERC1271SignatureNow",
            "parameters": "address signer, bytes32 hash, bytes memory signature",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            // Copy the `signature` over.\n            let n := add(0x20, mload(signature))\n            pop(staticcall(gas(), 4, signature, n, add(m, 0x44), n))\n            isValid := staticcall(gas(), signer, m, add(returndatasize(), 0x44), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "start": "204",
            "end": "223",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidERC1271SignatureNowaddress signer, bytes32 hash, bytes memory signature",
            "full_signature": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes memory signature) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidERC1271SignatureNowaddress signer, bytes32 hash, bytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given signature is valid for a specific signer and hash according to the ERC1271 standard.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param signature The signature to be validated.\n * @return isValid A boolean indicating whether the signature is valid for the given signer and hash.\n *\n * Steps:\n * 1. Allocate memory for the function call data.\n * 2. Store the ERC1271 selector (`isValidSignature(bytes32,bytes)`) in memory.\n * 3. Store the hash in memory.\n * 4. Store the offset of the `signature` in memory.\n * 5. Copy the `signature` into memory.\n * 6. Perform a static call to the ERC1271 contract to validate the signature.\n * 7. Check if the returned data matches the expected selector and if the call was successful.\n * 8. Return the result of the validation.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and static calls.\n */"
        },
        {
            "identifier": "isValidERC1271SignatureNowCalldata",
            "parameters": "address signer, bytes32 hash, bytes calldata signature",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidERC1271SignatureNowCalldata(\n        address signer,\n        bytes32 hash,\n        bytes calldata signature\n    ) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), signature.length)\n            // Copy the `signature` over.\n            calldatacopy(add(m, 0x64), signature.offset, signature.length)\n            isValid := staticcall(gas(), signer, m, add(signature.length, 0x64), d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "start": "226",
            "end": "245",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidERC1271SignatureNowCalldataaddress signer, bytes32 hash, bytes calldata signature",
            "full_signature": "function isValidERC1271SignatureNowCalldata(address signer, bytes32 hash, bytes calldata signature) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidERC1271SignatureNowCalldataaddress signer, bytes32 hash, bytes calldata signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Validates an ERC1271 signature using calldata.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param signature The signature to be validated, passed as calldata.\n * @return isValid A boolean indicating whether the signature is valid.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the ERC1271 magic value (`0x1626ba7e`) shifted to the correct position.\n * 3. Store the hash in memory.\n * 4. Store the offset of the signature in memory.\n * 5. Store the length of the signature in memory.\n * 6. Copy the signature from calldata to memory.\n * 7. Perform a static call to the signer's `isValidSignature` function.\n * 8. Check if the returned value matches the ERC1271 magic value and the call was successful.\n * 9. Return the result of the validation.\n */"
        },
        {
            "identifier": "isValidERC1271SignatureNow",
            "parameters": "address signer, bytes32 hash, bytes32 r, bytes32 vs",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), shr(1, shl(1, vs))) // `s`.\n            mstore8(add(m, 0xa4), add(shr(255, vs), 27)) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "start": "249",
            "end": "269",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidERC1271SignatureNowaddress signer, bytes32 hash, bytes32 r, bytes32 vs",
            "full_signature": "function isValidERC1271SignatureNow(address signer, bytes32 hash, bytes32 r, bytes32 vs) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidERC1271SignatureNowaddress signer, bytes32 hash, bytes32 r, bytes32 vs",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Validates an ERC1271 signature for a given signer, hash, and signature components.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param r The `r` component of the ECDSA signature.\n * @param vs The `vs` component of the ECDSA signature (combines `s` and `v`).\n * @return isValid A boolean indicating whether the signature is valid for the given signer and hash.\n *\n * Steps:\n * 1. Allocate memory for the function call data.\n * 2. Store the ERC1271 function selector (`isValidSignature(bytes32,bytes)`) in memory.\n * 3. Store the hash in memory.\n * 4. Prepare the memory layout for the signature data, including its offset and length.\n * 5. Store the `r`, `s`, and `v` components of the signature in memory.\n * 6. Perform a static call to the signer's `isValidSignature` function with the prepared data.\n * 7. Check if the returned value matches the expected function selector and if the call was successful.\n * 8. Return the validation result.\n */"
        },
        {
            "identifier": "isValidERC1271SignatureNow",
            "parameters": "address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let f := shl(224, 0x1626ba7e)\n            mstore(m, f) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n            mstore(add(m, 0x04), hash)\n            let d := add(m, 0x24)\n            mstore(d, 0x40) // The offset of the `signature` in the calldata.\n            mstore(add(m, 0x44), 65) // Length of the signature.\n            mstore(add(m, 0x64), r) // `r`.\n            mstore(add(m, 0x84), s) // `s`.\n            mstore8(add(m, 0xa4), v) // `v`.\n            isValid := staticcall(gas(), signer, m, 0xa5, d, 0x20)\n            isValid := and(eq(mload(d), f), isValid)\n        }\n    }",
            "start": "273",
            "end": "293",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidERC1271SignatureNowaddress signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function isValidERC1271SignatureNow(address signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  view returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidERC1271SignatureNowaddress signer, bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Validates an ERC1271 signature using the provided signer, hash, and signature components (v, r, s).\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param v The recovery byte of the signature.\n * @param r The first 32 bytes of the signature.\n * @param s The second 32 bytes of the signature.\n * @return isValid A boolean indicating whether the signature is valid according to the ERC1271 standard.\n *\n * Steps:\n * 1. Allocate memory for the function call data.\n * 2. Store the ERC1271 function selector (`isValidSignature(bytes32,bytes)`) in memory.\n * 3. Store the hash in memory.\n * 4. Prepare the memory layout for the signature data, including the offset and length of the signature.\n * 5. Store the signature components (r, s, v) in memory.\n * 6. Perform a static call to the signer's `isValidSignature` function with the prepared data.\n * 7. Check if the returned value matches the expected function selector and if the call was successful.\n * 8. Return the validation result.\n */"
        },
        {
            "identifier": "isValidERC6492SignatureNowAllowSideEffects",
            "parameters": "address signer, bytes32 hash, bytes memory signature",
            "modifiers": "",
            "return": "returns (bool isValid)",
            "body": "function isValidERC6492SignatureNowAllowSideEffects(\n        address signer,\n        bytes32 hash,\n        bytes memory signature\n    ) internal returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                pop(staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_))\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), _isValid)\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                pop(\n                    call(\n                        gas(), // Remaining gas.\n                        0x0000bc370E4DC924F427d84e2f4B9Ec81626ba7E, // Non-reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                )\n                isValid := returndatasize()\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "start": "311",
            "end": "382",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidERC6492SignatureNowAllowSideEffectsaddress signer, bytes32 hash, bytes memory signature",
            "full_signature": "function isValidERC6492SignatureNowAllowSideEffects(address signer, bytes32 hash, bytes memory signature) internal   returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidERC6492SignatureNowAllowSideEffectsaddress signer, bytes32 hash, bytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Validates an ERC6492 signature with side effects allowed.\n *\n * @param signer The address of the signer whose signature is being validated.\n * @param hash The hash of the data that was signed.\n * @param signature The signature to be validated.\n * @return isValid A boolean indicating whether the signature is valid.\n *\n * Steps:\n * 1. Check if the signer is a contract or an EOA (Externally Owned Account).\n * 2. If the signer is a contract, call the `isValidSignature` function on the contract to validate the signature.\n * 3. If the signer is an EOA, perform an `ecrecover` operation to validate the signature.\n * 4. Handle different signature lengths (64 or 65 bytes) for EOA validation.\n * 5. Return `true` if the signature is valid, otherwise `false`.\n *\n * Assembly Details:\n * - The function uses inline assembly to optimize gas usage and handle low-level operations.\n * - It dynamically checks the signature length and processes it accordingly.\n * - It restores the free memory pointer and zero slot after operations to maintain memory safety.\n */"
        },
        {
            "identifier": "isValidERC6492SignatureNow",
            "parameters": "address signer, bytes32 hash, bytes memory signature",
            "modifiers": "",
            "return": "returns (bool isValid)",
            "body": "function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature)\n        internal\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function callIsValidSignature(signer_, hash_, signature_) -> _isValid {\n                let m_ := mload(0x40)\n                let f_ := shl(224, 0x1626ba7e)\n                mstore(m_, f_) // `bytes4(keccak256(\"isValidSignature(bytes32,bytes)\"))`.\n                mstore(add(m_, 0x04), hash_)\n                let d_ := add(m_, 0x24)\n                mstore(d_, 0x40) // The offset of the `signature` in the calldata.\n                let n_ := add(0x20, mload(signature_))\n                pop(staticcall(gas(), 4, signature_, n_, add(m_, 0x44), n_))\n                _isValid := staticcall(gas(), signer_, m_, add(returndatasize(), 0x44), d_, 0x20)\n                _isValid := and(eq(mload(d_), f_), _isValid)\n            }\n            let noCode := iszero(extcodesize(signer))\n            let n := mload(signature)\n            for {} 1 {} {\n                if iszero(eq(mload(add(signature, n)), mul(0x6492, div(not(isValid), 0xffff)))) {\n                    if iszero(noCode) { isValid := callIsValidSignature(signer, hash, signature) }\n                    break\n                }\n                if iszero(noCode) {\n                    let o := add(signature, 0x20) // Signature bytes.\n                    isValid := callIsValidSignature(signer, hash, add(o, mload(add(o, 0x40))))\n                    if isValid { break }\n                }\n                let m := mload(0x40)\n                mstore(m, signer)\n                mstore(add(m, 0x20), hash)\n                let willBeZeroIfRevertingVerifierExists :=\n                    call(\n                        gas(), // Remaining gas.\n                        0x00007bd799e4A591FeA53f8A8a3E9f931626Ba7e, // Reverting verifier.\n                        0, // Send zero ETH.\n                        m, // Start of memory.\n                        add(returndatasize(), 0x40), // Length of calldata in memory.\n                        staticcall(gas(), 4, add(signature, 0x20), n, add(m, 0x40), n), // 1.\n                        0x00 // Length of returndata to write.\n                    )\n                isValid := gt(returndatasize(), willBeZeroIfRevertingVerifierExists)\n                break\n            }\n            // Do `ecrecover` fallback if `noCode && !isValid`.\n            for {} gt(noCode, isValid) {} {\n                switch n\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                let m := mload(0x40)\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                let recovered := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                isValid := gt(returndatasize(), shl(96, xor(signer, recovered)))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "start": "392",
            "end": "461",
            "class": "SignatureCheckerLib",
            "signature": "returns (bool isValid) isValidERC6492SignatureNowaddress signer, bytes32 hash, bytes memory signature",
            "full_signature": "function isValidERC6492SignatureNow(address signer, bytes32 hash, bytes memory signature) internal   returns (bool isValid)",
            "class_method_signature": "SignatureCheckerLib.isValidERC6492SignatureNowaddress signer, bytes32 hash, bytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Validates an ERC6492 signature by checking if it matches the provided signer and hash.\n *\n * @dev This function uses low-level assembly to perform signature validation. It supports both\n *      contract-based signatures (via `isValidSignature`) and EOA-based signatures (via `ecrecover`).\n *      The function handles edge cases such as reverting verifiers and fallback to `ecrecover`.\n *\n * @param signer The address of the expected signer.\n * @param hash The hash of the message that was signed.\n * @param signature The signature to be validated.\n * @return isValid A boolean indicating whether the signature is valid for the given signer and hash.\n *\n * Steps:\n * 1. Check if the signer is a contract or an externally owned account (EOA).\n * 2. If the signer is a contract, attempt to validate the signature using `isValidSignature`.\n * 3. If the signer is an EOA, fallback to `ecrecover` for signature validation.\n * 4. Handle edge cases such as reverting verifiers and ensure proper memory management.\n * 5. Return `true` if the signature is valid, otherwise `false`.\n */"
        },
        {
            "identifier": "toEthSignedMessageHash",
            "parameters": "bytes32 hash",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }",
            "start": "471",
            "end": "478",
            "class": "SignatureCheckerLib",
            "signature": "returns (bytes32 result) toEthSignedMessageHashbytes32 hash",
            "full_signature": "function toEthSignedMessageHash(bytes32 hash) internal  pure returns (bytes32 result)",
            "class_method_signature": "SignatureCheckerLib.toEthSignedMessageHashbytes32 hash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a bytes32 hash into an Ethereum signed message hash.\n *\n * @dev This function prepends the Ethereum signed message prefix to the hash and computes the keccak256 hash of the result.\n * The prefix is \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\" (28 bytes), followed by the 32-byte hash.\n * The final result is a 32-byte hash that can be used for signature verification.\n *\n * @param hash The 32-byte hash to be converted into an Ethereum signed message hash.\n * @return result The resulting Ethereum signed message hash.\n *\n * Steps:\n * 1. Store the input hash in memory at position 0x20.\n * 2. Store the Ethereum signed message prefix in memory at position 0x00.\n * 3. Compute the keccak256 hash of the concatenated prefix and hash, starting from byte 0x04 to 0x3c (60 bytes in total).\n * 4. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "toEthSignedMessageHash",
            "parameters": "bytes memory s",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }",
            "start": "485",
            "end": "506",
            "class": "SignatureCheckerLib",
            "signature": "returns (bytes32 result) toEthSignedMessageHashbytes memory s",
            "full_signature": "function toEthSignedMessageHash(bytes memory s) internal  pure returns (bytes32 result)",
            "class_method_signature": "SignatureCheckerLib.toEthSignedMessageHashbytes memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a byte array into an Ethereum signed message hash.\n *\n * @param s The byte array to be hashed.\n * @return result The resulting Ethereum signed message hash.\n *\n * Steps:\n * 1. Load the length of the byte array `s`.\n * 2. Prepare the Ethereum signed message prefix: \"\\x19Ethereum Signed Message:\\n\".\n * 3. Convert the length of `s` to its ASCII decimal representation.\n * 4. Calculate the header length, which includes the prefix and the length of `s`.\n * 5. Ensure the header does not exceed 32 bytes; otherwise, throw an out-of-offset error.\n * 6. Temporarily store the header in memory.\n * 7. Compute the Keccak-256 hash of the concatenated header and the original byte array `s`.\n * 8. Restore the original length of `s` in memory.\n * 9. Return the computed hash.\n */"
        },
        {
            "identifier": "emptySignature",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes calldata signature)",
            "body": "function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }",
            "start": "513",
            "end": "518",
            "class": "SignatureCheckerLib",
            "signature": "returns (bytes calldata signature) emptySignature",
            "full_signature": "function emptySignature() internal  pure returns (bytes calldata signature)",
            "class_method_signature": "SignatureCheckerLib.emptySignature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns an empty signature in the form of a `bytes calldata` object.\n *\n * Steps:\n * 1. Use inline assembly to set the length of the `signature` to 0.\n * 2. Return the empty `signature`.\n *\n * @dev This function is marked as `internal pure`, meaning it can only be called internally and does not modify the state.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/MetadataReaderLib.sol": [
        {
            "identifier": "readName",
            "parameters": "address target, uint256 limit, uint256 gasStipend",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function readName(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x06fdde03), limit, gasStipend);\n    }",
            "start": "45",
            "end": "51",
            "class": "MetadataReaderLib",
            "signature": "returns (string memory) readNameaddress target, uint256 limit, uint256 gasStipend",
            "full_signature": "function readName(address target, uint256 limit, uint256 gasStipend) internal  view returns (string memory)",
            "class_method_signature": "MetadataReaderLib.readNameaddress target, uint256 limit, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads the name of a target contract using a low-level call with a specified gas stipend.\n *\n * @param target The address of the target contract from which to read the name.\n * @param limit The maximum number of bytes to read from the target contract.\n * @param gasStipend The amount of gas to stipend for the low-level call.\n * @return The name of the target contract as a string.\n *\n * Steps:\n * 1. Calls the internal `_string` function with the target address, the function selector for `name()` (0x06fdde03), \n *    the byte limit, and the gas stipend.\n * 2. Returns the name of the target contract as a string.\n */"
        },
        {
            "identifier": "readSymbol",
            "parameters": "address target, uint256 limit, uint256 gasStipend",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function readSymbol(address target, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(0x95d89b41), limit, gasStipend);\n    }",
            "start": "64",
            "end": "70",
            "class": "MetadataReaderLib",
            "signature": "returns (string memory) readSymboladdress target, uint256 limit, uint256 gasStipend",
            "full_signature": "function readSymbol(address target, uint256 limit, uint256 gasStipend) internal  view returns (string memory)",
            "class_method_signature": "MetadataReaderLib.readSymboladdress target, uint256 limit, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads the symbol of an ERC20 token from a target contract address.\n *\n * @param target The address of the target ERC20 token contract.\n * @param limit The maximum number of bytes to read from the target contract.\n * @param gasStipend The amount of gas to stipend for the call.\n *\n * @return The symbol of the ERC20 token as a string.\n *\n * Steps:\n * 1. Calls the internal `_string` function with the target address, the function selector for `symbol()` (0x95d89b41), the byte limit, and the gas stipend.\n * 2. Returns the symbol of the token as a string.\n */"
        },
        {
            "identifier": "readString",
            "parameters": "address target, bytes memory data, uint256 limit",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function readString(address target, bytes memory data, uint256 limit)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, GAS_STIPEND_NO_GRIEF);\n    }",
            "start": "80",
            "end": "86",
            "class": "MetadataReaderLib",
            "signature": "returns (string memory) readStringaddress target, bytes memory data, uint256 limit",
            "full_signature": "function readString(address target, bytes memory data, uint256 limit) internal  view returns (string memory)",
            "class_method_signature": "MetadataReaderLib.readStringaddress target, bytes memory data, uint256 limit",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads a string from a target contract using the provided data and gas limit.\n *\n * @param target The address of the target contract from which to read the string.\n * @param data The data to be passed to the target contract for the string read operation.\n * @param limit The maximum gas limit to be used for the read operation.\n * @return string memory The string read from the target contract.\n *\n * Steps:\n * 1. Calls the internal `_string` function with the target address, data pointer, gas limit, and a predefined gas stipend.\n * 2. Returns the string read from the target contract.\n */"
        },
        {
            "identifier": "readString",
            "parameters": "address target, bytes memory data, uint256 limit, uint256 gasStipend",
            "modifiers": "view",
            "return": "returns (string memory)",
            "body": "function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend)\n        internal\n        view\n        returns (string memory)\n    {\n        return _string(target, _ptr(data), limit, gasStipend);\n    }",
            "start": "90",
            "end": "96",
            "class": "MetadataReaderLib",
            "signature": "returns (string memory) readStringaddress target, bytes memory data, uint256 limit, uint256 gasStipend",
            "full_signature": "function readString(address target, bytes memory data, uint256 limit, uint256 gasStipend) internal  view returns (string memory)",
            "class_method_signature": "MetadataReaderLib.readStringaddress target, bytes memory data, uint256 limit, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads a string from a target contract using the provided data, gas limit, and gas stipend.\n *\n * @param target The address of the target contract from which to read the string.\n * @param data The data to be passed to the target contract for the read operation.\n * @param limit The maximum number of bytes to read from the target contract.\n * @param gasStipend The amount of gas to be provided for the read operation.\n *\n * @return string memory The string read from the target contract.\n *\n * Steps:\n * 1. Calls the internal `_string` function with the target address, data pointer, limit, and gas stipend.\n * 2. Returns the string retrieved from the target contract.\n */"
        },
        {
            "identifier": "readUint",
            "parameters": "address target, bytes memory data, uint256 gasStipend",
            "modifiers": "view",
            "return": "returns (uint256)",
            "body": "function readUint(address target, bytes memory data, uint256 gasStipend)\n        internal\n        view\n        returns (uint256)\n    {\n        return _uint(target, _ptr(data), gasStipend);\n    }",
            "start": "126",
            "end": "132",
            "class": "MetadataReaderLib",
            "signature": "returns (uint256) readUintaddress target, bytes memory data, uint256 gasStipend",
            "full_signature": "function readUint(address target, bytes memory data, uint256 gasStipend) internal  view returns (uint256)",
            "class_method_signature": "MetadataReaderLib.readUintaddress target, bytes memory data, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reads a `uint256` value from a target contract using the provided data and gas stipend.\n *\n * @param target The address of the target contract from which to read the `uint256` value.\n * @param data The encoded data to be sent to the target contract for the read operation.\n * @param gasStipend The amount of gas to be provided for the read operation.\n * @return The `uint256` value read from the target contract.\n *\n * Steps:\n * 1. Calls the internal `_uint` function with the target address, the pointer to the data, and the gas stipend.\n * 2. Returns the `uint256` value obtained from the target contract.\n */"
        },
        {
            "identifier": "_string",
            "parameters": "address target, bytes32 ptr, uint256 limit, uint256 gasStipend",
            "modifiers": "view",
            "return": "returns (string memory result)",
            "body": "function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend)\n        private\n        view\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function min(x_, y_) -> _z {\n                _z := xor(x_, mul(xor(x_, y_), lt(y_, x_)))\n            }\n            for {} staticcall(gasStipend, target, add(ptr, 0x20), mload(ptr), 0x00, 0x20) {} {\n                let m := mload(0x40) // Grab the free memory pointer.\n                let s := add(0x20, m) // Start of the string's bytes in memory.\n                // Attempt to `abi.decode` if the returndatasize is greater or equal to 64.\n                if iszero(lt(returndatasize(), 0x40)) {\n                    let o := mload(0x00) // Load the string's offset in the returndata.\n                    // If the string's offset is within bounds.\n                    if iszero(gt(o, sub(returndatasize(), 0x20))) {\n                        returndatacopy(m, o, 0x20) // Copy the string's length.\n                        // If the full string's end is within bounds.\n                        // Note: If the full string doesn't fit, the `abi.decode` must be aborted\n                        // for compliance purposes, regardless if the truncated string can fit.\n                        if iszero(gt(mload(m), sub(returndatasize(), add(o, 0x20)))) {\n                            let n := min(mload(m), limit) // Truncate if needed.\n                            mstore(m, n) // Overwrite the length.\n                            returndatacopy(s, add(o, 0x20), n) // Copy the string's bytes.\n                            mstore(add(s, n), 0) // Zeroize the slot after the string.\n                            mstore(0x40, add(0x20, add(s, n))) // Allocate memory for the string.\n                            result := m\n                            break\n                        }\n                    }\n                }\n                // Try interpreting as a null-terminated string.\n                let n := min(returndatasize(), limit) // Truncate if needed.\n                returndatacopy(s, 0, n) // Copy the string's bytes.\n                mstore8(add(s, n), 0) // Place a '\\0' at the end.\n                let i := s // Pointer to the next byte to scan.\n                for {} byte(0, mload(i)) { i := add(i, 1) } {} // Scan for '\\0'.\n                mstore(m, sub(i, s)) // Store the string's length.\n                mstore(i, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, i)) // Allocate memory for the string.\n                result := m\n                break\n            }\n        }\n    }",
            "start": "139",
            "end": "185",
            "class": "MetadataReaderLib",
            "signature": "returns (string memory result) _stringaddress target, bytes32 ptr, uint256 limit, uint256 gasStipend",
            "full_signature": "function _string(address target, bytes32 ptr, uint256 limit, uint256 gasStipend) private  view returns (string memory result)",
            "class_method_signature": "MetadataReaderLib._stringaddress target, bytes32 ptr, uint256 limit, uint256 gasStipend",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A private view function that retrieves a string from a target contract using low-level assembly.\n *\n * @param target The address of the target contract to call.\n * @param ptr A pointer to the data to be passed to the target contract.\n * @param limit The maximum length of the string to be returned.\n * @param gasStipend The amount of gas to be provided for the static call.\n * @return result The resulting string retrieved from the target contract.\n *\n * Steps:\n * 1. Perform a static call to the target contract with the provided gas stipend and data pointer.\n * 2. Check if the returndata size is sufficient (>= 64 bytes) to attempt ABI decoding.\n * 3. If the string's offset is within bounds, copy the string's length and bytes from returndata.\n * 4. Truncate the string if it exceeds the specified limit.\n * 5. Allocate memory for the string and store it in the result.\n * 6. If ABI decoding fails, interpret the returndata as a null-terminated string.\n * 7. Copy the string's bytes, place a null terminator, and calculate the string's length.\n * 8. Allocate memory for the string and store it in the result.\n *\n * Notes:\n * - The function uses low-level assembly for memory-safe operations.\n * - The function ensures compliance by aborting if the full string cannot be safely decoded.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/MinHeapLib.sol": [
        {
            "identifier": "root",
            "parameters": "Heap storage heap",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function root(Heap storage heap) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(sload(heap.slot)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x00, heap.slot)\n            result := sload(keccak256(0x00, 0x20))\n        }\n    }",
            "start": "40",
            "end": "50",
            "class": "MinHeapLib",
            "signature": "returns (uint256 result) rootHeap storage heap",
            "full_signature": "function root(Heap storage heap) internal  view returns (uint256 result)",
            "class_method_signature": "MinHeapLib.rootHeap storage heap",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the root element of the heap.\n * @dev This function uses low-level assembly to interact with storage directly.\n *      It checks if the heap is empty and reverts with a custom error if it is.\n *      Otherwise, it retrieves and returns the root element of the heap.\n *\n * @param heap The heap storage reference from which to retrieve the root element.\n * @return result The root element of the heap.\n *\n * Steps:\n * 1. Check if the heap is empty by verifying if the slot is zero.\n *    - If the heap is empty, revert with a custom error `HeapIsEmpty()`.\n * 2. If the heap is not empty, compute the storage slot for the root element.\n * 3. Load and return the root element from the computed storage slot.\n */"
        },
        {
            "identifier": "root",
            "parameters": "MemHeap memory heap",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function root(MemHeap memory heap) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(heap)\n            if iszero(mload(result)) {\n                mstore(0x00, 0xa6ca772e) // `HeapIsEmpty()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(add(0x20, result))\n        }\n    }",
            "start": "54",
            "end": "64",
            "class": "MinHeapLib",
            "signature": "returns (uint256 result) rootMemHeap memory heap",
            "full_signature": "function root(MemHeap memory heap) internal  pure returns (uint256 result)",
            "class_method_signature": "MinHeapLib.rootMemHeap memory heap",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the root value from a memory heap.\n *\n * @dev This function reads the root value from the provided `MemHeap` structure.\n *      If the heap is empty, it reverts with the error `HeapIsEmpty()`.\n *\n * @param heap The memory heap structure from which to retrieve the root value.\n * @return result The root value stored in the heap.\n *\n * Steps:\n * 1. Load the root value from the heap.\n * 2. Check if the heap is empty by verifying if the root value is zero.\n *    - If the heap is empty, revert with the error `HeapIsEmpty()`.\n * 3. Return the root value.\n */"
        },
        {
            "identifier": "reserve",
            "parameters": "MemHeap memory heap, uint256 minimum",
            "modifiers": "pure",
            "return": "",
            "body": "function reserve(MemHeap memory heap, uint256 minimum) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let prime := 204053801631428327883786711931463459222251954273621\n            let cap := not(mload(add(mload(heap), w)))\n            if gt(minimum, mul(iszero(mod(cap, prime)), div(cap, prime))) {\n                let data := mload(heap)\n                let n := mload(data)\n                let newCap := and(add(minimum, 0x1f), w) // Round up to multiple of 32.\n                mstore(mload(0x40), not(mul(newCap, prime)))\n                let m := add(mload(0x40), 0x20)\n                mstore(m, n) // Store the length.\n                mstore(0x40, add(add(m, 0x20), shl(5, newCap))) // Allocate `heap.data` memory.\n                mstore(heap, m) // Update `heap.data`.\n                if n {\n                    for { let i := shl(5, n) } 1 {} {\n                        mstore(add(m, i), mload(add(data, i)))\n                        i := add(i, w)\n                        if iszero(i) { break }\n                    }\n                }\n            }\n        }\n    }",
            "start": "68",
            "end": "92",
            "class": "MinHeapLib",
            "signature": " reserveMemHeap memory heap, uint256 minimum",
            "full_signature": "function reserve(MemHeap memory heap, uint256 minimum) internal  pure",
            "class_method_signature": "MinHeapLib.reserveMemHeap memory heap, uint256 minimum",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Reserves memory for the heap and ensures it has a minimum capacity.\n * \n * @param heap The memory heap structure to reserve memory for.\n * @param minimum The minimum required capacity for the heap.\n *\n * Steps:\n * 1. Calculate the current capacity of the heap.\n * 2. Check if the current capacity is insufficient for the minimum requirement.\n * 3. If insufficient, allocate new memory with the required capacity.\n * 4. Copy existing data from the old heap to the newly allocated memory.\n * 5. Update the heap's data pointer to point to the new memory location.\n *\n * Assembly Details:\n * - Uses low-level assembly for memory manipulation.\n * - Ensures memory safety by rounding up to the nearest multiple of 32.\n * - Uses a prime number for capacity calculations to avoid collisions.\n * - Copies data from the old heap to the new heap if data exists.\n */"
        },
        {
            "identifier": "smallest",
            "parameters": "Heap storage heap, uint256 k",
            "modifiers": "view",
            "return": "returns (uint256[] memory a)",
            "body": "function smallest(Heap storage heap, uint256 k) internal view returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            mstore(0x00, heap.slot)\n            let sOffset := keccak256(0x00, 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := sload(heap.slot) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, sload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, sload(add(sOffset, childPos)))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, sload(add(sOffset, childPos)))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }",
            "start": "97",
            "end": "156",
            "class": "MinHeapLib",
            "signature": "returns (uint256[] memory a) smallestHeap storage heap, uint256 k",
            "full_signature": "function smallest(Heap storage heap, uint256 k) internal  view returns (uint256[] memory a)",
            "class_method_signature": "MinHeapLib.smallestHeap storage heap, uint256 k",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the smallest `k` elements from a heap data structure.\n *\n * @dev This function uses inline assembly to efficiently manipulate the heap and retrieve the smallest elements.\n * It implements a priority queue to manage the heap and uses sift-up and sift-down operations to maintain the heap property.\n *\n * @param heap The heap storage reference from which to retrieve the smallest elements.\n * @param k The number of smallest elements to retrieve.\n * @return a An array containing the smallest `k` elements from the heap.\n *\n * Steps:\n * 1. Define helper functions for heap operations:\n *    - `pIndex`: Retrieves the index of a heap element.\n *    - `pValue`: Retrieves the value of a heap element.\n *    - `pSet`: Sets the value and index of a heap element.\n *    - `pSiftdown`: Performs a sift-down operation to maintain the heap property.\n *    - `pSiftup`: Performs a sift-up operation to maintain the heap property.\n *\n * 2. Initialize memory for the result array `a`.\n * 3. Calculate the storage offset for the heap.\n * 4. Determine the number of elements to retrieve (`m`), which is the minimum of `k` and the heap size.\n * 5. Initialize a priority queue (`h`) to manage the heap elements.\n * 6. Store the root element of the heap in the priority queue.\n * 7. Iterate through the heap:\n *    - Extract the smallest element from the priority queue and store it in the result array.\n *    - Update the priority queue by sifting up or down based on the heap structure.\n * 8. Store the length of the result array and allocate memory for it.\n */"
        },
        {
            "identifier": "smallest",
            "parameters": "MemHeap memory heap, uint256 k",
            "modifiers": "pure",
            "return": "returns (uint256[] memory a)",
            "body": "function smallest(MemHeap memory heap, uint256 k) internal pure returns (uint256[] memory a) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function pIndex(h_, p_) -> _i {\n                _i := mload(add(0x20, add(h_, shl(6, p_))))\n            }\n            function pValue(h_, p_) -> _v {\n                _v := mload(add(h_, shl(6, p_)))\n            }\n            function pSet(h_, p_, i_, v_) {\n                mstore(add(h_, shl(6, p_)), v_)\n                mstore(add(0x20, add(h_, shl(6, p_))), i_)\n            }\n            function pSiftdown(h_, p_, i_, v_) {\n                for {} 1 {} {\n                    let u_ := shr(1, sub(p_, 1))\n                    if iszero(mul(p_, lt(v_, pValue(h_, u_)))) { break }\n                    pSet(h_, p_, pIndex(h_, u_), pValue(h_, u_))\n                    p_ := u_\n                }\n                pSet(h_, p_, i_, v_)\n            }\n            function pSiftup(h_, e_, i_, v_) {\n                let p_ := 0\n                for { let c_ := 1 } lt(c_, e_) { c_ := add(1, shl(1, p_)) } {\n                    c_ := add(c_, gt(pValue(h_, c_), pValue(h_, add(c_, lt(add(c_, 1), e_)))))\n                    pSet(h_, p_, pIndex(h_, c_), pValue(h_, c_))\n                    p_ := c_\n                }\n                pSiftdown(h_, p_, i_, v_)\n            }\n            a := mload(0x40)\n            let sOffset := add(mload(heap), 0x20)\n            let o := add(a, 0x20) // Offset into `a`.\n            let n := mload(mload(heap)) // The number of items in the heap.\n            let m := xor(n, mul(xor(n, k), lt(k, n))) // `min(k, n)`.\n            let h := add(o, shl(5, m)) // Priority queue.\n            pSet(h, 0, 0, mload(sOffset)) // Store the root into the priority queue.\n            for { let e := iszero(eq(o, h)) } e {} {\n                mstore(o, pValue(h, 0))\n                o := add(0x20, o)\n                if eq(o, h) { break }\n                let childPos := add(shl(1, pIndex(h, 0)), 1)\n                if iszero(lt(childPos, n)) {\n                    e := sub(e, 1)\n                    pSiftup(h, e, pIndex(h, e), pValue(h, e))\n                    continue\n                }\n                pSiftup(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                childPos := add(1, childPos)\n                if iszero(eq(childPos, n)) {\n                    pSiftdown(h, e, childPos, mload(add(sOffset, shl(5, childPos))))\n                    e := add(e, 1)\n                }\n            }\n            mstore(a, shr(5, sub(o, add(a, 0x20)))) // Store the length.\n            mstore(0x40, o) // Allocate memory.\n        }\n    }",
            "start": "161",
            "end": "219",
            "class": "MinHeapLib",
            "signature": "returns (uint256[] memory a) smallestMemHeap memory heap, uint256 k",
            "full_signature": "function smallest(MemHeap memory heap, uint256 k) internal  pure returns (uint256[] memory a)",
            "class_method_signature": "MinHeapLib.smallestMemHeap memory heap, uint256 k",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Finds the smallest `k` elements in a min-heap using an internal assembly implementation.\n *\n * @param heap The memory heap structure containing the data to process.\n * @param k The number of smallest elements to retrieve.\n * @return a An array containing the smallest `k` elements from the heap.\n *\n * Steps:\n * 1. Define helper functions for heap operations:\n *    - `pIndex`: Retrieves the index of a heap element.\n *    - `pValue`: Retrieves the value of a heap element.\n *    - `pSet`: Sets the value and index of a heap element.\n *    - `pSiftdown`: Adjusts the heap structure by moving an element down.\n *    - `pSiftup`: Adjusts the heap structure by moving an element up.\n *\n * 2. Initialize memory pointers and variables:\n *    - Allocate memory for the result array `a`.\n *    - Calculate offsets and sizes for heap traversal.\n *    - Determine the minimum of `k` and the heap size `n`.\n *\n * 3. Build and maintain a priority queue:\n *    - Store the root element of the heap in the priority queue.\n *    - Iterate through the heap to extract the smallest `k` elements:\n *      - Move elements up or down in the heap as needed.\n *      - Update the priority queue with the smallest elements.\n *\n * 4. Store the result and update memory allocation:\n *    - Store the length of the result array.\n *    - Allocate memory for the result array.\n *\n * Note: This function uses low-level assembly for efficient heap manipulation.\n */"
        },
        {
            "identifier": "enqueue",
            "parameters": "Heap storage heap, uint256 value, uint256 maxLength",
            "modifiers": "",
            "return": "returns (bool success, bool hasPopped, uint256 popped)",
            "body": "function enqueue(Heap storage heap, uint256 value, uint256 maxLength)\n        internal\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }",
            "start": "288",
            "end": "298",
            "class": "MinHeapLib",
            "signature": "returns (bool success, bool hasPopped, uint256 popped) enqueueHeap storage heap, uint256 value, uint256 maxLength",
            "full_signature": "function enqueue(Heap storage heap, uint256 value, uint256 maxLength) internal   returns (bool success, bool hasPopped, uint256 popped)",
            "class_method_signature": "MinHeapLib.enqueueHeap storage heap, uint256 value, uint256 maxLength",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Enqueues a value into a heap storage structure, ensuring it does not exceed the maximum length.\n *\n * @param heap The heap storage structure where the value will be enqueued.\n * @param value The value to be enqueued into the heap.\n * @param maxLength The maximum allowed length of the heap.\n *\n * @return success A boolean indicating whether the enqueue operation was successful.\n * @return hasPopped A boolean indicating whether an element was popped from the heap during the operation.\n * @return popped The value that was popped from the heap (if any).\n *\n * Steps:\n * 1. Call the internal `_set` function to handle the insertion of the value into the heap, ensuring it does not exceed the maximum length.\n * 2. Use inline assembly to check if an element was popped (`hasPopped`) and whether the operation was successful (`success`).\n * 3. Return the results of the operation, including whether an element was popped and its value.\n */"
        },
        {
            "identifier": "enqueue",
            "parameters": "MemHeap memory heap, uint256 value, uint256 maxLength",
            "modifiers": "pure",
            "return": "returns (bool success, bool hasPopped, uint256 popped)",
            "body": "function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength)\n        internal\n        pure\n        returns (bool success, bool hasPopped, uint256 popped)\n    {\n        (value, popped) = _set(heap, value, maxLength, 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            hasPopped := eq(3, value)\n            success := value\n        }\n    }",
            "start": "313",
            "end": "324",
            "class": "MinHeapLib",
            "signature": "returns (bool success, bool hasPopped, uint256 popped) enqueueMemHeap memory heap, uint256 value, uint256 maxLength",
            "full_signature": "function enqueue(MemHeap memory heap, uint256 value, uint256 maxLength) internal  pure returns (bool success, bool hasPopped, uint256 popped)",
            "class_method_signature": "MinHeapLib.enqueueMemHeap memory heap, uint256 value, uint256 maxLength",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Enqueues a value into a memory heap, ensuring the heap does not exceed a specified maximum length.\n *\n * @param heap The memory heap structure where the value will be enqueued.\n * @param value The value to be enqueued into the heap.\n * @param maxLength The maximum allowed length of the heap.\n *\n * @return success A boolean indicating whether the enqueue operation was successful.\n * @return hasPopped A boolean indicating whether an element was popped from the heap during the operation.\n * @return popped The value that was popped from the heap (if any).\n *\n * Steps:\n * 1. Call the internal `_set` function to attempt to enqueue the value into the heap.\n *    - The `_set` function returns a modified value and a popped value (if applicable).\n * 2. Use inline assembly to determine:\n *    - `hasPopped`: Whether an element was popped (indicated by the modified value being 3).\n *    - `success`: Whether the enqueue operation was successful (indicated by the modified value).\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/SafeCastLib.sol": [
        {
            "identifier": "toUint8",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint8)",
            "body": "function toUint8(uint256 x) internal pure returns (uint8) {\n        if (x >= 1 << 8) _revertOverflow();\n        return uint8(x);\n    }",
            "start": "19",
            "end": "22",
            "class": "SafeCastLib",
            "signature": "returns (uint8) toUint8uint256 x",
            "full_signature": "function toUint8(uint256 x) internal  pure returns (uint8)",
            "class_method_signature": "SafeCastLib.toUint8uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint8 value, reverting if the value exceeds the uint8 range.\n *\n * @param x The uint256 value to be converted.\n * @return uint8 The converted uint8 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^8 (256), which is the maximum value for uint8.\n * 2. If the value exceeds the uint8 range, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint8 and return it.\n */"
        },
        {
            "identifier": "toUint16",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint16)",
            "body": "function toUint16(uint256 x) internal pure returns (uint16) {\n        if (x >= 1 << 16) _revertOverflow();\n        return uint16(x);\n    }",
            "start": "24",
            "end": "27",
            "class": "SafeCastLib",
            "signature": "returns (uint16) toUint16uint256 x",
            "full_signature": "function toUint16(uint256 x) internal  pure returns (uint16)",
            "class_method_signature": "SafeCastLib.toUint16uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint16 value, reverting if the value exceeds the uint16 range.\n *\n * @param x The uint256 value to be converted.\n * @return uint16 The converted uint16 value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by a uint16 (2^16 - 1).\n * 2. If the value exceeds the range, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as a uint16.\n */"
        },
        {
            "identifier": "toUint24",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint24)",
            "body": "function toUint24(uint256 x) internal pure returns (uint24) {\n        if (x >= 1 << 24) _revertOverflow();\n        return uint24(x);\n    }",
            "start": "29",
            "end": "32",
            "class": "SafeCastLib",
            "signature": "returns (uint24) toUint24uint256 x",
            "full_signature": "function toUint24(uint256 x) internal  pure returns (uint24)",
            "class_method_signature": "SafeCastLib.toUint24uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint24 value, reverting if the value exceeds the uint24 range.\n *\n * @param x The uint256 value to be converted.\n * @return uint24 The converted uint24 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^24 (the maximum value for uint24).\n * 2. If the value exceeds the uint24 range, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint24 and return it.\n */"
        },
        {
            "identifier": "toUint32",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint32)",
            "body": "function toUint32(uint256 x) internal pure returns (uint32) {\n        if (x >= 1 << 32) _revertOverflow();\n        return uint32(x);\n    }",
            "start": "34",
            "end": "37",
            "class": "SafeCastLib",
            "signature": "returns (uint32) toUint32uint256 x",
            "full_signature": "function toUint32(uint256 x) internal  pure returns (uint32)",
            "class_method_signature": "SafeCastLib.toUint32uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint32 value, reverting if the value exceeds the uint32 range.\n *\n * @param x The uint256 value to be converted.\n * @return uint32 The converted uint32 value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by a uint32 (2^32 - 1).\n * 2. If the value exceeds the range, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint32 and return it.\n */"
        },
        {
            "identifier": "toUint40",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint40)",
            "body": "function toUint40(uint256 x) internal pure returns (uint40) {\n        if (x >= 1 << 40) _revertOverflow();\n        return uint40(x);\n    }",
            "start": "39",
            "end": "42",
            "class": "SafeCastLib",
            "signature": "returns (uint40) toUint40uint256 x",
            "full_signature": "function toUint40(uint256 x) internal  pure returns (uint40)",
            "class_method_signature": "SafeCastLib.toUint40uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint40 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to uint40.\n * @return uint40 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^40 (1 << 40).\n * 2. If the value is too large, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint40 and return it.\n */"
        },
        {
            "identifier": "toUint48",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint48)",
            "body": "function toUint48(uint256 x) internal pure returns (uint48) {\n        if (x >= 1 << 48) _revertOverflow();\n        return uint48(x);\n    }",
            "start": "44",
            "end": "47",
            "class": "SafeCastLib",
            "signature": "returns (uint48) toUint48uint256 x",
            "full_signature": "function toUint48(uint256 x) internal  pure returns (uint48)",
            "class_method_signature": "SafeCastLib.toUint48uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint48 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint48 The converted uint48 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^48 (the maximum value for uint48).\n * 2. If the value is too large, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint48 and return it.\n */"
        },
        {
            "identifier": "toUint56",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint56)",
            "body": "function toUint56(uint256 x) internal pure returns (uint56) {\n        if (x >= 1 << 56) _revertOverflow();\n        return uint56(x);\n    }",
            "start": "49",
            "end": "52",
            "class": "SafeCastLib",
            "signature": "returns (uint56) toUint56uint256 x",
            "full_signature": "function toUint56(uint256 x) internal  pure returns (uint56)",
            "class_method_signature": "SafeCastLib.toUint56uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint56 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint56 The converted uint56 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^56 (1 << 56).\n * 2. If the check passes, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint56 and return it.\n */"
        },
        {
            "identifier": "toUint64",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint64)",
            "body": "function toUint64(uint256 x) internal pure returns (uint64) {\n        if (x >= 1 << 64) _revertOverflow();\n        return uint64(x);\n    }",
            "start": "54",
            "end": "57",
            "class": "SafeCastLib",
            "signature": "returns (uint64) toUint64uint256 x",
            "full_signature": "function toUint64(uint256 x) internal  pure returns (uint64)",
            "class_method_signature": "SafeCastLib.toUint64uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint64, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint64 The converted uint64 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^64 (the maximum value for uint64).\n * 2. If the value exceeds the uint64 range, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint64.\n */"
        },
        {
            "identifier": "toUint72",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint72)",
            "body": "function toUint72(uint256 x) internal pure returns (uint72) {\n        if (x >= 1 << 72) _revertOverflow();\n        return uint72(x);\n    }",
            "start": "59",
            "end": "62",
            "class": "SafeCastLib",
            "signature": "returns (uint72) toUint72uint256 x",
            "full_signature": "function toUint72(uint256 x) internal  pure returns (uint72)",
            "class_method_signature": "SafeCastLib.toUint72uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint72 value, reverting if the input exceeds the uint72 range.\n *\n * @param x The uint256 value to be converted.\n * @return uint72 The converted uint72 value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by a uint72 (2^72 - 1).\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint72 and return it.\n */"
        },
        {
            "identifier": "toUint80",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint80)",
            "body": "function toUint80(uint256 x) internal pure returns (uint80) {\n        if (x >= 1 << 80) _revertOverflow();\n        return uint80(x);\n    }",
            "start": "64",
            "end": "67",
            "class": "SafeCastLib",
            "signature": "returns (uint80) toUint80uint256 x",
            "full_signature": "function toUint80(uint256 x) internal  pure returns (uint80)",
            "class_method_signature": "SafeCastLib.toUint80uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint80, ensuring it does not overflow.\n *\n * @param x The uint256 value to be converted.\n * @return uint80 The converted uint80 value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by a uint80.\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint80.\n */"
        },
        {
            "identifier": "toUint88",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint88)",
            "body": "function toUint88(uint256 x) internal pure returns (uint88) {\n        if (x >= 1 << 88) _revertOverflow();\n        return uint88(x);\n    }",
            "start": "69",
            "end": "72",
            "class": "SafeCastLib",
            "signature": "returns (uint88) toUint88uint256 x",
            "full_signature": "function toUint88(uint256 x) internal  pure returns (uint88)",
            "class_method_signature": "SafeCastLib.toUint88uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint88, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint88 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^88.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint88 and return it.\n */"
        },
        {
            "identifier": "toUint96",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint96)",
            "body": "function toUint96(uint256 x) internal pure returns (uint96) {\n        if (x >= 1 << 96) _revertOverflow();\n        return uint96(x);\n    }",
            "start": "74",
            "end": "77",
            "class": "SafeCastLib",
            "signature": "returns (uint96) toUint96uint256 x",
            "full_signature": "function toUint96(uint256 x) internal  pure returns (uint96)",
            "class_method_signature": "SafeCastLib.toUint96uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint96, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint96 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^96.\n * 2. If it is, revert with an overflow error.\n * 3. Otherwise, safely cast the value to uint96 and return it.\n */"
        },
        {
            "identifier": "toUint104",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint104)",
            "body": "function toUint104(uint256 x) internal pure returns (uint104) {\n        if (x >= 1 << 104) _revertOverflow();\n        return uint104(x);\n    }",
            "start": "79",
            "end": "82",
            "class": "SafeCastLib",
            "signature": "returns (uint104) toUint104uint256 x",
            "full_signature": "function toUint104(uint256 x) internal  pure returns (uint104)",
            "class_method_signature": "SafeCastLib.toUint104uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Safely converts a uint256 value to uint104, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint104 The converted value, if it fits within the uint104 range.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by uint104 (2^104 - 1).\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint104 and return the result.\n */ "
        },
        {
            "identifier": "toUint112",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint112)",
            "body": "function toUint112(uint256 x) internal pure returns (uint112) {\n        if (x >= 1 << 112) _revertOverflow();\n        return uint112(x);\n    }",
            "start": "84",
            "end": "87",
            "class": "SafeCastLib",
            "signature": "returns (uint112) toUint112uint256 x",
            "full_signature": "function toUint112(uint256 x) internal  pure returns (uint112)",
            "class_method_signature": "SafeCastLib.toUint112uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint112, ensuring it does not overflow.\n *\n * @param x The uint256 value to be converted.\n * @return uint112 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^112.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint112 and return it.\n */"
        },
        {
            "identifier": "toUint120",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint120)",
            "body": "function toUint120(uint256 x) internal pure returns (uint120) {\n        if (x >= 1 << 120) _revertOverflow();\n        return uint120(x);\n    }",
            "start": "89",
            "end": "92",
            "class": "SafeCastLib",
            "signature": "returns (uint120) toUint120uint256 x",
            "full_signature": "function toUint120(uint256 x) internal  pure returns (uint120)",
            "class_method_signature": "SafeCastLib.toUint120uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint120, reverting if the value exceeds the uint120 range.\n *\n * @param x The uint256 value to be converted.\n * @return uint120 The converted uint120 value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by uint120 (2^120 - 1).\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint120 and return it.\n */"
        },
        {
            "identifier": "toUint128",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint128)",
            "body": "function toUint128(uint256 x) internal pure returns (uint128) {\n        if (x >= 1 << 128) _revertOverflow();\n        return uint128(x);\n    }",
            "start": "94",
            "end": "97",
            "class": "SafeCastLib",
            "signature": "returns (uint128) toUint128uint256 x",
            "full_signature": "function toUint128(uint256 x) internal  pure returns (uint128)",
            "class_method_signature": "SafeCastLib.toUint128uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint128, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint128 The converted uint128 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^128.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint128 and return the result.\n */"
        },
        {
            "identifier": "toUint136",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint136)",
            "body": "function toUint136(uint256 x) internal pure returns (uint136) {\n        if (x >= 1 << 136) _revertOverflow();\n        return uint136(x);\n    }",
            "start": "99",
            "end": "102",
            "class": "SafeCastLib",
            "signature": "returns (uint136) toUint136uint256 x",
            "full_signature": "function toUint136(uint256 x) internal  pure returns (uint136)",
            "class_method_signature": "SafeCastLib.toUint136uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint136, ensuring it does not overflow.\n *\n * @param x The uint256 value to be converted.\n * @return uint136 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^136.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint136.\n */"
        },
        {
            "identifier": "toUint144",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint144)",
            "body": "function toUint144(uint256 x) internal pure returns (uint144) {\n        if (x >= 1 << 144) _revertOverflow();\n        return uint144(x);\n    }",
            "start": "104",
            "end": "107",
            "class": "SafeCastLib",
            "signature": "returns (uint144) toUint144uint256 x",
            "full_signature": "function toUint144(uint256 x) internal  pure returns (uint144)",
            "class_method_signature": "SafeCastLib.toUint144uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint144 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint144 The converted uint144 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^144.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint144.\n */"
        },
        {
            "identifier": "toUint152",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint152)",
            "body": "function toUint152(uint256 x) internal pure returns (uint152) {\n        if (x >= 1 << 152) _revertOverflow();\n        return uint152(x);\n    }",
            "start": "109",
            "end": "112",
            "class": "SafeCastLib",
            "signature": "returns (uint152) toUint152uint256 x",
            "full_signature": "function toUint152(uint256 x) internal  pure returns (uint152)",
            "class_method_signature": "SafeCastLib.toUint152uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint152, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint152 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by uint152 (i.e., 2^152 - 1).\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint152.\n */"
        },
        {
            "identifier": "toUint160",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint160)",
            "body": "function toUint160(uint256 x) internal pure returns (uint160) {\n        if (x >= 1 << 160) _revertOverflow();\n        return uint160(x);\n    }",
            "start": "114",
            "end": "117",
            "class": "SafeCastLib",
            "signature": "returns (uint160) toUint160uint256 x",
            "full_signature": "function toUint160(uint256 x) internal  pure returns (uint160)",
            "class_method_signature": "SafeCastLib.toUint160uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint160, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint160 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^160 (the maximum value for uint160).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint160 and return it.\n */"
        },
        {
            "identifier": "toUint168",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint168)",
            "body": "function toUint168(uint256 x) internal pure returns (uint168) {\n        if (x >= 1 << 168) _revertOverflow();\n        return uint168(x);\n    }",
            "start": "119",
            "end": "122",
            "class": "SafeCastLib",
            "signature": "returns (uint168) toUint168uint256 x",
            "full_signature": "function toUint168(uint256 x) internal  pure returns (uint168)",
            "class_method_signature": "SafeCastLib.toUint168uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint168, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint168 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by a uint168.\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint168.\n */"
        },
        {
            "identifier": "toUint176",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint176)",
            "body": "function toUint176(uint256 x) internal pure returns (uint176) {\n        if (x >= 1 << 176) _revertOverflow();\n        return uint176(x);\n    }",
            "start": "124",
            "end": "127",
            "class": "SafeCastLib",
            "signature": "returns (uint176) toUint176uint256 x",
            "full_signature": "function toUint176(uint256 x) internal  pure returns (uint176)",
            "class_method_signature": "SafeCastLib.toUint176uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint176, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint176 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^176.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint176 and return it.\n */"
        },
        {
            "identifier": "toUint184",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint184)",
            "body": "function toUint184(uint256 x) internal pure returns (uint184) {\n        if (x >= 1 << 184) _revertOverflow();\n        return uint184(x);\n    }",
            "start": "129",
            "end": "132",
            "class": "SafeCastLib",
            "signature": "returns (uint184) toUint184uint256 x",
            "full_signature": "function toUint184(uint256 x) internal  pure returns (uint184)",
            "class_method_signature": "SafeCastLib.toUint184uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint184, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint184 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^184.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint184 and return the result.\n */"
        },
        {
            "identifier": "toUint192",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint192)",
            "body": "function toUint192(uint256 x) internal pure returns (uint192) {\n        if (x >= 1 << 192) _revertOverflow();\n        return uint192(x);\n    }",
            "start": "134",
            "end": "137",
            "class": "SafeCastLib",
            "signature": "returns (uint192) toUint192uint256 x",
            "full_signature": "function toUint192(uint256 x) internal  pure returns (uint192)",
            "class_method_signature": "SafeCastLib.toUint192uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint192 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint192 The converted uint192 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^192.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint192 and return the result.\n */"
        },
        {
            "identifier": "toUint200",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint200)",
            "body": "function toUint200(uint256 x) internal pure returns (uint200) {\n        if (x >= 1 << 200) _revertOverflow();\n        return uint200(x);\n    }",
            "start": "139",
            "end": "142",
            "class": "SafeCastLib",
            "signature": "returns (uint200) toUint200uint256 x",
            "full_signature": "function toUint200(uint256 x) internal  pure returns (uint200)",
            "class_method_signature": "SafeCastLib.toUint200uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint200, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint200 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^200.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint200.\n */"
        },
        {
            "identifier": "toUint208",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint208)",
            "body": "function toUint208(uint256 x) internal pure returns (uint208) {\n        if (x >= 1 << 208) _revertOverflow();\n        return uint208(x);\n    }",
            "start": "144",
            "end": "147",
            "class": "SafeCastLib",
            "signature": "returns (uint208) toUint208uint256 x",
            "full_signature": "function toUint208(uint256 x) internal  pure returns (uint208)",
            "class_method_signature": "SafeCastLib.toUint208uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint208, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint208 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^208.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint208 and return the result.\n */"
        },
        {
            "identifier": "toUint216",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint216)",
            "body": "function toUint216(uint256 x) internal pure returns (uint216) {\n        if (x >= 1 << 216) _revertOverflow();\n        return uint216(x);\n    }",
            "start": "149",
            "end": "152",
            "class": "SafeCastLib",
            "signature": "returns (uint216) toUint216uint256 x",
            "full_signature": "function toUint216(uint256 x) internal  pure returns (uint216)",
            "class_method_signature": "SafeCastLib.toUint216uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint216, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint216 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^216.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint216 and return the result.\n */"
        },
        {
            "identifier": "toUint224",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint224)",
            "body": "function toUint224(uint256 x) internal pure returns (uint224) {\n        if (x >= 1 << 224) _revertOverflow();\n        return uint224(x);\n    }",
            "start": "154",
            "end": "157",
            "class": "SafeCastLib",
            "signature": "returns (uint224) toUint224uint256 x",
            "full_signature": "function toUint224(uint256 x) internal  pure returns (uint224)",
            "class_method_signature": "SafeCastLib.toUint224uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint224, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint224 The converted uint224 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^224.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint224.\n */"
        },
        {
            "identifier": "toUint232",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint232)",
            "body": "function toUint232(uint256 x) internal pure returns (uint232) {\n        if (x >= 1 << 232) _revertOverflow();\n        return uint232(x);\n    }",
            "start": "159",
            "end": "162",
            "class": "SafeCastLib",
            "signature": "returns (uint232) toUint232uint256 x",
            "full_signature": "function toUint232(uint256 x) internal  pure returns (uint232)",
            "class_method_signature": "SafeCastLib.toUint232uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to a uint232 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint232 The converted uint232 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^232.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast `x` to uint232 and return the result.\n */"
        },
        {
            "identifier": "toUint240",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint240)",
            "body": "function toUint240(uint256 x) internal pure returns (uint240) {\n        if (x >= 1 << 240) _revertOverflow();\n        return uint240(x);\n    }",
            "start": "164",
            "end": "167",
            "class": "SafeCastLib",
            "signature": "returns (uint240) toUint240uint256 x",
            "full_signature": "function toUint240(uint256 x) internal  pure returns (uint240)",
            "class_method_signature": "SafeCastLib.toUint240uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint240, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint240 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum value that can be represented by uint240 (i.e., 2^240 - 1).\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to uint240 and return it.\n */"
        },
        {
            "identifier": "toUint248",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint248)",
            "body": "function toUint248(uint256 x) internal pure returns (uint248) {\n        if (x >= 1 << 248) _revertOverflow();\n        return uint248(x);\n    }",
            "start": "169",
            "end": "172",
            "class": "SafeCastLib",
            "signature": "returns (uint248) toUint248uint256 x",
            "full_signature": "function toUint248(uint256 x) internal  pure returns (uint248)",
            "class_method_signature": "SafeCastLib.toUint248uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to uint248, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return uint248 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^248.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast and return the value as uint248.\n */"
        },
        {
            "identifier": "toInt8",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int8)",
            "body": "function toInt8(int256 x) internal pure returns (int8) {\n        unchecked {\n            if (((1 << 7) + uint256(x)) >> 8 == uint256(0)) return int8(x);\n            _revertOverflow();\n        }\n    }",
            "start": "178",
            "end": "183",
            "class": "SafeCastLib",
            "signature": "returns (int8) toInt8int256 x",
            "full_signature": "function toInt8(int256 x) internal  pure returns (int8)",
            "class_method_signature": "SafeCastLib.toInt8int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit integer to an 8-bit integer, checking for overflow.\n *\n * @param x The 256-bit integer to be converted.\n * @return int8 The resulting 8-bit integer.\n *\n * Steps:\n * 1. Check if the value of `x` can fit within an 8-bit integer by verifying that the upper bits are zero.\n * 2. If the value fits, return the 8-bit integer representation of `x`.\n * 3. If the value does not fit, revert with an overflow error.\n *\n * @dev This function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt16",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int16)",
            "body": "function toInt16(int256 x) internal pure returns (int16) {\n        unchecked {\n            if (((1 << 15) + uint256(x)) >> 16 == uint256(0)) return int16(x);\n            _revertOverflow();\n        }\n    }",
            "start": "185",
            "end": "190",
            "class": "SafeCastLib",
            "signature": "returns (int16) toInt16int256 x",
            "full_signature": "function toInt16(int256 x) internal  pure returns (int16)",
            "class_method_signature": "SafeCastLib.toInt16int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit integer to a 16-bit integer, reverting on overflow.\n *\n * @param x The 256-bit integer to be converted.\n * @return int16 The resulting 16-bit integer.\n *\n * Steps:\n * 1. Check if the value of `x` can be safely represented as a 16-bit integer.\n * 2. If the value is within the valid range, return the 16-bit integer.\n * 3. If the value is out of range, revert with an overflow error.\n *\n * @dev The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt24",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int24)",
            "body": "function toInt24(int256 x) internal pure returns (int24) {\n        unchecked {\n            if (((1 << 23) + uint256(x)) >> 24 == uint256(0)) return int24(x);\n            _revertOverflow();\n        }\n    }",
            "start": "192",
            "end": "197",
            "class": "SafeCastLib",
            "signature": "returns (int24) toInt24int256 x",
            "full_signature": "function toInt24(int256 x) internal  pure returns (int24)",
            "class_method_signature": "SafeCastLib.toInt24int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int24, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted to int24.\n * @return int24 The converted int24 value.\n *\n * Steps:\n * 1. Check if the value `x` can fit within the int24 range without overflow.\n * 2. If it fits, return the value as int24.\n * 3. If it does not fit, revert with an overflow error.\n *\n * Note: The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt32",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int32)",
            "body": "function toInt32(int256 x) internal pure returns (int32) {\n        unchecked {\n            if (((1 << 31) + uint256(x)) >> 32 == uint256(0)) return int32(x);\n            _revertOverflow();\n        }\n    }",
            "start": "199",
            "end": "204",
            "class": "SafeCastLib",
            "signature": "returns (int32) toInt32int256 x",
            "full_signature": "function toInt32(int256 x) internal  pure returns (int32)",
            "class_method_signature": "SafeCastLib.toInt32int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 32-bit signed integer.\n * @dev This function checks if the input value `x` can be safely cast to an `int32` without overflow.\n *      If the value is within the valid range for `int32`, it returns the cast value.\n *      Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int32 The 32-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value `x` can be represented as a 32-bit signed integer by verifying that the upper bits are zero.\n * 2. If the value is within the valid range, return the cast value as `int32`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt40",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int40)",
            "body": "function toInt40(int256 x) internal pure returns (int40) {\n        unchecked {\n            if (((1 << 39) + uint256(x)) >> 40 == uint256(0)) return int40(x);\n            _revertOverflow();\n        }\n    }",
            "start": "206",
            "end": "211",
            "class": "SafeCastLib",
            "signature": "returns (int40) toInt40int256 x",
            "full_signature": "function toInt40(int256 x) internal  pure returns (int40)",
            "class_method_signature": "SafeCastLib.toInt40int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 40-bit signed integer.\n * @dev This function checks if the input value `x` can be safely cast to a 40-bit integer.\n *      If the value is within the valid range for a 40-bit integer, it returns the cast value.\n *      Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int40 The 40-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value `x` can fit within a 40-bit integer by verifying if the 40th bit is not set.\n * 2. If the value is within the valid range, return the cast value as `int40`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt48",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int48)",
            "body": "function toInt48(int256 x) internal pure returns (int48) {\n        unchecked {\n            if (((1 << 47) + uint256(x)) >> 48 == uint256(0)) return int48(x);\n            _revertOverflow();\n        }\n    }",
            "start": "213",
            "end": "218",
            "class": "SafeCastLib",
            "signature": "returns (int48) toInt48int256 x",
            "full_signature": "function toInt48(int256 x) internal  pure returns (int48)",
            "class_method_signature": "SafeCastLib.toInt48int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 48-bit signed integer.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int48 The resulting 48-bit signed integer.\n *\n * Steps:\n * 1. Check if the input value `x` can be safely cast to a 48-bit integer without overflow.\n * 2. If the value is within the valid range, return the casted 48-bit integer.\n * 3. If the value exceeds the 48-bit range, revert with an overflow error.\n *\n * @dev The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt56",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int56)",
            "body": "function toInt56(int256 x) internal pure returns (int56) {\n        unchecked {\n            if (((1 << 55) + uint256(x)) >> 56 == uint256(0)) return int56(x);\n            _revertOverflow();\n        }\n    }",
            "start": "220",
            "end": "225",
            "class": "SafeCastLib",
            "signature": "returns (int56) toInt56int256 x",
            "full_signature": "function toInt56(int256 x) internal  pure returns (int56)",
            "class_method_signature": "SafeCastLib.toInt56int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 56-bit signed integer.\n *\n * @dev This function performs an unchecked conversion to ensure efficiency.\n *      It checks if the input value `x` can fit within the 56-bit range.\n *      If the value is within the valid range, it returns the converted value.\n *      Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int56 The converted 56-bit signed integer.\n *\n * Steps:\n * 1. Check if the input value `x` can fit within the 56-bit range by performing a bitwise operation.\n * 2. If the value is within the valid range, return the converted value as `int56`.\n * 3. If the value exceeds the 56-bit range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt64",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int64)",
            "body": "function toInt64(int256 x) internal pure returns (int64) {\n        unchecked {\n            if (((1 << 63) + uint256(x)) >> 64 == uint256(0)) return int64(x);\n            _revertOverflow();\n        }\n    }",
            "start": "227",
            "end": "232",
            "class": "SafeCastLib",
            "signature": "returns (int64) toInt64int256 x",
            "full_signature": "function toInt64(int256 x) internal  pure returns (int64)",
            "class_method_signature": "SafeCastLib.toInt64int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 64-bit signed integer.\n * @dev This function checks if the input value `x` can be safely cast to `int64` without overflow.\n *      If the value is within the valid range for `int64`, it returns the cast value.\n *      Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int64 The 64-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value `x` can be safely represented as a 64-bit integer by verifying that the upper bits are zero.\n * 2. If the value is within the valid range, return the cast value as `int64`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt72",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int72)",
            "body": "function toInt72(int256 x) internal pure returns (int72) {\n        unchecked {\n            if (((1 << 71) + uint256(x)) >> 72 == uint256(0)) return int72(x);\n            _revertOverflow();\n        }\n    }",
            "start": "234",
            "end": "239",
            "class": "SafeCastLib",
            "signature": "returns (int72) toInt72int256 x",
            "full_signature": "function toInt72(int256 x) internal  pure returns (int72)",
            "class_method_signature": "SafeCastLib.toInt72int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer (`int256`) to a 72-bit signed integer (`int72`).\n * \n * @dev This function performs a safe downcast from `int256` to `int72`. It checks if the value of `x` \n *      fits within the range of a 72-bit signed integer. If the value is out of bounds, it reverts \n *      with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int72 The converted 72-bit signed integer.\n *\n * Steps:\n * 1. Check if the value of `x` can fit within the range of a 72-bit signed integer by performing \n *    a bitwise operation. Specifically, it checks if the value, when shifted and masked, is zero.\n * 2. If the value fits, return the downcasted `int72` value.\n * 3. If the value does not fit, revert with an overflow error using `_revertOverflow()`.\n */"
        },
        {
            "identifier": "toInt80",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int80)",
            "body": "function toInt80(int256 x) internal pure returns (int80) {\n        unchecked {\n            if (((1 << 79) + uint256(x)) >> 80 == uint256(0)) return int80(x);\n            _revertOverflow();\n        }\n    }",
            "start": "241",
            "end": "246",
            "class": "SafeCastLib",
            "signature": "returns (int80) toInt80int256 x",
            "full_signature": "function toInt80(int256 x) internal  pure returns (int80)",
            "class_method_signature": "SafeCastLib.toInt80int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to an 80-bit signed integer.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int80 The resulting 80-bit signed integer.\n *\n * Steps:\n * 1. Check if the input value `x` can be safely represented as an 80-bit integer.\n * 2. If the value is within the valid range, return the converted 80-bit integer.\n * 3. If the value exceeds the range of an 80-bit integer, revert with an overflow error.\n *\n * @dev The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt88",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int88)",
            "body": "function toInt88(int256 x) internal pure returns (int88) {\n        unchecked {\n            if (((1 << 87) + uint256(x)) >> 88 == uint256(0)) return int88(x);\n            _revertOverflow();\n        }\n    }",
            "start": "248",
            "end": "253",
            "class": "SafeCastLib",
            "signature": "returns (int88) toInt88int256 x",
            "full_signature": "function toInt88(int256 x) internal  pure returns (int88)",
            "class_method_signature": "SafeCastLib.toInt88int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to an 88-bit signed integer.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int88 The resulting 88-bit signed integer.\n *\n * Steps:\n * 1. Check if the value of `x` can fit within the range of an 88-bit integer.\n * 2. If it fits, return the value as an 88-bit integer.\n * 3. If it does not fit, revert with an overflow error.\n *\n * @dev The function uses unchecked arithmetic to avoid unnecessary gas costs.\n *      The overflow check ensures that the value does not exceed the bounds of an 88-bit integer.\n */"
        },
        {
            "identifier": "toInt96",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int96)",
            "body": "function toInt96(int256 x) internal pure returns (int96) {\n        unchecked {\n            if (((1 << 95) + uint256(x)) >> 96 == uint256(0)) return int96(x);\n            _revertOverflow();\n        }\n    }",
            "start": "255",
            "end": "260",
            "class": "SafeCastLib",
            "signature": "returns (int96) toInt96int256 x",
            "full_signature": "function toInt96(int256 x) internal  pure returns (int96)",
            "class_method_signature": "SafeCastLib.toInt96int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int96, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int96 The converted value, if it fits within the int96 range.\n *\n * Steps:\n * 1. Check if the value `x` can be safely cast to int96 by verifying it does not exceed the 96-bit range.\n * 2. If the value fits within the range, return it as int96.\n * 3. If the value exceeds the range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt104",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int104)",
            "body": "function toInt104(int256 x) internal pure returns (int104) {\n        unchecked {\n            if (((1 << 103) + uint256(x)) >> 104 == uint256(0)) return int104(x);\n            _revertOverflow();\n        }\n    }",
            "start": "262",
            "end": "267",
            "class": "SafeCastLib",
            "signature": "returns (int104) toInt104int256 x",
            "full_signature": "function toInt104(int256 x) internal  pure returns (int104)",
            "class_method_signature": "SafeCastLib.toInt104int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 104-bit signed integer.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int104 The resulting 104-bit signed integer.\n *\n * Steps:\n * 1. Check if the input value `x` can be safely downcasted to a 104-bit integer.\n * 2. If the value is within the valid range for a 104-bit integer, return the downcasted value.\n * 3. If the value exceeds the valid range, revert with an overflow error.\n *\n * @dev The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt112",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int112)",
            "body": "function toInt112(int256 x) internal pure returns (int112) {\n        unchecked {\n            if (((1 << 111) + uint256(x)) >> 112 == uint256(0)) return int112(x);\n            _revertOverflow();\n        }\n    }",
            "start": "269",
            "end": "274",
            "class": "SafeCastLib",
            "signature": "returns (int112) toInt112int256 x",
            "full_signature": "function toInt112(int256 x) internal  pure returns (int112)",
            "class_method_signature": "SafeCastLib.toInt112int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit integer to a 112-bit integer, reverting on overflow.\n *\n * @param x The 256-bit integer to be converted.\n * @return int112 The converted 112-bit integer.\n *\n * Steps:\n * 1. Check if the value of `x` can fit within a 112-bit integer by verifying that the upper bits (beyond 112 bits) are zero.\n * 2. If the value fits, return the value as a 112-bit integer.\n * 3. If the value does not fit, revert with an overflow error.\n *\n * Note: The function uses `unchecked` to avoid unnecessary overflow checks, but explicitly reverts if the value exceeds the 112-bit range.\n */"
        },
        {
            "identifier": "toInt120",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int120)",
            "body": "function toInt120(int256 x) internal pure returns (int120) {\n        unchecked {\n            if (((1 << 119) + uint256(x)) >> 120 == uint256(0)) return int120(x);\n            _revertOverflow();\n        }\n    }",
            "start": "276",
            "end": "281",
            "class": "SafeCastLib",
            "signature": "returns (int120) toInt120int256 x",
            "full_signature": "function toInt120(int256 x) internal  pure returns (int120)",
            "class_method_signature": "SafeCastLib.toInt120int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 120-bit signed integer.\n * @dev This function performs an unchecked conversion and checks for overflow.\n * If the value of `x` is within the valid range for a 120-bit integer, it is returned.\n * Otherwise, the function reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int120 The converted 120-bit signed integer.\n *\n * Steps:\n * 1. Perform an unchecked operation to avoid overflow checks during arithmetic.\n * 2. Check if the value of `x` is within the valid range for a 120-bit integer.\n *    - If valid, return the value as an `int120`.\n *    - If invalid, revert with an overflow error using `_revertOverflow()`.\n */"
        },
        {
            "identifier": "toInt128",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int128)",
            "body": "function toInt128(int256 x) internal pure returns (int128) {\n        unchecked {\n            if (((1 << 127) + uint256(x)) >> 128 == uint256(0)) return int128(x);\n            _revertOverflow();\n        }\n    }",
            "start": "283",
            "end": "288",
            "class": "SafeCastLib",
            "signature": "returns (int128) toInt128int256 x",
            "full_signature": "function toInt128(int256 x) internal  pure returns (int128)",
            "class_method_signature": "SafeCastLib.toInt128int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 128-bit signed integer.\n * @dev This function checks if the input value `x` can be safely cast to `int128` without overflow.\n *      If the value is within the valid range for `int128`, it returns the cast value.\n *      Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int128 The 128-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value `x` can be safely represented as an `int128` by verifying that the upper 128 bits are zero.\n * 2. If the value is within the valid range, return the cast value as `int128`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt136",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int136)",
            "body": "function toInt136(int256 x) internal pure returns (int136) {\n        unchecked {\n            if (((1 << 135) + uint256(x)) >> 136 == uint256(0)) return int136(x);\n            _revertOverflow();\n        }\n    }",
            "start": "290",
            "end": "295",
            "class": "SafeCastLib",
            "signature": "returns (int136) toInt136int256 x",
            "full_signature": "function toInt136(int256 x) internal  pure returns (int136)",
            "class_method_signature": "SafeCastLib.toInt136int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 136-bit signed integer.\n * \n * @dev This function performs an overflow check to ensure the input value fits within the 136-bit range.\n * If the input value is within the valid range, it is cast to `int136` and returned.\n * If the input value exceeds the 136-bit range, the function reverts with an overflow error.\n * \n * @param x The 256-bit signed integer to be converted.\n * @return int136 The converted 136-bit signed integer.\n * \n * Steps:\n * 1. Perform an unchecked block to avoid overflow checks during arithmetic operations.\n * 2. Check if the input value `x` fits within the 136-bit range by shifting and comparing.\n * 3. If the value is within range, return it as `int136`.\n * 4. If the value exceeds the range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt144",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int144)",
            "body": "function toInt144(int256 x) internal pure returns (int144) {\n        unchecked {\n            if (((1 << 143) + uint256(x)) >> 144 == uint256(0)) return int144(x);\n            _revertOverflow();\n        }\n    }",
            "start": "297",
            "end": "302",
            "class": "SafeCastLib",
            "signature": "returns (int144) toInt144int256 x",
            "full_signature": "function toInt144(int256 x) internal  pure returns (int144)",
            "class_method_signature": "SafeCastLib.toInt144int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 144-bit signed integer.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int144 The resulting 144-bit signed integer.\n *\n * Steps:\n * 1. Check if the input value `x` can be safely represented as a 144-bit signed integer.\n * 2. If the value is within the valid range, return the value cast to `int144`.\n * 3. If the value exceeds the valid range, revert with an overflow error.\n *\n * Note: The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt152",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int152)",
            "body": "function toInt152(int256 x) internal pure returns (int152) {\n        unchecked {\n            if (((1 << 151) + uint256(x)) >> 152 == uint256(0)) return int152(x);\n            _revertOverflow();\n        }\n    }",
            "start": "304",
            "end": "309",
            "class": "SafeCastLib",
            "signature": "returns (int152) toInt152int256 x",
            "full_signature": "function toInt152(int256 x) internal  pure returns (int152)",
            "class_method_signature": "SafeCastLib.toInt152int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int152, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int152 The converted value, if it fits within the int152 range.\n *\n * Steps:\n * 1. Check if the value `x` can be safely cast to int152 by verifying it does not exceed the range of int152.\n * 2. If the value is within the valid range, return it as int152.\n * 3. If the value exceeds the range, revert with an overflow error.\n *\n * @dev This function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt160",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int160)",
            "body": "function toInt160(int256 x) internal pure returns (int160) {\n        unchecked {\n            if (((1 << 159) + uint256(x)) >> 160 == uint256(0)) return int160(x);\n            _revertOverflow();\n        }\n    }",
            "start": "311",
            "end": "316",
            "class": "SafeCastLib",
            "signature": "returns (int160) toInt160int256 x",
            "full_signature": "function toInt160(int256 x) internal  pure returns (int160)",
            "class_method_signature": "SafeCastLib.toInt160int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer (`int256`) to a 160-bit signed integer (`int160`).\n * @dev This function checks for overflow conditions. If the value of `x` cannot be represented\n *      as a 160-bit signed integer, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int160 The 160-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value of `x` can be safely represented as a 160-bit signed integer.\n *    - This is done by shifting and masking to ensure the upper bits are zero.\n * 2. If the value is within the valid range, return the converted `int160` value.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt168",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int168)",
            "body": "function toInt168(int256 x) internal pure returns (int168) {\n        unchecked {\n            if (((1 << 167) + uint256(x)) >> 168 == uint256(0)) return int168(x);\n            _revertOverflow();\n        }\n    }",
            "start": "318",
            "end": "323",
            "class": "SafeCastLib",
            "signature": "returns (int168) toInt168int256 x",
            "full_signature": "function toInt168(int256 x) internal  pure returns (int168)",
            "class_method_signature": "SafeCastLib.toInt168int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 168-bit signed integer.\n * @dev This function ensures that the input value fits within the 168-bit range.\n * If the value exceeds the range, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int168 The resulting 168-bit signed integer.\n *\n * Steps:\n * 1. Check if the input value `x` fits within the 168-bit range by performing bitwise operations.\n * 2. If the value fits, return the value as a 168-bit integer.\n * 3. If the value exceeds the range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt176",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int176)",
            "body": "function toInt176(int256 x) internal pure returns (int176) {\n        unchecked {\n            if (((1 << 175) + uint256(x)) >> 176 == uint256(0)) return int176(x);\n            _revertOverflow();\n        }\n    }",
            "start": "325",
            "end": "330",
            "class": "SafeCastLib",
            "signature": "returns (int176) toInt176int256 x",
            "full_signature": "function toInt176(int256 x) internal  pure returns (int176)",
            "class_method_signature": "SafeCastLib.toInt176int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 176-bit signed integer.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int176 The resulting 176-bit signed integer.\n *\n * Steps:\n * 1. Check if the input `x` can be safely represented as a 176-bit integer.\n * 2. If the conversion is safe, return the 176-bit integer.\n * 3. If the conversion would result in overflow, revert with an overflow error.\n *\n * @dev The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "toInt184",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int184)",
            "body": "function toInt184(int256 x) internal pure returns (int184) {\n        unchecked {\n            if (((1 << 183) + uint256(x)) >> 184 == uint256(0)) return int184(x);\n            _revertOverflow();\n        }\n    }",
            "start": "332",
            "end": "337",
            "class": "SafeCastLib",
            "signature": "returns (int184) toInt184int256 x",
            "full_signature": "function toInt184(int256 x) internal  pure returns (int184)",
            "class_method_signature": "SafeCastLib.toInt184int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 184-bit signed integer.\n * @dev This function checks if the input value `x` can be safely cast to a 184-bit integer.\n *      If the value is within the valid range for a 184-bit integer, it returns the cast value.\n *      Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int184 The 184-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value `x` can be represented as a 184-bit integer by verifying that the\n *    most significant bits (beyond the 184th bit) are zero.\n * 2. If the value is within the valid range, return the cast value as `int184`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt192",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int192)",
            "body": "function toInt192(int256 x) internal pure returns (int192) {\n        unchecked {\n            if (((1 << 191) + uint256(x)) >> 192 == uint256(0)) return int192(x);\n            _revertOverflow();\n        }\n    }",
            "start": "339",
            "end": "344",
            "class": "SafeCastLib",
            "signature": "returns (int192) toInt192int256 x",
            "full_signature": "function toInt192(int256 x) internal  pure returns (int192)",
            "class_method_signature": "SafeCastLib.toInt192int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer (`int256`) to a 192-bit signed integer (`int192`).\n * @dev This function ensures that the value of `x` fits within the range of a 192-bit integer.\n * If the value is out of range, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int192 The converted 192-bit signed integer.\n *\n * Steps:\n * 1. Check if the value of `x` fits within the range of a 192-bit integer by performing a bitwise operation.\n * 2. If the value is within range, return the value as an `int192`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt200",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int200)",
            "body": "function toInt200(int256 x) internal pure returns (int200) {\n        unchecked {\n            if (((1 << 199) + uint256(x)) >> 200 == uint256(0)) return int200(x);\n            _revertOverflow();\n        }\n    }",
            "start": "346",
            "end": "351",
            "class": "SafeCastLib",
            "signature": "returns (int200) toInt200int256 x",
            "full_signature": "function toInt200(int256 x) internal  pure returns (int200)",
            "class_method_signature": "SafeCastLib.toInt200int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 200-bit signed integer.\n *\n * @dev This function performs an unchecked conversion from `int256` to `int200`.\n * It checks if the value of `x` can fit within the range of a 200-bit signed integer.\n * If the value is within the valid range, it returns the value as `int200`.\n * If the value exceeds the range, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int200 The converted 200-bit signed integer.\n *\n * Steps:\n * 1. Check if the value of `x` can fit within the range of a 200-bit signed integer.\n * 2. If it fits, return the value as `int200`.\n * 3. If it does not fit, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt208",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int208)",
            "body": "function toInt208(int256 x) internal pure returns (int208) {\n        unchecked {\n            if (((1 << 207) + uint256(x)) >> 208 == uint256(0)) return int208(x);\n            _revertOverflow();\n        }\n    }",
            "start": "353",
            "end": "358",
            "class": "SafeCastLib",
            "signature": "returns (int208) toInt208int256 x",
            "full_signature": "function toInt208(int256 x) internal  pure returns (int208)",
            "class_method_signature": "SafeCastLib.toInt208int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int208, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int208 The converted int208 value.\n *\n * Steps:\n * 1. Check if the value `x` can fit within the int208 range by verifying that the most significant bits are zero.\n * 2. If the value fits, return the converted int208 value.\n * 3. If the value does not fit (overflow), revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt216",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int216)",
            "body": "function toInt216(int256 x) internal pure returns (int216) {\n        unchecked {\n            if (((1 << 215) + uint256(x)) >> 216 == uint256(0)) return int216(x);\n            _revertOverflow();\n        }\n    }",
            "start": "360",
            "end": "365",
            "class": "SafeCastLib",
            "signature": "returns (int216) toInt216int256 x",
            "full_signature": "function toInt216(int256 x) internal  pure returns (int216)",
            "class_method_signature": "SafeCastLib.toInt216int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int216, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int216 The converted int216 value.\n *\n * Steps:\n * 1. Check if the value `x` can fit within the range of int216.\n * 2. If it fits, return the value as int216.\n * 3. If it does not fit, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt224",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int224)",
            "body": "function toInt224(int256 x) internal pure returns (int224) {\n        unchecked {\n            if (((1 << 223) + uint256(x)) >> 224 == uint256(0)) return int224(x);\n            _revertOverflow();\n        }\n    }",
            "start": "367",
            "end": "372",
            "class": "SafeCastLib",
            "signature": "returns (int224) toInt224int256 x",
            "full_signature": "function toInt224(int256 x) internal  pure returns (int224)",
            "class_method_signature": "SafeCastLib.toInt224int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int224, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int224 The converted value, if it fits within the int224 range.\n *\n * Steps:\n * 1. Check if the value `x` can be safely cast to int224 by verifying it does not exceed the int224 range.\n * 2. If the value is within the valid range, return it as int224.\n * 3. If the value exceeds the range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt232",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int232)",
            "body": "function toInt232(int256 x) internal pure returns (int232) {\n        unchecked {\n            if (((1 << 231) + uint256(x)) >> 232 == uint256(0)) return int232(x);\n            _revertOverflow();\n        }\n    }",
            "start": "374",
            "end": "379",
            "class": "SafeCastLib",
            "signature": "returns (int232) toInt232int256 x",
            "full_signature": "function toInt232(int256 x) internal  pure returns (int232)",
            "class_method_signature": "SafeCastLib.toInt232int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int232, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int232 The converted int232 value.\n *\n * Steps:\n * 1. Check if the value `x` can be safely cast to int232 without overflow.\n * 2. If the value is within the valid range, return the casted int232 value.\n * 3. If the value exceeds the valid range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt240",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int240)",
            "body": "function toInt240(int256 x) internal pure returns (int240) {\n        unchecked {\n            if (((1 << 239) + uint256(x)) >> 240 == uint256(0)) return int240(x);\n            _revertOverflow();\n        }\n    }",
            "start": "381",
            "end": "386",
            "class": "SafeCastLib",
            "signature": "returns (int240) toInt240int256 x",
            "full_signature": "function toInt240(int256 x) internal  pure returns (int240)",
            "class_method_signature": "SafeCastLib.toInt240int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a 256-bit signed integer to a 240-bit signed integer.\n * @dev This function checks if the input value `x` can be safely cast to a 240-bit integer without overflow.\n * If the value is within the valid range for a 240-bit integer, it returns the cast value.\n * Otherwise, it reverts with an overflow error.\n *\n * @param x The 256-bit signed integer to be converted.\n * @return int240 The 240-bit signed integer representation of `x`.\n *\n * Steps:\n * 1. Check if the value `x` can be safely represented as a 240-bit integer by verifying that the upper bits (above 240) are zero.\n * 2. If the value is valid, return the cast value as `int240`.\n * 3. If the value is out of range, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt248",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int248)",
            "body": "function toInt248(int256 x) internal pure returns (int248) {\n        unchecked {\n            if (((1 << 247) + uint256(x)) >> 248 == uint256(0)) return int248(x);\n            _revertOverflow();\n        }\n    }",
            "start": "388",
            "end": "393",
            "class": "SafeCastLib",
            "signature": "returns (int248) toInt248int256 x",
            "full_signature": "function toInt248(int256 x) internal  pure returns (int248)",
            "class_method_signature": "SafeCastLib.toInt248int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts an int256 value to int248, ensuring it does not overflow.\n *\n * @param x The int256 value to be converted.\n * @return int248 The converted value if it fits within the int248 range.\n *\n * Steps:\n * 1. Check if the value `x` can be safely cast to int248 without overflow.\n * 2. If the value is within the valid range, return it as int248.\n * 3. If the value overflows, revert with an overflow error.\n */"
        },
        {
            "identifier": "toInt8",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int8)",
            "body": "function toInt8(uint256 x) internal pure returns (int8) {\n        if (x >= 1 << 7) _revertOverflow();\n        return int8(int256(x));\n    }",
            "start": "399",
            "end": "402",
            "class": "SafeCastLib",
            "signature": "returns (int8) toInt8uint256 x",
            "full_signature": "function toInt8(uint256 x) internal  pure returns (int8)",
            "class_method_signature": "SafeCastLib.toInt8uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int8 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int8.\n * @return int8 The converted int8 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^7 (128), which is the maximum positive value for int8.\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int8 and return it.\n */"
        },
        {
            "identifier": "toInt16",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int16)",
            "body": "function toInt16(uint256 x) internal pure returns (int16) {\n        if (x >= 1 << 15) _revertOverflow();\n        return int16(int256(x));\n    }",
            "start": "404",
            "end": "407",
            "class": "SafeCastLib",
            "signature": "returns (int16) toInt16uint256 x",
            "full_signature": "function toInt16(uint256 x) internal  pure returns (int16)",
            "class_method_signature": "SafeCastLib.toInt16uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int16, ensuring it does not overflow.\n *\n * @param x The uint256 value to be converted to int16.\n * @return int16 The converted int16 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^15 (the maximum value for int16).\n * 2. If the value overflows, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int16 and return it.\n */"
        },
        {
            "identifier": "toInt24",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int24)",
            "body": "function toInt24(uint256 x) internal pure returns (int24) {\n        if (x >= 1 << 23) _revertOverflow();\n        return int24(int256(x));\n    }",
            "start": "409",
            "end": "412",
            "class": "SafeCastLib",
            "signature": "returns (int24) toInt24uint256 x",
            "full_signature": "function toInt24(uint256 x) internal  pure returns (int24)",
            "class_method_signature": "SafeCastLib.toInt24uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int24 value, ensuring it does not overflow.\n *\n * @param x The uint256 value to be converted to int24.\n * @return int24 The converted int24 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^23 (the maximum value for int24).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int24 and return it.\n */"
        },
        {
            "identifier": "toInt32",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int32)",
            "body": "function toInt32(uint256 x) internal pure returns (int32) {\n        if (x >= 1 << 31) _revertOverflow();\n        return int32(int256(x));\n    }",
            "start": "414",
            "end": "417",
            "class": "SafeCastLib",
            "signature": "returns (int32) toInt32uint256 x",
            "full_signature": "function toInt32(uint256 x) internal  pure returns (int32)",
            "class_method_signature": "SafeCastLib.toInt32uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int32 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int32 The converted int32 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^31 (the maximum positive value for int32).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int32 and return it.\n */"
        },
        {
            "identifier": "toInt40",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int40)",
            "body": "function toInt40(uint256 x) internal pure returns (int40) {\n        if (x >= 1 << 39) _revertOverflow();\n        return int40(int256(x));\n    }",
            "start": "419",
            "end": "422",
            "class": "SafeCastLib",
            "signature": "returns (int40) toInt40uint256 x",
            "full_signature": "function toInt40(uint256 x) internal  pure returns (int40)",
            "class_method_signature": "SafeCastLib.toInt40uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int40 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int40.\n * @return int40 The converted int40 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^39 (the maximum value that can be safely represented as int40).\n * 2. If the check fails, revert with an overflow error.\n * 3. If the check passes, safely cast the uint256 value to int256 and then to int40.\n */"
        },
        {
            "identifier": "toInt48",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int48)",
            "body": "function toInt48(uint256 x) internal pure returns (int48) {\n        if (x >= 1 << 47) _revertOverflow();\n        return int48(int256(x));\n    }",
            "start": "424",
            "end": "427",
            "class": "SafeCastLib",
            "signature": "returns (int48) toInt48uint256 x",
            "full_signature": "function toInt48(uint256 x) internal  pure returns (int48)",
            "class_method_signature": "SafeCastLib.toInt48uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int48, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int48 The converted int48 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^47 (the maximum value that can be safely represented by int48).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int48 and return it.\n */"
        },
        {
            "identifier": "toInt56",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int56)",
            "body": "function toInt56(uint256 x) internal pure returns (int56) {\n        if (x >= 1 << 55) _revertOverflow();\n        return int56(int256(x));\n    }",
            "start": "429",
            "end": "432",
            "class": "SafeCastLib",
            "signature": "returns (int56) toInt56uint256 x",
            "full_signature": "function toInt56(uint256 x) internal  pure returns (int56)",
            "class_method_signature": "SafeCastLib.toInt56uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int56, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int56.\n * @return int56 The converted int56 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^55 (the maximum value that can be safely represented in int56).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, cast the uint256 value to int256 and then to int56, and return the result.\n */"
        },
        {
            "identifier": "toInt64",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int64)",
            "body": "function toInt64(uint256 x) internal pure returns (int64) {\n        if (x >= 1 << 63) _revertOverflow();\n        return int64(int256(x));\n    }",
            "start": "434",
            "end": "437",
            "class": "SafeCastLib",
            "signature": "returns (int64) toInt64uint256 x",
            "full_signature": "function toInt64(uint256 x) internal  pure returns (int64)",
            "class_method_signature": "SafeCastLib.toInt64uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int64, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int64.\n * @return int64 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^63 (the maximum positive value for int64).\n * 2. If the value is too large, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int64 and return it.\n */"
        },
        {
            "identifier": "toInt72",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int72)",
            "body": "function toInt72(uint256 x) internal pure returns (int72) {\n        if (x >= 1 << 71) _revertOverflow();\n        return int72(int256(x));\n    }",
            "start": "439",
            "end": "442",
            "class": "SafeCastLib",
            "signature": "returns (int72) toInt72uint256 x",
            "full_signature": "function toInt72(uint256 x) internal  pure returns (int72)",
            "class_method_signature": "SafeCastLib.toInt72uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int72 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int72 The converted int72 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^71 (the maximum value that can be safely represented by int72).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int72 and return it.\n */"
        },
        {
            "identifier": "toInt80",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int80)",
            "body": "function toInt80(uint256 x) internal pure returns (int80) {\n        if (x >= 1 << 79) _revertOverflow();\n        return int80(int256(x));\n    }",
            "start": "444",
            "end": "447",
            "class": "SafeCastLib",
            "signature": "returns (int80) toInt80uint256 x",
            "full_signature": "function toInt80(uint256 x) internal  pure returns (int80)",
            "class_method_signature": "SafeCastLib.toInt80uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int80, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int80.\n * @return int80 The converted int80 value.\n *\n * Steps:\n * 1. Check if the input value `x` exceeds the maximum allowable value for int80 (2^79 - 1).\n * 2. If it does, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int80 and return it.\n */"
        },
        {
            "identifier": "toInt88",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int88)",
            "body": "function toInt88(uint256 x) internal pure returns (int88) {\n        if (x >= 1 << 87) _revertOverflow();\n        return int88(int256(x));\n    }",
            "start": "449",
            "end": "452",
            "class": "SafeCastLib",
            "signature": "returns (int88) toInt88uint256 x",
            "full_signature": "function toInt88(uint256 x) internal  pure returns (int88)",
            "class_method_signature": "SafeCastLib.toInt88uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a `uint256` value to an `int88` value, ensuring no overflow occurs.\n *\n * @param x The `uint256` value to be converted to `int88`.\n * @return int88 The converted `int88` value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to `1 << 87` (2^87).\n * 2. If the check passes, revert with an overflow error.\n * 3. Otherwise, safely cast the `uint256` value to `int88` and return it.\n */"
        },
        {
            "identifier": "toInt96",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int96)",
            "body": "function toInt96(uint256 x) internal pure returns (int96) {\n        if (x >= 1 << 95) _revertOverflow();\n        return int96(int256(x));\n    }",
            "start": "454",
            "end": "457",
            "class": "SafeCastLib",
            "signature": "returns (int96) toInt96uint256 x",
            "full_signature": "function toInt96(uint256 x) internal  pure returns (int96)",
            "class_method_signature": "SafeCastLib.toInt96uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int96 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int96 The converted int96 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^95 (to prevent overflow).\n * 2. If the check fails, revert with an overflow error.\n * 3. Safely cast the uint256 value to int96 and return it.\n */"
        },
        {
            "identifier": "toInt104",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int104)",
            "body": "function toInt104(uint256 x) internal pure returns (int104) {\n        if (x >= 1 << 103) _revertOverflow();\n        return int104(int256(x));\n    }",
            "start": "459",
            "end": "462",
            "class": "SafeCastLib",
            "signature": "returns (int104) toInt104uint256 x",
            "full_signature": "function toInt104(uint256 x) internal  pure returns (int104)",
            "class_method_signature": "SafeCastLib.toInt104uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int104 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int104 The converted int104 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^103 (the maximum value that can be safely represented by int104).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int104 and return it.\n */"
        },
        {
            "identifier": "toInt112",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int112)",
            "body": "function toInt112(uint256 x) internal pure returns (int112) {\n        if (x >= 1 << 111) _revertOverflow();\n        return int112(int256(x));\n    }",
            "start": "464",
            "end": "467",
            "class": "SafeCastLib",
            "signature": "returns (int112) toInt112uint256 x",
            "full_signature": "function toInt112(uint256 x) internal  pure returns (int112)",
            "class_method_signature": "SafeCastLib.toInt112uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int112 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int112 The converted int112 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^111 (the maximum value for int112).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int112 and return it.\n */"
        },
        {
            "identifier": "toInt120",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int120)",
            "body": "function toInt120(uint256 x) internal pure returns (int120) {\n        if (x >= 1 << 119) _revertOverflow();\n        return int120(int256(x));\n    }",
            "start": "469",
            "end": "472",
            "class": "SafeCastLib",
            "signature": "returns (int120) toInt120uint256 x",
            "full_signature": "function toInt120(uint256 x) internal  pure returns (int120)",
            "class_method_signature": "SafeCastLib.toInt120uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int120 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int120 The converted int120 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^119 (the maximum value that can be safely represented by int120).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int120 and return it.\n */"
        },
        {
            "identifier": "toInt128",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int128)",
            "body": "function toInt128(uint256 x) internal pure returns (int128) {\n        if (x >= 1 << 127) _revertOverflow();\n        return int128(int256(x));\n    }",
            "start": "474",
            "end": "477",
            "class": "SafeCastLib",
            "signature": "returns (int128) toInt128uint256 x",
            "full_signature": "function toInt128(uint256 x) internal  pure returns (int128)",
            "class_method_signature": "SafeCastLib.toInt128uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a `uint256` value to an `int128` value, ensuring it does not overflow.\n *\n * @param x The `uint256` value to be converted to `int128`.\n * @return int128 The converted `int128` value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to `1 << 127` (i.e., the maximum value that can be represented by `int128`).\n * 2. If the value is too large, revert with an overflow error.\n * 3. Otherwise, safely cast the `uint256` value to `int128` and return it.\n */"
        },
        {
            "identifier": "toInt136",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int136)",
            "body": "function toInt136(uint256 x) internal pure returns (int136) {\n        if (x >= 1 << 135) _revertOverflow();\n        return int136(int256(x));\n    }",
            "start": "479",
            "end": "482",
            "class": "SafeCastLib",
            "signature": "returns (int136) toInt136uint256 x",
            "full_signature": "function toInt136(uint256 x) internal  pure returns (int136)",
            "class_method_signature": "SafeCastLib.toInt136uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int136 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int136.\n * @return int136 The converted int136 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^135 (the maximum value that can be safely represented by int136).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int136 and return it.\n */"
        },
        {
            "identifier": "toInt144",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int144)",
            "body": "function toInt144(uint256 x) internal pure returns (int144) {\n        if (x >= 1 << 143) _revertOverflow();\n        return int144(int256(x));\n    }",
            "start": "484",
            "end": "487",
            "class": "SafeCastLib",
            "signature": "returns (int144) toInt144uint256 x",
            "full_signature": "function toInt144(uint256 x) internal  pure returns (int144)",
            "class_method_signature": "SafeCastLib.toInt144uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int144 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int144 The converted int144 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^143 (the maximum value that can be safely represented by int144).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int144 and return it.\n */"
        },
        {
            "identifier": "toInt152",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int152)",
            "body": "function toInt152(uint256 x) internal pure returns (int152) {\n        if (x >= 1 << 151) _revertOverflow();\n        return int152(int256(x));\n    }",
            "start": "489",
            "end": "492",
            "class": "SafeCastLib",
            "signature": "returns (int152) toInt152uint256 x",
            "full_signature": "function toInt152(uint256 x) internal  pure returns (int152)",
            "class_method_signature": "SafeCastLib.toInt152uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int152 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int152 The converted int152 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^151 (the maximum value that can be safely represented by int152).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int152 and return it.\n */"
        },
        {
            "identifier": "toInt160",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int160)",
            "body": "function toInt160(uint256 x) internal pure returns (int160) {\n        if (x >= 1 << 159) _revertOverflow();\n        return int160(int256(x));\n    }",
            "start": "494",
            "end": "497",
            "class": "SafeCastLib",
            "signature": "returns (int160) toInt160uint256 x",
            "full_signature": "function toInt160(uint256 x) internal  pure returns (int160)",
            "class_method_signature": "SafeCastLib.toInt160uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int160 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int160 The converted int160 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^159 (the maximum positive value for int160).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int160 and return it.\n */"
        },
        {
            "identifier": "toInt168",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int168)",
            "body": "function toInt168(uint256 x) internal pure returns (int168) {\n        if (x >= 1 << 167) _revertOverflow();\n        return int168(int256(x));\n    }",
            "start": "499",
            "end": "502",
            "class": "SafeCastLib",
            "signature": "returns (int168) toInt168uint256 x",
            "full_signature": "function toInt168(uint256 x) internal  pure returns (int168)",
            "class_method_signature": "SafeCastLib.toInt168uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int168 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int168.\n * @return int168 The converted int168 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^167 (the maximum value that can be safely represented by int168).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int168 and return it.\n */"
        },
        {
            "identifier": "toInt176",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int176)",
            "body": "function toInt176(uint256 x) internal pure returns (int176) {\n        if (x >= 1 << 175) _revertOverflow();\n        return int176(int256(x));\n    }",
            "start": "504",
            "end": "507",
            "class": "SafeCastLib",
            "signature": "returns (int176) toInt176uint256 x",
            "full_signature": "function toInt176(uint256 x) internal  pure returns (int176)",
            "class_method_signature": "SafeCastLib.toInt176uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int176, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int176 The converted value as an int176.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^175.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int176 and return it.\n */"
        },
        {
            "identifier": "toInt184",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int184)",
            "body": "function toInt184(uint256 x) internal pure returns (int184) {\n        if (x >= 1 << 183) _revertOverflow();\n        return int184(int256(x));\n    }",
            "start": "509",
            "end": "512",
            "class": "SafeCastLib",
            "signature": "returns (int184) toInt184uint256 x",
            "full_signature": "function toInt184(uint256 x) internal  pure returns (int184)",
            "class_method_signature": "SafeCastLib.toInt184uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int184 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int184.\n * @return int184 The converted value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^183.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int184 and return it.\n */"
        },
        {
            "identifier": "toInt192",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int192)",
            "body": "function toInt192(uint256 x) internal pure returns (int192) {\n        if (x >= 1 << 191) _revertOverflow();\n        return int192(int256(x));\n    }",
            "start": "514",
            "end": "517",
            "class": "SafeCastLib",
            "signature": "returns (int192) toInt192uint256 x",
            "full_signature": "function toInt192(uint256 x) internal  pure returns (int192)",
            "class_method_signature": "SafeCastLib.toInt192uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int192 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int192 The converted int192 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^191 (the maximum value that can be safely represented by int192).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int256 and then to int192.\n */"
        },
        {
            "identifier": "toInt200",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int200)",
            "body": "function toInt200(uint256 x) internal pure returns (int200) {\n        if (x >= 1 << 199) _revertOverflow();\n        return int200(int256(x));\n    }",
            "start": "519",
            "end": "522",
            "class": "SafeCastLib",
            "signature": "returns (int200) toInt200uint256 x",
            "full_signature": "function toInt200(uint256 x) internal  pure returns (int200)",
            "class_method_signature": "SafeCastLib.toInt200uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int200 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int200 The converted int200 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^199 (the maximum value that can be safely represented as an int200).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int256 and then to int200.\n */"
        },
        {
            "identifier": "toInt208",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int208)",
            "body": "function toInt208(uint256 x) internal pure returns (int208) {\n        if (x >= 1 << 207) _revertOverflow();\n        return int208(int256(x));\n    }",
            "start": "524",
            "end": "527",
            "class": "SafeCastLib",
            "signature": "returns (int208) toInt208uint256 x",
            "full_signature": "function toInt208(uint256 x) internal  pure returns (int208)",
            "class_method_signature": "SafeCastLib.toInt208uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int208, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int208 The converted int208 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^207.\n * 2. If true, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int256 and then to int208.\n */"
        },
        {
            "identifier": "toInt216",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int216)",
            "body": "function toInt216(uint256 x) internal pure returns (int216) {\n        if (x >= 1 << 215) _revertOverflow();\n        return int216(int256(x));\n    }",
            "start": "529",
            "end": "532",
            "class": "SafeCastLib",
            "signature": "returns (int216) toInt216uint256 x",
            "full_signature": "function toInt216(uint256 x) internal  pure returns (int216)",
            "class_method_signature": "SafeCastLib.toInt216uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int216 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int216 The converted int216 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^215 (the maximum value that can be safely represented by int216).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int216 and return it.\n */"
        },
        {
            "identifier": "toInt224",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int224)",
            "body": "function toInt224(uint256 x) internal pure returns (int224) {\n        if (x >= 1 << 223) _revertOverflow();\n        return int224(int256(x));\n    }",
            "start": "534",
            "end": "537",
            "class": "SafeCastLib",
            "signature": "returns (int224) toInt224uint256 x",
            "full_signature": "function toInt224(uint256 x) internal  pure returns (int224)",
            "class_method_signature": "SafeCastLib.toInt224uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int224 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int224 The converted int224 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^223 (the maximum value that can be safely converted to int224).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int256 and then to int224.\n */"
        },
        {
            "identifier": "toInt232",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int232)",
            "body": "function toInt232(uint256 x) internal pure returns (int232) {\n        if (x >= 1 << 231) _revertOverflow();\n        return int232(int256(x));\n    }",
            "start": "539",
            "end": "542",
            "class": "SafeCastLib",
            "signature": "returns (int232) toInt232uint256 x",
            "full_signature": "function toInt232(uint256 x) internal  pure returns (int232)",
            "class_method_signature": "SafeCastLib.toInt232uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int232 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int232 The converted int232 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^231 (the maximum value for int232).\n * 2. If the value exceeds the limit, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int256 and then to int232.\n */"
        },
        {
            "identifier": "toInt240",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int240)",
            "body": "function toInt240(uint256 x) internal pure returns (int240) {\n        if (x >= 1 << 239) _revertOverflow();\n        return int240(int256(x));\n    }",
            "start": "544",
            "end": "547",
            "class": "SafeCastLib",
            "signature": "returns (int240) toInt240uint256 x",
            "full_signature": "function toInt240(uint256 x) internal  pure returns (int240)",
            "class_method_signature": "SafeCastLib.toInt240uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int240 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int240 The converted int240 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^239 (the maximum value that can be safely represented by int240).\n * 2. If the check fails, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int256 and then to int240, and return the result.\n */"
        },
        {
            "identifier": "toInt248",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int248)",
            "body": "function toInt248(uint256 x) internal pure returns (int248) {\n        if (x >= 1 << 247) _revertOverflow();\n        return int248(int256(x));\n    }",
            "start": "549",
            "end": "552",
            "class": "SafeCastLib",
            "signature": "returns (int248) toInt248uint256 x",
            "full_signature": "function toInt248(uint256 x) internal  pure returns (int248)",
            "class_method_signature": "SafeCastLib.toInt248uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int248, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted.\n * @return int248 The converted int248 value.\n *\n * Steps:\n * 1. Check if the input value `x` is greater than or equal to 2^247 (the maximum value an int248 can hold).\n * 2. If the value is too large, revert with an overflow error.\n * 3. Otherwise, safely cast the uint256 value to int248 and return it.\n */"
        },
        {
            "identifier": "toInt256",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function toInt256(uint256 x) internal pure returns (int256) {\n        if (int256(x) >= 0) return int256(x);\n        _revertOverflow();\n    }",
            "start": "554",
            "end": "557",
            "class": "SafeCastLib",
            "signature": "returns (int256) toInt256uint256 x",
            "full_signature": "function toInt256(uint256 x) internal  pure returns (int256)",
            "class_method_signature": "SafeCastLib.toInt256uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a uint256 value to an int256 value, ensuring no overflow occurs.\n *\n * @param x The uint256 value to be converted to int256.\n * @return int256 The converted int256 value.\n *\n * Steps:\n * 1. Check if the uint256 value can be safely cast to int256 (i.e., it is within the valid range for int256).\n * 2. If the value is within the valid range, return the cast int256 value.\n * 3. If the value is outside the valid range (i.e., it would cause an overflow), revert with an overflow error.\n */"
        },
        {
            "identifier": "toUint256",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function toUint256(int256 x) internal pure returns (uint256) {\n        if (x >= 0) return uint256(x);\n        _revertOverflow();\n    }",
            "start": "559",
            "end": "562",
            "class": "SafeCastLib",
            "signature": "returns (uint256) toUint256int256 x",
            "full_signature": "function toUint256(int256 x) internal  pure returns (uint256)",
            "class_method_signature": "SafeCastLib.toUint256int256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts an int256 to a uint256. Reverts if the input is negative.\n *\n * @param x The int256 value to be converted to uint256.\n * @return uint256 The converted unsigned integer value.\n *\n * Steps:\n * 1. Check if the input `x` is non-negative.\n * 2. If `x` is non-negative, safely cast it to uint256 and return.\n * 3. If `x` is negative, revert with an overflow error.\n */ "
        }
    ],
    "/root/solady/lib/solady/src/utils/ECDSA.sol": [
        {
            "identifier": "recover",
            "parameters": "bytes32 hash, bytes memory signature",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function recover(bytes32 hash, bytes memory signature) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }",
            "start": "50",
            "end": "77",
            "class": "ECDSA",
            "signature": "returns (address result) recoverbytes32 hash, bytes memory signature",
            "full_signature": "function recover(bytes32 hash, bytes memory signature) internal  view returns (address result)",
            "class_method_signature": "ECDSA.recoverbytes32 hash, bytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Recovers the address from a given hash and signature using inline assembly.\n *\n * @param hash The hash of the data that was signed.\n * @param signature The signature to recover the address from.\n * @return result The recovered address from the signature.\n *\n * Steps:\n * 1. Use inline assembly to handle low-level memory operations.\n * 2. Check the length of the signature:\n *    - If the signature length is 64 bytes, extract `v` and `s` from the signature.\n *    - If the signature length is 65 bytes, extract `v`, `r`, and `s` from the signature.\n * 3. Revert with an \"InvalidSignature\" error if the signature length is neither 64 nor 65 bytes.\n * 4. Use the `staticcall` opcode to perform an ECDSA recovery operation on the hash and signature.\n * 5. If the recovery is successful, return the recovered address.\n * 6. Restore the zero slot and free memory pointer after the operation.\n */"
        },
        {
            "identifier": "recoverCalldata",
            "parameters": "bytes32 hash, bytes calldata signature",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function recoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            } {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { continue }\n                mstore(0x00, hash)\n                result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                mstore(0x40, m) // Restore the free memory pointer.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                if returndatasize() { break }\n            }\n        }\n    }",
            "start": "80",
            "end": "111",
            "class": "ECDSA",
            "signature": "returns (address result) recoverCalldatabytes32 hash, bytes calldata signature",
            "full_signature": "function recoverCalldata(bytes32 hash, bytes calldata signature) internal  view returns (address result)",
            "class_method_signature": "ECDSA.recoverCalldatabytes32 hash, bytes calldata signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Recovers the signer's address from a given hash and signature using inline assembly.\n *\n * @param hash The hash of the data that was signed.\n * @param signature The signature to recover the signer's address from.\n * @return result The address of the signer.\n *\n * Steps:\n * 1. Use inline assembly to handle low-level memory operations.\n * 2. Check the length of the signature:\n *    - If the signature length is 64 bytes, extract `v`, `r`, and `s` from the signature.\n *    - If the signature length is 65 bytes, extract `v`, `r`, and `s` from the signature.\n *    - If the signature length is neither 64 nor 65 bytes, continue the loop.\n * 3. Store the hash and signature components in memory.\n * 4. Perform a static call to the `ecrecover` precompiled contract to recover the signer's address.\n * 5. If the recovery is successful, return the signer's address.\n * 6. If the recovery fails, revert with an \"InvalidSignature\" error.\n * 7. Restore the zero slot and free memory pointer after the operation.\n */"
        },
        {
            "identifier": "recover",
            "parameters": "bytes32 hash, bytes32 r, bytes32 vs",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function recover(bytes32 hash, bytes32 r, bytes32 vs) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "115",
            "end": "132",
            "class": "ECDSA",
            "signature": "returns (address result) recoverbytes32 hash, bytes32 r, bytes32 vs",
            "full_signature": "function recover(bytes32 hash, bytes32 r, bytes32 vs) internal  view returns (address result)",
            "class_method_signature": "ECDSA.recoverbytes32 hash, bytes32 r, bytes32 vs",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Recovers the address associated with a given hash and signature components (r, vs).\n *\n * @param hash The hash of the signed message.\n * @param r The r component of the signature.\n * @param vs The vs component of the signature, which encodes both s and v.\n * @return result The address recovered from the signature.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the hash in memory at position 0x00.\n * 3. Extract and store the `v` component from `vs` at position 0x20.\n * 4. Store the `r` component at position 0x40.\n * 5. Extract and store the `s` component from `vs` at position 0x60.\n * 6. Perform a static call to the `ecrecover` precompiled contract (address 1) to recover the address.\n * 7. Check the return data size to ensure the call was successful.\n * 8. If the call fails, revert with the `InvalidSignature()` error.\n * 9. Restore the zero slot and free memory pointer.\n */"
        },
        {
            "identifier": "recover",
            "parameters": "bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            result := mload(staticcall(gas(), 1, 0x00, 0x80, 0x01, 0x20))\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            if iszero(returndatasize()) {\n                mstore(0x00, 0x8baa579f) // `InvalidSignature()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "136",
            "end": "157",
            "class": "ECDSA",
            "signature": "returns (address result) recoverbytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  view returns (address result)",
            "class_method_signature": "ECDSA.recoverbytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Recovers the signer's address from a signed message using ECDSA.\n *\n * @param hash The hash of the signed message.\n * @param v The recovery byte of the signature.\n * @param r The first 32 bytes of the signature.\n * @param s The second 32 bytes of the signature.\n * @return result The address of the signer.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the hash, `v`, `r`, and `s` in memory.\n * 3. Perform a static call to the ECDSA recovery precompiled contract (address 1) to recover the signer's address.\n * 4. Check if the call was successful by verifying the return data size.\n *    - If unsuccessful, revert with an `InvalidSignature` error.\n * 5. Restore the zero slot and free memory pointer.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and interacts with the ECDSA recovery precompiled contract.\n */"
        },
        {
            "identifier": "tryRecover",
            "parameters": "bytes32 hash, bytes memory signature",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function tryRecover(bytes32 hash, bytes memory signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch mload(signature)\n                case 64 {\n                    let vs := mload(add(signature, 0x40))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, mload(add(signature, 0x60)))) // `v`.\n                    mstore(0x60, mload(add(signature, 0x40))) // `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                mstore(0x40, mload(add(signature, 0x20))) // `r`.\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "start": "170",
            "end": "199",
            "class": "ECDSA",
            "signature": "returns (address result) tryRecoverbytes32 hash, bytes memory signature",
            "full_signature": "function tryRecover(bytes32 hash, bytes memory signature) internal  view returns (address result)",
            "class_method_signature": "ECDSA.tryRecoverbytes32 hash, bytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to recover the signer's address from a given hash and signature.\n *\n * @dev This function uses inline assembly to handle the signature recovery process.\n * It supports both 64-byte and 65-byte signatures (standard ECDSA signatures).\n * The function is marked as `internal` and `view`, meaning it can only be called\n * internally and does not modify the state.\n *\n * @param hash The hash of the message that was signed.\n * @param signature The signature to recover the signer's address from.\n * @return result The address of the signer if the recovery is successful, otherwise 0.\n *\n * Steps:\n * 1. Load the free memory pointer (`mload(0x40)`) to manage memory allocation.\n * 2. Check the length of the signature:\n *    - If the signature is 64 bytes, extract `v` and `s` from the signature.\n *    - If the signature is 65 bytes, extract `v`, `r`, and `s` from the signature.\n * 3. Store the hash, `r`, `s`, and `v` in memory for the `ecrecover` operation.\n * 4. Use `staticcall` to invoke the `ecrecover` precompiled contract (address 1).\n * 5. Check the `returndatasize` to determine if the recovery was successful:\n *    - If successful, return the recovered address.\n *    - If unsuccessful, return 0.\n * 6. Restore the free memory pointer and zero slot to clean up memory.\n */"
        },
        {
            "identifier": "tryRecoverCalldata",
            "parameters": "bytes32 hash, bytes calldata signature",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function tryRecoverCalldata(bytes32 hash, bytes calldata signature)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let m := mload(0x40) } 1 {} {\n                switch signature.length\n                case 64 {\n                    let vs := calldataload(add(signature.offset, 0x20))\n                    mstore(0x20, add(shr(255, vs), 27)) // `v`.\n                    mstore(0x40, calldataload(signature.offset)) // `r`.\n                    mstore(0x60, shr(1, shl(1, vs))) // `s`.\n                }\n                case 65 {\n                    mstore(0x20, byte(0, calldataload(add(signature.offset, 0x40)))) // `v`.\n                    calldatacopy(0x40, signature.offset, 0x40) // Copy `r` and `s`.\n                }\n                default { break }\n                mstore(0x00, hash)\n                pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n                mstore(0x60, 0) // Restore the zero slot.\n                // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n                result := mload(xor(0x60, returndatasize()))\n                mstore(0x40, m) // Restore the free memory pointer.\n                break\n            }\n        }\n    }",
            "start": "202",
            "end": "231",
            "class": "ECDSA",
            "signature": "returns (address result) tryRecoverCalldatabytes32 hash, bytes calldata signature",
            "full_signature": "function tryRecoverCalldata(bytes32 hash, bytes calldata signature) internal  view returns (address result)",
            "class_method_signature": "ECDSA.tryRecoverCalldatabytes32 hash, bytes calldata signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to recover the signer's address from a given hash and signature using inline assembly.\n *\n * @param hash The hash of the data that was signed.\n * @param signature The signature to recover the signer's address from.\n * @return result The address of the signer if the recovery is successful, otherwise returns 0.\n *\n * Steps:\n * 1. Load the free memory pointer into `m`.\n * 2. Check the length of the signature:\n *    - If the signature length is 64 bytes:\n *      a. Extract `v` from the signature and adjust it to the correct format.\n *      b. Extract `r` and `s` from the signature.\n *    - If the signature length is 65 bytes:\n *      a. Extract `v` from the signature.\n *      b. Copy `r` and `s` from the signature.\n *    - If the signature length is neither 64 nor 65 bytes, break out of the loop.\n * 3. Store the hash at memory location 0x00.\n * 4. Perform a static call to the `ecrecover` precompiled contract (address 1) to recover the signer's address.\n * 5. Check the return data size to determine if the recovery was successful:\n *    - If successful, store the recovered address in `result`.\n *    - If unsuccessful, store 0 in `result`.\n * 6. Restore the zero slot and free memory pointer.\n * 7. Return the result.\n */"
        },
        {
            "identifier": "tryRecover",
            "parameters": "bytes32 hash, bytes32 r, bytes32 vs",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function tryRecover(bytes32 hash, bytes32 r, bytes32 vs)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, add(shr(255, vs), 27)) // `v`.\n            mstore(0x40, r)\n            mstore(0x60, shr(1, shl(1, vs))) // `s`.\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "235",
            "end": "253",
            "class": "ECDSA",
            "signature": "returns (address result) tryRecoverbytes32 hash, bytes32 r, bytes32 vs",
            "full_signature": "function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal  view returns (address result)",
            "class_method_signature": "ECDSA.tryRecoverbytes32 hash, bytes32 r, bytes32 vs",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to recover the signer's address from a given hash and signature components (r, vs).\n *\n * @param hash The hash of the message that was signed.\n * @param r The first 32 bytes of the signature.\n * @param vs The last 64 bytes of the signature, where the first 32 bytes represent `s` and the last byte represents `v`.\n * @return result The address of the signer if the recovery is successful, otherwise returns `0x0`.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the hash in memory at position 0x00.\n * 3. Extract and store the `v` component of the signature in memory at position 0x20.\n * 4. Store the `r` component of the signature in memory at position 0x40.\n * 5. Extract and store the `s` component of the signature in memory at position 0x60.\n * 6. Perform a static call to the `ecrecover` precompiled contract (address 1) to recover the signer's address.\n * 7. Restore the zero slot in memory.\n * 8. Retrieve the result from memory, which will be the signer's address if the recovery was successful, or `0x0` otherwise.\n * 9. Restore the free memory pointer.\n */"
        },
        {
            "identifier": "tryRecover",
            "parameters": "bytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s)\n        internal\n        view\n        returns (address result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x00, hash)\n            mstore(0x20, and(v, 0xff))\n            mstore(0x40, r)\n            mstore(0x60, s)\n            pop(staticcall(gas(), 1, 0x00, 0x80, 0x40, 0x20))\n            mstore(0x60, 0) // Restore the zero slot.\n            // `returndatasize()` will be `0x20` upon success, and `0x00` otherwise.\n            result := mload(xor(0x60, returndatasize()))\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "257",
            "end": "275",
            "class": "ECDSA",
            "signature": "returns (address result) tryRecoverbytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "full_signature": "function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal  view returns (address result)",
            "class_method_signature": "ECDSA.tryRecoverbytes32 hash, uint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to recover the signer address from a given hash and signature components.\n *\n * @param hash The hash of the message that was signed.\n * @param v The recovery byte of the signature.\n * @param r The first 32 bytes of the signature.\n * @param s The second 32 bytes of the signature.\n * @return result The address of the signer if the recovery is successful, otherwise returns `0x0`.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the hash, `v`, `r`, and `s` in memory at specific offsets.\n * 3. Perform a static call to the `ecrecover` precompiled contract (address `1`) to recover the signer address.\n * 4. Restore the zero slot in memory.\n * 5. Check the return data size to determine if the recovery was successful.\n * 6. Load the recovered address into `result`.\n * 7. Restore the free memory pointer.\n *\n * Note: This function uses inline assembly for low-level memory manipulation and interaction with the `ecrecover` precompiled contract.\n */"
        },
        {
            "identifier": "toEthSignedMessageHash",
            "parameters": "bytes32 hash",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, hash) // Store into scratch space for keccak256.\n            mstore(0x00, \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\") // 28 bytes.\n            result := keccak256(0x04, 0x3c) // `32 * 2 - (32 - 28) = 60 = 0x3c`.\n        }\n    }",
            "start": "285",
            "end": "292",
            "class": "ECDSA",
            "signature": "returns (bytes32 result) toEthSignedMessageHashbytes32 hash",
            "full_signature": "function toEthSignedMessageHash(bytes32 hash) internal  pure returns (bytes32 result)",
            "class_method_signature": "ECDSA.toEthSignedMessageHashbytes32 hash",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a bytes32 hash into an Ethereum signed message hash.\n * \n * @dev This function prepends the Ethereum signed message prefix to the hash and then computes the keccak256 hash of the result.\n * The prefix is \"\\x00\\x00\\x00\\x00\\x19Ethereum Signed Message:\\n32\", which is 28 bytes long.\n * The function uses inline assembly to efficiently perform the operation.\n * \n * @param hash The original bytes32 hash to be converted.\n * @return result The resulting Ethereum signed message hash.\n * \n * Steps:\n * 1. Store the original hash in memory at position 0x20.\n * 2. Store the Ethereum signed message prefix in memory at position 0x00.\n * 3. Compute the keccak256 hash of the combined prefix and hash, starting from byte 0x04 and spanning 0x3c (60) bytes.\n * 4. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "toEthSignedMessageHash",
            "parameters": "bytes memory s",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let sLength := mload(s)\n            let o := 0x20\n            mstore(o, \"\\x19Ethereum Signed Message:\\n\") // 26 bytes, zero-right-padded.\n            mstore(0x00, 0x00)\n            // Convert the `s.length` to ASCII decimal representation: `base10(s.length)`.\n            for { let temp := sLength } 1 {} {\n                o := sub(o, 1)\n                mstore8(o, add(48, mod(temp, 10)))\n                temp := div(temp, 10)\n                if iszero(temp) { break }\n            }\n            let n := sub(0x3a, o) // Header length: `26 + 32 - o`.\n            // Throw an out-of-offset error (consumes all gas) if the header exceeds 32 bytes.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0x20))\n            mstore(s, or(mload(0x00), mload(n))) // Temporarily store the header.\n            result := keccak256(add(s, sub(0x20, n)), add(n, sLength))\n            mstore(s, sLength) // Restore the length.\n        }\n    }",
            "start": "299",
            "end": "320",
            "class": "ECDSA",
            "signature": "returns (bytes32 result) toEthSignedMessageHashbytes memory s",
            "full_signature": "function toEthSignedMessageHash(bytes memory s) internal  pure returns (bytes32 result)",
            "class_method_signature": "ECDSA.toEthSignedMessageHashbytes memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a byte array into an Ethereum signed message hash.\n *\n * @param s The byte array to be converted into a signed message hash.\n * @return result The resulting Ethereum signed message hash.\n *\n * Steps:\n * 1. Load the length of the byte array `s`.\n * 2. Prepare the Ethereum signed message prefix: \"\\x19Ethereum Signed Message:\\n\".\n * 3. Convert the length of `s` into its ASCII decimal representation.\n * 4. Calculate the header length, which includes the prefix and the length of `s`.\n * 5. Ensure the header does not exceed 32 bytes; otherwise, throw an out-of-offset error.\n * 6. Temporarily store the header in memory.\n * 7. Compute the Keccak-256 hash of the combined header and the original byte array `s`.\n * 8. Restore the original length of `s` in memory.\n * 9. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "canonicalHash",
            "parameters": "bytes memory signature",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function canonicalHash(bytes memory signature) internal pure returns (bytes32 result) {\n        // @solidity memory-safe-assembly\n        assembly {\n            let l := mload(signature)\n            for {} 1 {} {\n                mstore(0x00, mload(add(signature, 0x20))) // `r`.\n                let s := mload(add(signature, 0x40))\n                let v := mload(add(signature, 0x41))\n                if eq(l, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(l, 64), 2)) {\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(add(signature, 0x20), l), 0xd62f1ab2)\n            }\n        }\n    }",
            "start": "335",
            "end": "364",
            "class": "ECDSA",
            "signature": "returns (bytes32 result) canonicalHashbytes memory signature",
            "full_signature": "function canonicalHash(bytes memory signature) internal  pure returns (bytes32 result)",
            "class_method_signature": "ECDSA.canonicalHashbytes memory signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the canonical hash of a given signature.\n *\n * @dev This function processes the signature to generate a canonical hash. It handles both 64-byte and 65-byte signatures.\n *      For 64-byte signatures, it adjusts the `v` value and ensures `s` is within the valid range.\n *      For 65-byte signatures, it uses the provided `v` and `s` values directly.\n *      If the signature length is neither 64 nor 65 bytes, it returns a uniquely corrupted hash.\n *\n * @param signature The signature bytes to be hashed.\n * @return result The canonical hash of the signature.\n *\n * Steps:\n * 1. Load the length of the signature.\n * 2. For 64-byte signatures:\n *    a. Adjust the `v` value by adding 27 to the shifted `s` value.\n *    b. Ensure `s` is within the valid range by shifting and masking.\n * 3. For 65-byte signatures:\n *    a. Use the provided `v` and `s` values directly.\n * 4. If `s` is not less than `_HALF_N_PLUS_1`, adjust `v` and `s` to ensure canonical form.\n * 5. Compute the Keccak-256 hash of the processed signature.\n * 6. If the signature length is invalid, return a uniquely corrupted hash.\n */"
        },
        {
            "identifier": "canonicalHashCalldata",
            "parameters": "bytes calldata signature",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function canonicalHashCalldata(bytes calldata signature)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        // @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                mstore(0x00, calldataload(signature.offset)) // `r`.\n                let s := calldataload(add(signature.offset, 0x20))\n                let v := calldataload(add(signature.offset, 0x21))\n                if eq(signature.length, 64) {\n                    v := add(shr(255, s), 27)\n                    s := shr(1, shl(1, s))\n                }\n                if iszero(lt(s, _HALF_N_PLUS_1)) {\n                    v := xor(v, 7)\n                    s := sub(N, s)\n                }\n                mstore(0x21, v)\n                mstore(0x20, s)\n                result := keccak256(0x00, 0x41)\n                mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n                break\n            }\n            // If the length is neither 64 nor 65, return a uniquely corrupted hash.\n            if iszero(lt(sub(signature.length, 64), 2)) {\n                calldatacopy(mload(0x40), signature.offset, signature.length)\n                // `bytes4(keccak256(\"InvalidSignatureLength\"))`.\n                result := xor(keccak256(mload(0x40), signature.length), 0xd62f1ab2)\n            }\n        }\n    }",
            "start": "367",
            "end": "399",
            "class": "ECDSA",
            "signature": "returns (bytes32 result) canonicalHashCalldatabytes calldata signature",
            "full_signature": "function canonicalHashCalldata(bytes calldata signature) internal  pure returns (bytes32 result)",
            "class_method_signature": "ECDSA.canonicalHashCalldatabytes calldata signature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the canonical hash of a given signature calldata.\n *\n * @dev This function processes the signature calldata to generate a canonical hash.\n * It handles both 64-byte and 65-byte signatures, adjusting the `v` and `s` values\n * to ensure canonical representation. If the signature length is invalid, it returns\n * a uniquely corrupted hash to indicate an error.\n *\n * @param signature The signature calldata to be hashed.\n * @return result The canonical hash of the signature calldata.\n *\n * Steps:\n * 1. Load the `r` value from the signature calldata.\n * 2. Load the `s` and `v` values from the signature calldata.\n * 3. If the signature length is 64 bytes:\n *    - Adjust `v` to be either 27 or 28 based on the highest bit of `s`.\n *    - Ensure `s` is within the valid range by masking the highest bit.\n * 4. If `s` is not less than `_HALF_N_PLUS_1`, adjust `v` and `s` to ensure canonical form.\n * 5. Compute the Keccak-256 hash of the combined `r`, `s`, and `v` values.\n * 6. If the signature length is neither 64 nor 65 bytes, return a uniquely corrupted hash\n *    by XORing the hash of the signature with a specific error code.\n */"
        },
        {
            "identifier": "canonicalHash",
            "parameters": "bytes32 r, bytes32 vs",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function canonicalHash(bytes32 r, bytes32 vs) internal pure returns (bytes32 result) {\n        // @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            let v := add(shr(255, vs), 27)\n            let s := shr(1, shl(1, vs))\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "402",
            "end": "413",
            "class": "ECDSA",
            "signature": "returns (bytes32 result) canonicalHashbytes32 r, bytes32 vs",
            "full_signature": "function canonicalHash(bytes32 r, bytes32 vs) internal  pure returns (bytes32 result)",
            "class_method_signature": "ECDSA.canonicalHashbytes32 r, bytes32 vs",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the canonical hash using the provided `r` and `vs` values.\n *\n * @param r The first part of the signature (32 bytes).\n * @param vs The second part of the signature, containing `v` and `s` packed together.\n * @return result The computed Keccak-256 hash.\n *\n * Steps:\n * 1. Store `r` in memory at position `0x00`.\n * 2. Extract `v` from `vs` by shifting and adding 27.\n * 3. Extract `s` from `vs` by shifting and masking.\n * 4. Store `v` and `s` in memory at positions `0x21` and `0x20`, respectively.\n * 5. Compute the Keccak-256 hash of the memory range `0x00` to `0x41`.\n * 6. Restore the overwritten part of the free memory pointer by setting `0x21` to `0`.\n * 7. Return the computed hash.\n */"
        },
        {
            "identifier": "canonicalHash",
            "parameters": "uint8 v, bytes32 r, bytes32 s",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal pure returns (bytes32 result) {\n        // @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, r) // `r`.\n            if iszero(lt(s, _HALF_N_PLUS_1)) {\n                v := xor(v, 7)\n                s := sub(N, s)\n            }\n            mstore(0x21, v)\n            mstore(0x20, s)\n            result := keccak256(0x00, 0x41)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "416",
            "end": "429",
            "class": "ECDSA",
            "signature": "returns (bytes32 result) canonicalHashuint8 v, bytes32 r, bytes32 s",
            "full_signature": "function canonicalHash(uint8 v, bytes32 r, bytes32 s) internal  pure returns (bytes32 result)",
            "class_method_signature": "ECDSA.canonicalHashuint8 v, bytes32 r, bytes32 s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the canonical hash for a given set of ECDSA signature parameters (v, r, s).\n *\n * @param v The recovery byte of the ECDSA signature.\n * @param r The r component of the ECDSA signature.\n * @param s The s component of the ECDSA signature.\n * @return result The computed canonical hash as a bytes32 value.\n *\n * Steps:\n * 1. Store the `r` value in memory at position 0x00.\n * 2. Check if `s` is greater than or equal to `_HALF_N_PLUS_1` (a predefined constant).\n *    - If true, adjust `v` by XORing it with 7 and adjust `s` by subtracting it from `N` (a predefined constant).\n * 3. Store the adjusted `v` and `s` values in memory at positions 0x21 and 0x20, respectively.\n * 4. Compute the Keccak-256 hash of the memory range from 0x00 to 0x41 (65 bytes).\n * 5. Restore the overwritten part of the free memory pointer by setting memory at 0x21 to 0.\n * 6. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "emptySignature",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes calldata signature)",
            "body": "function emptySignature() internal pure returns (bytes calldata signature) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            signature.length := 0\n        }\n    }",
            "start": "436",
            "end": "441",
            "class": "ECDSA",
            "signature": "returns (bytes calldata signature) emptySignature",
            "full_signature": "function emptySignature() internal  pure returns (bytes calldata signature)",
            "class_method_signature": "ECDSA.emptySignature",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns an empty signature in the form of a `bytes calldata` object.\n *\n * This function is marked as `internal` and `pure`, meaning it does not modify the state and can only be called internally.\n * It uses inline assembly to set the length of the signature to 0, effectively returning an empty signature.\n *\n * @return signature An empty `bytes calldata` object with a length of 0.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EnumerableSetLib.sol": [
        {
            "identifier": "length",
            "parameters": "AddressSet storage set",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function length(AddressSet storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := shr(1, n)\n            for {} iszero(or(iszero(shr(96, rootPacked)), n)) {} {\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }",
            "start": "96",
            "end": "112",
            "class": "EnumerableSetLib",
            "signature": "returns (uint256 result) lengthAddressSet storage set",
            "full_signature": "function length(AddressSet storage set) internal  view returns (uint256 result)",
            "class_method_signature": "EnumerableSetLib.lengthAddressSet storage set",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns the length of the AddressSet, which represents the number of unique addresses stored in the set.\n *\n * @param set The AddressSet storage reference to query.\n * @return result The number of unique addresses in the set.\n *\n * Steps:\n * 1. Retrieve the root slot of the AddressSet.\n * 2. Use inline assembly to:\n *    a. Load the packed data from the root slot.\n *    b. Extract the number of addresses (`n`) from the packed data.\n *    c. Calculate the result by shifting bits to isolate the length.\n *    d. Iterate through the set to determine the exact length if necessary.\n * 3. Return the calculated length.\n *\n * @dev This function uses low-level assembly for efficient storage access and bit manipulation.\n */"
        },
        {
            "identifier": "length",
            "parameters": "Bytes32Set storage set",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function length(Bytes32Set storage set) internal view returns (uint256 result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := sload(not(rootSlot))\n            result := shr(1, n)\n            for {} iszero(n) {} {\n                result := 0\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 1\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 2\n                if iszero(sload(add(rootSlot, result))) { break }\n                result := 3\n                break\n            }\n        }\n    }",
            "start": "115",
            "end": "132",
            "class": "EnumerableSetLib",
            "signature": "returns (uint256 result) lengthBytes32Set storage set",
            "full_signature": "function length(Bytes32Set storage set) internal  view returns (uint256 result)",
            "class_method_signature": "EnumerableSetLib.lengthBytes32Set storage set",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns the length of a Bytes32Set by inspecting its storage slots.\n *\n * @dev This function uses low-level assembly to read the length of the set.\n * It first retrieves the root slot of the set and then checks the storage slots\n * to determine the length. The function is memory-safe and optimized for gas efficiency.\n *\n * @param set The Bytes32Set storage reference to query.\n * @return result The length of the set, determined by inspecting the storage slots.\n *\n * Steps:\n * 1. Retrieve the root slot of the set.\n * 2. Use assembly to load the value from the root slot.\n * 3. Shift the value right by 1 to get the length.\n * 4. If the length is zero, check the first few slots to determine if the set is empty.\n * 5. Return the calculated length.\n */"
        },
        {
            "identifier": "length",
            "parameters": "Uint8Set storage set",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function length(Uint8Set storage set) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let packed := sload(set.slot) } packed { result := add(1, result) } {\n                packed := xor(packed, and(packed, add(1, not(packed))))\n            }\n        }\n    }",
            "start": "145",
            "end": "152",
            "class": "EnumerableSetLib",
            "signature": "returns (uint256 result) lengthUint8Set storage set",
            "full_signature": "function length(Uint8Set storage set) internal  view returns (uint256 result)",
            "class_method_signature": "EnumerableSetLib.lengthUint8Set storage set",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns the number of elements in a Uint8Set.\n *\n * @dev This function uses low-level assembly to efficiently count the number of elements in the set.\n * It iterates through the packed storage slot of the set, counting the number of set bits (1s) in the packed data.\n *\n * @param set The Uint8Set storage reference to query.\n * @return result The number of elements in the set.\n *\n * Steps:\n * 1. Load the packed data from the set's storage slot.\n * 2. Iterate through the packed data, counting the number of set bits (1s) using bitwise operations.\n * 3. Return the count of set bits, which represents the number of elements in the set.\n */"
        },
        {
            "identifier": "contains",
            "parameters": "AddressSet storage set, address value",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function contains(AddressSet storage set, address value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for {} 1 {} {\n                if iszero(shr(160, shl(160, rootPacked))) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) { break }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }",
            "start": "155",
            "end": "181",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) containsAddressSet storage set, address value",
            "full_signature": "function contains(AddressSet storage set, address value) internal  view returns (bool result)",
            "class_method_signature": "EnumerableSetLib.containsAddressSet storage set, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given address exists in the AddressSet.\n *\n * @dev This function uses low-level assembly to optimize gas usage and handle edge cases.\n * It checks if the provided address is the zero sentinel value and reverts if so.\n * It then checks if the address exists in the set by traversing the storage slots.\n *\n * @param set The AddressSet storage reference to check against.\n * @param value The address to check for existence in the set.\n * @return result A boolean indicating whether the address exists in the set.\n *\n * Steps:\n * 1. Retrieve the root slot of the set.\n * 2. Use assembly to handle the address value:\n *    - Shift the address to ensure it is properly aligned.\n *    - Revert if the address is the zero sentinel value.\n *    - Replace a zero address with the zero sentinel value.\n * 3. Load the packed root value from storage.\n * 4. Traverse the storage slots to check if the address exists:\n *    - If the root is not packed, check the first three slots directly.\n *    - If the root is packed, compute the storage slot using keccak256 and check the value.\n * 5. Return the result indicating whether the address exists in the set.\n */"
        },
        {
            "identifier": "contains",
            "parameters": "Bytes32Set storage set, bytes32 value",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for {} 1 {} {\n                if iszero(sload(not(rootSlot))) {\n                    result := 1\n                    if eq(sload(rootSlot), value) { break }\n                    if eq(sload(add(rootSlot, 1)), value) { break }\n                    if eq(sload(add(rootSlot, 2)), value) { break }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                result := iszero(iszero(sload(keccak256(0x00, 0x40))))\n                break\n            }\n        }\n    }",
            "start": "184",
            "end": "208",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) containsBytes32Set storage set, bytes32 value",
            "full_signature": "function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)",
            "class_method_signature": "EnumerableSetLib.containsBytes32Set storage set, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given value exists in a Bytes32Set.\n *\n * @param set The storage reference to the Bytes32Set.\n * @param value The value to check for existence in the set.\n * @return result A boolean indicating whether the value exists in the set.\n *\n * Steps:\n * 1. Retrieve the root slot of the set.\n * 2. Use assembly to perform low-level operations for efficiency.\n * 3. If the value is the zero sentinel, revert with an error indicating that the value is invalid.\n * 4. If the value is zero, replace it with the zero sentinel.\n * 5. Iterate through the set to check if the value exists:\n *    - If the root slot is empty, the value does not exist.\n *    - If the value matches any of the first three slots, it exists.\n *    - Otherwise, compute the hash of the value and check if it exists in the set.\n * 6. Return the result indicating whether the value was found.\n */"
        },
        {
            "identifier": "contains",
            "parameters": "Uint8Set storage set, uint8 value",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function contains(Uint8Set storage set, uint8 value) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(1, shr(and(0xff, value), sload(set.slot)))\n        }\n    }",
            "start": "221",
            "end": "226",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) containsUint8Set storage set, uint8 value",
            "full_signature": "function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)",
            "class_method_signature": "EnumerableSetLib.containsUint8Set storage set, uint8 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given value exists in a Uint8Set.\n *\n * @param set The Uint8Set storage reference to check.\n * @param value The uint8 value to check for existence in the set.\n * @return result A boolean indicating whether the value exists in the set (true) or not (false).\n *\n * Steps:\n * 1. Use inline assembly to perform bitwise operations:\n *    - Extract the relevant bit from the storage slot of the set.\n *    - Shift and mask the value to determine if the bit is set (indicating the value exists in the set).\n * 2. Return the result as a boolean.\n */"
        },
        {
            "identifier": "add",
            "parameters": "AddressSet storage set, address value",
            "modifiers": "",
            "return": "returns (bool result)",
            "body": "function add(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := shr(96, rootPacked)\n                    if iszero(v0) {\n                        sstore(rootSlot, shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := shr(96, sload(add(rootSlot, 1)))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := shr(96, sload(add(rootSlot, 2)))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), shl(96, value))\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    rootPacked := or(rootPacked, 7)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    result := 1\n                    sstore(p, add(1, n))\n                    if iszero(n) {\n                        sstore(rootSlot, or(3, shl(96, value)))\n                        break\n                    }\n                    sstore(add(rootSlot, n), shl(96, value))\n                    sstore(rootSlot, add(2, rootPacked))\n                    break\n                }\n                break\n            }\n        }\n    }",
            "start": "229",
            "end": "290",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) addAddressSet storage set, address value",
            "full_signature": "function add(AddressSet storage set, address value) internal   returns (bool result)",
            "class_method_signature": "EnumerableSetLib.addAddressSet storage set, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Adds an address to the AddressSet if it is not already present.\n *\n * @dev This function uses low-level assembly to manipulate storage slots directly.\n * It ensures that the address is not the zero sentinel value and handles the addition\n * of the address to the set in a memory-safe manner.\n *\n * @param set The AddressSet storage reference where the address will be added.\n * @param value The address to be added to the set.\n * @return result A boolean indicating whether the address was successfully added (true) or already existed (false).\n *\n * Steps:\n * 1. Retrieve the root slot of the AddressSet.\n * 2. Use assembly to:\n *    - Ensure the address is not the zero sentinel value; revert if it is.\n *    - Handle the case where the address is zero by replacing it with the zero sentinel.\n *    - Load the packed root value from storage.\n *    - Iterate through the set to check if the address already exists.\n *    - If the address does not exist, add it to the set and update the root slot.\n *    - Return true if the address was added, false if it already existed.\n *\n * Reverts:\n * - If the address is the zero sentinel value, reverts with the error `ValueIsZeroSentinel()`.\n */"
        },
        {
            "identifier": "add",
            "parameters": "Bytes32Set storage set, bytes32 value",
            "modifiers": "",
            "return": "returns (bool result)",
            "body": "function add(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                mstore(0x20, rootSlot)\n                if iszero(n) {\n                    let v0 := sload(rootSlot)\n                    if iszero(v0) {\n                        sstore(rootSlot, value)\n                        result := 1\n                        break\n                    }\n                    if eq(v0, value) { break }\n                    let v1 := sload(add(rootSlot, 1))\n                    if iszero(v1) {\n                        sstore(add(rootSlot, 1), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v1, value) { break }\n                    let v2 := sload(add(rootSlot, 2))\n                    if iszero(v2) {\n                        sstore(add(rootSlot, 2), value)\n                        result := 1\n                        break\n                    }\n                    if eq(v2, value) { break }\n                    mstore(0x00, v0)\n                    sstore(keccak256(0x00, 0x40), 1)\n                    mstore(0x00, v1)\n                    sstore(keccak256(0x00, 0x40), 2)\n                    mstore(0x00, v2)\n                    sstore(keccak256(0x00, 0x40), 3)\n                    n := 7\n                }\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                if iszero(sload(p)) {\n                    n := shr(1, n)\n                    sstore(add(rootSlot, n), value)\n                    sstore(p, add(1, n))\n                    sstore(not(rootSlot), or(1, shl(1, add(1, n))))\n                    result := 1\n                    break\n                }\n                break\n            }\n        }\n    }",
            "start": "293",
            "end": "347",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) addBytes32Set storage set, bytes32 value",
            "full_signature": "function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)",
            "class_method_signature": "EnumerableSetLib.addBytes32Set storage set, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Adds a value to a Bytes32Set storage set. This function ensures that the value is not zero or the zero sentinel.\n * If the value is zero, it is replaced with the zero sentinel. The function uses low-level assembly for efficient storage operations.\n *\n * @param set The storage set to which the value will be added.\n * @param value The value to be added to the set.\n * @return result A boolean indicating whether the value was successfully added (true) or not (false).\n *\n * Steps:\n * 1. Retrieve the root slot of the set.\n * 2. Check if the value is the zero sentinel. If so, revert with an error.\n * 3. If the value is zero, replace it with the zero sentinel.\n * 4. Iterate through the set to find an empty slot or a slot that already contains the value.\n * 5. If an empty slot is found, store the value and update the set's metadata.\n * 6. If the value is already present in the set, do not add it again.\n * 7. Return true if the value was added, otherwise return false.\n *\n * Assembly Details:\n * - The function uses inline assembly to directly manipulate storage slots for efficiency.\n * - It checks for the zero sentinel and handles zero values appropriately.\n * - It iterates through the set's slots and updates the set's metadata to reflect the addition of the new value.\n */"
        },
        {
            "identifier": "add",
            "parameters": "Uint8Set storage set, uint8 value",
            "modifiers": "",
            "return": "returns (bool result)",
            "body": "function add(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, or(result, mask))\n            result := iszero(and(result, mask))\n        }\n    }",
            "start": "360",
            "end": "368",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) addUint8Set storage set, uint8 value",
            "full_signature": "function add(Uint8Set storage set, uint8 value) internal   returns (bool result)",
            "class_method_signature": "EnumerableSetLib.addUint8Set storage set, uint8 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Adds a uint8 value to a Uint8Set storage set using low-level assembly for efficiency.\n *\n * @param set The storage set to which the value will be added.\n * @param value The uint8 value to add to the set.\n * @return result A boolean indicating whether the value was successfully added (true if added, false if already present).\n *\n * Steps:\n * 1. Load the current value of the set from storage.\n * 2. Create a bitmask by shifting 1 to the left by the value's position (using `and(0xff, value)` to ensure it's within 8 bits).\n * 3. Store the updated set value by performing a bitwise OR operation between the current value and the mask.\n * 4. Check if the value was already present by performing a bitwise AND operation between the current value and the mask.\n * 5. Return `true` if the value was not already present (i.e., the AND result is zero), otherwise return `false`.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "AddressSet storage set, address value",
            "modifiers": "",
            "return": "returns (bool result)",
            "body": "function remove(AddressSet storage set, address value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            value := shr(96, shl(96, value))\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            let rootPacked := sload(rootSlot)\n            for { let n := shr(160, shl(160, rootPacked)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(shr(96, rootPacked), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 1))), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(shr(96, sload(add(rootSlot, 2))), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := shr(96, sload(add(rootSlot, n)))\n                    sstore(add(rootSlot, sub(position, 1)), shl(96, lastValue))\n                    sstore(add(rootSlot, n), 0)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(rootSlot, or(shl(96, shr(96, sload(rootSlot))), or(shl(1, n), 1)))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }",
            "start": "371",
            "end": "422",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) removeAddressSet storage set, address value",
            "full_signature": "function remove(AddressSet storage set, address value) internal   returns (bool result)",
            "class_method_signature": "EnumerableSetLib.removeAddressSet storage set, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Removes a specific address from an AddressSet storage structure.\n *\n * @param set The AddressSet storage reference from which the address will be removed.\n * @param value The address to be removed from the set.\n * @return result A boolean indicating whether the removal was successful (true) or not (false).\n *\n * Steps:\n * 1. Retrieve the root slot of the AddressSet.\n * 2. Perform low-level assembly operations to manipulate the storage:\n *    - Ensure the address is properly aligned and not the zero sentinel.\n *    - If the address is zero, replace it with the zero sentinel.\n *    - Load the packed root data from storage.\n *    - Iterate through the set to find the address:\n *      - If the address is found, update the storage to remove it and adjust the set structure.\n *      - If the address is not found, return false.\n * 3. Return the result of the operation.\n *\n * Reverts:\n * - If the address is the zero sentinel, the function reverts with the error `ValueIsZeroSentinel()`.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Bytes32Set storage set, bytes32 value",
            "modifiers": "",
            "return": "returns (bool result)",
            "body": "function remove(Bytes32Set storage set, bytes32 value) internal returns (bool result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(value, _ZERO_SENTINEL) {\n                mstore(0x00, 0xf5a267f1) // `ValueIsZeroSentinel()`.\n                revert(0x1c, 0x04)\n            }\n            if iszero(value) { value := _ZERO_SENTINEL }\n            for { let n := sload(not(rootSlot)) } 1 {} {\n                if iszero(n) {\n                    result := 1\n                    if eq(sload(rootSlot), value) {\n                        sstore(rootSlot, sload(add(rootSlot, 1)))\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 1)), value) {\n                        sstore(add(rootSlot, 1), sload(add(rootSlot, 2)))\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    if eq(sload(add(rootSlot, 2)), value) {\n                        sstore(add(rootSlot, 2), 0)\n                        break\n                    }\n                    result := 0\n                    break\n                }\n                mstore(0x20, rootSlot)\n                mstore(0x00, value)\n                let p := keccak256(0x00, 0x40)\n                let position := sload(p)\n                if iszero(position) { break }\n                n := sub(shr(1, n), 1)\n                if iszero(eq(sub(position, 1), n)) {\n                    let lastValue := sload(add(rootSlot, n))\n                    sstore(add(rootSlot, sub(position, 1)), lastValue)\n                    sstore(add(rootSlot, n), 0)\n                    mstore(0x00, lastValue)\n                    sstore(keccak256(0x00, 0x40), position)\n                }\n                sstore(not(rootSlot), or(shl(1, n), 1))\n                sstore(p, 0)\n                result := 1\n                break\n            }\n        }\n    }",
            "start": "425",
            "end": "474",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) removeBytes32Set storage set, bytes32 value",
            "full_signature": "function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)",
            "class_method_signature": "EnumerableSetLib.removeBytes32Set storage set, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Removes a value from a Bytes32Set storage set.\n *\n * @param set The storage set from which the value will be removed.\n * @param value The value to be removed from the set.\n * @return result A boolean indicating whether the value was successfully removed (true) or not (false).\n *\n * Steps:\n * 1. Retrieve the root slot of the set.\n * 2. Check if the value is the zero sentinel (`_ZERO_SENTINEL`). If so, revert with an error.\n * 3. If the value is zero, replace it with the zero sentinel.\n * 4. Iterate through the set to find the value:\n *    - If the value is found in the root slot or its adjacent slots, update the slots and mark the value as removed.\n *    - If the value is not found, return false.\n * 5. If the value is found in a deeper position, update the set's structure to maintain consistency and mark the value as removed.\n * 6. Return true if the value was successfully removed, otherwise return false.\n *\n * @dev This function uses low-level assembly for efficient storage manipulation.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Uint8Set storage set, uint8 value",
            "modifiers": "",
            "return": "returns (bool result)",
            "body": "function remove(Uint8Set storage set, uint8 value) internal returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(set.slot)\n            let mask := shl(and(0xff, value), 1)\n            sstore(set.slot, and(result, not(mask)))\n            result := iszero(iszero(and(result, mask)))\n        }\n    }",
            "start": "487",
            "end": "495",
            "class": "EnumerableSetLib",
            "signature": "returns (bool result) removeUint8Set storage set, uint8 value",
            "full_signature": "function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)",
            "class_method_signature": "EnumerableSetLib.removeUint8Set storage set, uint8 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Removes a specific value from a Uint8Set storage set.\n *\n * @param set The storage set from which the value will be removed.\n * @param value The value to be removed from the set.\n * @return result A boolean indicating whether the value was successfully removed (true if the value was present and removed, false otherwise).\n *\n * Steps:\n * 1. Load the current value of the set from storage.\n * 2. Create a mask by shifting 1 to the left by the value's position.\n * 3. Update the set in storage by applying the mask to clear the bit corresponding to the value.\n * 4. Determine if the value was present in the set by checking the bit before clearing it.\n * 5. Return the result indicating whether the value was removed.\n *\n * @dev This function uses inline assembly for low-level storage manipulation.\n */"
        },
        {
            "identifier": "values",
            "parameters": "AddressSet storage set",
            "modifiers": "view",
            "return": "returns (address[] memory result)",
            "body": "function values(AddressSet storage set) internal view returns (address[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let rootPacked := sload(rootSlot)\n            let n := shr(160, shl(160, rootPacked))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            let v := shr(96, rootPacked)\n            mstore(o, mul(v, iszero(eq(v, zs))))\n            for {} 1 {} {\n                if iszero(n) {\n                    if v {\n                        n := 1\n                        v := shr(96, sload(add(rootSlot, n)))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := shr(96, sload(add(rootSlot, n)))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 1 } lt(i, n) { i := add(i, 1) } {\n                    v := shr(96, sload(add(rootSlot, i)))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "start": "499",
            "end": "537",
            "class": "EnumerableSetLib",
            "signature": "returns (address[] memory result) valuesAddressSet storage set",
            "full_signature": "function values(AddressSet storage set) internal  view returns (address[] memory result)",
            "class_method_signature": "EnumerableSetLib.valuesAddressSet storage set",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the list of addresses stored in the AddressSet.\n *\n * @param set The AddressSet storage reference from which to retrieve the values.\n * @return result An array of addresses stored in the AddressSet.\n *\n * Steps:\n * 1. Calculate the root slot for the AddressSet.\n * 2. Use inline assembly to efficiently load and process the addresses:\n *    - Load the root packed value from storage.\n *    - Determine the number of addresses (`n`) stored in the set.\n *    - Allocate memory for the result array.\n *    - Iterate through the stored addresses, skipping the zero sentinel value.\n *    - Store the valid addresses in the result array.\n *    - Update the memory pointer to reflect the allocated space.\n * 3. Return the array of addresses.\n *\n * @dev This function uses low-level assembly for gas optimization and memory safety.\n */ "
        },
        {
            "identifier": "values",
            "parameters": "Bytes32Set storage set",
            "modifiers": "view",
            "return": "returns (bytes32[] memory result)",
            "body": "function values(Bytes32Set storage set) internal view returns (bytes32[] memory result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let zs := _ZERO_SENTINEL\n            let n := sload(not(rootSlot))\n            result := mload(0x40)\n            let o := add(0x20, result)\n            for {} 1 {} {\n                if iszero(n) {\n                    let v := sload(rootSlot)\n                    if v {\n                        n := 1\n                        mstore(o, mul(v, iszero(eq(v, zs))))\n                        v := sload(add(rootSlot, n))\n                        if v {\n                            n := 2\n                            mstore(add(o, 0x20), mul(v, iszero(eq(v, zs))))\n                            v := sload(add(rootSlot, n))\n                            if v {\n                                n := 3\n                                mstore(add(o, 0x40), mul(v, iszero(eq(v, zs))))\n                            }\n                        }\n                    }\n                    break\n                }\n                n := shr(1, n)\n                for { let i := 0 } lt(i, n) { i := add(i, 1) } {\n                    let v := sload(add(rootSlot, i))\n                    mstore(add(o, shl(5, i)), mul(v, iszero(eq(v, zs))))\n                }\n                break\n            }\n            mstore(result, n)\n            mstore(0x40, add(o, shl(5, n)))\n        }\n    }",
            "start": "541",
            "end": "578",
            "class": "EnumerableSetLib",
            "signature": "returns (bytes32[] memory result) valuesBytes32Set storage set",
            "full_signature": "function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)",
            "class_method_signature": "EnumerableSetLib.valuesBytes32Set storage set",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the values stored in a Bytes32Set.\n *\n * @dev This function reads the values from the storage of a Bytes32Set and returns them as an array.\n * It uses low-level assembly to optimize gas usage and handle storage slots directly.\n *\n * @param set The Bytes32Set storage reference from which to retrieve values.\n * @return result An array of bytes32 values stored in the set.\n *\n * Steps:\n * 1. Determine the root slot of the set.\n * 2. Use assembly to:\n *    a. Load the number of elements in the set.\n *    b. Allocate memory for the result array.\n *    c. Iterate through the storage slots to retrieve each value.\n *    d. Store the retrieved values in the result array.\n *    e. Update the memory pointer to reflect the allocated space.\n * 3. Return the array of values.\n */"
        },
        {
            "identifier": "values",
            "parameters": "Uint8Set storage set",
            "modifiers": "view",
            "return": "returns (uint8[] memory result)",
            "body": "function values(Uint8Set storage set) internal view returns (uint8[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let ptr := add(result, 0x20)\n            let o := 0\n            for { let packed := sload(set.slot) } packed {} {\n                if iszero(and(packed, 0xffff)) {\n                    o := add(o, 16)\n                    packed := shr(16, packed)\n                    continue\n                }\n                mstore(ptr, o)\n                ptr := add(ptr, shl(5, and(packed, 1)))\n                o := add(o, 1)\n                packed := shr(1, packed)\n            }\n            mstore(result, shr(5, sub(ptr, add(result, 0x20))))\n            mstore(0x40, ptr)\n        }\n    }",
            "start": "593",
            "end": "613",
            "class": "EnumerableSetLib",
            "signature": "returns (uint8[] memory result) valuesUint8Set storage set",
            "full_signature": "function values(Uint8Set storage set) internal  view returns (uint8[] memory result)",
            "class_method_signature": "EnumerableSetLib.valuesUint8Set storage set",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the values stored in a `Uint8Set` as an array of `uint8`.\n *\n * @param set The `Uint8Set` storage reference from which to retrieve values.\n * @return result An array of `uint8` containing the values stored in the set.\n *\n * Steps:\n * 1. Allocate memory for the result array.\n * 2. Use assembly to efficiently iterate over the packed storage of the set.\n * 3. Unpack the values from the storage slot and store them in the result array.\n * 4. Update the free memory pointer to reflect the allocated memory.\n *\n * Note: This function uses low-level assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "at",
            "parameters": "AddressSet storage set, uint256 i",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function at(AddressSet storage set, uint256 i) internal view returns (address result) {\n        bytes32 rootSlot = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(96, sload(add(rootSlot, i)))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }",
            "start": "616",
            "end": "624",
            "class": "EnumerableSetLib",
            "signature": "returns (address result) atAddressSet storage set, uint256 i",
            "full_signature": "function at(AddressSet storage set, uint256 i) internal  view returns (address result)",
            "class_method_signature": "EnumerableSetLib.atAddressSet storage set, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the address at a specific index in an AddressSet.\n *\n * @param set The AddressSet storage reference from which to retrieve the address.\n * @param i The index of the address to retrieve.\n * @return result The address at the specified index.\n *\n * Steps:\n * 1. Calculate the root slot for the AddressSet.\n * 2. Use inline assembly to:\n *    - Load the address from the storage slot corresponding to the index.\n *    - Shift the address to the right by 96 bits to remove any padding.\n *    - Multiply the result by a check to ensure the address is not the zero sentinel.\n * 3. If the index is out of bounds (greater than or equal to the length of the set), revert with an \"IndexOutOfBounds\" error.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Bytes32Set storage set, uint256 i",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function at(Bytes32Set storage set, uint256 i) internal view returns (bytes32 result) {\n        result = _rootSlot(set);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := sload(add(result, i))\n            result := mul(result, iszero(eq(result, _ZERO_SENTINEL)))\n        }\n        if (i >= length(set)) revert IndexOutOfBounds();\n    }",
            "start": "627",
            "end": "635",
            "class": "EnumerableSetLib",
            "signature": "returns (bytes32 result) atBytes32Set storage set, uint256 i",
            "full_signature": "function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)",
            "class_method_signature": "EnumerableSetLib.atBytes32Set storage set, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the element at a specific index in a Bytes32Set storage set.\n *\n * @param set The Bytes32Set storage set from which to retrieve the element.\n * @param i The index of the element to retrieve.\n * @return result The element at the specified index.\n *\n * Steps:\n * 1. Retrieve the root slot of the set.\n * 2. Use assembly to load the element at the specified index from storage.\n * 3. If the element is the zero sentinel, return zero.\n * 4. Check if the index is out of bounds and revert if true.\n * 5. Return the retrieved element.\n *\n * @dev This function uses low-level assembly to directly interact with storage.\n *      It ensures that the index is within bounds and handles the zero sentinel case.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Uint8Set storage set, uint256 i",
            "modifiers": "view",
            "return": "returns (uint8 result)",
            "body": "function at(Uint8Set storage set, uint256 i) internal view returns (uint8 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let packed := sload(set.slot)\n            for {} 1 {\n                mstore(0x00, 0x4e23d035) // `IndexOutOfBounds()`.\n                revert(0x1c, 0x04)\n            } {\n                if iszero(lt(i, 256)) { continue }\n                for { let j := 0 } iszero(eq(i, j)) {} {\n                    packed := xor(packed, and(packed, add(1, not(packed))))\n                    j := add(j, 1)\n                }\n                if iszero(packed) { continue }\n                break\n            }\n            // Find first set subroutine, optimized for smaller bytecode size.\n            let x := and(packed, add(1, not(packed)))\n            let r := shl(7, iszero(iszero(shr(128, x))))\n            r := or(r, shl(6, iszero(iszero(shr(64, shr(r, x))))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            result := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }",
            "start": "648",
            "end": "674",
            "class": "EnumerableSetLib",
            "signature": "returns (uint8 result) atUint8Set storage set, uint256 i",
            "full_signature": "function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)",
            "class_method_signature": "EnumerableSetLib.atUint8Set storage set, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value at a specific index in a Uint8Set storage set.\n *\n * @dev This function uses low-level assembly to efficiently find the value at the specified index.\n * It performs a series of bitwise operations to locate the value and handles out-of-bounds errors.\n *\n * @param set The Uint8Set storage set to query.\n * @param i The index of the value to retrieve.\n * @return result The value at the specified index in the set.\n *\n * Steps:\n * 1. Load the packed data from the storage slot of the set.\n * 2. Check if the index is out of bounds (greater than or equal to 256). If so, revert with an \"IndexOutOfBounds\" error.\n * 3. Iterate through the packed data to find the value at the specified index.\n * 4. Use a De Bruijn lookup to efficiently determine the position of the set bit.\n * 5. Return the result, which is the value at the specified index.\n *\n * @custom:assembly The function uses inline assembly for optimized performance and smaller bytecode size.\n */"
        },
        {
            "identifier": "_toUints",
            "parameters": "bytes32[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function _toUints(bytes32[] memory a) private pure returns (uint256[] memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := a\n        }\n    }",
            "start": "717",
            "end": "722",
            "class": "EnumerableSetLib",
            "signature": "returns (uint256[] memory c) _toUintsbytes32[] memory a",
            "full_signature": "function _toUints(bytes32[] memory a) private  pure returns (uint256[] memory c)",
            "class_method_signature": "EnumerableSetLib._toUintsbytes32[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts an array of `bytes32` to an array of `uint256`.\n *\n * @param a The input array of `bytes32` values.\n * @return c The output array of `uint256` values, which is a direct memory reference to the input array.\n *\n * Steps:\n * 1. Use inline assembly to directly assign the memory reference of the input array `a` to the output array `c`.\n * 2. The conversion is memory-safe and leverages Solidity's assembly to avoid unnecessary copying.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibTransient.sol": [
        {
            "identifier": "tUint256",
            "parameters": "bytes32 tSlot",
            "modifiers": "pure",
            "return": "returns (TUint256 storage ptr)",
            "body": "function tUint256(bytes32 tSlot) internal pure returns (TUint256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "59",
            "end": "64",
            "class": "LibTransient",
            "signature": "returns (TUint256 storage ptr) tUint256bytes32 tSlot",
            "full_signature": "function tUint256(bytes32 tSlot) internal  pure returns (TUint256 storage ptr)",
            "class_method_signature": "LibTransient.tUint256bytes32 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a reference to a `TUint256` storage variable located at the specified slot.\n *\n * @param tSlot The storage slot where the `TUint256` variable is located.\n * @return ptr A reference to the `TUint256` storage variable at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided slot (`tSlot`) to the `slot` property of the `TUint256` storage pointer (`ptr`).\n * 2. Return the pointer to the `TUint256` storage variable.\n *\n * @dev This function is marked as `internal pure` and uses inline assembly for low-level storage manipulation.\n */"
        },
        {
            "identifier": "tUint256",
            "parameters": "uint256 tSlot",
            "modifiers": "pure",
            "return": "returns (TUint256 storage ptr)",
            "body": "function tUint256(uint256 tSlot) internal pure returns (TUint256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "67",
            "end": "72",
            "class": "LibTransient",
            "signature": "returns (TUint256 storage ptr) tUint256uint256 tSlot",
            "full_signature": "function tUint256(uint256 tSlot) internal  pure returns (TUint256 storage ptr)",
            "class_method_signature": "LibTransient.tUint256uint256 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a reference to a `TUint256` storage struct located at the specified storage slot.\n *\n * @param tSlot The storage slot where the `TUint256` struct is located.\n * @return ptr A reference to the `TUint256` storage struct at the given slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `slot` property of the `TUint256` struct.\n * 2. Return the reference to the `TUint256` struct.\n *\n * @dev This function is marked as `memory-safe-assembly` to ensure safe memory handling during assembly operations.\n */"
        },
        {
            "identifier": "get",
            "parameters": "TUint256 storage ptr",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function get(TUint256 storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "start": "75",
            "end": "80",
            "class": "LibTransient",
            "signature": "returns (uint256 result) getTUint256 storage ptr",
            "full_signature": "function get(TUint256 storage ptr) internal  view returns (uint256 result)",
            "class_method_signature": "LibTransient.getTUint256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the value stored at the given `TUint256` pointer.\n *\n * @param ptr The storage pointer of type `TUint256` from which to retrieve the value.\n * @return result The value stored at the provided storage pointer.\n *\n * Steps:\n * 1. Use inline assembly to load the value from the storage slot associated with the pointer.\n * 2. Return the loaded value as the result.\n *\n * @dev This function uses `tload` in assembly to directly access the storage slot of the pointer.\n */"
        },
        {
            "identifier": "set",
            "parameters": "TUint256 storage ptr, uint256 value",
            "modifiers": "",
            "return": "",
            "body": "function set(TUint256 storage ptr, uint256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "start": "88",
            "end": "93",
            "class": "LibTransient",
            "signature": " setTUint256 storage ptr, uint256 value",
            "full_signature": "function set(TUint256 storage ptr, uint256 value) internal",
            "class_method_signature": "LibTransient.setTUint256 storage ptr, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TUint256 storage pointer to a specified value.\n *\n * @param ptr The storage pointer of type TUint256 whose value is to be set.\n * @param value The value to be stored at the location pointed to by `ptr`.\n *\n * Steps:\n * 1. Use inline assembly to store the `value` at the storage slot of `ptr`.\n * 2. The `tstore` opcode is used to store the value directly in the specified storage slot.\n */"
        },
        {
            "identifier": "setCompat",
            "parameters": "TUint256 storage ptr, uint256 value",
            "modifiers": "",
            "return": "",
            "body": "function setCompat(TUint256 storage ptr, uint256 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = value;\n    }",
            "start": "96",
            "end": "99",
            "class": "LibTransient",
            "signature": " setCompatTUint256 storage ptr, uint256 value",
            "full_signature": "function setCompat(TUint256 storage ptr, uint256 value) internal",
            "class_method_signature": "LibTransient.setCompatTUint256 storage ptr, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TUint256 storage pointer, with compatibility handling for different chains.\n *\n * @param ptr The TUint256 storage pointer to be updated.\n * @param value The value to set for the TUint256 storage pointer.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum Mainnet), call the `set` function to update the value directly.\n * 2. For other chains, update the `_spacer` field of the compatibility structure (`_compat`) with the provided value.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "TUint256 storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clear(TUint256 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "start": "102",
            "end": "107",
            "class": "LibTransient",
            "signature": " clearTUint256 storage ptr",
            "full_signature": "function clear(TUint256 storage ptr) internal",
            "class_method_signature": "LibTransient.clearTUint256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the value stored at the given storage pointer.\n *\n * @param ptr The storage pointer to the uint256 value that needs to be cleared.\n *\n * Steps:\n * 1. Use inline assembly to set the value at the storage slot of the pointer to 0.\n * 2. This effectively clears the stored value at the specified location.\n */"
        },
        {
            "identifier": "clearCompat",
            "parameters": "TUint256 storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clearCompat(TUint256 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "start": "110",
            "end": "113",
            "class": "LibTransient",
            "signature": " clearCompatTUint256 storage ptr",
            "full_signature": "function clearCompat(TUint256 storage ptr) internal",
            "class_method_signature": "LibTransient.clearCompatTUint256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clears the storage pointer `ptr` in a way that is compatible with different chain IDs.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum Mainnet), call the `clear` function to reset the storage pointer.\n * 2. If the chain ID is not 1, set the `_spacer` field of the compatibility struct to 0.\n *\n * This function ensures that the storage is cleared appropriately based on the chain ID, maintaining compatibility across different networks.\n */"
        },
        {
            "identifier": "incSigned",
            "parameters": "TUint256 storage ptr, int256 delta",
            "modifiers": "",
            "return": "returns (uint256 newValue)",
            "body": "function incSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := tload(ptr.slot)\n            newValue := add(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            tstore(ptr.slot, newValue)\n        }\n    }",
            "start": "156",
            "end": "168",
            "class": "LibTransient",
            "signature": "returns (uint256 newValue) incSignedTUint256 storage ptr, int256 delta",
            "full_signature": "function incSigned(TUint256 storage ptr, int256 delta) internal   returns (uint256 newValue)",
            "class_method_signature": "LibTransient.incSignedTUint256 storage ptr, int256 delta",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Increments a signed integer value stored in a `TUint256` storage pointer by a specified delta.\n * @dev This function uses inline assembly to perform the operation and checks for overflow/underflow.\n *      If an overflow or underflow occurs, it reverts with a panic error.\n *\n * @param ptr The storage pointer to the `TUint256` value to be incremented.\n * @param delta The signed integer value to add to the current value.\n * @return newValue The new value after incrementing by the delta.\n *\n * Steps:\n * 1. Load the current value from the storage slot pointed to by `ptr`.\n * 2. Calculate the new value by adding `delta` to the current value.\n * 3. Check for overflow or underflow by comparing the new value with the current value and the sign of `delta`.\n *    - If an overflow or underflow is detected, revert with a panic error (0x11 for overflow/underflow).\n * 4. Store the new value back into the storage slot.\n * 5. Return the new value.\n */"
        },
        {
            "identifier": "incSignedCompat",
            "parameters": "TUint256 storage ptr, int256 delta",
            "modifiers": "",
            "return": "returns (uint256 newValue)",
            "body": "function incSignedCompat(TUint256 storage ptr, int256 delta)\n        internal\n        returns (uint256 newValue)\n    {\n        if (block.chainid == 1) return incSigned(ptr, delta);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := sload(ptr.slot)\n            newValue := add(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), slt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            sstore(ptr.slot, newValue)\n        }\n    }",
            "start": "171",
            "end": "188",
            "class": "LibTransient",
            "signature": "returns (uint256 newValue) incSignedCompatTUint256 storage ptr, int256 delta",
            "full_signature": "function incSignedCompat(TUint256 storage ptr, int256 delta) internal   returns (uint256 newValue)",
            "class_method_signature": "LibTransient.incSignedCompatTUint256 storage ptr, int256 delta",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Increments a signed integer value stored at a given storage pointer by a specified delta.\n * This function is compatible with different chain IDs and handles underflow/overflow checks.\n *\n * @param ptr The storage pointer to the uint256 value to be incremented.\n * @param delta The signed integer delta by which to increment the value.\n * @return newValue The new value after incrementing.\n *\n * Steps:\n * 1. If the chain ID is 1 (Ethereum Mainnet), call the `incSigned` function directly and return its result.\n * 2. Otherwise, ensure compatibility by calling `_compat` on the storage pointer.\n * 3. Use inline assembly to:\n *    - Load the current value from storage.\n *    - Calculate the new value by adding the delta to the current value.\n *    - Check for underflow or overflow by comparing the new value with the current value and the sign of the delta.\n *    - If an underflow or overflow is detected, revert with a panic error (0x11).\n *    - Store the new value back into storage.\n */"
        },
        {
            "identifier": "decSigned",
            "parameters": "TUint256 storage ptr, int256 delta",
            "modifiers": "",
            "return": "returns (uint256 newValue)",
            "body": "function decSigned(TUint256 storage ptr, int256 delta) internal returns (uint256 newValue) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := tload(ptr.slot)\n            newValue := sub(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            tstore(ptr.slot, newValue)\n        }\n    }",
            "start": "191",
            "end": "203",
            "class": "LibTransient",
            "signature": "returns (uint256 newValue) decSignedTUint256 storage ptr, int256 delta",
            "full_signature": "function decSigned(TUint256 storage ptr, int256 delta) internal   returns (uint256 newValue)",
            "class_method_signature": "LibTransient.decSignedTUint256 storage ptr, int256 delta",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Decrements a signed integer value from a storage pointer and returns the new value.\n * \n * @param ptr The storage pointer to the uint256 value to be decremented.\n * @param delta The signed integer value to subtract from the storage value.\n * @return newValue The new value after decrementing.\n *\n * Steps:\n * 1. Load the current value from the storage slot pointed to by `ptr`.\n * 2. Subtract the `delta` from the current value to get `newValue`.\n * 3. Check for underflow or overflow conditions:\n *    - If `newValue` is less than `currentValue` and `delta` is positive, or\n *    - If `newValue` is greater than `currentValue` and `delta` is negative,\n *    then revert with a panic error (0x11 for underflow/overflow).\n * 4. Store the `newValue` back into the storage slot.\n *\n * @dev This function uses inline assembly for low-level operations and ensures memory safety.\n */"
        },
        {
            "identifier": "decSignedCompat",
            "parameters": "TUint256 storage ptr, int256 delta",
            "modifiers": "",
            "return": "returns (uint256 newValue)",
            "body": "function decSignedCompat(TUint256 storage ptr, int256 delta)\n        internal\n        returns (uint256 newValue)\n    {\n        if (block.chainid == 1) return decSigned(ptr, delta);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let currentValue := sload(ptr.slot)\n            newValue := sub(currentValue, delta)\n            if iszero(eq(lt(newValue, currentValue), sgt(delta, 0))) {\n                mstore(0x00, 0x4e487b71) // `Panic(uint256)`.\n                mstore(0x20, 0x11) // Underflow or overflow panic.\n                revert(0x1c, 0x24)\n            }\n            sstore(ptr.slot, newValue)\n        }\n    }",
            "start": "206",
            "end": "223",
            "class": "LibTransient",
            "signature": "returns (uint256 newValue) decSignedCompatTUint256 storage ptr, int256 delta",
            "full_signature": "function decSignedCompat(TUint256 storage ptr, int256 delta) internal   returns (uint256 newValue)",
            "class_method_signature": "LibTransient.decSignedCompatTUint256 storage ptr, int256 delta",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Decreases the value stored at the given pointer by a signed delta, with compatibility checks.\n *\n * @dev This function handles decrementing a value stored at a pointer (`ptr`) by a signed delta (`delta`).\n *      It includes compatibility checks for different blockchain environments (e.g., Ethereum mainnet).\n *      If the chain ID is 1 (Ethereum mainnet), it delegates to `decSigned`. Otherwise, it performs\n *      the decrement operation manually, ensuring no underflow or overflow occurs.\n *\n * @param ptr The storage pointer to the value being decremented.\n * @param delta The signed integer value by which to decrement the stored value.\n * @return newValue The new value after decrementing.\n *\n * Steps:\n * 1. If the chain ID is 1 (Ethereum mainnet), delegate to `decSigned` and return the result.\n * 2. Otherwise, ensure compatibility by calling `_compat` on the pointer.\n * 3. Use inline assembly to:\n *    a. Load the current value from storage.\n *    b. Calculate the new value by subtracting `delta` from the current value.\n *    c. Check for underflow or overflow conditions.\n *    d. If an underflow or overflow is detected, revert with a panic error.\n *    e. Store the new value back into storage.\n * 4. Return the new value.\n */"
        },
        {
            "identifier": "tInt256",
            "parameters": "bytes32 tSlot",
            "modifiers": "pure",
            "return": "returns (TInt256 storage ptr)",
            "body": "function tInt256(bytes32 tSlot) internal pure returns (TInt256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "230",
            "end": "235",
            "class": "LibTransient",
            "signature": "returns (TInt256 storage ptr) tInt256bytes32 tSlot",
            "full_signature": "function tInt256(bytes32 tSlot) internal  pure returns (TInt256 storage ptr)",
            "class_method_signature": "LibTransient.tInt256bytes32 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a `TInt256` type located at the specified storage slot.\n *\n * @param tSlot The storage slot where the `TInt256` data is stored.\n * @return ptr A storage pointer to the `TInt256` data at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. The function returns the storage pointer to the `TInt256` data.\n *\n * @dev This function uses low-level assembly to directly manipulate storage slots, ensuring memory safety.\n */"
        },
        {
            "identifier": "tInt256",
            "parameters": "uint256 tSlot",
            "modifiers": "pure",
            "return": "returns (TInt256 storage ptr)",
            "body": "function tInt256(uint256 tSlot) internal pure returns (TInt256 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "238",
            "end": "243",
            "class": "LibTransient",
            "signature": "returns (TInt256 storage ptr) tInt256uint256 tSlot",
            "full_signature": "function tInt256(uint256 tSlot) internal  pure returns (TInt256 storage ptr)",
            "class_method_signature": "LibTransient.tInt256uint256 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a `TInt256` type located at the specified storage slot.\n *\n * @param tSlot The storage slot where the `TInt256` data is located.\n * @return ptr A storage pointer to the `TInt256` data at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot to the `ptr.slot`.\n * 2. Return the pointer to the `TInt256` storage location.\n *\n * @dev This function is marked as memory-safe using the `@solidity memory-safe-assembly` annotation.\n */"
        },
        {
            "identifier": "get",
            "parameters": "TInt256 storage ptr",
            "modifiers": "view",
            "return": "returns (int256 result)",
            "body": "function get(TInt256 storage ptr) internal view returns (int256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "start": "246",
            "end": "251",
            "class": "LibTransient",
            "signature": "returns (int256 result) getTInt256 storage ptr",
            "full_signature": "function get(TInt256 storage ptr) internal  view returns (int256 result)",
            "class_method_signature": "LibTransient.getTInt256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the value stored at the given TInt256 storage pointer.\n *\n * @param ptr The storage pointer to the TInt256 value.\n * @return result The value stored at the specified storage slot.\n *\n * Steps:\n * 1. Use inline assembly to load the value from the storage slot of the provided pointer.\n * 2. Return the loaded value as the result.\n */"
        },
        {
            "identifier": "set",
            "parameters": "TInt256 storage ptr, int256 value",
            "modifiers": "",
            "return": "",
            "body": "function set(TInt256 storage ptr, int256 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "start": "259",
            "end": "264",
            "class": "LibTransient",
            "signature": " setTInt256 storage ptr, int256 value",
            "full_signature": "function set(TInt256 storage ptr, int256 value) internal",
            "class_method_signature": "LibTransient.setTInt256 storage ptr, int256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TInt256 storage pointer to the specified value.\n *\n * @param ptr The storage pointer of type TInt256 whose value is to be set.\n * @param value The integer value to be stored at the specified storage pointer.\n *\n * Steps:\n * 1. Use inline assembly to directly store the provided value at the storage slot of the pointer.\n * 2. The `tstore` assembly instruction is used to store the value in the specified storage slot.\n */"
        },
        {
            "identifier": "setCompat",
            "parameters": "TInt256 storage ptr, int256 value",
            "modifiers": "",
            "return": "",
            "body": "function setCompat(TInt256 storage ptr, int256 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint256(value);\n    }",
            "start": "267",
            "end": "270",
            "class": "LibTransient",
            "signature": " setCompatTInt256 storage ptr, int256 value",
            "full_signature": "function setCompat(TInt256 storage ptr, int256 value) internal",
            "class_method_signature": "LibTransient.setCompatTInt256 storage ptr, int256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a `TInt256` storage pointer, with compatibility handling for different chains.\n *\n * @param ptr The storage pointer to the `TInt256` variable.\n * @param value The value to set for the `TInt256` variable.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum Mainnet), directly set the value using the `set` function.\n * 2. For other chains, store the value in the `_spacer` field of the compatibility structure to ensure compatibility.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "TInt256 storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clear(TInt256 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "start": "273",
            "end": "278",
            "class": "LibTransient",
            "signature": " clearTInt256 storage ptr",
            "full_signature": "function clear(TInt256 storage ptr) internal",
            "class_method_signature": "LibTransient.clearTInt256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the value stored at the given storage pointer.\n *\n * @param ptr The storage pointer to the TInt256 variable whose value should be cleared.\n *\n * Steps:\n * 1. Use inline assembly to set the value at the storage slot of the pointer to 0.\n * 2. The `tstore` opcode is used to store the value 0 at the specified storage slot.\n */"
        },
        {
            "identifier": "clearCompat",
            "parameters": "TInt256 storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clearCompat(TInt256 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "start": "281",
            "end": "284",
            "class": "LibTransient",
            "signature": " clearCompatTInt256 storage ptr",
            "full_signature": "function clearCompat(TInt256 storage ptr) internal",
            "class_method_signature": "LibTransient.clearCompatTInt256 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clears the storage pointer `ptr` in a way that is compatible with different chain IDs.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum Mainnet), call the `clear` function on the pointer `ptr`.\n * 2. Otherwise, set the `_spacer` field of the compatibility struct (`_compat(ptr)`) to 0.\n *\n * This function ensures that the storage is cleared appropriately depending on the chain ID, \n * maintaining compatibility across different blockchain environments.\n */"
        },
        {
            "identifier": "tBytes32",
            "parameters": "bytes32 tSlot",
            "modifiers": "pure",
            "return": "returns (TBytes32 storage ptr)",
            "body": "function tBytes32(bytes32 tSlot) internal pure returns (TBytes32 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "331",
            "end": "336",
            "class": "LibTransient",
            "signature": "returns (TBytes32 storage ptr) tBytes32bytes32 tSlot",
            "full_signature": "function tBytes32(bytes32 tSlot) internal  pure returns (TBytes32 storage ptr)",
            "class_method_signature": "LibTransient.tBytes32bytes32 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a `TBytes32` struct located at the specified storage slot.\n *\n * @param tSlot The storage slot where the `TBytes32` struct is located.\n * @return ptr A storage pointer to the `TBytes32` struct at the given slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot to the `ptr.slot`.\n * 2. Return the storage pointer.\n *\n * @dev This function is marked as `internal pure` and uses inline assembly for direct storage access.\n */"
        },
        {
            "identifier": "tBytes32",
            "parameters": "uint256 tSlot",
            "modifiers": "pure",
            "return": "returns (TBytes32 storage ptr)",
            "body": "function tBytes32(uint256 tSlot) internal pure returns (TBytes32 storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "339",
            "end": "344",
            "class": "LibTransient",
            "signature": "returns (TBytes32 storage ptr) tBytes32uint256 tSlot",
            "full_signature": "function tBytes32(uint256 tSlot) internal  pure returns (TBytes32 storage ptr)",
            "class_method_signature": "LibTransient.tBytes32uint256 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a `TBytes32` struct located at a specific storage slot.\n *\n * @param tSlot The storage slot where the `TBytes32` struct is located.\n * @return ptr A storage pointer to the `TBytes32` struct at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. Return the pointer to the `TBytes32` struct.\n *\n * @dev This function uses inline assembly to directly manipulate storage slots, which is memory-safe.\n */"
        },
        {
            "identifier": "get",
            "parameters": "TBytes32 storage ptr",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function get(TBytes32 storage ptr) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "start": "347",
            "end": "352",
            "class": "LibTransient",
            "signature": "returns (bytes32 result) getTBytes32 storage ptr",
            "full_signature": "function get(TBytes32 storage ptr) internal  view returns (bytes32 result)",
            "class_method_signature": "LibTransient.getTBytes32 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the value stored at the given storage pointer.\n *\n * @param ptr The storage pointer to the bytes32 value.\n * @return result The bytes32 value stored at the specified storage slot.\n *\n * Steps:\n * 1. Use inline assembly to load the value from the storage slot pointed to by `ptr`.\n * 2. Return the loaded value as `result`.\n *\n * @dev This function uses inline assembly for low-level storage access, ensuring memory safety.\n */"
        },
        {
            "identifier": "set",
            "parameters": "TBytes32 storage ptr, bytes32 value",
            "modifiers": "",
            "return": "",
            "body": "function set(TBytes32 storage ptr, bytes32 value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, value)\n        }\n    }",
            "start": "360",
            "end": "365",
            "class": "LibTransient",
            "signature": " setTBytes32 storage ptr, bytes32 value",
            "full_signature": "function set(TBytes32 storage ptr, bytes32 value) internal",
            "class_method_signature": "LibTransient.setTBytes32 storage ptr, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TBytes32 storage pointer to the provided bytes32 value.\n *\n * @param ptr The storage pointer of type TBytes32 where the value will be stored.\n * @param value The bytes32 value to be stored at the specified storage location.\n *\n * Steps:\n * 1. Use inline assembly to directly store the provided `value` at the storage slot \n *    specified by `ptr.slot`.\n * 2. The `tstore` opcode is used to perform the storage operation efficiently.\n */"
        },
        {
            "identifier": "setCompat",
            "parameters": "TBytes32 storage ptr, bytes32 value",
            "modifiers": "",
            "return": "",
            "body": "function setCompat(TBytes32 storage ptr, bytes32 value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint256(value);\n    }",
            "start": "368",
            "end": "371",
            "class": "LibTransient",
            "signature": " setCompatTBytes32 storage ptr, bytes32 value",
            "full_signature": "function setCompat(TBytes32 storage ptr, bytes32 value) internal",
            "class_method_signature": "LibTransient.setCompatTBytes32 storage ptr, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TBytes32 storage pointer, with compatibility handling for different chains.\n *\n * @param ptr The TBytes32 storage pointer to be updated.\n * @param value The bytes32 value to be set.\n *\n * Steps:\n * 1. Check if the current chain ID is 1 (Ethereum Mainnet).\n *    - If true, call the `set` function to update the storage pointer with the provided value.\n *    - If false, update the `_spacer` field of the compatibility struct (`_compat`) with the provided value.\n *\n * This function ensures compatibility across different chains by handling storage updates differently\n * depending on the chain ID.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "TBytes32 storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clear(TBytes32 storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "start": "374",
            "end": "379",
            "class": "LibTransient",
            "signature": " clearTBytes32 storage ptr",
            "full_signature": "function clear(TBytes32 storage ptr) internal",
            "class_method_signature": "LibTransient.clearTBytes32 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the storage at the specified pointer location by setting it to 0.\n *\n * @param ptr The storage pointer of type `TBytes32` to be cleared.\n *\n * Steps:\n * 1. Use inline assembly to directly interact with storage.\n * 2. Set the value at the storage slot of the provided pointer to 0 using `tstore`.\n */"
        },
        {
            "identifier": "clearCompat",
            "parameters": "TBytes32 storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clearCompat(TBytes32 storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "start": "382",
            "end": "385",
            "class": "LibTransient",
            "signature": " clearCompatTBytes32 storage ptr",
            "full_signature": "function clearCompat(TBytes32 storage ptr) internal",
            "class_method_signature": "LibTransient.clearCompatTBytes32 storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clears the storage pointer `ptr` in a way that is compatible with the current blockchain.\n * \n * Steps:\n * 1. If the current blockchain is Ethereum mainnet (chain ID 1), call the `clear` function to clear the storage.\n * 2. Otherwise, set the `_spacer` field of the compatibility struct to 0, effectively clearing the storage in a way that is compatible with other blockchains.\n * \n * @param ptr The storage pointer to be cleared.\n */"
        },
        {
            "identifier": "tAddress",
            "parameters": "bytes32 tSlot",
            "modifiers": "pure",
            "return": "returns (TAddress storage ptr)",
            "body": "function tAddress(bytes32 tSlot) internal pure returns (TAddress storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "392",
            "end": "397",
            "class": "LibTransient",
            "signature": "returns (TAddress storage ptr) tAddressbytes32 tSlot",
            "full_signature": "function tAddress(bytes32 tSlot) internal  pure returns (TAddress storage ptr)",
            "class_method_signature": "LibTransient.tAddressbytes32 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a storage pointer to a `TAddress` struct located at a specific storage slot.\n *\n * @param tSlot The storage slot where the `TAddress` struct is located.\n * @return ptr A storage pointer to the `TAddress` struct at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. Return the storage pointer to the `TAddress` struct.\n *\n * @dev This function uses inline assembly to directly manipulate storage slots, which is a low-level operation.\n */"
        },
        {
            "identifier": "tAddress",
            "parameters": "uint256 tSlot",
            "modifiers": "pure",
            "return": "returns (TAddress storage ptr)",
            "body": "function tAddress(uint256 tSlot) internal pure returns (TAddress storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "400",
            "end": "405",
            "class": "LibTransient",
            "signature": "returns (TAddress storage ptr) tAddressuint256 tSlot",
            "full_signature": "function tAddress(uint256 tSlot) internal  pure returns (TAddress storage ptr)",
            "class_method_signature": "LibTransient.tAddressuint256 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a `TAddress` struct located at a specific storage slot.\n *\n * @param tSlot The storage slot where the `TAddress` struct is located.\n * @return ptr A storage pointer to the `TAddress` struct at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. Return the storage pointer to the `TAddress` struct.\n *\n * @dev This function uses inline assembly to directly manipulate storage slots, which is a low-level operation.\n */"
        },
        {
            "identifier": "get",
            "parameters": "TAddress storage ptr",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function get(TAddress storage ptr) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "start": "408",
            "end": "413",
            "class": "LibTransient",
            "signature": "returns (address result) getTAddress storage ptr",
            "full_signature": "function get(TAddress storage ptr) internal  view returns (address result)",
            "class_method_signature": "LibTransient.getTAddress storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the address stored at the specified storage pointer.\n *\n * @param ptr The storage pointer from which to retrieve the address.\n * @return result The address stored at the given storage pointer.\n *\n * Steps:\n * 1. Use inline assembly to load the address from the storage slot of the provided pointer.\n * 2. Return the loaded address as the result.\n */"
        },
        {
            "identifier": "set",
            "parameters": "TAddress storage ptr, address value",
            "modifiers": "",
            "return": "",
            "body": "function set(TAddress storage ptr, address value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, shr(96, shl(96, value)))\n        }\n    }",
            "start": "421",
            "end": "426",
            "class": "LibTransient",
            "signature": " setTAddress storage ptr, address value",
            "full_signature": "function set(TAddress storage ptr, address value) internal",
            "class_method_signature": "LibTransient.setTAddress storage ptr, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TAddress storage pointer to the provided address.\n *\n * @param ptr The storage pointer of type TAddress to be updated.\n * @param value The address value to be stored in the provided storage pointer.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level storage operations.\n * 2. Shift the address value to ensure it is properly aligned and stored in the specified slot.\n * 3. Store the aligned address value in the slot of the provided storage pointer.\n *\n * @dev This function uses inline assembly to directly manipulate storage, ensuring memory safety.\n */"
        },
        {
            "identifier": "setCompat",
            "parameters": "TAddress storage ptr, address value",
            "modifiers": "",
            "return": "",
            "body": "function setCompat(TAddress storage ptr, address value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        _compat(ptr)._spacer = uint160(value);\n    }",
            "start": "429",
            "end": "432",
            "class": "LibTransient",
            "signature": " setCompatTAddress storage ptr, address value",
            "full_signature": "function setCompat(TAddress storage ptr, address value) internal",
            "class_method_signature": "LibTransient.setCompatTAddress storage ptr, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the compatibility address for a given TAddress storage pointer.\n * \n * @dev If the current blockchain chain ID is 1 (Ethereum Mainnet), the function directly sets the value.\n *      Otherwise, it stores the address in the `_spacer` field of the compatibility struct.\n *\n * @param ptr The storage pointer to the TAddress struct.\n * @param value The address value to be set or stored in the compatibility struct.\n *\n * Steps:\n * 1. Check if the current chain ID is 1 (Ethereum Mainnet).\n * 2. If true, call the `set` function to directly set the value.\n * 3. If false, store the address in the `_spacer` field of the compatibility struct.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "TAddress storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clear(TAddress storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "start": "435",
            "end": "440",
            "class": "LibTransient",
            "signature": " clearTAddress storage ptr",
            "full_signature": "function clear(TAddress storage ptr) internal",
            "class_method_signature": "LibTransient.clearTAddress storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the value stored at the given storage pointer.\n *\n * @param ptr The storage pointer whose value is to be cleared.\n *\n * Steps:\n * 1. Use inline assembly to set the value at the storage slot of `ptr` to 0.\n * 2. This effectively clears the data stored at that location.\n */ "
        },
        {
            "identifier": "clearCompat",
            "parameters": "TAddress storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clearCompat(TAddress storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "start": "443",
            "end": "446",
            "class": "LibTransient",
            "signature": " clearCompatTAddress storage ptr",
            "full_signature": "function clearCompat(TAddress storage ptr) internal",
            "class_method_signature": "LibTransient.clearCompatTAddress storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clears the compatibility storage for a given TAddress pointer.\n *\n * @dev If the current chain ID is 1 (Ethereum Mainnet), it calls the `clear` function.\n * Otherwise, it sets the `_spacer` field of the compatibility storage to 0.\n *\n * @param ptr The TAddress storage pointer to be cleared or modified.\n *\n * Steps:\n * 1. Check if the current chain ID is 1 (Ethereum Mainnet).\n * 2. If true, call the `clear` function on the provided pointer.\n * 3. If false, set the `_spacer` field of the compatibility storage to 0.\n */"
        },
        {
            "identifier": "tBool",
            "parameters": "bytes32 tSlot",
            "modifiers": "pure",
            "return": "returns (TBool storage ptr)",
            "body": "function tBool(bytes32 tSlot) internal pure returns (TBool storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "453",
            "end": "458",
            "class": "LibTransient",
            "signature": "returns (TBool storage ptr) tBoolbytes32 tSlot",
            "full_signature": "function tBool(bytes32 tSlot) internal  pure returns (TBool storage ptr)",
            "class_method_signature": "LibTransient.tBoolbytes32 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a `TBool` storage pointer from a given storage slot.\n *\n * @param tSlot The storage slot to retrieve the `TBool` pointer from.\n * @return ptr A `TBool` storage pointer pointing to the specified storage slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. Return the `TBool` storage pointer.\n *\n * @dev This function uses inline assembly to directly manipulate storage slots, which is memory-safe.\n */"
        },
        {
            "identifier": "tBool",
            "parameters": "uint256 tSlot",
            "modifiers": "pure",
            "return": "returns (TBool storage ptr)",
            "body": "function tBool(uint256 tSlot) internal pure returns (TBool storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "461",
            "end": "466",
            "class": "LibTransient",
            "signature": "returns (TBool storage ptr) tBooluint256 tSlot",
            "full_signature": "function tBool(uint256 tSlot) internal  pure returns (TBool storage ptr)",
            "class_method_signature": "LibTransient.tBooluint256 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a TBool type at the specified storage slot.\n *\n * @param tSlot The storage slot where the TBool type is located.\n * @return ptr A storage pointer to the TBool type at the specified slot.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. Return the storage pointer (`ptr`) to the TBool type.\n *\n * Note: This function is marked as `pure` because it does not modify the state and only performs a storage slot assignment.\n */"
        },
        {
            "identifier": "get",
            "parameters": "TBool storage ptr",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function get(TBool storage ptr) internal view returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := tload(ptr.slot)\n        }\n    }",
            "start": "469",
            "end": "474",
            "class": "LibTransient",
            "signature": "returns (bool result) getTBool storage ptr",
            "full_signature": "function get(TBool storage ptr) internal  view returns (bool result)",
            "class_method_signature": "LibTransient.getTBool storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the boolean value stored at the specified storage pointer.\n *\n * @param ptr The storage pointer to the boolean value.\n * @return result The boolean value stored at the given storage pointer.\n *\n * Steps:\n * 1. Use inline assembly to load the value from the storage slot of the pointer.\n * 2. Return the loaded boolean value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "TBool storage ptr, bool value",
            "modifiers": "",
            "return": "",
            "body": "function set(TBool storage ptr, bool value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, iszero(iszero(value)))\n        }\n    }",
            "start": "482",
            "end": "487",
            "class": "LibTransient",
            "signature": " setTBool storage ptr, bool value",
            "full_signature": "function set(TBool storage ptr, bool value) internal",
            "class_method_signature": "LibTransient.setTBool storage ptr, bool value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the boolean value at the given storage pointer.\n *\n * @param ptr The storage pointer where the boolean value is stored.\n * @param value The boolean value to set.\n *\n * Steps:\n * 1. Use inline assembly to store the boolean value at the specified storage slot.\n * 2. The value is stored as `1` for `true` and `0` for `false` using `iszero(iszero(value))`.\n */"
        },
        {
            "identifier": "setCompat",
            "parameters": "TBool storage ptr, bool value",
            "modifiers": "",
            "return": "",
            "body": "function setCompat(TBool storage ptr, bool value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, iszero(iszero(value)))\n        }\n    }",
            "start": "490",
            "end": "497",
            "class": "LibTransient",
            "signature": " setCompatTBool storage ptr, bool value",
            "full_signature": "function setCompat(TBool storage ptr, bool value) internal",
            "class_method_signature": "LibTransient.setCompatTBool storage ptr, bool value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TBool storage pointer, with special handling for Ethereum mainnet (chain ID 1).\n *         On other chains, it ensures compatibility by converting the pointer and storing the boolean value.\n *\n * @param ptr The TBool storage pointer to be modified.\n * @param value The boolean value to set.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum mainnet), directly set the value using the `set` function.\n * 2. For other chains, convert the TBool pointer to a compatible format using `_compat`.\n * 3. Use inline assembly to store the boolean value in the storage slot of the converted pointer.\n *    - The value is stored as `1` for `true` and `0` for `false`.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "TBool storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clear(TBool storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "start": "500",
            "end": "505",
            "class": "LibTransient",
            "signature": " clearTBool storage ptr",
            "full_signature": "function clear(TBool storage ptr) internal",
            "class_method_signature": "LibTransient.clearTBool storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the value stored in a TBool storage pointer by setting it to 0.\n *\n * @param ptr The storage pointer to the TBool value that needs to be cleared.\n *\n * Steps:\n * 1. Use inline assembly to directly manipulate storage.\n * 2. Set the value at the storage slot of the provided pointer to 0.\n */"
        },
        {
            "identifier": "clearCompat",
            "parameters": "TBool storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clearCompat(TBool storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "start": "508",
            "end": "511",
            "class": "LibTransient",
            "signature": " clearCompatTBool storage ptr",
            "full_signature": "function clearCompat(TBool storage ptr) internal",
            "class_method_signature": "LibTransient.clearCompatTBool storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clears the state of a TBool storage pointer, with compatibility handling for different chains.\n *\n * @param ptr The TBool storage pointer to be cleared.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum Mainnet), call the `clear` function to clear the state.\n * 2. Otherwise, set the `_spacer` field of the compatibility struct to 0.\n *\n * This function ensures compatibility across different blockchain networks by handling the clearing operation differently based on the chain ID.\n */"
        },
        {
            "identifier": "tBytes",
            "parameters": "bytes32 tSlot",
            "modifiers": "pure",
            "return": "returns (TBytes storage ptr)",
            "body": "function tBytes(bytes32 tSlot) internal pure returns (TBytes storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "518",
            "end": "523",
            "class": "LibTransient",
            "signature": "returns (TBytes storage ptr) tBytesbytes32 tSlot",
            "full_signature": "function tBytes(bytes32 tSlot) internal  pure returns (TBytes storage ptr)",
            "class_method_signature": "LibTransient.tBytesbytes32 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns a storage pointer to a `TBytes` struct located at the specified storage slot.\n *\n * @param tSlot The storage slot where the `TBytes` struct is located.\n * @return ptr A storage pointer to the `TBytes` struct.\n *\n * Steps:\n * 1. Use inline assembly to assign the provided storage slot (`tSlot`) to the `ptr.slot`.\n * 2. Return the storage pointer (`ptr`).\n *\n * @dev This function is marked as `internal pure` and uses inline assembly to directly manipulate storage slots.\n */"
        },
        {
            "identifier": "tBytes",
            "parameters": "uint256 tSlot",
            "modifiers": "pure",
            "return": "returns (TBytes storage ptr)",
            "body": "function tBytes(uint256 tSlot) internal pure returns (TBytes storage ptr) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            ptr.slot := tSlot\n        }\n    }",
            "start": "526",
            "end": "531",
            "class": "LibTransient",
            "signature": "returns (TBytes storage ptr) tBytesuint256 tSlot",
            "full_signature": "function tBytes(uint256 tSlot) internal  pure returns (TBytes storage ptr)",
            "class_method_signature": "LibTransient.tBytesuint256 tSlot",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves a reference to a `TBytes` struct stored at a specific storage slot.\n *\n * @param tSlot The storage slot where the `TBytes` struct is located.\n * @return ptr A reference to the `TBytes` struct at the specified storage slot.\n *\n * Steps:\n * 1. Use inline assembly to retrieve the storage slot of the `TBytes` struct.\n * 2. Assign the storage slot to the `ptr` variable, which is of type `TBytes storage`.\n *\n * Note: This function is marked as `internal pure` and uses inline assembly, which is memory-safe.\n */"
        },
        {
            "identifier": "length",
            "parameters": "TBytes storage ptr",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function length(TBytes storage ptr) internal view returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, tload(ptr.slot))\n        }\n    }",
            "start": "534",
            "end": "539",
            "class": "LibTransient",
            "signature": "returns (uint256 result) lengthTBytes storage ptr",
            "full_signature": "function length(TBytes storage ptr) internal  view returns (uint256 result)",
            "class_method_signature": "LibTransient.lengthTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns the length of the byte array stored in the given storage pointer.\n *\n * @param ptr The storage pointer to the byte array.\n * @return result The length of the byte array.\n *\n * Steps:\n * 1. Use inline assembly to load the value from the storage slot of the pointer.\n * 2. Shift the loaded value right by 224 bits to extract the length.\n * 3. Return the extracted length as the result.\n */"
        },
        {
            "identifier": "lengthCompat",
            "parameters": "TBytes storage ptr",
            "modifiers": "view",
            "return": "returns (uint256 result)",
            "body": "function lengthCompat(TBytes storage ptr) internal view returns (uint256 result) {\n        if (block.chainid == 1) return length(ptr);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := shr(224, sload(ptr.slot))\n        }\n    }",
            "start": "542",
            "end": "549",
            "class": "LibTransient",
            "signature": "returns (uint256 result) lengthCompatTBytes storage ptr",
            "full_signature": "function lengthCompat(TBytes storage ptr) internal  view returns (uint256 result)",
            "class_method_signature": "LibTransient.lengthCompatTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns the length of a byte array stored in a `TBytes` struct, with compatibility handling for different chains.\n *\n * @dev This function checks the current chain ID. If the chain ID is 1 (Ethereum Mainnet), it directly calls the `length` function.\n *      For other chains, it adjusts the pointer using `_compat` and then retrieves the length from storage using assembly.\n *\n * @param ptr The `TBytes` storage pointer to the byte array.\n * @return result The length of the byte array.\n *\n * Steps:\n * 1. Check if the current chain ID is 1 (Ethereum Mainnet).\n *    - If true, return the length directly using the `length` function.\n * 2. For other chains, adjust the pointer using `_compat`.\n * 3. Use inline assembly to load the length from storage by shifting the stored value.\n * 4. Return the computed length.\n */"
        },
        {
            "identifier": "get",
            "parameters": "TBytes storage ptr",
            "modifiers": "view",
            "return": "returns (bytes memory result)",
            "body": "function get(TBytes storage ptr) internal view returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x00)\n            mstore(add(result, 0x1c), tload(ptr.slot)) // Length and first `0x1c` bytes.\n            let n := mload(result)\n            let e := add(add(result, 0x20), n)\n            if iszero(lt(n, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let d := sub(keccak256(0x00, 0x20), result)\n                for { let o := add(result, 0x3c) } 1 {} {\n                    mstore(o, tload(add(o, d)))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n            mstore(e, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(0x20, e)) // Allocate memory.\n        }\n    }",
            "start": "552",
            "end": "572",
            "class": "LibTransient",
            "signature": "returns (bytes memory result) getTBytes storage ptr",
            "full_signature": "function get(TBytes storage ptr) internal  view returns (bytes memory result)",
            "class_method_signature": "LibTransient.getTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the bytes data stored in the `TBytes` storage pointer.\n *\n * @dev This function uses inline assembly to efficiently load and manipulate the data.\n * It performs the following steps:\n * 1. Allocates memory for the result.\n * 2. Loads the length and the first `0x1c` bytes of the data from the storage slot.\n * 3. If the length is greater than or equal to `0x1d`, it calculates the storage offset and copies the remaining data.\n * 4. Zeroizes the slot after the string to ensure no leftover data.\n * 5. Allocates memory for the result and returns it.\n *\n * @param ptr The storage pointer to the `TBytes` data.\n * @return result The bytes data retrieved from the storage.\n */"
        },
        {
            "identifier": "getCompat",
            "parameters": "TBytes storage ptr",
            "modifiers": "view",
            "return": "returns (bytes memory result)",
            "body": "function getCompat(TBytes storage ptr) internal view returns (bytes memory result) {\n        if (block.chainid == 1) return get(ptr);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x00)\n            mstore(add(result, 0x1c), sload(ptr.slot)) // Length and first `0x1c` bytes.\n            let n := mload(result)\n            let e := add(add(result, 0x20), n)\n            if iszero(lt(n, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let d := sub(keccak256(0x00, 0x20), result)\n                for { let o := add(result, 0x3c) } 1 {} {\n                    mstore(o, sload(add(o, d)))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n            mstore(e, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(0x20, e)) // Allocate memory.\n        }\n    }",
            "start": "575",
            "end": "597",
            "class": "LibTransient",
            "signature": "returns (bytes memory result) getCompatTBytes storage ptr",
            "full_signature": "function getCompat(TBytes storage ptr) internal  view returns (bytes memory result)",
            "class_method_signature": "LibTransient.getCompatTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the compatibility-adjusted bytes from storage based on the current chain ID.\n *\n * @param ptr The storage pointer to the TBytes structure.\n * @return result The compatibility-adjusted bytes stored in memory.\n *\n * Steps:\n * 1. If the current chain ID is 1 (Ethereum Mainnet), return the bytes directly using `get(ptr)`.\n * 2. Otherwise, adjust the storage pointer for compatibility using `_compat(ptr)`.\n * 3. Use inline assembly to:\n *    - Load the result pointer from memory.\n *    - Store the length and first `0x1c` bytes of the data.\n *    - Calculate the end of the data.\n *    - If the length is greater than or equal to `0x1d`, iterate through the storage slots to copy the remaining data.\n *    - Zeroize the slot after the string to ensure memory safety.\n *    - Allocate memory for the result.\n */"
        },
        {
            "identifier": "set",
            "parameters": "TBytes storage ptr, bytes memory value",
            "modifiers": "",
            "return": "",
            "body": "function set(TBytes storage ptr, bytes memory value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, mload(add(value, 0x1c)))\n            if iszero(lt(mload(value), 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(add(value, 0x20), mload(value))\n                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)\n                for { let o := add(value, 0x3c) } 1 {} {\n                    tstore(add(o, d), mload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "start": "600",
            "end": "615",
            "class": "LibTransient",
            "signature": " setTBytes storage ptr, bytes memory value",
            "full_signature": "function set(TBytes storage ptr, bytes memory value) internal",
            "class_method_signature": "LibTransient.setTBytes storage ptr, bytes memory value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a TBytes storage pointer to the provided bytes value.\n *\n * @dev This function uses inline assembly to optimize storage operations.\n * It first stores the length of the bytes value in the storage slot of the pointer.\n * If the length of the bytes value is greater than or equal to 0x1d (29 bytes),\n * it performs additional storage operations to store the remaining bytes.\n *\n * @param ptr The TBytes storage pointer to set.\n * @param value The bytes value to store in the pointer.\n *\n * Steps:\n * 1. Store the length of the bytes value in the storage slot of the pointer.\n * 2. If the length of the bytes value is greater than or equal to 0x1d:\n *    a. Calculate the starting and ending positions for the remaining bytes.\n *    b. Use a loop to store the remaining bytes in the appropriate storage slots.\n */"
        },
        {
            "identifier": "setCompat",
            "parameters": "TBytes storage ptr, bytes memory value",
            "modifiers": "",
            "return": "",
            "body": "function setCompat(TBytes storage ptr, bytes memory value) internal {\n        if (block.chainid == 1) return set(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, mload(add(value, 0x1c)))\n            if iszero(lt(mload(value), 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(add(value, 0x20), mload(value))\n                let d := sub(keccak256(0x00, or(0x20, sub(0, shr(32, mload(value))))), value)\n                for { let o := add(value, 0x3c) } 1 {} {\n                    sstore(add(o, d), mload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "start": "618",
            "end": "635",
            "class": "LibTransient",
            "signature": " setCompatTBytes storage ptr, bytes memory value",
            "full_signature": "function setCompat(TBytes storage ptr, bytes memory value) internal",
            "class_method_signature": "LibTransient.setCompatTBytes storage ptr, bytes memory value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value of a `TBytes` storage pointer, with compatibility handling for different chains.\n * \n * @dev If the current chain ID is 1 (Ethereum Mainnet), it directly sets the value using the `set` function.\n * Otherwise, it ensures compatibility by adjusting the storage pointer and then stores the value.\n * \n * @param ptr The storage pointer to the `TBytes` variable.\n * @param value The byte array to be stored.\n * \n * Steps:\n * 1. Check if the chain ID is 1 (Ethereum Mainnet). If true, call the `set` function and return.\n * 2. If not on Ethereum Mainnet, adjust the storage pointer using the `_compat` function.\n * 3. Use inline assembly to store the value in the adjusted storage slot.\n *   - Store the first 28 bytes of the value directly in the slot.\n *   - If the value length is greater than 28 bytes, calculate the remaining slots and store the rest of the data.\n */"
        },
        {
            "identifier": "setCalldata",
            "parameters": "TBytes storage ptr, bytes calldata value",
            "modifiers": "",
            "return": "",
            "body": "function setCalldata(TBytes storage ptr, bytes calldata value) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))\n            if iszero(lt(value.length, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(value.offset, value.length)\n                // forgefmt: disable-next-item\n                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),\n                    value.offset), 0x20)\n                for { let o := add(value.offset, 0x1c) } 1 {} {\n                    tstore(add(o, d), calldataload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "start": "638",
            "end": "655",
            "class": "LibTransient",
            "signature": " setCalldataTBytes storage ptr, bytes calldata value",
            "full_signature": "function setCalldata(TBytes storage ptr, bytes calldata value) internal",
            "class_method_signature": "LibTransient.setCalldataTBytes storage ptr, bytes calldata value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets the calldata for a TBytes storage pointer.\n *\n * @dev This function uses inline assembly to efficiently store calldata into a TBytes storage slot.\n * It handles both short and long calldata lengths, ensuring memory safety.\n *\n * @param ptr The TBytes storage pointer where the calldata will be stored.\n * @param value The calldata to be stored, passed as a bytes calldata type.\n *\n * Steps:\n * 1. Store the length of the calldata in the first 32 bits of the storage slot.\n * 2. If the calldata length is greater than or equal to 29 bytes:\n *    a. Calculate the storage offset and length for the remaining data.\n *    b. Use a loop to store the remaining calldata in 32-byte chunks.\n * 3. The function ensures that the calldata is stored efficiently and safely in the storage slot.\n */"
        },
        {
            "identifier": "setCalldataCompat",
            "parameters": "TBytes storage ptr, bytes calldata value",
            "modifiers": "",
            "return": "",
            "body": "function setCalldataCompat(TBytes storage ptr, bytes calldata value) internal {\n        if (block.chainid == 1) return setCalldata(ptr, value);\n        ptr = _compat(ptr);\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(ptr.slot, or(shl(224, value.length), shr(32, calldataload(value.offset))))\n            if iszero(lt(value.length, 0x1d)) {\n                mstore(0x00, ptr.slot)\n                let e := add(value.offset, value.length)\n                // forgefmt: disable-next-item\n                let d := add(sub(keccak256(0x00, or(0x20, sub(0, shr(32, value.length)))),\n                    value.offset), 0x20)\n                for { let o := add(value.offset, 0x1c) } 1 {} {\n                    sstore(add(o, d), calldataload(o))\n                    o := add(o, 0x20)\n                    if iszero(lt(o, e)) { break }\n                }\n            }\n        }\n    }",
            "start": "658",
            "end": "677",
            "class": "LibTransient",
            "signature": " setCalldataCompatTBytes storage ptr, bytes calldata value",
            "full_signature": "function setCalldataCompat(TBytes storage ptr, bytes calldata value) internal",
            "class_method_signature": "LibTransient.setCalldataCompatTBytes storage ptr, bytes calldata value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the calldata compatibility for a given TBytes storage pointer.\n * \n * This function handles calldata compatibility based on the chain ID. If the chain ID is 1 (Ethereum Mainnet),\n * it directly sets the calldata. Otherwise, it performs a compatibility operation on the storage pointer.\n * \n * @param ptr The TBytes storage pointer to set the calldata for.\n * @param value The calldata bytes to be stored.\n * \n * Steps:\n * 1. Check if the chain ID is 1 (Ethereum Mainnet). If true, call `setCalldata` and return.\n * 2. If not, call `_compat` to ensure compatibility with the storage pointer.\n * 3. Use inline assembly to store the length of the calldata in the first 32 bytes of the storage slot.\n * 4. If the calldata length is greater than or equal to 29 bytes, perform additional storage operations:\n *    a. Calculate the storage offset and end pointer.\n *    b. Use a loop to store the calldata in chunks of 32 bytes.\n * \n * Note: This function uses low-level assembly for efficient storage operations.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "TBytes storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clear(TBytes storage ptr) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            tstore(ptr.slot, 0)\n        }\n    }",
            "start": "680",
            "end": "685",
            "class": "LibTransient",
            "signature": " clearTBytes storage ptr",
            "full_signature": "function clear(TBytes storage ptr) internal",
            "class_method_signature": "LibTransient.clearTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the storage of a TBytes variable by setting its value to 0.\n *\n * @param ptr The storage pointer to the TBytes variable that needs to be cleared.\n *\n * Steps:\n * 1. Use inline assembly to directly manipulate storage.\n * 2. Set the value at the storage slot of the provided pointer (`ptr.slot`) to 0.\n *\n * @dev This function uses low-level assembly to ensure memory safety and efficiency.\n */"
        },
        {
            "identifier": "clearCompat",
            "parameters": "TBytes storage ptr",
            "modifiers": "",
            "return": "",
            "body": "function clearCompat(TBytes storage ptr) internal {\n        if (block.chainid == 1) return clear(ptr);\n        _compat(ptr)._spacer = 0;\n    }",
            "start": "688",
            "end": "691",
            "class": "LibTransient",
            "signature": " clearCompatTBytes storage ptr",
            "full_signature": "function clearCompat(TBytes storage ptr) internal",
            "class_method_signature": "LibTransient.clearCompatTBytes storage ptr",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clears the storage of a TBytes variable, with compatibility handling for different chains.\n *\n * Steps:\n * 1. Check if the current chain ID is 1 (Ethereum Mainnet).\n * 2. If on Ethereum Mainnet, call the `clear` function to clear the storage.\n * 3. If on any other chain, set the `_spacer` variable in the `_compat` struct to 0 to clear the storage.\n *\n * @param ptr The TBytes storage variable to be cleared.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/JSONParserLib.sol": [
        {
            "identifier": "Item",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Item {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }",
            "start": "48",
            "end": "51",
            "class": "JSONParserLib",
            "signature": " Item",
            "full_signature": "function Item()",
            "class_method_signature": "JSONParserLib.Item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `Item` with a single field `_data`.\n *\n * @dev The `_data` field is a `uint256` value. The comment warns against modifying `_data` directly,\n * suggesting that there may be specific methods or logic to handle its modification.\n */"
        },
        {
            "identifier": "parse",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (Item memory result)",
            "body": "function parse(string memory s) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // We will use our own allocation instead.\n        }\n        bytes32 r = _query(_toInput(s), 255);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "start": "82",
            "end": "92",
            "class": "JSONParserLib",
            "signature": "returns (Item memory result) parsestring memory s",
            "full_signature": "function parse(string memory s) internal  pure returns (Item memory result)",
            "class_method_signature": "JSONParserLib.parsestring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a string input into an `Item` struct using low-level assembly.\n *\n * @param s The input string to be parsed.\n * @return result The parsed `Item` struct.\n *\n * Steps:\n * 1. Allocate memory for the result using `mstore` to ensure memory safety.\n * 2. Call the internal `_query` function with the input string and a max length of 255.\n * 3. Store the result of the query into the `result` variable using low-level assembly.\n *\n * Note: This function uses inline assembly for memory management and parsing, ensuring efficiency and safety.\n */"
        },
        {
            "identifier": "value",
            "parameters": "Item memory item",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function value(Item memory item) internal pure returns (string memory result) {\n        bytes32 r = _query(_toInput(item), 0);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "start": "116",
            "end": "122",
            "class": "JSONParserLib",
            "signature": "returns (string memory result) valueItem memory item",
            "full_signature": "function value(Item memory item) internal  pure returns (string memory result)",
            "class_method_signature": "JSONParserLib.valueItem memory item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value of an `Item` by querying it and returning the result as a string.\n *\n * @param item The `Item` struct whose value is to be retrieved.\n * @return result The value of the `Item` as a string.\n *\n * Steps:\n * 1. Query the `Item` using the `_query` function, passing the `Item` converted to an input format and an offset of 0.\n * 2. Use inline assembly to assign the queried result (stored in `bytes32`) to the `result` string.\n *\n * Note: The function uses `memory-safe-assembly` to ensure safe memory handling during the assembly operation.\n */"
        },
        {
            "identifier": "index",
            "parameters": "Item memory item",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function index(Item memory item) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if and(mload(item), _PARENT_IS_ARRAY) {\n                result := and(_BITMASK_POINTER, shr(_BITPOS_KEY, mload(item)))\n            }\n        }\n    }",
            "start": "126",
            "end": "133",
            "class": "JSONParserLib",
            "signature": "returns (uint256 result) indexItem memory item",
            "full_signature": "function index(Item memory item) internal  pure returns (uint256 result)",
            "class_method_signature": "JSONParserLib.indexItem memory item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the index of an item in a data structure, specifically handling cases where the item is part of an array.\n *\n * @param item The item whose index is to be computed.\n * @return result The computed index of the item.\n *\n * Steps:\n * 1. Check if the item is part of an array by verifying the `_PARENT_IS_ARRAY` flag in the item's memory layout.\n * 2. If the item is part of an array, extract the index by shifting and masking the relevant bits in the item's memory.\n * 3. Return the computed index.\n *\n * @dev This function uses inline assembly for low-level memory manipulation to ensure efficiency and safety.\n */"
        },
        {
            "identifier": "key",
            "parameters": "Item memory item",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function key(Item memory item) internal pure returns (string memory result) {\n        if (item._data & _PARENT_IS_OBJECT != 0) {\n            bytes32 r = _query(_toInput(item), 1);\n            /// @solidity memory-safe-assembly\n            assembly {\n                result := r\n            }\n        }\n    }",
            "start": "141",
            "end": "149",
            "class": "JSONParserLib",
            "signature": "returns (string memory result) keyItem memory item",
            "full_signature": "function key(Item memory item) internal  pure returns (string memory result)",
            "class_method_signature": "JSONParserLib.keyItem memory item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Generates a key for a given Item based on its data.\n *\n * @param item The Item struct containing the data to generate the key from.\n * @return result The generated key as a string.\n *\n * Steps:\n * 1. Check if the `_data` field of the item has the `_PARENT_IS_OBJECT` flag set.\n * 2. If the flag is set, call the internal `_query` function with the item's data and a value of 1.\n * 3. Use inline assembly to assign the result of the `_query` function to the `result` variable.\n * 4. Return the generated key.\n */"
        },
        {
            "identifier": "children",
            "parameters": "Item memory item",
            "modifiers": "pure",
            "return": "returns (Item[] memory result)",
            "body": "function children(Item memory item) internal pure returns (Item[] memory result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := r\n        }\n    }",
            "start": "156",
            "end": "162",
            "class": "JSONParserLib",
            "signature": "returns (Item[] memory result) childrenItem memory item",
            "full_signature": "function children(Item memory item) internal  pure returns (Item[] memory result)",
            "class_method_signature": "JSONParserLib.childrenItem memory item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the child items of a given item by querying the internal data structure.\n *\n * @param item The item for which the child items are to be retrieved.\n * @return result An array of child items associated with the given item.\n *\n * Steps:\n * 1. Query the internal data structure using the item's input representation and a specific query type (3).\n * 2. Use inline assembly to assign the result of the query to the `result` variable.\n *\n * Note: The function uses low-level assembly to handle memory operations safely.\n */"
        },
        {
            "identifier": "size",
            "parameters": "Item memory item",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function size(Item memory item) internal pure returns (uint256 result) {\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(r)\n        }\n    }",
            "start": "166",
            "end": "172",
            "class": "JSONParserLib",
            "signature": "returns (uint256 result) sizeItem memory item",
            "full_signature": "function size(Item memory item) internal  pure returns (uint256 result)",
            "class_method_signature": "JSONParserLib.sizeItem memory item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the size of an `Item` struct in memory.\n *\n * @param item The `Item` struct whose size is to be determined.\n * @return result The size of the `Item` struct in memory.\n *\n * Steps:\n * 1. Convert the `Item` struct into an input format using `_toInput`.\n * 2. Query the size using the `_query` function with the input and a selector (3).\n * 3. Use inline assembly to load the result from the queried data.\n * 4. Return the size as a `uint256`.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Item memory item, uint256 i",
            "modifiers": "pure",
            "return": "returns (Item memory result)",
            "body": "function at(Item memory item, uint256 i) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n        }\n        bytes32 r = _query(_toInput(item), 3);\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(r, 0x20), shl(5, i)))\n            if iszero(and(lt(i, mload(r)), eq(and(mload(item), _BITMASK_TYPE), TYPE_ARRAY))) {\n                result := 0x60 // Reset to the zero pointer.\n            }\n        }\n    }",
            "start": "177",
            "end": "190",
            "class": "JSONParserLib",
            "signature": "returns (Item memory result) atItem memory item, uint256 i",
            "full_signature": "function at(Item memory item, uint256 i) internal  pure returns (Item memory result)",
            "class_method_signature": "JSONParserLib.atItem memory item, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves an item from a specific index in an array-type item.\n *\n * @dev This function is designed to work with array-type items. It performs a low-level query to fetch the item at the specified index.\n * If the index is out of bounds or the item is not of array type, the function returns a zero pointer (0x60).\n *\n * @param item The item from which to retrieve the element. Must be of array type.\n * @param i The index of the element to retrieve.\n * @return result The item at the specified index, or a zero pointer if the index is invalid or the item is not an array.\n *\n * Steps:\n * 1. Free the default memory allocation to prepare for manual memory management.\n * 2. Perform a low-level query to fetch the array data.\n * 3. Retrieve the item at the specified index using assembly.\n * 4. Check if the index is within bounds and if the item is of array type.\n * 5. If the index is invalid or the item is not an array, return a zero pointer (0x60).\n */"
        },
        {
            "identifier": "at",
            "parameters": "Item memory item, string memory k",
            "modifiers": "pure",
            "return": "returns (Item memory result)",
            "body": "function at(Item memory item, string memory k) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We'll allocate manually.\n            result := 0x60 // Initialize to the zero pointer.\n        }\n        if (isObject(item)) {\n            bytes32 kHash = keccak256(bytes(k));\n            Item[] memory r = children(item);\n            // We'll just do a linear search. The alternatives are very bloated.\n            for (uint256 i = r.length << 5; i != 0;) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    item := mload(add(r, i))\n                    i := sub(i, 0x20)\n                }\n                if (keccak256(bytes(key(item))) != kHash) continue;\n                result = item;\n                break;\n            }\n        }\n    }",
            "start": "199",
            "end": "220",
            "class": "JSONParserLib",
            "signature": "returns (Item memory result) atItem memory item, string memory k",
            "full_signature": "function at(Item memory item, string memory k) internal  pure returns (Item memory result)",
            "class_method_signature": "JSONParserLib.atItem memory item, string memory k",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves an item from a nested structure based on a given key.\n *\n * @param item The item to search within, which is expected to be an object.\n * @param k The key to search for within the item's children.\n * @return result The item corresponding to the provided key, or a zero pointer if not found.\n *\n * Steps:\n * 1. Initialize the result to a zero pointer.\n * 2. Check if the provided item is an object.\n * 3. If it is an object, compute the keccak256 hash of the provided key.\n * 4. Retrieve the children of the item.\n * 5. Perform a linear search through the children:\n *    a. Load each child item from memory.\n *    b. Compute the keccak256 hash of the child's key.\n *    c. Compare the hash with the target key's hash.\n *    d. If a match is found, set the result to the matching child item and break the loop.\n * 6. Return the result, which will be the matching item or a zero pointer if no match is found.\n *\n * Note: The function uses manual memory management and assembly for efficiency.\n */"
        },
        {
            "identifier": "parent",
            "parameters": "Item memory item",
            "modifiers": "pure",
            "return": "returns (Item memory result)",
            "body": "function parent(Item memory item) internal pure returns (Item memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x40, result) // Free the default allocation. We've already allocated.\n            result := and(shr(_BITPOS_SIBLING_OR_PARENT, mload(item)), _BITMASK_POINTER)\n            if iszero(result) { result := 0x60 } // Reset to the zero pointer.\n        }\n    }",
            "start": "266",
            "end": "273",
            "class": "JSONParserLib",
            "signature": "returns (Item memory result) parentItem memory item",
            "full_signature": "function parent(Item memory item) internal  pure returns (Item memory result)",
            "class_method_signature": "JSONParserLib.parentItem memory item",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the parent item from the given item in a memory-safe manner.\n *\n * @dev This function uses inline assembly to manipulate memory and extract the parent item.\n *      It ensures memory safety by freeing the default allocation and handling the result.\n *\n * @param item The input item from which the parent is to be extracted.\n * @return result The parent item, or the zero pointer if no parent exists.\n *\n * Steps:\n * 1. Free the default memory allocation using `mstore(0x40, result)`.\n * 2. Extract the parent item by shifting and masking the item's memory.\n * 3. If the result is zero, reset it to the zero pointer (0x60).\n */"
        },
        {
            "identifier": "parseUint",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function parseUint(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            let preMulOverflowThres := div(not(0), 10)\n            for { let i := 0 } 1 {} {\n                i := add(i, 1)\n                let digit := sub(and(mload(add(s, i)), 0xff), 48)\n                let mulOverflowed := gt(result, preMulOverflowThres)\n                let product := mul(10, result)\n                result := add(product, digit)\n                n := mul(n, iszero(or(or(mulOverflowed, lt(result, product)), gt(digit, 9))))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "282",
            "end": "301",
            "class": "JSONParserLib",
            "signature": "returns (uint256 result) parseUintstring memory s",
            "full_signature": "function parseUint(string memory s) internal  pure returns (uint256 result)",
            "class_method_signature": "JSONParserLib.parseUintstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a string representation of a number into a uint256 value.\n *\n * @dev This function uses inline assembly to efficiently parse the string into a uint256.\n * It handles overflow checks and ensures the input string contains valid numeric characters.\n * If parsing fails (e.g., invalid characters or overflow), it reverts with a custom error.\n *\n * @param s The string to parse into a uint256.\n * @return result The parsed uint256 value.\n *\n * Steps:\n * 1. Load the length of the string into `n`.\n * 2. Calculate the threshold for multiplication overflow (`preMulOverflowThres`).\n * 3. Iterate through each character in the string:\n *    a. Convert the character to its numeric digit value.\n *    b. Check for multiplication overflow.\n *    c. Multiply the current result by 10 and add the digit.\n *    d. Update `n` to track valid parsing progress.\n *    e. Break the loop if all characters are processed.\n * 4. If parsing fails (invalid characters or overflow), revert with the `ParsingFailed()` error.\n */"
        },
        {
            "identifier": "parseInt",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (int256 result)",
            "body": "function parseInt(string memory s) internal pure returns (int256 result) {\n        uint256 n = bytes(s).length;\n        uint256 sign;\n        uint256 isNegative;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if n {\n                let c := and(mload(add(s, 1)), 0xff)\n                isNegative := eq(c, 45)\n                if or(eq(c, 43), isNegative) {\n                    sign := c\n                    s := add(s, 1)\n                    mstore(s, sub(n, 1))\n                }\n                if iszero(or(sign, lt(sub(c, 48), 10))) { s := 0x60 }\n            }\n        }\n        uint256 x = parseUint(s);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, add(shl(255, 1), isNegative))) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            if sign {\n                mstore(s, sign)\n                s := sub(s, 1)\n                mstore(s, n)\n            }\n            result := xor(x, mul(xor(x, add(not(x), 1)), isNegative))\n        }\n    }",
            "start": "306",
            "end": "337",
            "class": "JSONParserLib",
            "signature": "returns (int256 result) parseIntstring memory s",
            "full_signature": "function parseInt(string memory s) internal  pure returns (int256 result)",
            "class_method_signature": "JSONParserLib.parseIntstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a string representation of a number into an integer.\n *\n * @dev This function handles both positive and negative numbers, and ensures that the input string is valid.\n * If the input string is invalid or the number is out of range, the function reverts with a `ParsingFailed` error.\n *\n * @param s The string to be parsed into an integer.\n * @return result The parsed integer value.\n *\n * Steps:\n * 1. Determine the length of the input string.\n * 2. Check if the string starts with a sign (+ or -) and handle accordingly.\n * 3. Validate that the remaining characters are digits.\n * 4. Parse the string into an unsigned integer using `parseUint`.\n * 5. Handle overflow and underflow conditions for negative numbers.\n * 6. Return the parsed integer, adjusting for the sign if necessary.\n *\n * Reverts:\n * - If the input string is invalid or the number is out of range, the function reverts with a `ParsingFailed` error.\n */"
        },
        {
            "identifier": "parseUintFromHex",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function parseUintFromHex(string memory s) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(s)\n            // Skip two if starts with '0x' or '0X'.\n            let i := shl(1, and(eq(0x3078, or(shr(240, mload(add(s, 0x20))), 0x20)), gt(n, 1)))\n            for {} 1 {} {\n                i := add(i, 1)\n                let c :=\n                    byte(\n                        and(0x1f, shr(and(mload(add(s, i)), 0xff), 0x3e4088843e41bac000000000000)),\n                        0x3010a071000000b0104040208000c05090d060e0f\n                    )\n                n := mul(n, iszero(or(iszero(c), shr(252, result))))\n                result := add(shl(4, result), sub(c, 1))\n                if iszero(lt(i, n)) { break }\n            }\n            if iszero(n) {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "342",
            "end": "364",
            "class": "JSONParserLib",
            "signature": "returns (uint256 result) parseUintFromHexstring memory s",
            "full_signature": "function parseUintFromHex(string memory s) internal  pure returns (uint256 result)",
            "class_method_signature": "JSONParserLib.parseUintFromHexstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Parses a hexadecimal string into a uint256 value.\n *\n * @dev This function uses low-level assembly to efficiently parse the hexadecimal string.\n * It skips the '0x' or '0X' prefix if present and processes the string character by character.\n * If the string is invalid (e.g., contains non-hex characters), the function reverts with a custom error.\n *\n * @param s The hexadecimal string to parse.\n * @return result The parsed uint256 value.\n *\n * Steps:\n * 1. Load the length of the string.\n * 2. Check if the string starts with '0x' or '0X' and skip these characters if present.\n * 3. Iterate through each character of the string:\n *    a. Convert the character to its corresponding hexadecimal value.\n *    b. Update the result by shifting and adding the hexadecimal value.\n *    c. Break the loop if the end of the string is reached.\n * 4. If the string is invalid (e.g., empty or contains non-hex characters), revert with a custom error.\n */"
        },
        {
            "identifier": "decodeString",
            "parameters": "string memory s",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function decodeString(string memory s) internal pure returns (string memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function fail() {\n                mstore(0x00, 0x10182796) // `ParsingFailed()`.\n                revert(0x1c, 0x04)\n            }\n\n            function decodeUnicodeEscapeSequence(pIn_, end_) -> _unicode, _pOut {\n                _pOut := add(pIn_, 4)\n                let b_ := iszero(gt(_pOut, end_))\n                let t_ := mload(pIn_) // Load the whole word.\n                for { let i_ := 0 } iszero(eq(i_, 4)) { i_ := add(i_, 1) } {\n                    let c_ := sub(byte(i_, t_), 48)\n                    if iszero(and(shr(c_, 0x7e0000007e03ff), b_)) { fail() } // Not hexadecimal.\n                    c_ := sub(c_, add(mul(gt(c_, 16), 7), shl(5, gt(c_, 48))))\n                    _unicode := add(shl(4, _unicode), c_)\n                }\n            }\n\n            function decodeUnicodeCodePoint(pIn_, end_) -> _unicode, _pOut {\n                _unicode, _pOut := decodeUnicodeEscapeSequence(pIn_, end_)\n                if iszero(or(lt(_unicode, 0xd800), gt(_unicode, 0xdbff))) {\n                    let t_ := mload(_pOut) // Load the whole word.\n                    end_ := mul(end_, eq(shr(240, t_), 0x5c75)) // Fail if not starting with '\\\\u'.\n                    t_, _pOut := decodeUnicodeEscapeSequence(add(_pOut, 2), end_)\n                    _unicode := add(0x10000, add(shl(10, and(0x3ff, _unicode)), and(0x3ff, t_)))\n                }\n            }\n\n            function appendCodePointAsUTF8(pIn_, c_) -> _pOut {\n                if iszero(gt(c_, 0x7f)) {\n                    mstore8(pIn_, c_)\n                    _pOut := add(pIn_, 1)\n                    leave\n                }\n                mstore8(0x1f, c_)\n                mstore8(0x1e, shr(6, c_))\n                if iszero(gt(c_, 0x7ff)) {\n                    mstore(pIn_, shl(240, or(0xc080, and(0x1f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 2)\n                    leave\n                }\n                mstore8(0x1d, shr(12, c_))\n                if iszero(gt(c_, 0xffff)) {\n                    mstore(pIn_, shl(232, or(0xe08080, and(0x0f3f3f, mload(0x00)))))\n                    _pOut := add(pIn_, 3)\n                    leave\n                }\n                mstore8(0x1c, shr(18, c_))\n                mstore(pIn_, shl(224, or(0xf0808080, and(0x073f3f3f, mload(0x00)))))\n                _pOut := add(pIn_, shl(2, lt(c_, 0x110000)))\n            }\n\n            function chr(p_) -> _c {\n                _c := byte(0, mload(p_))\n            }\n\n            let n := mload(s)\n            let end := add(add(s, n), 0x1f)\n            if iszero(and(gt(n, 1), eq(0x2222, or(and(0xff00, mload(add(s, 2))), chr(end))))) {\n                fail() // Fail if not double-quoted.\n            }\n            let out := add(mload(0x40), 0x20)\n            for { let curr := add(s, 0x21) } iszero(eq(curr, end)) {} {\n                let c := chr(curr)\n                curr := add(curr, 1)\n                // Not '\\\\'.\n                if iszero(eq(c, 92)) {\n                    // Not '\"'.\n                    if iszero(eq(c, 34)) {\n                        mstore8(out, c)\n                        out := add(out, 1)\n                        continue\n                    }\n                    curr := end\n                }\n                if iszero(eq(curr, end)) {\n                    let escape := chr(curr)\n                    curr := add(curr, 1)\n                    // '\"', '/', '\\\\'.\n                    if and(shr(escape, 0x100000000000800400000000), 1) {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                    // 'u'.\n                    if eq(escape, 117) {\n                        escape, curr := decodeUnicodeCodePoint(curr, end)\n                        out := appendCodePointAsUTF8(out, escape)\n                        continue\n                    }\n                    // `{'b':'\\b', 'f':'\\f', 'n':'\\n', 'r':'\\r', 't':'\\t'}`.\n                    escape := byte(sub(escape, 85), 0x080000000c000000000000000a0000000d0009)\n                    if escape {\n                        mstore8(out, escape)\n                        out := add(out, 1)\n                        continue\n                    }\n                }\n                fail()\n                break\n            }\n            mstore(out, 0) // Zeroize the last slot.\n            result := mload(0x40)\n            mstore(result, sub(out, add(result, 0x20))) // Store the length.\n            mstore(0x40, add(out, 0x20)) // Allocate the memory.\n        }\n    }",
            "start": "370",
            "end": "478",
            "class": "JSONParserLib",
            "signature": "returns (string memory result) decodeStringstring memory s",
            "full_signature": "function decodeString(string memory s) internal  pure returns (string memory result)",
            "class_method_signature": "JSONParserLib.decodeStringstring memory s",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Decodes a string that may contain Unicode escape sequences into a valid UTF-8 string.\n *\n * The function processes a string that is expected to be double-quoted and may contain escape sequences\n * such as `\\\\uXXXX` for Unicode characters. It handles standard escape sequences like `\\\\n`, `\\\\t`, etc.,\n * and converts Unicode escape sequences into their corresponding UTF-8 encoded characters.\n *\n * Steps:\n * 1. Check if the input string is properly double-quoted and has a valid length.\n * 2. Iterate through the string character by character.\n * 3. Handle standard escape sequences (e.g., `\\\\n`, `\\\\t`, `\\\\\"`, etc.).\n * 4. Decode Unicode escape sequences (`\\\\uXXXX`) into their corresponding UTF-8 encoded characters.\n * 5. Append the decoded characters to the result string.\n * 6. Fail if any invalid escape sequence or character is encountered.\n * 7. Return the decoded string.\n *\n * @dev The function uses low-level assembly for efficient memory manipulation and error handling.\n * It ensures that the output string is properly null-terminated and allocated in memory.\n *\n * @param s The input string to decode, which may contain escape sequences.\n * @return result The decoded UTF-8 string.\n */\nfunction decodeString(string memory s) internal pure returns (string memory result) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Assembly code for decoding the string...\n    }\n}\n```\n\n### Explanation of the Assembly Code:\n1. **Error Handling (`fail()`)**:\n   - If the string is not properly formatted or contains invalid escape sequences, the function reverts with a custom error (`ParsingFailed()`).\n\n2. **Unicode Escape Sequence Decoding (`decodeUnicodeEscapeSequence`)**:\n   - Decodes a `\\\\uXXXX` sequence into a Unicode code point.\n   - Ensures the sequence is valid hexadecimal and within the expected range.\n\n3. **Unicode Code Point Decoding (`decodeUnicodeCodePoint`)**:\n   - Handles surrogate pairs (used for characters outside the Basic Multilingual Plane, e.g., emojis).\n   - Combines two `\\\\uXXXX` sequences into a single UTF-16 code point.\n\n4. **UTF-8 Encoding (`appendCodePointAsUTF8`)**:\n   - Converts a Unicode code point into its UTF-8 encoded representation.\n   - Handles 1-byte, 2-byte, 3-byte, and 4-byte UTF-8 sequences.\n\n5. **Main Loop**:\n   - Iterates through the input string, processing each character.\n   - Handles standard escape sequences (`\\\\n`, `\\\\t`, etc.) and Unicode escape sequences (`\\\\uXXXX`).\n   - Appends the decoded characters to the result string.\n\n6. **Memory Management**:\n   - Allocates memory for the result string and ensures it is properly null-terminated.\n   - Updates the free memory pointer (`mstore(0x40, ...)`) to reflect the allocated memory.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibSort.sol": [
        {
            "identifier": "insertionSort",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function insertionSort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(a) // Length of `a`.\n            mstore(a, 0) // For insertion sort's inner loop to terminate.\n            let h := add(a, shl(5, n)) // High slot.\n            let w := not(0x1f)\n            for { let i := add(a, 0x20) } 1 {} {\n                i := add(i, 0x20)\n                if gt(i, h) { break }\n                let k := mload(i) // Key.\n                let j := add(i, w) // The slot before the current slot.\n                let v := mload(j) // The value of `j`.\n                if iszero(gt(v, k)) { continue }\n                for {} 1 {} {\n                    mstore(add(j, 0x20), v)\n                    j := add(j, w) // `sub(j, 0x20)`.\n                    v := mload(j)\n                    if iszero(gt(v, k)) { break }\n                }\n                mstore(add(j, 0x20), k)\n            }\n            mstore(a, n) // Restore the length of `a`.\n        }\n    }",
            "start": "17",
            "end": "41",
            "class": "LibSort",
            "signature": " insertionSortuint256[] memory a",
            "full_signature": "function insertionSort(uint256[] memory a) internal  pure",
            "class_method_signature": "LibSort.insertionSortuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs an insertion sort on an array of unsigned integers in-place.\n *\n * @dev This function uses low-level assembly for optimization and memory safety.\n * The array is sorted in ascending order.\n *\n * Steps:\n * 1. Load the length of the array `a` into `n`.\n * 2. Temporarily set the length of `a` to 0 to ensure the inner loop terminates correctly.\n * 3. Calculate the high slot (`h`) of the array for loop termination.\n * 4. Initialize the loop with the first element of the array.\n * 5. For each element in the array:\n *    a. Load the current element (`k`).\n *    b. Compare it with the previous element (`v`).\n *    c. If the previous element is greater than the current element, shift the previous elements to the right until the correct position for `k` is found.\n *    d. Insert `k` into its correct position.\n * 6. Restore the original length of the array `a` after sorting.\n */"
        },
        {
            "identifier": "insertionSort",
            "parameters": "int256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function insertionSort(int256[] memory a) internal pure {\n        _flipSign(a);\n        insertionSort(_toUints(a));\n        _flipSign(a);\n    }",
            "start": "44",
            "end": "48",
            "class": "LibSort",
            "signature": " insertionSortint256[] memory a",
            "full_signature": "function insertionSort(int256[] memory a) internal  pure",
            "class_method_signature": "LibSort.insertionSortint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sorts an array of integers using the insertion sort algorithm.\n *\n * Steps:\n * 1. Flip the sign of each element in the array to handle negative numbers.\n * 2. Perform insertion sort on the array after converting it to unsigned integers.\n * 3. Flip the sign of each element back to restore the original values.\n *\n * @param a The array of integers to be sorted.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function sort(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function swap(a_, b_) -> _a, _b {\n                _b := a_\n                _a := b_\n            }\n            function mswap(i_, j_) {\n                let t_ := mload(i_)\n                mstore(i_, mload(j_))\n                mstore(j_, t_)\n            }\n            function sortInner(w_, l_, h_) {\n                // Do insertion sort if `h_ - l_ <= 0x20 * 12`.\n                // Threshold is fine-tuned via trial and error.\n                if iszero(gt(sub(h_, l_), 0x180)) {\n                    // Hardcode sort the first 2 elements.\n                    let i_ := add(l_, 0x20)\n                    if iszero(lt(mload(l_), mload(i_))) { mswap(i_, l_) }\n                    for {} 1 {} {\n                        i_ := add(i_, 0x20)\n                        if gt(i_, h_) { break }\n                        let k_ := mload(i_) // Key.\n                        let j_ := add(i_, w_) // The slot before the current slot.\n                        let v_ := mload(j_) // The value of `j_`.\n                        if iszero(gt(v_, k_)) { continue }\n                        for {} 1 {} {\n                            mstore(add(j_, 0x20), v_)\n                            j_ := add(j_, w_)\n                            v_ := mload(j_)\n                            if iszero(gt(v_, k_)) { break }\n                        }\n                        mstore(add(j_, 0x20), k_)\n                    }\n                    leave\n                }\n                // Pivot slot is the average of `l_` and `h_`.\n                let p_ := add(shl(5, shr(6, add(l_, h_))), and(31, l_))\n                // Median of 3 with sorting.\n                {\n                    let e0_ := mload(l_)\n                    let e1_ := mload(p_)\n                    if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    let e2_ := mload(h_)\n                    if iszero(lt(e1_, e2_)) {\n                        e1_, e2_ := swap(e1_, e2_)\n                        if iszero(lt(e0_, e1_)) { e0_, e1_ := swap(e0_, e1_) }\n                    }\n                    mstore(h_, e2_)\n                    mstore(p_, e1_)\n                    mstore(l_, e0_)\n                }\n                // Hoare's partition.\n                {\n                    // The value of the pivot slot.\n                    let x_ := mload(p_)\n                    p_ := h_\n                    for { let i_ := l_ } 1 {} {\n                        for {} 1 {} {\n                            i_ := add(0x20, i_)\n                            if iszero(gt(x_, mload(i_))) { break }\n                        }\n                        let j_ := p_\n                        for {} 1 {} {\n                            j_ := add(w_, j_)\n                            if iszero(lt(x_, mload(j_))) { break }\n                        }\n                        p_ := j_\n                        if iszero(lt(i_, p_)) { break }\n                        mswap(i_, p_)\n                    }\n                }\n                if iszero(eq(add(p_, 0x20), h_)) { sortInner(w_, add(p_, 0x20), h_) }\n                if iszero(eq(p_, l_)) { sortInner(w_, l_, p_) }\n            }\n\n            for { let n := mload(a) } iszero(lt(n, 2)) {} {\n                let w := not(0x1f) // `-0x20`.\n                let l := add(a, 0x20) // Low slot.\n                let h := add(a, shl(5, n)) // High slot.\n                let j := h\n                // While `mload(j - 0x20) <= mload(j): j -= 0x20`.\n                for {} iszero(gt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is already sorted, break.\n                if iszero(gt(j, l)) { break }\n                // While `mload(j - 0x20) >= mload(j): j -= 0x20`.\n                for { j := h } iszero(lt(mload(add(w, j)), mload(j))) {} { j := add(w, j) }\n                // If the array is reversed sorted.\n                if iszero(gt(j, l)) {\n                    for {} 1 {} {\n                        let t := mload(l)\n                        mstore(l, mload(h))\n                        mstore(h, t)\n                        h := add(w, h)\n                        l := add(l, 0x20)\n                        if iszero(lt(l, h)) { break }\n                    }\n                    break\n                }\n                mstore(a, 0) // For insertion sort's inner loop to terminate.\n                sortInner(w, l, h)\n                mstore(a, n) // Restore the length of `a`.\n                break\n            }\n        }\n    }",
            "start": "69",
            "end": "174",
            "class": "LibSort",
            "signature": " sortuint256[] memory a",
            "full_signature": "function sort(uint256[] memory a) internal  pure",
            "class_method_signature": "LibSort.sortuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of unsigned integers in ascending order using a combination of insertion sort and quicksort.\n *\n * The function uses inline assembly for optimized performance and memory safety.\n *\n * Steps:\n * 1. Check if the array length is less than 2. If true, the array is already sorted, so exit.\n * 2. Define helper functions:\n *    - `swap`: Swaps two values.\n *    - `mswap`: Swaps two memory slots.\n *    - `sortInner`: Recursively sorts the array using a combination of insertion sort and quicksort.\n * 3. Perform insertion sort if the array size is small (threshold fine-tuned via trial and error).\n * 4. For larger arrays, use quicksort:\n *    - Select a pivot using the median-of-three method.\n *    - Partition the array around the pivot using Hoare's partition scheme.\n *    - Recursively sort the sub-arrays.\n * 5. Handle edge cases:\n *    - If the array is already sorted, exit early.\n *    - If the array is reverse-sorted, reverse it in place.\n * 6. Restore the array length after sorting.\n *\n * @param a The array of unsigned integers to be sorted.\n */"
        },
        {
            "identifier": "sort",
            "parameters": "int256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function sort(int256[] memory a) internal pure {\n        _flipSign(a);\n        sort(_toUints(a));\n        _flipSign(a);\n    }",
            "start": "177",
            "end": "181",
            "class": "LibSort",
            "signature": " sortint256[] memory a",
            "full_signature": "function sort(int256[] memory a) internal  pure",
            "class_method_signature": "LibSort.sortint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sorts an array of signed integers in ascending order.\n *\n * Steps:\n * 1. Flip the sign of each element in the array to convert them to unsigned integers.\n * 2. Sort the array of unsigned integers.\n * 3. Flip the sign of each element back to restore the original signed integers.\n *\n * @param a The array of signed integers to be sorted.\n */"
        },
        {
            "identifier": "uniquifySorted",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function uniquifySorted(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the length of `a` is greater than 1.\n            if iszero(lt(mload(a), 2)) {\n                let x := add(a, 0x20)\n                let y := add(a, 0x40)\n                let end := add(a, shl(5, add(mload(a), 1)))\n                for {} 1 {} {\n                    if iszero(eq(mload(x), mload(y))) {\n                        x := add(x, 0x20)\n                        mstore(x, mload(y))\n                    }\n                    y := add(y, 0x20)\n                    if eq(y, end) { break }\n                }\n                mstore(a, shr(5, sub(x, a)))\n            }\n        }\n    }",
            "start": "201",
            "end": "220",
            "class": "LibSort",
            "signature": " uniquifySorteduint256[] memory a",
            "full_signature": "function uniquifySorted(uint256[] memory a) internal  pure",
            "class_method_signature": "LibSort.uniquifySorteduint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Removes duplicate elements from a sorted array in-place.\n *\n * @dev This function assumes that the input array `a` is already sorted.\n * It uses low-level assembly to optimize memory operations and ensure gas efficiency.\n *\n * Steps:\n * 1. Check if the length of the array `a` is greater than 1.\n * 2. If true, initialize pointers `x` and `y` to the first and second elements of the array, respectively.\n * 3. Calculate the end of the array.\n * 4. Iterate through the array:\n *    - If the current element at `x` is not equal to the next element at `y`, move `x` forward and store the unique element.\n *    - Move `y` forward to the next element.\n *    - If `y` reaches the end of the array, break the loop.\n * 5. Update the length of the array to reflect the number of unique elements.\n *\n * @param a The sorted array of uint256 values to be uniquified.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "uint256[] memory a, uint256 needle",
            "modifiers": "pure",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(a, needle, 0);\n    }",
            "start": "239",
            "end": "245",
            "class": "LibSort",
            "signature": "returns (bool found, uint256 index) searchSorteduint256[] memory a, uint256 needle",
            "full_signature": "function searchSorted(uint256[] memory a, uint256 needle) internal  pure returns (bool found, uint256 index)",
            "class_method_signature": "LibSort.searchSorteduint256[] memory a, uint256 needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) in a sorted array (`a`) and returns whether it was found and its index.\n *\n * @param a The sorted array of uint256 values to search within.\n * @param needle The uint256 value to search for in the array.\n * @return found A boolean indicating whether the value was found in the array.\n * @return index The index of the found value in the array. If not found, this will be the position where the value could be inserted to maintain the sorted order.\n *\n * Steps:\n * 1. Calls the internal helper function `_searchSorted` with the array, the value to search for, and a starting index of 0.\n * 2. Returns the result from `_searchSorted`, which includes whether the value was found and its index.\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "int256[] memory a, int256 needle",
            "modifiers": "pure",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(int256[] memory a, int256 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 1 << 255);\n    }",
            "start": "249",
            "end": "255",
            "class": "LibSort",
            "signature": "returns (bool found, uint256 index) searchSortedint256[] memory a, int256 needle",
            "full_signature": "function searchSorted(int256[] memory a, int256 needle) internal  pure returns (bool found, uint256 index)",
            "class_method_signature": "LibSort.searchSortedint256[] memory a, int256 needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific value (`needle`) in a sorted array of integers (`a`).\n *\n * @param a The sorted array of integers to search within.\n * @param needle The integer value to search for in the array.\n *\n * @return found A boolean indicating whether the value was found in the array.\n * @return index The position of the value in the array if found, or the position where it should be inserted to maintain order.\n *\n * Steps:\n * 1. Convert the array of integers (`a`) to an array of unsigned integers using `_toUints`.\n * 2. Perform a binary search on the converted array using the `_searchSorted` function.\n * 3. Return the result of the search, including whether the value was found and its index (or insertion point).\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "address[] memory a, address needle",
            "modifiers": "pure",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(address[] memory a, address needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint160(needle), 0);\n    }",
            "start": "259",
            "end": "265",
            "class": "LibSort",
            "signature": "returns (bool found, uint256 index) searchSortedaddress[] memory a, address needle",
            "full_signature": "function searchSorted(address[] memory a, address needle) internal  pure returns (bool found, uint256 index)",
            "class_method_signature": "LibSort.searchSortedaddress[] memory a, address needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for an address (`needle`) in a sorted array of addresses (`a`).\n *\n * @param a The sorted array of addresses to search within.\n * @param needle The address to search for in the array.\n *\n * @return found A boolean indicating whether the address was found in the array.\n * @return index The index of the address in the array if found, or the index where it should be inserted to maintain sorting.\n *\n * Steps:\n * 1. Convert the array of addresses (`a`) to an array of uint256 values.\n * 2. Call the internal `_searchSorted` function with the converted array, the uint160 representation of `needle`, and a starting index of 0.\n * 3. Return the results from `_searchSorted`, which include whether the address was found and its index (or the insertion point).\n */"
        },
        {
            "identifier": "searchSorted",
            "parameters": "bytes32[] memory a, bytes32 needle",
            "modifiers": "pure",
            "return": "returns (bool found, uint256 index)",
            "body": "function searchSorted(bytes32[] memory a, bytes32 needle)\n        internal\n        pure\n        returns (bool found, uint256 index)\n    {\n        (found, index) = _searchSorted(_toUints(a), uint256(needle), 0);\n    }",
            "start": "269",
            "end": "275",
            "class": "LibSort",
            "signature": "returns (bool found, uint256 index) searchSortedbytes32[] memory a, bytes32 needle",
            "full_signature": "function searchSorted(bytes32[] memory a, bytes32 needle) internal  pure returns (bool found, uint256 index)",
            "class_method_signature": "LibSort.searchSortedbytes32[] memory a, bytes32 needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Searches for a specific `bytes32` value (`needle`) in a sorted `bytes32` array (`a`).\n *\n * @param a The sorted array of `bytes32` values to search within.\n * @param needle The `bytes32` value to search for in the array.\n *\n * @return found A boolean indicating whether the `needle` was found in the array.\n * @return index The index of the `needle` in the array if found, or the index where it should be inserted to maintain order.\n *\n * Steps:\n * 1. Convert the `bytes32` array to a `uint256` array using `_toUints`.\n * 2. Perform a binary search on the `uint256` array using `_searchSorted`.\n * 3. Return the result of the search, including whether the value was found and its index.\n */"
        },
        {
            "identifier": "reverse",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function reverse(uint256[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(mload(a), 2)) {\n                let s := 0x20\n                let w := not(0x1f)\n                let h := add(a, shl(5, mload(a)))\n                for { a := add(a, s) } 1 {} {\n                    let t := mload(a)\n                    mstore(a, mload(h))\n                    mstore(h, t)\n                    h := add(h, w)\n                    a := add(a, s)\n                    if iszero(lt(a, h)) { break }\n                }\n            }\n        }\n    }",
            "start": "298",
            "end": "315",
            "class": "LibSort",
            "signature": " reverseuint256[] memory a",
            "full_signature": "function reverse(uint256[] memory a) internal  pure",
            "class_method_signature": "LibSort.reverseuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reverses the order of elements in a given array in-place.\n *\n * @dev This function uses low-level assembly to efficiently reverse the array.\n * It checks if the array has fewer than 2 elements, in which case no reversal is needed.\n * Otherwise, it iterates through the array, swapping elements from the start and end until the middle is reached.\n *\n * Steps:\n * 1. Check if the array length is less than 2. If true, exit early as no reversal is needed.\n * 2. Initialize pointers for the start (`a`) and end (`h`) of the array.\n * 3. Iterate through the array:\n *    - Swap the elements at the current start and end positions.\n *    - Move the start pointer forward and the end pointer backward.\n *    - Continue until the start pointer is no longer less than the end pointer.\n * 4. Exit the loop once the array is fully reversed.\n *\n * @param a The array of uint256 values to be reversed.\n */"
        },
        {
            "identifier": "copy",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function copy(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let end := add(add(result, 0x20), shl(5, mload(a)))\n            let o := result\n            for { let d := sub(a, result) } 1 {} {\n                mstore(o, mload(add(o, d)))\n                o := add(0x20, o)\n                if eq(o, end) { break }\n            }\n            mstore(0x40, o)\n        }\n    }",
            "start": "333",
            "end": "346",
            "class": "LibSort",
            "signature": "returns (uint256[] memory result) copyuint256[] memory a",
            "full_signature": "function copy(uint256[] memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "LibSort.copyuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Copies an array of uint256 values in memory using low-level assembly for efficiency.\n *\n * @param a The input array of uint256 values to be copied.\n * @return result A new array containing the copied values.\n *\n * Steps:\n * 1. Allocate memory for the result array using the free memory pointer (`mload(0x40)`).\n * 2. Calculate the end address of the result array based on the length of the input array.\n * 3. Use a loop to copy each element from the input array to the result array.\n * 4. Update the free memory pointer to reflect the new memory allocation.\n *\n * Note: This function uses inline assembly for memory-safe operations, ensuring efficient copying of large arrays.\n */"
        },
        {
            "identifier": "isSorted",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSorted(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(gt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "start": "364",
            "end": "378",
            "class": "LibSort",
            "signature": "returns (bool result) isSorteduint256[] memory a",
            "full_signature": "function isSorted(uint256[] memory a) internal  pure returns (bool result)",
            "class_method_signature": "LibSort.isSorteduint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if an array of unsigned integers is sorted in ascending order.\n * \n * @dev This function uses low-level assembly to optimize the sorting check.\n * \n * @param a The array of unsigned integers to check.\n * @return result A boolean indicating whether the array is sorted (true) or not (false).\n * \n * Steps:\n * 1. Initialize `result` to 1 (true) assuming the array is sorted.\n * 2. If the array length is less than 2, it is considered sorted by default.\n * 3. Otherwise, iterate through the array:\n *    a. Compare each element with the next one.\n *    b. If any element is greater than the next, set `result` to 0 (false) and break the loop.\n * 4. Return the final value of `result`.\n */"
        },
        {
            "identifier": "isSorted",
            "parameters": "int256[] memory a",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSorted(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := iszero(sgt(p, mload(a)))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "start": "381",
            "end": "395",
            "class": "LibSort",
            "signature": "returns (bool result) isSortedint256[] memory a",
            "full_signature": "function isSorted(int256[] memory a) internal  pure returns (bool result)",
            "class_method_signature": "LibSort.isSortedint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if an array of integers is sorted in non-decreasing order.\n *\n * @param a The array of integers to be checked.\n * @return result A boolean indicating whether the array is sorted (true) or not (false).\n *\n * Steps:\n * 1. Initialize `result` to 1 (true) assuming the array is sorted.\n * 2. If the array length is less than 2, it is considered sorted by default.\n * 3. Otherwise, iterate through the array:\n *    a. Compare each element with the next one.\n *    b. If any element is greater than the next, set `result` to 0 (false) and break the loop.\n * 4. Return the final value of `result`.\n *\n * @dev This function uses low-level assembly for efficiency.\n */"
        },
        {
            "identifier": "isSortedAndUniquified",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSortedAndUniquified(uint256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := lt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "start": "408",
            "end": "422",
            "class": "LibSort",
            "signature": "returns (bool result) isSortedAndUniquifieduint256[] memory a",
            "full_signature": "function isSortedAndUniquified(uint256[] memory a) internal  pure returns (bool result)",
            "class_method_signature": "LibSort.isSortedAndUniquifieduint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given array of uint256 is sorted in ascending order and contains no duplicate elements.\n *\n * @param a The array of uint256 values to be checked.\n * @return result A boolean indicating whether the array is sorted and uniquified (true) or not (false).\n *\n * Steps:\n * 1. Initialize `result` to 1 (true) assuming the array is sorted and uniquified.\n * 2. If the array length is less than 2, it is inherently sorted and uniquified, so return true.\n * 3. Otherwise, iterate through the array:\n *    a. Compare each element with the next one.\n *    b. If any element is greater than or equal to the next, set `result` to 0 (false).\n *    c. If the end of the array is reached without finding any duplicates or unsorted elements, return true.\n * 4. The function uses low-level assembly for efficient memory access and comparison.\n */"
        },
        {
            "identifier": "isSortedAndUniquified",
            "parameters": "int256[] memory a",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isSortedAndUniquified(int256[] memory a) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := 1\n            if iszero(lt(mload(a), 2)) {\n                let end := add(a, shl(5, mload(a)))\n                for { a := add(a, 0x20) } 1 {} {\n                    let p := mload(a)\n                    a := add(a, 0x20)\n                    result := slt(p, mload(a))\n                    if iszero(mul(result, xor(a, end))) { break }\n                }\n            }\n        }\n    }",
            "start": "425",
            "end": "439",
            "class": "LibSort",
            "signature": "returns (bool result) isSortedAndUniquifiedint256[] memory a",
            "full_signature": "function isSortedAndUniquified(int256[] memory a) internal  pure returns (bool result)",
            "class_method_signature": "LibSort.isSortedAndUniquifiedint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if an array of integers is sorted in ascending order and contains no duplicate values.\n *\n * @param a The array of integers to be checked.\n * @return result A boolean value indicating whether the array is sorted and uniquified (true) or not (false).\n *\n * Steps:\n * 1. Initialize `result` to 1 (true).\n * 2. If the array length is less than 2, it is considered sorted and uniquified by default.\n * 3. Otherwise, iterate through the array:\n *    a. Compare each element with the next one.\n *    b. If any element is greater than or equal to the next, set `result` to 0 (false).\n *    c. If the end of the array is reached, break the loop.\n * 4. Return the `result`.\n *\n * Note: This function uses low-level assembly for optimization.\n */"
        },
        {
            "identifier": "difference",
            "parameters": "uint256[] memory a, uint256[] memory b",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function difference(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _difference(a, b, 0);\n    }",
            "start": "453",
            "end": "459",
            "class": "LibSort",
            "signature": "returns (uint256[] memory c) differenceuint256[] memory a, uint256[] memory b",
            "full_signature": "function difference(uint256[] memory a, uint256[] memory b) internal  pure returns (uint256[] memory c)",
            "class_method_signature": "LibSort.differenceuint256[] memory a, uint256[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the difference between two arrays of unsigned integers.\n *\n * @param a The first array of unsigned integers.\n * @param b The second array of unsigned integers.\n * @return c An array containing the elements that are in `a` but not in `b`.\n *\n * Steps:\n * 1. Calls the internal helper function `_difference` with the two arrays and an initial index of 0.\n * 2. Returns the resulting array `c` which contains the difference between `a` and `b`.\n */"
        },
        {
            "identifier": "difference",
            "parameters": "int256[] memory a, int256[] memory b",
            "modifiers": "pure",
            "return": "returns (int256[] memory c)",
            "body": "function difference(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_difference(_toUints(a), _toUints(b), 1 << 255));\n    }",
            "start": "463",
            "end": "469",
            "class": "LibSort",
            "signature": "returns (int256[] memory c) differenceint256[] memory a, int256[] memory b",
            "full_signature": "function difference(int256[] memory a, int256[] memory b) internal  pure returns (int256[] memory c)",
            "class_method_signature": "LibSort.differenceint256[] memory a, int256[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the difference between two arrays of integers.\n *\n * @param a The first array of integers.\n * @param b The second array of integers.\n * @return c An array of integers representing the difference between `a` and `b`.\n *\n * Steps:\n * 1. Convert the input integer arrays `a` and `b` to arrays of unsigned integers.\n * 2. Compute the difference between the two unsigned integer arrays, using a mask (1 << 255) to handle negative values.\n * 3. Convert the resulting unsigned integer array back to an array of integers.\n * 4. Return the resulting array of integers.\n */"
        },
        {
            "identifier": "difference",
            "parameters": "address[] memory a, address[] memory b",
            "modifiers": "pure",
            "return": "returns (address[] memory c)",
            "body": "function difference(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_difference(_toUints(a), _toUints(b), 0));\n    }",
            "start": "473",
            "end": "479",
            "class": "LibSort",
            "signature": "returns (address[] memory c) differenceaddress[] memory a, address[] memory b",
            "full_signature": "function difference(address[] memory a, address[] memory b) internal  pure returns (address[] memory c)",
            "class_method_signature": "LibSort.differenceaddress[] memory a, address[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the difference between two arrays of addresses.\n *\n * @param a The first array of addresses.\n * @param b The second array of addresses.\n * @return c An array of addresses representing the difference between `a` and `b`.\n *\n * Steps:\n * 1. Convert the input address arrays `a` and `b` to arrays of uints using `_toUints`.\n * 2. Compute the difference between the two uint arrays using `_difference`.\n * 3. Convert the resulting uint array back to an array of addresses using `_toAddresses`.\n * 4. Return the resulting address array `c`.\n */"
        },
        {
            "identifier": "difference",
            "parameters": "bytes32[] memory a, bytes32[] memory b",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory c)",
            "body": "function difference(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_difference(_toUints(a), _toUints(b), 0));\n    }",
            "start": "483",
            "end": "489",
            "class": "LibSort",
            "signature": "returns (bytes32[] memory c) differencebytes32[] memory a, bytes32[] memory b",
            "full_signature": "function difference(bytes32[] memory a, bytes32[] memory b) internal  pure returns (bytes32[] memory c)",
            "class_method_signature": "LibSort.differencebytes32[] memory a, bytes32[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the difference between two arrays of `bytes32` values.\n *\n * @param a The first array of `bytes32` values.\n * @param b The second array of `bytes32` values.\n * @return c An array of `bytes32` values representing the difference between `a` and `b`.\n *\n * Steps:\n * 1. Convert the input arrays `a` and `b` from `bytes32[]` to `uint256[]` using the `_toUints` helper function.\n * 2. Compute the difference between the two `uint256[]` arrays using the `_difference` helper function.\n * 3. Convert the resulting `uint256[]` array back to `bytes32[]` using the `_toBytes32s` helper function.\n * 4. Return the resulting `bytes32[]` array.\n */"
        },
        {
            "identifier": "intersection",
            "parameters": "uint256[] memory a, uint256[] memory b",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function intersection(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _intersection(a, b, 0);\n    }",
            "start": "493",
            "end": "499",
            "class": "LibSort",
            "signature": "returns (uint256[] memory c) intersectionuint256[] memory a, uint256[] memory b",
            "full_signature": "function intersection(uint256[] memory a, uint256[] memory b) internal  pure returns (uint256[] memory c)",
            "class_method_signature": "LibSort.intersectionuint256[] memory a, uint256[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the intersection of two arrays of unsigned integers.\n *\n * @param a The first array of unsigned integers.\n * @param b The second array of unsigned integers.\n * @return c An array containing the common elements between `a` and `b`.\n *\n * Steps:\n * 1. Calls the internal helper function `_intersection` with the two input arrays and an initial index of 0.\n * 2. Returns the resulting array of common elements.\n */"
        },
        {
            "identifier": "intersection",
            "parameters": "int256[] memory a, int256[] memory b",
            "modifiers": "pure",
            "return": "returns (int256[] memory c)",
            "body": "function intersection(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_intersection(_toUints(a), _toUints(b), 1 << 255));\n    }",
            "start": "503",
            "end": "509",
            "class": "LibSort",
            "signature": "returns (int256[] memory c) intersectionint256[] memory a, int256[] memory b",
            "full_signature": "function intersection(int256[] memory a, int256[] memory b) internal  pure returns (int256[] memory c)",
            "class_method_signature": "LibSort.intersectionint256[] memory a, int256[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the intersection of two integer arrays.\n *\n * @param a The first array of integers.\n * @param b The second array of integers.\n * @return c An array containing the intersection of `a` and `b`.\n *\n * Steps:\n * 1. Convert the input integer arrays `a` and `b` to unsigned integer arrays.\n * 2. Compute the intersection of the unsigned integer arrays.\n * 3. Convert the resulting unsigned integer array back to an integer array.\n * 4. Return the resulting integer array as the intersection.\n *\n * Note: The function uses internal helper functions `_toUints` and `_toInts` for type conversion.\n */"
        },
        {
            "identifier": "intersection",
            "parameters": "address[] memory a, address[] memory b",
            "modifiers": "pure",
            "return": "returns (address[] memory c)",
            "body": "function intersection(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_intersection(_toUints(a), _toUints(b), 0));\n    }",
            "start": "513",
            "end": "519",
            "class": "LibSort",
            "signature": "returns (address[] memory c) intersectionaddress[] memory a, address[] memory b",
            "full_signature": "function intersection(address[] memory a, address[] memory b) internal  pure returns (address[] memory c)",
            "class_method_signature": "LibSort.intersectionaddress[] memory a, address[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the intersection of two arrays of addresses.\n *\n * @param a The first array of addresses.\n * @param b The second array of addresses.\n * @return c An array of addresses that are common to both input arrays.\n *\n * Steps:\n * 1. Convert the input address arrays `a` and `b` to arrays of unsigned integers using `_toUints`.\n * 2. Compute the intersection of the two integer arrays using `_intersection`.\n * 3. Convert the resulting integer array back to an array of addresses using `_toAddresses`.\n * 4. Return the resulting array of common addresses.\n */"
        },
        {
            "identifier": "intersection",
            "parameters": "bytes32[] memory a, bytes32[] memory b",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory c)",
            "body": "function intersection(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_intersection(_toUints(a), _toUints(b), 0));\n    }",
            "start": "523",
            "end": "529",
            "class": "LibSort",
            "signature": "returns (bytes32[] memory c) intersectionbytes32[] memory a, bytes32[] memory b",
            "full_signature": "function intersection(bytes32[] memory a, bytes32[] memory b) internal  pure returns (bytes32[] memory c)",
            "class_method_signature": "LibSort.intersectionbytes32[] memory a, bytes32[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the intersection of two arrays of `bytes32` elements.\n *\n * @param a The first array of `bytes32` elements.\n * @param b The second array of `bytes32` elements.\n * @return c An array of `bytes32` elements representing the intersection of `a` and `b`.\n *\n * Steps:\n * 1. Convert the `bytes32` arrays `a` and `b` to arrays of `uint256` using the `_toUints` function.\n * 2. Compute the intersection of the two `uint256` arrays using the `_intersection` function.\n * 3. Convert the resulting `uint256` array back to a `bytes32` array using the `_toBytes32s` function.\n * 4. Return the resulting `bytes32` array as the intersection.\n */"
        },
        {
            "identifier": "union",
            "parameters": "uint256[] memory a, uint256[] memory b",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function union(uint256[] memory a, uint256[] memory b)\n        internal\n        pure\n        returns (uint256[] memory c)\n    {\n        c = _union(a, b, 0);\n    }",
            "start": "533",
            "end": "539",
            "class": "LibSort",
            "signature": "returns (uint256[] memory c) unionuint256[] memory a, uint256[] memory b",
            "full_signature": "function union(uint256[] memory a, uint256[] memory b) internal  pure returns (uint256[] memory c)",
            "class_method_signature": "LibSort.unionuint256[] memory a, uint256[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the union of two arrays of unsigned integers.\n *\n * @param a The first array of unsigned integers.\n * @param b The second array of unsigned integers.\n * @return c The resulting array containing the union of `a` and `b`.\n *\n * Steps:\n * 1. Calls the internal helper function `_union` with the two input arrays and an initial index of 0.\n * 2. Returns the resulting array `c` which contains the union of `a` and `b`.\n */"
        },
        {
            "identifier": "union",
            "parameters": "int256[] memory a, int256[] memory b",
            "modifiers": "pure",
            "return": "returns (int256[] memory c)",
            "body": "function union(int256[] memory a, int256[] memory b)\n        internal\n        pure\n        returns (int256[] memory c)\n    {\n        c = _toInts(_union(_toUints(a), _toUints(b), 1 << 255));\n    }",
            "start": "543",
            "end": "549",
            "class": "LibSort",
            "signature": "returns (int256[] memory c) unionint256[] memory a, int256[] memory b",
            "full_signature": "function union(int256[] memory a, int256[] memory b) internal  pure returns (int256[] memory c)",
            "class_method_signature": "LibSort.unionint256[] memory a, int256[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the union of two arrays of integers.\n *\n * @param a The first array of integers.\n * @param b The second array of integers.\n * @return c The resulting array containing the union of elements from `a` and `b`.\n *\n * Steps:\n * 1. Convert the input integer arrays `a` and `b` to arrays of unsigned integers using `_toUints`.\n * 2. Compute the union of the two unsigned integer arrays using `_union`, with a special flag `1 << 255`.\n * 3. Convert the resulting unsigned integer array back to an array of integers using `_toInts`.\n * 4. Return the resulting integer array `c`.\n */"
        },
        {
            "identifier": "union",
            "parameters": "address[] memory a, address[] memory b",
            "modifiers": "pure",
            "return": "returns (address[] memory c)",
            "body": "function union(address[] memory a, address[] memory b)\n        internal\n        pure\n        returns (address[] memory c)\n    {\n        c = _toAddresses(_union(_toUints(a), _toUints(b), 0));\n    }",
            "start": "553",
            "end": "559",
            "class": "LibSort",
            "signature": "returns (address[] memory c) unionaddress[] memory a, address[] memory b",
            "full_signature": "function union(address[] memory a, address[] memory b) internal  pure returns (address[] memory c)",
            "class_method_signature": "LibSort.unionaddress[] memory a, address[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the union of two arrays of addresses.\n *\n * @param a The first array of addresses.\n * @param b The second array of addresses.\n * @return c The resulting array of addresses after performing the union operation.\n *\n * Steps:\n * 1. Convert the input address arrays `a` and `b` to arrays of uints using `_toUints`.\n * 2. Compute the union of the two uint arrays using `_union`.\n * 3. Convert the resulting uint array back to an address array using `_toAddresses`.\n * 4. Return the resulting address array `c`.\n */"
        },
        {
            "identifier": "union",
            "parameters": "bytes32[] memory a, bytes32[] memory b",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory c)",
            "body": "function union(bytes32[] memory a, bytes32[] memory b)\n        internal\n        pure\n        returns (bytes32[] memory c)\n    {\n        c = _toBytes32s(_union(_toUints(a), _toUints(b), 0));\n    }",
            "start": "563",
            "end": "569",
            "class": "LibSort",
            "signature": "returns (bytes32[] memory c) unionbytes32[] memory a, bytes32[] memory b",
            "full_signature": "function union(bytes32[] memory a, bytes32[] memory b) internal  pure returns (bytes32[] memory c)",
            "class_method_signature": "LibSort.unionbytes32[] memory a, bytes32[] memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the union of two arrays of `bytes32` elements.\n *\n * @param a The first array of `bytes32` elements.\n * @param b The second array of `bytes32` elements.\n * @return c The resulting array containing the union of elements from `a` and `b`.\n *\n * Steps:\n * 1. Convert the `bytes32` arrays `a` and `b` to arrays of `uint256` using `_toUints`.\n * 2. Compute the union of the two `uint256` arrays using `_union`.\n * 3. Convert the resulting `uint256` array back to a `bytes32` array using `_toBytes32s`.\n * 4. Return the resulting `bytes32` array.\n */"
        },
        {
            "identifier": "clean",
            "parameters": "address[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function clean(address[] memory a) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let addressMask := shr(96, not(0))\n            for { let end := add(a, shl(5, mload(a))) } iszero(eq(a, end)) {} {\n                a := add(a, 0x20)\n                mstore(a, and(mload(a), addressMask))\n            }\n        }\n    }",
            "start": "573",
            "end": "582",
            "class": "LibSort",
            "signature": " cleanaddress[] memory a",
            "full_signature": "function clean(address[] memory a) internal  pure",
            "class_method_signature": "LibSort.cleanaddress[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Cleans an array of addresses by masking out non-address bits.\n *\n * @param a An array of addresses to be cleaned.\n *\n * Steps:\n * 1. Define an address mask to ensure only the lower 160 bits (20 bytes) are retained.\n * 2. Iterate through the array of addresses.\n * 3. For each address, apply the mask to remove any non-address bits.\n * 4. Store the cleaned address back into the array.\n *\n * @dev This function uses inline assembly to optimize memory operations.\n */"
        },
        {
            "identifier": "_difference",
            "parameters": "uint256[] memory a, uint256[] memory b, uint256 signed",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function _difference(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }",
            "start": "687",
            "end": "725",
            "class": "LibSort",
            "signature": "returns (uint256[] memory c) _differenceuint256[] memory a, uint256[] memory b, uint256 signed",
            "full_signature": "function _difference(uint256[] memory a, uint256[] memory b, uint256 signed) private  pure returns (uint256[] memory c)",
            "class_method_signature": "LibSort._differenceuint256[] memory a, uint256[] memory b, uint256 signed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the difference between two arrays of unsigned integers (`a` and `b`) based on a signed flag.\n * \n * @dev This function uses low-level assembly to efficiently compute the difference between two arrays.\n *      The function assumes that the input arrays are sorted and uses a merge-like approach to compute the difference.\n *      The result is stored in a new array `c`, which is allocated in memory.\n *\n * @param a The first array of unsigned integers.\n * @param b The second array of unsigned integers.\n * @param signed A flag to determine the comparison logic (e.g., signed or unsigned comparison).\n * \n * @return c A new array containing the difference between `a` and `b`.\n *\n * Steps:\n * 1. Initialize pointers and memory locations for the input arrays and the result array.\n * 2. Iterate through both arrays simultaneously:\n *    - If the current elements of `a` and `b` are equal, skip both.\n *    - If the current element of `a` is greater than the current element of `b` (based on the `signed` flag), skip the element in `b`.\n *    - Otherwise, add the current element of `a` to the result array `c`.\n * 3. After processing both arrays, add any remaining elements from `a` to the result array `c`.\n * 4. Store the length of the result array `c` and update the free memory pointer.\n */"
        },
        {
            "identifier": "_intersection",
            "parameters": "uint256[] memory a, uint256[] memory b, uint256 signed",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    b := add(b, s)\n                    continue\n                }\n                a := add(a, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }",
            "start": "729",
            "end": "762",
            "class": "LibSort",
            "signature": "returns (uint256[] memory c) _intersectionuint256[] memory a, uint256[] memory b, uint256 signed",
            "full_signature": "function _intersection(uint256[] memory a, uint256[] memory b, uint256 signed) private  pure returns (uint256[] memory c)",
            "class_method_signature": "LibSort._intersectionuint256[] memory a, uint256[] memory b, uint256 signed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the intersection of two sorted arrays `a` and `b` with an optional signed offset.\n *\n * @param a The first sorted array of uint256 values.\n * @param b The second sorted array of uint256 values.\n * @param signed An optional signed offset to adjust the comparison logic.\n *\n * @return c A new array containing the intersection of `a` and `b`.\n *\n * Steps:\n * 1. Initialize pointers and memory locations for arrays `a`, `b`, and the result `c`.\n * 2. Iterate through both arrays simultaneously using pointers.\n * 3. Compare elements of `a` and `b`:\n *    - If elements are equal, add the element to the result array `c`.\n *    - If elements are not equal, move the pointer of the array with the smaller element.\n * 4. Store the length of the result array `c` and allocate memory for it.\n * 5. Return the result array `c`.\n *\n * @dev This function uses low-level assembly for memory-safe operations and optimized performance.\n */"
        },
        {
            "identifier": "_union",
            "parameters": "uint256[] memory a, uint256[] memory b, uint256 signed",
            "modifiers": "pure",
            "return": "returns (uint256[] memory c)",
            "body": "function _union(uint256[] memory a, uint256[] memory b, uint256 signed)\n        private\n        pure\n        returns (uint256[] memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let s := 0x20\n            let aEnd := add(a, shl(5, mload(a)))\n            let bEnd := add(b, shl(5, mload(b)))\n            c := mload(0x40) // Set `c` to the free memory pointer.\n            a := add(a, s)\n            b := add(b, s)\n            let k := c\n            for {} iszero(or(gt(a, aEnd), gt(b, bEnd))) {} {\n                let u := mload(a)\n                let v := mload(b)\n                if iszero(xor(u, v)) {\n                    k := add(k, s)\n                    mstore(k, u)\n                    a := add(a, s)\n                    b := add(b, s)\n                    continue\n                }\n                if iszero(lt(add(u, signed), add(v, signed))) {\n                    k := add(k, s)\n                    mstore(k, v)\n                    b := add(b, s)\n                    continue\n                }\n                k := add(k, s)\n                mstore(k, u)\n                a := add(a, s)\n            }\n            for {} iszero(gt(a, aEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(a))\n                a := add(a, s)\n            }\n            for {} iszero(gt(b, bEnd)) {} {\n                k := add(k, s)\n                mstore(k, mload(b))\n                b := add(b, s)\n            }\n            mstore(c, shr(5, sub(k, c))) // Store the length of `c`.\n            mstore(0x40, add(k, s)) // Allocate the memory for `c`.\n        }\n    }",
            "start": "766",
            "end": "813",
            "class": "LibSort",
            "signature": "returns (uint256[] memory c) _unionuint256[] memory a, uint256[] memory b, uint256 signed",
            "full_signature": "function _union(uint256[] memory a, uint256[] memory b, uint256 signed) private  pure returns (uint256[] memory c)",
            "class_method_signature": "LibSort._unionuint256[] memory a, uint256[] memory b, uint256 signed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "private",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the union of two sorted arrays `a` and `b` with optional signed comparison.\n *\n * @param a The first sorted array of uint256 values.\n * @param b The second sorted array of uint256 values.\n * @param signed A flag to determine if signed comparison should be used (0 for unsigned, non-zero for signed).\n * @return c A new array containing the union of `a` and `b`.\n *\n * Steps:\n * 1. Initialize pointers and memory locations for arrays `a`, `b`, and the result `c`.\n * 2. Iterate through both arrays simultaneously:\n *    - If elements from `a` and `b` are equal, add the element to `c` and move both pointers.\n *    - If the element from `a` is less than the element from `b` (considering the `signed` flag), add the element from `a` to `c` and move the `a` pointer.\n *    - Otherwise, add the element from `b` to `c` and move the `b` pointer.\n * 3. If there are remaining elements in `a`, add them to `c`.\n * 4. If there are remaining elements in `b`, add them to `c`.\n * 5. Store the length of the resulting array `c` and update the free memory pointer.\n *\n * Note: This function uses low-level assembly for memory-safe operations and efficient array manipulation.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DynamicArrayLib.sol": [
        {
            "identifier": "malloc",
            "parameters": "uint256 n",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function malloc(uint256 n) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := or(sub(0, shr(32, n)), mload(0x40))\n            mstore(result, n)\n            mstore(0x40, add(add(result, 0x20), shl(5, n)))\n        }\n    }",
            "start": "35",
            "end": "42",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) mallocuint256 n",
            "full_signature": "function malloc(uint256 n) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.mallocuint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Allocates memory for an array of `n` elements and returns a pointer to the array.\n *\n * @param n The number of elements to allocate memory for.\n * @return result A pointer to the allocated memory for the array.\n *\n * Steps:\n * 1. Calculate the memory pointer for the array by combining the size of the array (`n`) with the free memory pointer (`mload(0x40)`).\n * 2. Store the size of the array (`n`) at the allocated memory location.\n * 3. Update the free memory pointer (`mstore(0x40)`) to point to the next available memory slot after the allocated array.\n *\n * @dev This function uses inline assembly for memory allocation and is marked as memory-safe.\n */"
        },
        {
            "identifier": "zeroize",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function zeroize(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            codecopy(add(result, 0x20), codesize(), shl(5, mload(result)))\n        }\n    }",
            "start": "45",
            "end": "51",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) zeroizeuint256[] memory a",
            "full_signature": "function zeroize(uint256[] memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.zeroizeuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Zeroizes an array of unsigned integers in memory.\n *\n * @param a The input array of unsigned integers to be zeroized.\n * @return result A new array with the same length as the input array, but all elements set to zero.\n *\n * Steps:\n * 1. Assign the input array `a` to the `result` variable.\n * 2. Use inline assembly to copy zeroed memory into the `result` array.\n *   - `codecopy` is used to copy memory from the code section (which is zeroed) into the `result` array.\n *   - The size of the copied memory is calculated as `shl(5, mload(result))`, which is equivalent to `32 * length of the array`.\n *   - This effectively zeroes out the entire array.\n */"
        },
        {
            "identifier": "get",
            "parameters": "uint256[] memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function get(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "start": "54",
            "end": "59",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) getuint256[] memory a, uint256 i",
            "full_signature": "function get(uint256[] memory a, uint256 i) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.getuint256[] memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves an element from a uint256 array at a specified index using low-level assembly.\n *\n * @param a The uint256 array from which to retrieve the element.\n * @param i The index of the element to retrieve.\n * @return result The value of the element at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to perform a memory-safe operation.\n * 2. Calculate the memory address of the element at index `i` in the array `a`.\n * 3. Load the value from the calculated memory address into `result`.\n *\n * Note: This function uses low-level assembly for efficiency and assumes the array is properly allocated.\n */"
        },
        {
            "identifier": "getUint256",
            "parameters": "uint256[] memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function getUint256(uint256[] memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "start": "62",
            "end": "67",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) getUint256uint256[] memory a, uint256 i",
            "full_signature": "function getUint256(uint256[] memory a, uint256 i) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.getUint256uint256[] memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a uint256 value from a given array at a specified index.\n *\n * @param a The array of uint256 values from which to retrieve the element.\n * @param i The index of the element to retrieve.\n * @return result The uint256 value at the specified index in the array.\n *\n * Steps:\n * 1. Use inline assembly to perform a memory-safe operation.\n * 2. Calculate the memory address of the element at the specified index:\n *    - Start with the base address of the array (`a`).\n *    - Add 0x20 to skip the length slot of the array.\n *    - Shift the index `i` left by 5 (equivalent to multiplying by 32) to get the offset.\n * 3. Load the value from the calculated memory address into `result`.\n */"
        },
        {
            "identifier": "getAddress",
            "parameters": "uint256[] memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (address result)",
            "body": "function getAddress(uint256[] memory a, uint256 i) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "start": "70",
            "end": "75",
            "class": "DynamicArrayLib",
            "signature": "returns (address result) getAddressuint256[] memory a, uint256 i",
            "full_signature": "function getAddress(uint256[] memory a, uint256 i) internal  pure returns (address result)",
            "class_method_signature": "DynamicArrayLib.getAddressuint256[] memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves an address from a given array of uint256 values at a specific index.\n *\n * @param a The array of uint256 values from which to retrieve the address.\n * @param i The index of the address to retrieve within the array.\n * @return result The address stored at the specified index in the array.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the memory offset for the desired index `i` in the array `a`.\n * 3. Load the address from the calculated memory location and return it.\n *\n * Note: This function assumes that the array `a` contains valid addresses stored as uint256 values.\n */"
        },
        {
            "identifier": "getBool",
            "parameters": "uint256[] memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function getBool(uint256[] memory a, uint256 i) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "start": "78",
            "end": "83",
            "class": "DynamicArrayLib",
            "signature": "returns (bool result) getBooluint256[] memory a, uint256 i",
            "full_signature": "function getBool(uint256[] memory a, uint256 i) internal  pure returns (bool result)",
            "class_method_signature": "DynamicArrayLib.getBooluint256[] memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a boolean value from a specific index in a uint256 array using low-level assembly.\n *\n * @param a The uint256 array from which to retrieve the boolean value.\n * @param i The index in the array where the boolean value is stored.\n * @return result The boolean value retrieved from the specified index in the array.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the memory address of the desired index in the array.\n * 3. Load the value from the calculated memory address and return it as a boolean.\n *\n * Note: This function uses assembly to directly access memory, which is more efficient but less safe than Solidity's high-level constructs.\n */"
        },
        {
            "identifier": "getBytes32",
            "parameters": "uint256[] memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function getBytes32(uint256[] memory a, uint256 i) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(a, 0x20), shl(5, i)))\n        }\n    }",
            "start": "86",
            "end": "91",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32 result) getBytes32uint256[] memory a, uint256 i",
            "full_signature": "function getBytes32(uint256[] memory a, uint256 i) internal  pure returns (bytes32 result)",
            "class_method_signature": "DynamicArrayLib.getBytes32uint256[] memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a bytes32 value from a specific index in a uint256 array.\n *\n * @param a The uint256 array from which to retrieve the value.\n * @param i The index of the element to retrieve.\n * @return result The bytes32 value at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the memory address of the element at index `i` in the array `a`.\n * 3. Load the bytes32 value from the calculated memory address.\n * 4. Return the retrieved value.\n *\n * Note: This function uses `assembly` for memory-safe operations, ensuring efficient and safe access to array elements.\n */"
        },
        {
            "identifier": "set",
            "parameters": "uint256[] memory a, uint256 i, uint256 data",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function set(uint256[] memory a, uint256 i, uint256 data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), data)\n        }\n    }",
            "start": "94",
            "end": "104",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) setuint256[] memory a, uint256 i, uint256 data",
            "full_signature": "function set(uint256[] memory a, uint256 i, uint256 data) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.setuint256[] memory a, uint256 i, uint256 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a value at a specific index in a uint256 array and returns the modified array.\n *\n * @param a The original uint256 array to modify.\n * @param i The index at which to set the new value.\n * @param data The new value to set at the specified index.\n * @return result The modified array with the updated value at the specified index.\n *\n * Steps:\n * 1. Assign the input array `a` to the `result` variable.\n * 2. Use inline assembly to safely update the value at the specified index `i` in the array.\n *    - Calculate the memory offset for the index `i` using `shl(5, i)` (equivalent to `i * 32`).\n *    - Use `mstore` to store the new `data` value at the calculated memory offset.\n * 3. Return the modified array `result`.\n */"
        },
        {
            "identifier": "set",
            "parameters": "uint256[] memory a, uint256 i, address data",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function set(uint256[] memory a, uint256 i, address data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), shr(96, shl(96, data)))\n        }\n    }",
            "start": "107",
            "end": "117",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) setuint256[] memory a, uint256 i, address data",
            "full_signature": "function set(uint256[] memory a, uint256 i, address data) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.setuint256[] memory a, uint256 i, address data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a specific element in a `uint256[]` array to a given address value, using low-level assembly for memory safety.\n *\n * @param a The input array of `uint256` values.\n * @param i The index of the element in the array to be updated.\n * @param data The address value to be stored in the specified array index.\n * @return result The updated array with the new value at the specified index.\n *\n * Steps:\n * 1. Assign the input array `a` to the `result` variable.\n * 2. Use inline assembly to safely update the array element at index `i` with the provided address `data`.\n *    - Calculate the memory offset for the array element.\n *    - Shift and mask the address to fit into a `uint256` slot.\n *    - Store the modified value in the array.\n */"
        },
        {
            "identifier": "set",
            "parameters": "uint256[] memory a, uint256 i, bool data",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function set(uint256[] memory a, uint256 i, bool data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), iszero(iszero(data)))\n        }\n    }",
            "start": "120",
            "end": "130",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) setuint256[] memory a, uint256 i, bool data",
            "full_signature": "function set(uint256[] memory a, uint256 i, bool data) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.setuint256[] memory a, uint256 i, bool data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a boolean value at a specific index in a uint256 array.\n *\n * @param a The original uint256 array.\n * @param i The index at which to set the boolean value.\n * @param data The boolean value to set (true or false).\n * @return result The modified array with the boolean value set at the specified index.\n *\n * Steps:\n * 1. Assign the input array `a` to the `result` variable.\n * 2. Use inline assembly to safely modify the array in memory:\n *    - Calculate the memory address of the element at index `i`.\n *    - Convert the boolean `data` to a uint256 (1 for true, 0 for false).\n *    - Store the converted value at the calculated memory address.\n * 3. Return the modified array.\n *\n * @dev This function uses low-level assembly to ensure memory safety and efficiency.\n */"
        },
        {
            "identifier": "set",
            "parameters": "uint256[] memory a, uint256 i, bytes32 data",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function set(uint256[] memory a, uint256 i, bytes32 data)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(result, 0x20), shl(5, i)), data)\n        }\n    }",
            "start": "133",
            "end": "143",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) setuint256[] memory a, uint256 i, bytes32 data",
            "full_signature": "function set(uint256[] memory a, uint256 i, bytes32 data) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.setuint256[] memory a, uint256 i, bytes32 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a specific element in a `uint256[]` array to a given `bytes32` value using low-level assembly.\n *\n * @param a The original `uint256[]` array to be modified.\n * @param i The index of the element in the array to be updated.\n * @param data The `bytes32` value to set at the specified index.\n * @return result The modified array with the updated value at the specified index.\n *\n * Steps:\n * 1. Assign the input array `a` to the `result` variable.\n * 2. Use inline assembly to safely update the value at the specified index:\n *    - Calculate the memory offset for the index `i` in the array.\n *    - Store the `bytes32` value `data` at the calculated memory location.\n * 3. Return the modified array.\n *\n * @dev This function uses low-level assembly for memory-safe operations. Ensure the index `i` is within bounds.\n */"
        },
        {
            "identifier": "truncate",
            "parameters": "uint256[] memory a, uint256 n",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function truncate(uint256[] memory a, uint256 n)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            mstore(mul(lt(n, mload(result)), result), n)\n        }\n    }",
            "start": "195",
            "end": "205",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) truncateuint256[] memory a, uint256 n",
            "full_signature": "function truncate(uint256[] memory a, uint256 n) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.truncateuint256[] memory a, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Truncates an array of uint256 to a specified length `n` in a memory-safe manner.\n *\n * @param a The original array of uint256 values.\n * @param n The desired length to truncate the array to.\n * @return result The truncated array with length `n`.\n *\n * Steps:\n * 1. Use inline assembly to perform the truncation in a memory-safe way.\n * 2. Assign the original array `a` to the result.\n * 3. If `n` is less than the length of the original array, update the length of the result array to `n` using `mstore`.\n *\n * Note: This function is marked as `internal` and `pure`, meaning it does not modify state and can only be called internally.\n */"
        },
        {
            "identifier": "free",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function free(uint256[] memory a) internal pure returns (uint256[] memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := a\n            let n := mload(result)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), result), mload(0x40)))), result)\n            mstore(result, 0)\n        }\n    }",
            "start": "208",
            "end": "216",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) freeuint256[] memory a",
            "full_signature": "function free(uint256[] memory a) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.freeuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Frees the memory allocated for an array by resetting its length to 0.\n *\n * @param a The array of uint256 values to be freed.\n * @return result The same array with its length reset to 0.\n *\n * Steps:\n * 1. Assign the input array `a` to the `result` variable.\n * 2. Load the length of the array into `n`.\n * 3. Perform memory-safe assembly operations to reset the array length to 0.\n * 4. Return the modified array.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256[] memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(a, 0x20), shl(5, mload(a)))\n        }\n    }",
            "start": "219",
            "end": "224",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32 result) hashuint256[] memory a",
            "full_signature": "function hash(uint256[] memory a) internal  pure returns (bytes32 result)",
            "class_method_signature": "DynamicArrayLib.hashuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a given array of uint256 values.\n *\n * @param a The array of uint256 values to be hashed.\n * @return result The Keccak-256 hash of the array.\n *\n * Steps:\n * 1. Use inline assembly to optimize the hashing process.\n * 2. Calculate the hash by passing the starting memory address of the array (offset by 32 bytes) \n *    and the length of the array (multiplied by 32 bytes) to the `keccak256` opcode.\n * 3. Return the computed hash.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "uint256[] memory a, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (uint256[] memory result)",
            "body": "function slice(uint256[] memory a, uint256 start, uint256 end)\n        internal\n        pure\n        returns (uint256[] memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrayLen := mload(a)\n            if iszero(gt(arrayLen, end)) { end := arrayLen }\n            if iszero(gt(arrayLen, start)) { start := arrayLen }\n            if lt(start, end) {\n                result := mload(0x40)\n                let resultLen := sub(end, start)\n                mstore(result, resultLen)\n                a := add(a, shl(5, start))\n                // Copy the `a` one word at a time, backwards.\n                let o := shl(5, resultLen)\n                mstore(0x40, add(add(result, o), 0x20)) // Allocate memory.\n                for {} 1 {} {\n                    mstore(add(result, o), mload(add(a, o)))\n                    o := sub(o, 0x20)\n                    if iszero(o) { break }\n                }\n            }\n        }\n    }",
            "start": "227",
            "end": "252",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256[] memory result) sliceuint256[] memory a, uint256 start, uint256 end",
            "full_signature": "function slice(uint256[] memory a, uint256 start, uint256 end) internal  pure returns (uint256[] memory result)",
            "class_method_signature": "DynamicArrayLib.sliceuint256[] memory a, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Slices a portion of a dynamic array of uint256 values.\n *\n * @param a The input array from which a slice will be extracted.\n * @param start The starting index of the slice (inclusive).\n * @param end The ending index of the slice (exclusive).\n * @return result A new array containing the sliced portion of the input array.\n *\n * Steps:\n * 1. Load the length of the input array `a`.\n * 2. Adjust the `end` index to ensure it does not exceed the array length.\n * 3. Adjust the `start` index to ensure it does not exceed the array length.\n * 4. If `start` is less than `end`, proceed to create the slice:\n *    a. Allocate memory for the result array.\n *    b. Calculate the length of the result array (`resultLen`).\n *    c. Store the length of the result array in the first word of the result.\n *    d. Adjust the pointer of `a` to start at the `start` index.\n *    e. Copy elements from `a` to `result` one word at a time, working backwards.\n *    f. Allocate memory for the result array and ensure proper alignment.\n * 5. If `start` is not less than `end`, the result will be an empty array.\n *\n * @dev This function uses low-level assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "uint256[] memory a, uint256 needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function indexOf(uint256[] memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            if lt(from, mload(a)) {\n                let o := add(a, shl(5, from))\n                let end := add(shl(5, add(1, mload(a))), a)\n                let c := mload(end) // Cache the word after the array.\n                for { mstore(end, needle) } 1 {} {\n                    o := add(o, 0x20)\n                    if eq(mload(o), needle) { break }\n                }\n                mstore(end, c) // Restore the word after the array.\n                if iszero(eq(o, end)) { result := shr(5, sub(o, add(0x20, a))) }\n            }\n        }\n    }",
            "start": "261",
            "end": "281",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) indexOfuint256[] memory a, uint256 needle, uint256 from",
            "full_signature": "function indexOf(uint256[] memory a, uint256 needle, uint256 from) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.indexOfuint256[] memory a, uint256 needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the index of a specific value (`needle`) in a given array (`a`), starting from a specified index (`from`).\n *\n * @dev This function uses low-level assembly for efficient array traversal. It temporarily modifies the array's memory to optimize the search process.\n *\n * @param a The array in which to search for the value.\n * @param needle The value to search for in the array.\n * @param from The index from which to start the search.\n *\n * @return result The index of the first occurrence of `needle` in the array, starting from `from`. Returns `type(uint256).max` (not(0)) if the value is not found.\n *\n * Steps:\n * 1. Initialize `result` to `type(uint256).max` (not(0)) to indicate the value is not found.\n * 2. Check if `from` is within the bounds of the array.\n * 3. Calculate the starting memory offset for the search.\n * 4. Cache the word after the array to restore it later.\n * 5. Temporarily store `needle` at the end of the array to act as a sentinel value.\n * 6. Iterate through the array starting from `from` until `needle` is found.\n * 7. Restore the cached word after the array.\n * 8. If `needle` is found, calculate and return its index. Otherwise, return `type(uint256).max`.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "uint256[] memory a, uint256 needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function lastIndexOf(uint256[] memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := not(0)\n            let n := mload(a)\n            if n {\n                if iszero(lt(from, n)) { from := sub(n, 1) }\n                let o := add(shl(5, add(2, from)), a)\n                for { mstore(a, needle) } 1 {} {\n                    o := sub(o, 0x20)\n                    if eq(mload(o), needle) { break }\n                }\n                mstore(a, n) // Restore the length.\n                if iszero(eq(o, a)) { result := shr(5, sub(o, add(0x20, a))) }\n            }\n        }\n    }",
            "start": "291",
            "end": "311",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) lastIndexOfuint256[] memory a, uint256 needle, uint256 from",
            "full_signature": "function lastIndexOf(uint256[] memory a, uint256 needle, uint256 from) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.lastIndexOfuint256[] memory a, uint256 needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a specific value (`needle`) in a given array (`a`), starting from a specified index (`from`).\n *\n * @param a The array in which to search for the value.\n * @param needle The value to search for in the array.\n * @param from The index from which to start the search. If `from` is greater than or equal to the array length, the search starts from the last element.\n * @return result The index of the last occurrence of `needle` in the array. Returns `not(0)` (max uint256) if the value is not found.\n *\n * Steps:\n * 1. Initialize `result` to `not(0)` (indicating not found by default).\n * 2. Load the length of the array (`n`).\n * 3. If the array is not empty:\n *    a. Adjust `from` to be the last index if it is out of bounds.\n *    b. Calculate the starting memory offset (`o`) for the search.\n *    c. Temporarily store `needle` in the array's length slot to simplify the search loop.\n *    d. Iterate backward through the array to find the last occurrence of `needle`.\n *    e. Restore the original array length after the search.\n *    f. If `needle` is found, calculate and return its index.\n * 4. If `needle` is not found, return `not(0)`.\n *\n * @dev This function uses low-level assembly for efficient memory manipulation.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "uint256[] memory a, uint256 needle",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function lastIndexOf(uint256[] memory a, uint256 needle)\n        internal\n        pure\n        returns (uint256 result)\n    {\n        result = lastIndexOf(a, needle, NOT_FOUND);\n    }",
            "start": "315",
            "end": "321",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) lastIndexOfuint256[] memory a, uint256 needle",
            "full_signature": "function lastIndexOf(uint256[] memory a, uint256 needle) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.lastIndexOfuint256[] memory a, uint256 needle",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a specific value (`needle`) in an array (`a`).\n * @dev This function is internal and pure, meaning it does not modify state and can only be called internally.\n *\n * @param a The array in which to search for the value.\n * @param needle The value to search for in the array.\n * @return result The index of the last occurrence of `needle` in `a`. If `needle` is not found, it returns `NOT_FOUND`.\n *\n * Steps:\n * 1. Calls an overloaded version of `lastIndexOf` with the array, value, and `NOT_FOUND` as the default return value if the value is not found.\n * 2. Returns the result of the internal `lastIndexOf` function call.\n */"
        },
        {
            "identifier": "directReturn",
            "parameters": "uint256[] memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function directReturn(uint256[] memory a) internal pure {\n        assembly {\n            let retStart := sub(a, 0x20)\n            mstore(retStart, 0x20)\n            return(retStart, add(0x40, shl(5, mload(a))))\n        }\n    }",
            "start": "324",
            "end": "330",
            "class": "DynamicArrayLib",
            "signature": " directReturnuint256[] memory a",
            "full_signature": "function directReturn(uint256[] memory a) internal  pure",
            "class_method_signature": "DynamicArrayLib.directReturnuint256[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A low-level assembly function that directly returns an array from memory.\n *\n * @param a The array to be returned. The function assumes the array is passed as a memory pointer.\n *\n * Steps:\n * 1. Calculate the starting position of the return data by subtracting 0x20 (32 bytes) from the array pointer.\n * 2. Store the length of the array (0x20) at the calculated starting position.\n * 3. Use the `return` opcode to return the array data, including its length and elements.\n *    - The size of the return data is calculated as 0x40 (64 bytes) plus the size of the array elements (32 bytes * number of elements).\n */"
        },
        {
            "identifier": "wrap",
            "parameters": "address[] memory a",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function wrap(address[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "start": "350",
            "end": "355",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) wrapaddress[] memory a",
            "full_signature": "function wrap(address[] memory a) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.wrapaddress[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Wraps an array of addresses into a `DynamicArray` struct.\n *\n * @param a The array of addresses to be wrapped.\n * @return result A `DynamicArray` struct containing the provided array of addresses.\n *\n * Steps:\n * 1. Use inline assembly to store the array of addresses into the `result` struct.\n * 2. Return the `result` struct.\n */"
        },
        {
            "identifier": "wrap",
            "parameters": "bool[] memory a",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function wrap(bool[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "start": "358",
            "end": "363",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) wrapbool[] memory a",
            "full_signature": "function wrap(bool[] memory a) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.wrapbool[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Wraps a boolean array into a DynamicArray struct.\n *\n * @param a The boolean array to be wrapped.\n * @return result A DynamicArray struct containing the wrapped boolean array.\n *\n * Steps:\n * 1. Use inline assembly to store the boolean array `a` into the `result` struct.\n * 2. The `mstore` instruction is used to store the array in memory at the location of `result`.\n *\n * @dev This function uses low-level assembly to directly manipulate memory, ensuring memory safety.\n */"
        },
        {
            "identifier": "wrap",
            "parameters": "bytes32[] memory a",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function wrap(bytes32[] memory a) internal pure returns (DynamicArray memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, a)\n        }\n    }",
            "start": "366",
            "end": "371",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) wrapbytes32[] memory a",
            "full_signature": "function wrap(bytes32[] memory a) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.wrapbytes32[] memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Wraps a bytes32 array into a DynamicArray struct.\n *\n * @param a The bytes32 array to be wrapped.\n * @return result A DynamicArray struct containing the provided bytes32 array.\n *\n * Steps:\n * 1. Use inline assembly to store the bytes32 array `a` into the `result` struct.\n * 2. The `mstore` instruction is used to store the array at the memory location of `result`.\n *\n * Note: This function is marked as `internal pure`, meaning it can only be called internally and does not modify the state.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function clear(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(result), 0)\n        }\n    }",
            "start": "374",
            "end": "381",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) clearDynamicArray memory a",
            "full_signature": "function clear(DynamicArray memory a) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.clearDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the contents of a DynamicArray and returns the modified array.\n *\n * @param a The DynamicArray to be cleared.\n * @return result The modified DynamicArray after clearing its contents.\n *\n * Steps:\n * 1. Deallocate the memory associated with the result array.\n * 2. Assign the input array `a` to the result array.\n * 3. Use inline assembly to set the length of the result array to 0, effectively clearing its contents.\n */"
        },
        {
            "identifier": "free",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function free(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(result)\n            if iszero(eq(arrData, 0x60)) {\n                let prime := 8188386068317523\n                let cap := mload(sub(arrData, 0x20))\n                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n                cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n                // If `cap` is non-zero and the memory is contiguous, we can free it.\n                if lt(iszero(cap), eq(mload(0x40), add(arrData, add(0x20, cap)))) {\n                    mstore(0x40, sub(arrData, 0x20))\n                }\n                mstore(result, 0x60)\n            }\n        }\n    }",
            "start": "384",
            "end": "402",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) freeDynamicArray memory a",
            "full_signature": "function free(DynamicArray memory a) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.freeDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Frees the memory allocated for a DynamicArray and resets it to its initial state.\n *\n * @param a The DynamicArray to be freed.\n * @return result The DynamicArray after being freed and reset.\n *\n * Steps:\n * 1. Deallocate the memory of the result array.\n * 2. Assign the input array `a` to `result`.\n * 3. Use inline assembly to handle low-level memory operations:\n *    - Load the array data pointer.\n *    - Check if the array data is not already in its initial state (0x60).\n *    - Calculate the capacity of the array using a prime number (8188386068317523).\n *    - If the capacity is non-zero and the memory is contiguous, free the memory by updating the free memory pointer.\n *    - Reset the array data pointer to its initial state (0x60).\n */\nfunction free(DynamicArray memory a) internal pure returns (DynamicArray memory result) {\n    _deallocate(result);\n    result = a;\n    /// @solidity memory-safe-assembly\n    assembly {\n        let arrData := mload(result)\n        if iszero(eq(arrData, 0x60)) {\n            let prime := 8188386068317523\n            let cap := mload(sub(arrData, 0x20))\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n            // If `cap` is non-zero and the memory is contiguous, we can free it.\n            if lt(iszero(cap), eq(mload(0x40), add(arrData, add(0x20, cap)))) {\n                mstore(0x40, sub(arrData, 0x20))\n            }\n            mstore(result, 0x60)\n        }\n */"
        },
        {
            "identifier": "resize",
            "parameters": "DynamicArray memory a, uint256 n",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function resize(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        reserve(result, n);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(result)\n            let arrLen := mload(arrData)\n            if iszero(lt(n, arrLen)) {\n                codecopy(add(arrData, shl(5, add(1, arrLen))), codesize(), shl(5, sub(n, arrLen)))\n            }\n            mstore(arrData, n)\n        }\n    }",
            "start": "405",
            "end": "422",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) resizeDynamicArray memory a, uint256 n",
            "full_signature": "function resize(DynamicArray memory a, uint256 n) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.resizeDynamicArray memory a, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Resizes a DynamicArray to a specified length `n`.\n *\n * @param a The DynamicArray to be resized.\n * @param n The new length to which the array should be resized.\n * @return result The resized DynamicArray.\n *\n * Steps:\n * 1. Deallocate any existing memory associated with the result array.\n * 2. Assign the input array `a` to the result array.\n * 3. Reserve memory for the result array to accommodate the new length `n`.\n * 4. Use inline assembly to:\n *    - Load the array data and its current length.\n *    - If the new length `n` is greater than the current length, copy additional memory from the code section to the array.\n *    - Update the array length to `n`.\n *\n * @dev This function uses low-level assembly to manipulate memory directly, ensuring efficient resizing of the array.\n */"
        },
        {
            "identifier": "expand",
            "parameters": "DynamicArray memory a, uint256 n",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function expand(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        if (n >= a.data.length) {\n            reserve(result, n);\n            /// @solidity memory-safe-assembly\n            assembly {\n                mstore(mload(result), n)\n            }\n        }\n    }",
            "start": "427",
            "end": "441",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) expandDynamicArray memory a, uint256 n",
            "full_signature": "function expand(DynamicArray memory a, uint256 n) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.expandDynamicArray memory a, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Expands the capacity of a DynamicArray to at least `n` elements.\n *\n * @param a The DynamicArray to be expanded.\n * @param n The minimum number of elements the array should be able to hold.\n * @return result The expanded DynamicArray.\n *\n * Steps:\n * 1. Deallocate any existing memory associated with the `result` array.\n * 2. Assign the input array `a` to `result`.\n * 3. If `n` is greater than or equal to the current length of `a.data`, reserve additional memory for `result` to hold at least `n` elements.\n * 4. Update the length of `result` to `n` using inline assembly to ensure memory safety.\n */"
        },
        {
            "identifier": "truncate",
            "parameters": "DynamicArray memory a, uint256 n",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function truncate(DynamicArray memory a, uint256 n)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mul(lt(n, mload(mload(result))), mload(result)), n)\n        }\n    }",
            "start": "445",
            "end": "456",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) truncateDynamicArray memory a, uint256 n",
            "full_signature": "function truncate(DynamicArray memory a, uint256 n) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.truncateDynamicArray memory a, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Truncates a DynamicArray to a specified length `n`.\n *\n * @param a The DynamicArray to be truncated.\n * @param n The desired length to truncate the array to.\n * @return result A new DynamicArray with the truncated length.\n *\n * Steps:\n * 1. Deallocate any existing memory for the result array.\n * 2. Assign the input array `a` to the result array.\n * 3. Use inline assembly to safely truncate the array:\n *    - Check if `n` is less than the current length of the array.\n *    - If true, update the length of the array to `n` in memory.\n *    - This operation is memory-safe and ensures no out-of-bounds access.\n */"
        },
        {
            "identifier": "reserve",
            "parameters": "DynamicArray memory a, uint256 minimum",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function reserve(DynamicArray memory a, uint256 minimum)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(minimum, 0xffffffff)) { invalid() } // For extra safety.\n            for { let arrData := mload(a) } 1 {} {\n                // Some random prime number to multiply `cap`, so that\n                // we know that the `cap` is for a dynamic array.\n                // Selected to be larger than any memory pointer realistically.\n                let prime := 8188386068317523\n                // Special case for `arrData` pointing to zero pointer.\n                if eq(arrData, 0x60) {\n                    let newCap := shl(5, add(1, minimum))\n                    let capSlot := mload(0x40)\n                    mstore(capSlot, mul(prime, newCap)) // Store the capacity.\n                    let newArrData := add(0x20, capSlot)\n                    mstore(newArrData, 0) // Store the length.\n                    mstore(0x40, add(newArrData, add(0x20, newCap))) // Allocate memory.\n                    mstore(a, newArrData)\n                    break\n                }\n                let w := not(0x1f)\n                let cap := mload(add(arrData, w)) // `mload(sub(arrData, w))`.\n                // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n                cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n                let newCap := shl(5, minimum)\n                // If we don't need to grow the memory.\n                if iszero(and(gt(minimum, mload(arrData)), gt(newCap, cap))) { break }\n                // If the memory is contiguous, we can simply expand it.\n                if eq(mload(0x40), add(arrData, add(0x20, cap))) {\n                    mstore(add(arrData, w), mul(prime, newCap)) // Store the capacity.\n                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.\n                    break\n                }\n                let capSlot := mload(0x40)\n                let newArrData := add(capSlot, 0x20)\n                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.\n                mstore(a, newArrData) // Store the `newArrData`.\n                // Copy `arrData` one word at a time, backwards.\n                for { let o := add(0x20, shl(5, mload(arrData))) } 1 {} {\n                    mstore(add(newArrData, o), mload(add(arrData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                mstore(capSlot, mul(prime, newCap)) // Store the capacity.\n                mstore(newArrData, mload(arrData)) // Store the length.\n                break\n            }\n        }\n    }",
            "start": "459",
            "end": "513",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) reserveDynamicArray memory a, uint256 minimum",
            "full_signature": "function reserve(DynamicArray memory a, uint256 minimum) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.reserveDynamicArray memory a, uint256 minimum",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Reserves memory for a dynamic array and ensures it has a minimum capacity.\n *\n * @param a The dynamic array to reserve memory for.\n * @param minimum The minimum capacity required for the array.\n * @return result The updated dynamic array with the reserved memory.\n *\n * Steps:\n * 1. Deallocate any existing memory for the result array.\n * 2. Assign the input array `a` to `result`.\n * 3. Use inline assembly to handle memory allocation and capacity management:\n *    - Check if the `minimum` value is within a safe range (less than 0xffffffff).\n *    - If the array data pointer is zero (uninitialized), allocate new memory:\n *      - Calculate the new capacity based on the `minimum` value.\n *      - Store the capacity in a new memory slot, using a prime number to mark it as a dynamic array.\n *      - Allocate memory for the array and store the length.\n *    - If the array is already initialized:\n *      - Extract the current capacity, ensuring it is a multiple of the prime number.\n *      - Calculate the new capacity based on the `minimum` value.\n *      - If the current capacity is sufficient, break out of the loop.\n *      - If the memory is contiguous, expand the allocation by updating the capacity and memory pointer.\n *      - If the memory is not contiguous, reallocate memory:\n *        - Copy the existing array data to the new memory location.\n *        - Update the capacity and length in the new memory slot.\n * 4. Return the updated dynamic array with the reserved memory.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicArray memory a, uint256 data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function p(DynamicArray memory a, uint256 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let arrData := mload(a)\n            let newArrLen := add(mload(arrData), 1)\n            let newArrBytesLen := shl(5, newArrLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic array.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 8188386068317523\n            let cap := mload(sub(arrData, 0x20))\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length.\n            for {} iszero(lt(newArrBytesLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := add(cap, or(cap, newArrBytesLen))\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(arrData, add(0x20, cap))), eq(arrData, 0x60))) {\n                    mstore(sub(arrData, 0x20), mul(prime, newCap)) // Store the capacity.\n                    mstore(0x40, add(arrData, add(0x20, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newArrData` to point to the word after `cap`.\n                let newArrData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newArrData, add(0x20, newCap))) // Reallocate the memory.\n                mstore(a, newArrData) // Store the `newArrData`.\n                let w := not(0x1f)\n                // Copy `arrData` one word at a time, backwards.\n                for { let o := newArrBytesLen } 1 {} {\n                    mstore(add(newArrData, o), mload(add(arrData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                mstore(add(newArrData, w), mul(prime, newCap)) // Store the memory.\n                arrData := newArrData // Assign `newArrData` to `arrData`.\n                break\n            }\n            mstore(add(arrData, newArrBytesLen), data) // Append `data`.\n            mstore(arrData, newArrLen) // Store the length.\n        }\n    }",
            "start": "516",
            "end": "565",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) pDynamicArray memory a, uint256 data",
            "full_signature": "function p(DynamicArray memory a, uint256 data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.pDynamicArray memory a, uint256 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Appends a new element to a dynamic array and handles memory reallocation if necessary.\n *\n * @param a The dynamic array to which the new element will be appended.\n * @param data The data to be appended to the dynamic array.\n * @return result The updated dynamic array with the new element appended.\n *\n * Steps:\n * 1. Deallocate the memory of the result array to ensure a clean state.\n * 2. Assign the input array `a` to `result`.\n * 3. Use inline assembly to handle low-level memory operations:\n *    - Retrieve the current array data and calculate the new length after appending.\n *    - Calculate the new byte length required for the array.\n *    - Use a prime number to determine the capacity of the array.\n *    - Check if the memory needs to be expanded or reallocated:\n *      - If the memory is contiguous, expand it by updating the memory pointer.\n *      - If the memory is not contiguous, reallocate memory and copy the existing data.\n *    - Append the new data to the array.\n *    - Update the array length in memory.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicArray memory a, address data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function p(DynamicArray memory a, address data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, uint256(uint160(data)));\n    }",
            "start": "568",
            "end": "575",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) pDynamicArray memory a, address data",
            "full_signature": "function p(DynamicArray memory a, address data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.pDynamicArray memory a, address data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Processes a DynamicArray by deallocating the current result and then \n *         calling the `p` function with the same array and the address converted \n *         to a uint256.\n *\n * @param a The DynamicArray to be processed.\n * @param data The address to be converted to a uint256 and passed to the `p` function.\n * @return result The resulting DynamicArray after processing.\n *\n * Steps:\n * 1. Deallocate the current result to free up memory.\n * 2. Call the `p` function with the provided DynamicArray `a` and the address `data` \n *    converted to a uint256.\n * 3. Return the resulting DynamicArray.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicArray memory a, bool data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function p(DynamicArray memory a, bool data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, _toUint(data));\n    }",
            "start": "578",
            "end": "585",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) pDynamicArray memory a, bool data",
            "full_signature": "function p(DynamicArray memory a, bool data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.pDynamicArray memory a, bool data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Processes a DynamicArray by deallocating the current result and then calling another function `p` with the array and a converted boolean value.\n *\n * @param a The DynamicArray to be processed.\n * @param data A boolean value that will be converted to a uint and passed to the next function.\n *\n * Steps:\n * 1. Deallocate the memory of the current result.\n * 2. Call the function `p` with the provided DynamicArray `a` and the boolean `data` converted to a uint.\n * 3. Return the result of the function `p`.\n *\n * @return result The processed DynamicArray returned by the function `p`.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicArray memory a, bytes32 data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function p(DynamicArray memory a, bytes32 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = p(a, uint256(data));\n    }",
            "start": "588",
            "end": "595",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) pDynamicArray memory a, bytes32 data",
            "full_signature": "function p(DynamicArray memory a, bytes32 data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.pDynamicArray memory a, bytes32 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Processes a DynamicArray by deallocating the current result and then calling the `p` function with the array and the uint256 representation of the provided bytes32 data.\n *\n * @param a The DynamicArray to be processed.\n * @param data The bytes32 data to be converted to uint256 and passed to the `p` function.\n * @return result The resulting DynamicArray after processing.\n *\n * Steps:\n * 1. Deallocate the current result to free up memory.\n * 2. Call the `p` function with the provided DynamicArray `a` and the uint256 representation of `data`.\n * 3. Return the resulting DynamicArray.\n */"
        },
        {
            "identifier": "pop",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function pop(DynamicArray memory a) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let o := mload(a)\n            let n := mload(o)\n            result := mload(add(o, shl(5, n)))\n            mstore(o, sub(n, iszero(iszero(n))))\n        }\n    }",
            "start": "622",
            "end": "630",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) popDynamicArray memory a",
            "full_signature": "function pop(DynamicArray memory a) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.popDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Pops the last element from a DynamicArray and returns it.\n *\n * @dev This function uses inline assembly to manipulate memory directly.\n * It assumes the DynamicArray is stored in memory and follows a specific layout.\n *\n * Steps:\n * 1. Load the base pointer of the array (`o`).\n * 2. Load the length of the array (`n`).\n * 3. Calculate the memory address of the last element and load its value (`result`).\n * 4. Decrement the length of the array by 1, unless it is already zero.\n *\n * @param a The DynamicArray from which to pop the last element.\n * @return result The value of the last element in the array.\n */"
        },
        {
            "identifier": "get",
            "parameters": "DynamicArray memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function get(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "start": "681",
            "end": "686",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) getDynamicArray memory a, uint256 i",
            "full_signature": "function get(DynamicArray memory a, uint256 i) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.getDynamicArray memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves an element from a dynamic array at a specified index using low-level assembly.\n *\n * @param a The dynamic array from which to retrieve the element.\n * @param i The index of the element to retrieve.\n * @return result The value of the element at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the memory address of the element at index `i` by:\n *    - Adding the base address of the array (`mload(a)`).\n *    - Adding the offset for the array's length (0x20).\n *    - Adding the offset for the element at index `i` (shl(5, i) which is equivalent to i * 32).\n * 3. Load the value at the calculated memory address and return it as `result`.\n *\n * @dev This function uses `memory-safe-assembly` to ensure safe memory access.\n */"
        },
        {
            "identifier": "getUint256",
            "parameters": "DynamicArray memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (uint256 result)",
            "body": "function getUint256(DynamicArray memory a, uint256 i) internal pure returns (uint256 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "start": "689",
            "end": "694",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256 result) getUint256DynamicArray memory a, uint256 i",
            "full_signature": "function getUint256(DynamicArray memory a, uint256 i) internal  pure returns (uint256 result)",
            "class_method_signature": "DynamicArrayLib.getUint256DynamicArray memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a `uint256` value from a `DynamicArray` at a specified index.\n *\n * @param a The `DynamicArray` from which to retrieve the value.\n * @param i The index of the value to retrieve.\n * @return result The `uint256` value stored at the specified index in the `DynamicArray`.\n *\n * Steps:\n * 1. Use inline assembly to perform a memory-safe operation.\n * 2. Calculate the memory address of the element at the specified index.\n * 3. Load the value from the calculated memory address and return it.\n *\n * Note: The function assumes that the `DynamicArray` is properly initialized and that the index is within bounds.\n */"
        },
        {
            "identifier": "getAddress",
            "parameters": "DynamicArray memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (address result)",
            "body": "function getAddress(DynamicArray memory a, uint256 i) internal pure returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "start": "697",
            "end": "702",
            "class": "DynamicArrayLib",
            "signature": "returns (address result) getAddressDynamicArray memory a, uint256 i",
            "full_signature": "function getAddress(DynamicArray memory a, uint256 i) internal  pure returns (address result)",
            "class_method_signature": "DynamicArrayLib.getAddressDynamicArray memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the address stored at a specific index in a DynamicArray.\n *\n * @param a The DynamicArray from which to retrieve the address.\n * @param i The index of the address to retrieve.\n * @return result The address stored at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the memory offset of the desired index within the DynamicArray.\n * 3. Load the address from the calculated memory location and return it.\n *\n * @dev This function uses assembly to directly access memory, ensuring efficient and safe retrieval of the address.\n */"
        },
        {
            "identifier": "getBool",
            "parameters": "DynamicArray memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function getBool(DynamicArray memory a, uint256 i) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "start": "705",
            "end": "710",
            "class": "DynamicArrayLib",
            "signature": "returns (bool result) getBoolDynamicArray memory a, uint256 i",
            "full_signature": "function getBool(DynamicArray memory a, uint256 i) internal  pure returns (bool result)",
            "class_method_signature": "DynamicArrayLib.getBoolDynamicArray memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a boolean value from a specific index in a DynamicArray.\n *\n * @param a The DynamicArray from which to retrieve the boolean value.\n * @param i The index of the boolean value to retrieve.\n * @return result The boolean value at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to safely access memory.\n * 2. Calculate the memory address of the boolean value at the specified index.\n * 3. Load the boolean value from the calculated memory address.\n * 4. Return the retrieved boolean value.\n */"
        },
        {
            "identifier": "getBytes32",
            "parameters": "DynamicArray memory a, uint256 i",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function getBytes32(DynamicArray memory a, uint256 i) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(add(add(mload(a), 0x20), shl(5, i)))\n        }\n    }",
            "start": "713",
            "end": "718",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32 result) getBytes32DynamicArray memory a, uint256 i",
            "full_signature": "function getBytes32(DynamicArray memory a, uint256 i) internal  pure returns (bytes32 result)",
            "class_method_signature": "DynamicArrayLib.getBytes32DynamicArray memory a, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves a bytes32 value from a DynamicArray at a specified index.\n *\n * @param a The DynamicArray from which to retrieve the bytes32 value.\n * @param i The index of the bytes32 value to retrieve.\n * @return result The bytes32 value at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the memory offset of the desired bytes32 value within the DynamicArray.\n * 3. Load the bytes32 value from the calculated memory offset and return it.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "set",
            "parameters": "DynamicArray memory a, uint256 i, uint256 data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function set(DynamicArray memory a, uint256 i, uint256 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), data)\n        }\n    }",
            "start": "721",
            "end": "732",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) setDynamicArray memory a, uint256 i, uint256 data",
            "full_signature": "function set(DynamicArray memory a, uint256 i, uint256 data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.setDynamicArray memory a, uint256 i, uint256 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value at a specific index in a dynamic array and returns the updated array.\n *\n * @param a The dynamic array to modify.\n * @param i The index at which to set the new value.\n * @param data The value to set at the specified index.\n * @return result The updated dynamic array with the new value at the specified index.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` array to ensure no memory leaks.\n * 2. Assign the input array `a` to `result`.\n * 3. Use inline assembly to safely update the value at the specified index in the array.\n *    - Calculate the memory location of the index `i` in the array.\n *    - Store the new value `data` at the calculated memory location.\n */"
        },
        {
            "identifier": "set",
            "parameters": "DynamicArray memory a, uint256 i, address data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function set(DynamicArray memory a, uint256 i, address data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), shr(96, shl(96, data)))\n        }\n    }",
            "start": "735",
            "end": "746",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) setDynamicArray memory a, uint256 i, address data",
            "full_signature": "function set(DynamicArray memory a, uint256 i, address data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.setDynamicArray memory a, uint256 i, address data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets the value at a specific index in a DynamicArray and returns the updated array.\n *\n * @param a The DynamicArray to modify.\n * @param i The index at which to set the new value.\n * @param data The address value to set at the specified index.\n * @return result The updated DynamicArray after setting the value.\n *\n * Steps:\n * 1. Deallocate the memory of the result array to ensure no memory leaks.\n * 2. Assign the input array `a` to the result array.\n * 3. Use inline assembly to safely update the value at the specified index in the array.\n *    - Calculate the memory location of the index.\n *    - Store the provided address `data` at the calculated memory location.\n */"
        },
        {
            "identifier": "set",
            "parameters": "DynamicArray memory a, uint256 i, bool data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function set(DynamicArray memory a, uint256 i, bool data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), iszero(iszero(data)))\n        }\n    }",
            "start": "749",
            "end": "760",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) setDynamicArray memory a, uint256 i, bool data",
            "full_signature": "function set(DynamicArray memory a, uint256 i, bool data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.setDynamicArray memory a, uint256 i, bool data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a boolean value at a specific index in a DynamicArray.\n *\n * @param a The DynamicArray to modify.\n * @param i The index at which to set the boolean value.\n * @param data The boolean value to set at the specified index.\n * @return result The modified DynamicArray with the updated value.\n *\n * Steps:\n * 1. Deallocate any existing memory for the result array.\n * 2. Assign the input array `a` to the result array.\n * 3. Use inline assembly to safely set the boolean value at the specified index in the result array.\n *    - The value is stored in memory using `mstore` at the calculated memory offset.\n *    - The boolean value is converted to a uint256 (0 or 1) using `iszero(iszero(data))`.\n */"
        },
        {
            "identifier": "set",
            "parameters": "DynamicArray memory a, uint256 i, bytes32 data",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function set(DynamicArray memory a, uint256 i, bytes32 data)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        _deallocate(result);\n        result = a;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(add(mload(result), 0x20), shl(5, i)), data)\n        }\n    }",
            "start": "763",
            "end": "774",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) setDynamicArray memory a, uint256 i, bytes32 data",
            "full_signature": "function set(DynamicArray memory a, uint256 i, bytes32 data) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.setDynamicArray memory a, uint256 i, bytes32 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a specific element in a DynamicArray to a given value.\n *\n * @param a The DynamicArray to modify.\n * @param i The index of the element to set.\n * @param data The new value to set at the specified index.\n * @return result The modified DynamicArray after setting the element.\n *\n * Steps:\n * 1. Deallocate any existing memory for the result array.\n * 2. Assign the input array `a` to `result`.\n * 3. Use inline assembly to safely set the value at the specified index in the array.\n *    - Calculate the memory location of the element at index `i`.\n *    - Store the provided `data` at the calculated memory location.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "DynamicArray memory a, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function slice(DynamicArray memory a, uint256 start, uint256 end)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        result.data = slice(a.data, start, end);\n    }",
            "start": "821",
            "end": "827",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) sliceDynamicArray memory a, uint256 start, uint256 end",
            "full_signature": "function slice(DynamicArray memory a, uint256 start, uint256 end) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.sliceDynamicArray memory a, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Slices a portion of a DynamicArray based on the provided start and end indices.\n *\n * @param a The DynamicArray to be sliced.\n * @param start The starting index (inclusive) of the slice.\n * @param end The ending index (exclusive) of the slice.\n * @return result A new DynamicArray containing the sliced portion of the original array.\n *\n * Steps:\n * 1. Slice the `data` array of the input DynamicArray using the provided `start` and `end` indices.\n * 2. Assign the sliced data to the `data` field of the `result` DynamicArray.\n * 3. Return the `result` DynamicArray.\n */"
        },
        {
            "identifier": "slice",
            "parameters": "DynamicArray memory a, uint256 start",
            "modifiers": "pure",
            "return": "returns (DynamicArray memory result)",
            "body": "function slice(DynamicArray memory a, uint256 start)\n        internal\n        pure\n        returns (DynamicArray memory result)\n    {\n        result.data = slice(a.data, start, type(uint256).max);\n    }",
            "start": "830",
            "end": "836",
            "class": "DynamicArrayLib",
            "signature": "returns (DynamicArray memory result) sliceDynamicArray memory a, uint256 start",
            "full_signature": "function slice(DynamicArray memory a, uint256 start) internal  pure returns (DynamicArray memory result)",
            "class_method_signature": "DynamicArrayLib.sliceDynamicArray memory a, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Slices a DynamicArray starting from a specified index to the end of the array.\n *\n * @param a The DynamicArray to be sliced.\n * @param start The starting index from which to slice the array.\n * @return result A new DynamicArray containing the sliced data.\n *\n * Steps:\n * 1. Calls the internal `slice` function with the data from the input DynamicArray, the starting index, \n *    and the maximum possible value for `uint256` (indicating the end of the array).\n * 2. Returns a new DynamicArray with the sliced data.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "DynamicArray memory a, uint256 needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function indexOf(DynamicArray memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, needle, from);\n    }",
            "start": "855",
            "end": "861",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256) indexOfDynamicArray memory a, uint256 needle, uint256 from",
            "full_signature": "function indexOf(DynamicArray memory a, uint256 needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "DynamicArrayLib.indexOfDynamicArray memory a, uint256 needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the index of a specific value (`needle`) in a DynamicArray starting from a given index (`from`).\n *\n * @param a The DynamicArray to search within.\n * @param needle The value to search for in the array.\n * @param from The starting index from which to begin the search.\n * @return The index of the first occurrence of `needle` in the array, starting from `from`. If not found, the function will return an appropriate value (e.g., `type(uint256).max` or revert, depending on the implementation of `indexOf` for the underlying array).\n *\n * Steps:\n * 1. Calls the `indexOf` function on the underlying array (`a.data`) with the provided `needle` and `from` parameters.\n * 2. Returns the result of the search.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "DynamicArray memory a, address needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function indexOf(DynamicArray memory a, address needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, uint160(needle), from);\n    }",
            "start": "865",
            "end": "871",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256) indexOfDynamicArray memory a, address needle, uint256 from",
            "full_signature": "function indexOf(DynamicArray memory a, address needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "DynamicArrayLib.indexOfDynamicArray memory a, address needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the index of a specific address (`needle`) in a `DynamicArray` starting from a given index (`from`).\n *\n * @param a The `DynamicArray` containing the data to search through.\n * @param needle The address to search for within the array.\n * @param from The starting index from which to begin the search.\n * @return The index of the `needle` address within the array, if found. If not found, the function will return a value that depends on the implementation of `indexOf` for the underlying array type.\n *\n * Steps:\n * 1. Convert the `needle` address to a `uint160` type.\n * 2. Call the internal `indexOf` function with the `a.data` array, the converted `needle`, and the `from` index.\n * 3. Return the result of the internal `indexOf` function.\n */"
        },
        {
            "identifier": "indexOf",
            "parameters": "DynamicArray memory a, bytes32 needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function indexOf(DynamicArray memory a, bytes32 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return indexOf(a.data, uint256(needle), from);\n    }",
            "start": "875",
            "end": "881",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256) indexOfDynamicArray memory a, bytes32 needle, uint256 from",
            "full_signature": "function indexOf(DynamicArray memory a, bytes32 needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "DynamicArrayLib.indexOfDynamicArray memory a, bytes32 needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the index of a specific element (`needle`) in a dynamic array (`a`) starting from a given index (`from`).\n *\n * @param a The dynamic array to search within.\n * @param needle The element to search for in the array.\n * @param from The starting index from which to begin the search.\n * @return The index of the element if found, otherwise reverts or returns an invalid index depending on the implementation.\n *\n * Steps:\n * 1. Calls the internal `indexOf` function with the `data` field of the dynamic array, the `needle` converted to `uint256`, and the `from` index.\n * 2. Returns the index of the `needle` in the array, if found.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "DynamicArray memory a, uint256 needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lastIndexOf(DynamicArray memory a, uint256 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, needle, from);\n    }",
            "start": "903",
            "end": "909",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256) lastIndexOfDynamicArray memory a, uint256 needle, uint256 from",
            "full_signature": "function lastIndexOf(DynamicArray memory a, uint256 needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "DynamicArrayLib.lastIndexOfDynamicArray memory a, uint256 needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a specific value (`needle`) in a DynamicArray, starting from a specified index (`from`).\n *\n * @param a The DynamicArray to search within.\n * @param needle The value to search for in the array.\n * @param from The starting index from which to begin the search (searches backward).\n * @return The index of the last occurrence of `needle` in the array, or 0 if not found.\n *\n * Steps:\n * 1. Calls the `lastIndexOf` function on the underlying array (`a.data`) with the provided `needle` and `from` parameters.\n * 2. Returns the index of the last occurrence of `needle` in the array.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "DynamicArray memory a, address needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lastIndexOf(DynamicArray memory a, address needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, uint160(needle), from);\n    }",
            "start": "913",
            "end": "919",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256) lastIndexOfDynamicArray memory a, address needle, uint256 from",
            "full_signature": "function lastIndexOf(DynamicArray memory a, address needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "DynamicArrayLib.lastIndexOfDynamicArray memory a, address needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a specific address (`needle`) in a DynamicArray starting from a given index (`from`).\n *\n * @param a The DynamicArray to search within.\n * @param needle The address to search for in the array.\n * @param from The index to start searching backward from.\n * @return The last index of the address in the array, or 0 if not found.\n *\n * Steps:\n * 1. Convert the address `needle` to a uint160 value.\n * 2. Call the `lastIndexOf` function on the underlying data array (`a.data`) with the converted value and `from` index.\n * 3. Return the result of the search.\n */"
        },
        {
            "identifier": "lastIndexOf",
            "parameters": "DynamicArray memory a, bytes32 needle, uint256 from",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lastIndexOf(DynamicArray memory a, bytes32 needle, uint256 from)\n        internal\n        pure\n        returns (uint256)\n    {\n        return lastIndexOf(a.data, uint256(needle), from);\n    }",
            "start": "923",
            "end": "929",
            "class": "DynamicArrayLib",
            "signature": "returns (uint256) lastIndexOfDynamicArray memory a, bytes32 needle, uint256 from",
            "full_signature": "function lastIndexOf(DynamicArray memory a, bytes32 needle, uint256 from) internal  pure returns (uint256)",
            "class_method_signature": "DynamicArrayLib.lastIndexOfDynamicArray memory a, bytes32 needle, uint256 from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the last index of a specific `bytes32` value (`needle`) in a `DynamicArray`, starting from a specified index (`from`).\n *\n * @param a The `DynamicArray` to search within.\n * @param needle The `bytes32` value to search for.\n * @param from The index to start searching backward from.\n * @return The last index of `needle` in the array, or 0 if not found.\n *\n * Steps:\n * 1. Calls the internal `lastIndexOf` function with the `DynamicArray`'s data, the `needle` converted to `uint256`, and the `from` index.\n * 2. Returns the result of the internal search.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(DynamicArray memory a) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(mload(a), 0x20), shl(5, mload(mload(a))))\n        }\n    }",
            "start": "950",
            "end": "955",
            "class": "DynamicArrayLib",
            "signature": "returns (bytes32 result) hashDynamicArray memory a",
            "full_signature": "function hash(DynamicArray memory a) internal  pure returns (bytes32 result)",
            "class_method_signature": "DynamicArrayLib.hashDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the keccak256 hash of a DynamicArray.\n *\n * @param a The DynamicArray to be hashed.\n * @return result The keccak256 hash of the DynamicArray.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Calculate the hash by:\n *    - Loading the base address of the array (`mload(a)`).\n *    - Adding 0x20 to skip the length field of the array.\n *    - Using `shl(5, mload(mload(a)))` to calculate the size of the array in bytes (32 * length).\n *    - Passing the base address and size to `keccak256` to compute the hash.\n * 3. Return the computed hash as `result`.\n */"
        },
        {
            "identifier": "directReturn",
            "parameters": "DynamicArray memory a",
            "modifiers": "pure",
            "return": "",
            "body": "function directReturn(DynamicArray memory a) internal pure {\n        assembly {\n            let arrData := mload(a)\n            let retStart := sub(arrData, 0x20)\n            mstore(retStart, 0x20)\n            return(retStart, add(0x40, shl(5, mload(arrData))))\n        }\n    }",
            "start": "958",
            "end": "965",
            "class": "DynamicArrayLib",
            "signature": " directReturnDynamicArray memory a",
            "full_signature": "function directReturn(DynamicArray memory a) internal  pure",
            "class_method_signature": "DynamicArrayLib.directReturnDynamicArray memory a",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A low-level assembly function that directly returns a `DynamicArray` from memory.\n *\n * @param a The `DynamicArray` to be returned.\n *\n * Steps:\n * 1. Load the memory address of the `DynamicArray` data.\n * 2. Calculate the start of the return data by subtracting 0x20 (32 bytes) from the array data address.\n * 3. Store 0x20 (32 bytes) at the calculated return start address to indicate the length of the returned data.\n * 4. Use the `return` opcode to return the data, starting from the calculated address, with a size equal to the array length multiplied by 32 bytes plus 0x40 (64 bytes) for the length and offset.\n *\n * Note: This function uses inline assembly to manipulate memory directly and is intended for advanced use cases.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/Base64.sol": [
        {
            "identifier": "encode",
            "parameters": "bytes memory data, bool fileSafe, bool noPadding",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function encode(bytes memory data, bool fileSafe, bool noPadding)\n        internal\n        pure\n        returns (string memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                // Multiply by 4/3 rounded up.\n                // The `shl(2, ...)` is equivalent to multiplying by 4.\n                let encodedLength := shl(2, div(add(dataLength, 2), 3))\n\n                // Set `result` to point to the start of the free memory.\n                result := mload(0x40)\n\n                // Store the table into the scratch space.\n                // Offsetted by -1 byte so that the `mload` will load the character.\n                // We will rewrite the free memory pointer at `0x40` later with\n                // the allocated size.\n                // The magic constant 0x0670 will turn \"-_\" into \"+/\".\n                mstore(0x1f, \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdef\")\n                mstore(0x3f, xor(\"ghijklmnopqrstuvwxyz0123456789-_\", mul(iszero(fileSafe), 0x0670)))\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, encodedLength)\n\n                let dataEnd := add(add(0x20, data), dataLength)\n                let dataEndValue := mload(dataEnd) // Cache the value at the `dataEnd` slot.\n                mstore(dataEnd, 0x00) // Zeroize the `dataEnd` slot to clear dirty bits.\n\n                // Run over the input, 3 bytes at a time.\n                for {} 1 {} {\n                    data := add(data, 3) // Advance 3 bytes.\n                    let input := mload(data)\n\n                    // Write 4 bytes. Optimized for fewer stack operations.\n                    mstore8(0, mload(and(shr(18, input), 0x3F)))\n                    mstore8(1, mload(and(shr(12, input), 0x3F)))\n                    mstore8(2, mload(and(shr(6, input), 0x3F)))\n                    mstore8(3, mload(and(input, 0x3F)))\n                    mstore(ptr, mload(0x00))\n\n                    ptr := add(ptr, 4) // Advance 4 bytes.\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(dataEnd, dataEndValue) // Restore the cached value at `dataEnd`.\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                // Equivalent to `o = [0, 2, 1][dataLength % 3]`.\n                let o := div(2, mod(dataLength, 3))\n                // Offset `ptr` and pad with '='. We can simply write over the end.\n                mstore(sub(ptr, o), shl(240, 0x3d3d))\n                // Set `o` to zero if there is padding.\n                o := mul(iszero(iszero(noPadding)), o)\n                mstore(sub(ptr, o), 0) // Zeroize the slot after the string.\n                mstore(result, sub(encodedLength, o)) // Store the length.\n            }\n        }\n    }",
            "start": "13",
            "end": "73",
            "class": "Base64",
            "signature": "returns (string memory result) encodebytes memory data, bool fileSafe, bool noPadding",
            "full_signature": "function encode(bytes memory data, bool fileSafe, bool noPadding) internal  pure returns (string memory result)",
            "class_method_signature": "Base64.encodebytes memory data, bool fileSafe, bool noPadding",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes the given data into a Base64 string, with options for file-safe encoding and padding.\n *\n * @param data The input data to be encoded.\n * @param fileSafe If true, uses a file-safe Base64 alphabet (replaces '+' and '/' with '-' and '_').\n * @param noPadding If true, removes the padding characters ('=') from the output.\n * @return result The Base64 encoded string.\n *\n * Steps:\n * 1. Calculate the length of the input data.\n * 2. Compute the encoded length by multiplying the data length by 4/3 and rounding up.\n * 3. Allocate memory for the result and store the Base64 alphabet in scratch space.\n * 4. Iterate over the input data in chunks of 3 bytes, encoding each chunk into 4 Base64 characters.\n * 5. Handle padding by adjusting the result length and adding padding characters if necessary.\n * 6. Restore the original value at the end of the input data and update the free memory pointer.\n * 7. Return the encoded Base64 string.\n */"
        },
        {
            "identifier": "encode",
            "parameters": "bytes memory data, bool fileSafe",
            "modifiers": "pure",
            "return": "returns (string memory result)",
            "body": "function encode(bytes memory data, bool fileSafe)\n        internal\n        pure\n        returns (string memory result)\n    {\n        result = encode(data, fileSafe, false);\n    }",
            "start": "83",
            "end": "89",
            "class": "Base64",
            "signature": "returns (string memory result) encodebytes memory data, bool fileSafe",
            "full_signature": "function encode(bytes memory data, bool fileSafe) internal  pure returns (string memory result)",
            "class_method_signature": "Base64.encodebytes memory data, bool fileSafe",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes the given data into a string representation, optionally making it file-safe.\n *\n * @param data The raw bytes data to be encoded.\n * @param fileSafe A boolean flag indicating whether the encoded result should be file-safe.\n * @return result The encoded string representation of the data.\n *\n * Steps:\n * 1. Calls an internal `encode` function with the provided data, file-safe flag, and an additional `false` flag.\n * 2. Returns the encoded string result.\n */"
        },
        {
            "identifier": "decode",
            "parameters": "string memory data",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function decode(string memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let dataLength := mload(data)\n\n            if dataLength {\n                let decodedLength := mul(shr(2, dataLength), 3)\n\n                for {} 1 {} {\n                    // If padded.\n                    if iszero(and(dataLength, 3)) {\n                        let t := xor(mload(add(data, dataLength)), 0x3d3d)\n                        // forgefmt: disable-next-item\n                        decodedLength := sub(\n                            decodedLength,\n                            add(iszero(byte(30, t)), iszero(byte(31, t)))\n                        )\n                        break\n                    }\n                    // If non-padded.\n                    decodedLength := add(decodedLength, sub(and(dataLength, 3), 1))\n                    break\n                }\n                result := mload(0x40)\n\n                // Write the length of the bytes.\n                mstore(result, decodedLength)\n\n                // Skip the first slot, which stores the length.\n                let ptr := add(result, 0x20)\n                let end := add(ptr, decodedLength)\n\n                // Load the table into the scratch space.\n                // Constants are optimized for smaller bytecode with zero gas overhead.\n                // `m` also doubles as the mask of the upper 6 bits.\n                let m := 0xfc000000fc00686c7074787c8084888c9094989ca0a4a8acb0b4b8bcc0c4c8cc\n                mstore(0x5b, m)\n                mstore(0x3b, 0x04080c1014181c2024282c3034383c4044484c5054585c6064)\n                mstore(0x1a, 0xf8fcf800fcd0d4d8dce0e4e8ecf0f4)\n\n                for {} 1 {} {\n                    // Read 4 bytes.\n                    data := add(data, 4)\n                    let input := mload(data)\n\n                    // Write 3 bytes.\n                    // forgefmt: disable-next-item\n                    mstore(ptr, or(\n                        and(m, mload(byte(28, input))),\n                        shr(6, or(\n                            and(m, mload(byte(29, input))),\n                            shr(6, or(\n                                and(m, mload(byte(30, input))),\n                                shr(6, mload(byte(31, input)))\n                            ))\n                        ))\n                    ))\n                    ptr := add(ptr, 3)\n                    if iszero(lt(ptr, end)) { break }\n                }\n                mstore(0x40, add(end, 0x20)) // Allocate the memory.\n                mstore(end, 0) // Zeroize the slot after the bytes.\n                mstore(0x60, 0) // Restore the zero slot.\n            }\n        }\n    }",
            "start": "105",
            "end": "170",
            "class": "Base64",
            "signature": "returns (bytes memory result) decodestring memory data",
            "full_signature": "function decode(string memory data) internal  pure returns (bytes memory result)",
            "class_method_signature": "Base64.decodestring memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Decodes a base64 encoded string into bytes.\n *\n * @dev This function uses inline assembly to efficiently decode the base64 string.\n * It handles both padded and non-padded base64 strings.\n *\n * @param data The base64 encoded string to decode.\n * @return result The decoded bytes.\n *\n * Steps:\n * 1. Load the length of the input data.\n * 2. Calculate the decoded length based on the input length.\n * 3. Adjust the decoded length if the input is padded.\n * 4. Allocate memory for the result and store the decoded length.\n * 5. Use a lookup table to decode the base64 string into bytes.\n * 6. Write the decoded bytes into the allocated memory.\n * 7. Handle memory cleanup and return the decoded bytes.\n *\n * Assembly Details:\n * - The function uses a custom lookup table stored in memory to map base64 characters to their corresponding values.\n * - It processes 4 bytes of input at a time and writes 3 bytes of output.\n * - The function ensures that memory is properly allocated and cleaned up after decoding.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/DynamicBufferLib.sol": [
        {
            "identifier": "reserve",
            "parameters": "DynamicBuffer memory buffer, uint256 minimum",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function reserve(DynamicBuffer memory buffer, uint256 minimum)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        uint256 n = buffer.data.length;\n        if (minimum > n) {\n            uint256 i = 0x40;\n            do {} while ((i <<= 1) < minimum);\n            bytes memory data;\n            /// @solidity memory-safe-assembly\n            assembly {\n                data := 0x01\n                mstore(data, sub(i, n))\n            }\n            result = p(result, data);\n        }\n    }",
            "start": "32",
            "end": "51",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) reserveDynamicBuffer memory buffer, uint256 minimum",
            "full_signature": "function reserve(DynamicBuffer memory buffer, uint256 minimum) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.reserveDynamicBuffer memory buffer, uint256 minimum",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Reserves additional memory for a DynamicBuffer if the current length is less than the specified minimum.\n *\n * @param buffer The DynamicBuffer to reserve memory for.\n * @param minimum The minimum length required for the buffer.\n * @return result The updated DynamicBuffer with potentially increased memory allocation.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer.\n * 2. Assign the input buffer to the result.\n * 3. Check if the current length of the buffer is less than the minimum required.\n * 4. If so, calculate the next power of two that is greater than or equal to the minimum.\n * 5. Allocate additional memory using assembly to ensure the buffer has sufficient space.\n * 6. Update the result buffer with the new memory allocation.\n */"
        },
        {
            "identifier": "clear",
            "parameters": "DynamicBuffer memory buffer",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function clear(DynamicBuffer memory buffer)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(mload(buffer), 0)\n        }\n        result = buffer;\n    }",
            "start": "54",
            "end": "65",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) clearDynamicBuffer memory buffer",
            "full_signature": "function clear(DynamicBuffer memory buffer) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.clearDynamicBuffer memory buffer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Clears the contents of a DynamicBuffer by deallocating its memory and resetting its length.\n *\n * @param buffer The DynamicBuffer to be cleared.\n * @return result The cleared DynamicBuffer with its length reset to 0.\n *\n * Steps:\n * 1. Deallocate the memory associated with the DynamicBuffer.\n * 2. Use inline assembly to set the length of the buffer to 0.\n * 3. Return the cleared buffer.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(DynamicBuffer memory buffer, bytes memory data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = buffer;\n        if (data.length == uint256(0)) return result;\n        /// @solidity memory-safe-assembly\n        assembly {\n            let w := not(0x1f)\n            let bufData := mload(buffer)\n            let bufDataLen := mload(bufData)\n            let newBufDataLen := add(mload(data), bufDataLen)\n            // Some random prime number to multiply `cap`, so that\n            // we know that the `cap` is for a dynamic buffer.\n            // Selected to be larger than any memory pointer realistically.\n            let prime := 1621250193422201\n            let cap := mload(add(bufData, w)) // `mload(sub(bufData, 0x20))`.\n            // Extract `cap`, initializing it to zero if it is not a multiple of `prime`.\n            cap := mul(div(cap, prime), iszero(mod(cap, prime)))\n\n            // Expand / Reallocate memory if required.\n            // Note that we need to allocate an extra word for the length, and\n            // and another extra word as a safety word (giving a total of 0x40 bytes).\n            // Without the safety word, the backwards copying can cause a buffer overflow.\n            for {} iszero(lt(newBufDataLen, cap)) {} {\n                // Approximately more than double the capacity to ensure more than enough space.\n                let newCap := and(add(cap, add(or(cap, newBufDataLen), 0x20)), w)\n                // If the memory is contiguous, we can simply expand it.\n                if iszero(or(xor(mload(0x40), add(bufData, add(0x40, cap))), eq(bufData, 0x60))) {\n                    // Store `cap * prime` in the word before the length.\n                    mstore(add(bufData, w), mul(prime, newCap))\n                    mstore(0x40, add(bufData, add(0x40, newCap))) // Expand the memory allocation.\n                    break\n                }\n                // Set the `newBufData` to point to the word after `cap`.\n                let newBufData := add(mload(0x40), 0x20)\n                mstore(0x40, add(newBufData, add(0x40, newCap))) // Reallocate the memory.\n                mstore(buffer, newBufData) // Store the `newBufData`.\n                // Copy `bufData` one word at a time, backwards.\n                for { let o := and(add(bufDataLen, 0x20), w) } 1 {} {\n                    mstore(add(newBufData, o), mload(add(bufData, o)))\n                    o := add(o, w) // `sub(o, 0x20)`.\n                    if iszero(o) { break }\n                }\n                // Store `cap * prime` in the word before the length.\n                mstore(add(newBufData, w), mul(prime, newCap))\n                bufData := newBufData // Assign `newBufData` to `bufData`.\n                break\n            }\n            // If it's a reserve operation, set the variables to skip the appending.\n            if eq(data, 0x01) {\n                mstore(data, 0x00)\n                newBufDataLen := bufDataLen\n            }\n            // Copy `data` one word at a time, backwards.\n            for { let o := and(add(mload(data), 0x20), w) } 1 {} {\n                mstore(add(add(bufData, bufDataLen), o), mload(add(data, o)))\n                o := add(o, w) // `sub(o, 0x20)`.\n                if iszero(o) { break }\n            }\n            mstore(add(add(bufData, 0x20), newBufDataLen), 0) // Zeroize the word after the buffer.\n            mstore(bufData, newBufDataLen) // Store the length.\n        }\n    }",
            "start": "74",
            "end": "139",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Appends data to a dynamic buffer and handles memory reallocation if necessary.\n *\n * @param buffer The dynamic buffer to which data will be appended.\n * @param data The data to append to the buffer.\n * @return result The updated dynamic buffer after appending the data.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is clean before use.\n * 2. Assign the input buffer to the result buffer.\n * 3. If the data length is zero, return the result buffer immediately.\n *\n * 4. Use inline assembly for memory-safe operations:\n *    a. Calculate the new buffer length by adding the input data length to the existing buffer length.\n *    b. Check if the buffer capacity needs to be expanded.\n *    c. If expansion is needed, calculate the new capacity and reallocate memory.\n *    d. If the memory is contiguous, expand it directly.\n *    e. If not, allocate new memory, copy the existing buffer data, and update the buffer pointer.\n *    f. Store the new capacity multiplied by a prime number in the word before the buffer length.\n *\n * 5. If the data is a special reserve operation (0x01), skip appending and set the buffer length accordingly.\n * 6. Copy the input data to the buffer one word at a time, backwards.\n * 7. Zeroize the word after the buffer to ensure no leftover data.\n * 8. Store the updated buffer length.\n *\n * Note: This function uses low-level memory manipulation to optimize gas usage and ensure memory safety.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data0, bytes memory data1",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(p(buffer, data0), data1);\n    }",
            "start": "142",
            "end": "149",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates two byte arrays (`data0` and `data1`) into a DynamicBuffer.\n *\n * @param buffer The DynamicBuffer to which the data will be appended.\n * @param data0 The first byte array to be appended.\n * @param data1 The second byte array to be appended.\n * @return result The updated DynamicBuffer containing the concatenated data.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean before use.\n * 2. Append `data0` to the `buffer` using the `p` function.\n * 3. Append `data1` to the result of the previous step using the `p` function.\n * 4. Return the final concatenated DynamicBuffer.\n */ "
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(buffer, data0), data1), data2);\n    }",
            "start": "152",
            "end": "160",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates multiple byte arrays (`data0`, `data1`, `data2`) into a single `DynamicBuffer`.\n *\n * @param buffer The initial `DynamicBuffer` to which the byte arrays will be appended.\n * @param data0 The first byte array to append.\n * @param data1 The second byte array to append.\n * @param data2 The third byte array to append.\n * @return result The resulting `DynamicBuffer` after appending all byte arrays.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is empty.\n * 2. Recursively append `data0`, `data1`, and `data2` to the `buffer` using the `p` function.\n * 3. Return the final concatenated `DynamicBuffer`.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(buffer, data0), data1), data2), data3);\n    }",
            "start": "163",
            "end": "172",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates multiple byte arrays (`data0`, `data1`, `data2`, `data3`) into a single `DynamicBuffer`.\n *\n * @param buffer The initial `DynamicBuffer` to which the byte arrays will be appended.\n * @param data0 The first byte array to append.\n * @param data1 The second byte array to append.\n * @param data2 The third byte array to append.\n * @param data3 The fourth byte array to append.\n * @return result The resulting `DynamicBuffer` after all byte arrays have been concatenated.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it starts fresh.\n * 2. Recursively append `data0`, `data1`, `data2`, and `data3` to the `buffer` using the `p` function.\n * 3. Return the final concatenated `DynamicBuffer`.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(buffer, data0), data1), data2), data3), data4);\n    }",
            "start": "175",
            "end": "185",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates multiple byte arrays (`data0`, `data1`, `data2`, `data3`, `data4`) into a single `DynamicBuffer`.\n *\n * @param buffer The initial `DynamicBuffer` to which the byte arrays will be appended.\n * @param data0 The first byte array to append.\n * @param data1 The second byte array to append.\n * @param data2 The third byte array to append.\n * @param data3 The fourth byte array to append.\n * @param data4 The fifth byte array to append.\n *\n * @return result A new `DynamicBuffer` containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean before use.\n * 2. Recursively concatenate the byte arrays (`data0`, `data1`, `data2`, `data3`, `data4`) into the `buffer`.\n * 3. Return the resulting `DynamicBuffer` with all byte arrays concatenated.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5);\n    }",
            "start": "188",
            "end": "199",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates multiple byte arrays into a single DynamicBuffer.\n *\n * @param buffer The initial DynamicBuffer to which the data will be appended.\n * @param data0 The first byte array to append.\n * @param data1 The second byte array to append.\n * @param data2 The third byte array to append.\n * @param data3 The fourth byte array to append.\n * @param data4 The fifth byte array to append.\n * @param data5 The sixth byte array to append.\n *\n * @return result The resulting DynamicBuffer after all data has been concatenated.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean before use.\n * 2. Recursively concatenate the provided byte arrays (`data0` to `data5`) into the `buffer`.\n * 3. Return the final concatenated DynamicBuffer as `result`.\n */"
        },
        {
            "identifier": "p",
            "parameters": "DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        DynamicBuffer memory buffer,\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        _deallocate(result);\n        result = p(p(p(p(p(p(p(buffer, data0), data1), data2), data3), data4), data5), data6);\n    }",
            "start": "202",
            "end": "214",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6",
            "full_signature": "function p(DynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pDynamicBuffer memory buffer, bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates multiple byte arrays (`data0` to `data6`) into a single `DynamicBuffer`.\n *\n * @param buffer The initial `DynamicBuffer` to which the byte arrays will be appended.\n * @param data0 The first byte array to append.\n * @param data1 The second byte array to append.\n * @param data2 The third byte array to append.\n * @param data3 The fourth byte array to append.\n * @param data4 The fifth byte array to append.\n * @param data5 The sixth byte array to append.\n * @param data6 The seventh byte array to append.\n *\n * @return result The `DynamicBuffer` containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is empty.\n * 2. Recursively concatenate the byte arrays (`data0` to `data6`) into the `buffer`.\n * 3. Return the resulting `DynamicBuffer` with all byte arrays concatenated.\n */"
        },
        {
            "identifier": "pBool",
            "parameters": "DynamicBuffer memory buffer, bool data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBool(DynamicBuffer memory buffer, bool data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        uint256 casted;\n        /// @solidity memory-safe-assembly\n        assembly {\n            casted := iszero(iszero(data))\n        }\n        result = p(buffer, _single(casted, 1));\n    }",
            "start": "217",
            "end": "229",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBoolDynamicBuffer memory buffer, bool data",
            "full_signature": "function pBool(DynamicBuffer memory buffer, bool data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBoolDynamicBuffer memory buffer, bool data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Appends a boolean value to a DynamicBuffer in a memory-safe manner.\n *\n * @param buffer The DynamicBuffer to which the boolean value will be appended.\n * @param data The boolean value to append to the buffer.\n * @return result The updated DynamicBuffer after appending the boolean value.\n *\n * Steps:\n * 1. Deallocate the result buffer to ensure it is clean before use.\n * 2. Cast the boolean value to a uint256 (0 for false, 1 for true) using assembly for memory safety.\n * 3. Append the casted boolean value to the buffer using the `p` function, which handles single-byte data.\n * 4. Return the updated buffer.\n */"
        },
        {
            "identifier": "pAddress",
            "parameters": "DynamicBuffer memory buffer, address data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pAddress(DynamicBuffer memory buffer, address data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(uint256(uint160(data)), 20));\n    }",
            "start": "232",
            "end": "239",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pAddressDynamicBuffer memory buffer, address data",
            "full_signature": "function pAddress(DynamicBuffer memory buffer, address data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pAddressDynamicBuffer memory buffer, address data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Appends an Ethereum address to a dynamic buffer in a packed format.\n *\n * @param buffer The dynamic buffer to which the address will be appended.\n * @param data The Ethereum address to be appended to the buffer.\n *\n * @return result The updated dynamic buffer containing the appended address.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is empty.\n * 2. Append the address to the buffer in a packed format by converting the address to a uint256,\n *    then to a uint160, and finally packing it into 20 bytes.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint8",
            "parameters": "DynamicBuffer memory buffer, uint8 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint8(DynamicBuffer memory buffer, uint8 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 1));\n    }",
            "start": "242",
            "end": "249",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint8DynamicBuffer memory buffer, uint8 data",
            "full_signature": "function pUint8(DynamicBuffer memory buffer, uint8 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint8DynamicBuffer memory buffer, uint8 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a uint8 value into a DynamicBuffer.\n *\n * @param buffer The DynamicBuffer to which the uint8 value will be appended.\n * @param data The uint8 value to be packed into the buffer.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Pack the uint8 value into the buffer using the `p` function, which handles the actual packing logic.\n * 3. Return the updated buffer with the packed uint8 value.\n *\n * @return result The updated DynamicBuffer containing the packed uint8 value.\n */"
        },
        {
            "identifier": "pUint32",
            "parameters": "DynamicBuffer memory buffer, uint32 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint32(DynamicBuffer memory buffer, uint32 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 4));\n    }",
            "start": "272",
            "end": "279",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint32DynamicBuffer memory buffer, uint32 data",
            "full_signature": "function pUint32(DynamicBuffer memory buffer, uint32 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint32DynamicBuffer memory buffer, uint32 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a 32-bit unsigned integer (`uint32`) into a DynamicBuffer.\n *\n * @param buffer The DynamicBuffer to which the data will be appended.\n * @param data The 32-bit unsigned integer (`uint32`) to be packed into the buffer.\n * @return result The updated DynamicBuffer after appending the packed data.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Pack the `uint32` data into a 4-byte format using the `_single` function.\n * 3. Append the packed data to the provided buffer using the `p` function.\n * 4. Return the updated buffer.\n */"
        },
        {
            "identifier": "pUint256",
            "parameters": "DynamicBuffer memory buffer, uint256 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pUint256(DynamicBuffer memory buffer, uint256 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(data, 32));\n    }",
            "start": "552",
            "end": "559",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pUint256DynamicBuffer memory buffer, uint256 data",
            "full_signature": "function pUint256(DynamicBuffer memory buffer, uint256 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pUint256DynamicBuffer memory buffer, uint256 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Appends a uint256 value to a DynamicBuffer in a packed format.\n *\n * @param buffer The DynamicBuffer to which the uint256 value will be appended.\n * @param data The uint256 value to be appended to the buffer.\n *\n * @return result The updated DynamicBuffer after appending the uint256 value.\n *\n * Steps:\n * 1. Deallocate the memory of the result buffer to ensure it is clean.\n * 2. Append the uint256 value to the buffer in a packed format using the `p` function.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes1",
            "parameters": "DynamicBuffer memory buffer, bytes1 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes1(DynamicBuffer memory buffer, bytes1 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 1));\n    }",
            "start": "562",
            "end": "569",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes1DynamicBuffer memory buffer, bytes1 data",
            "full_signature": "function pBytes1(DynamicBuffer memory buffer, bytes1 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes1DynamicBuffer memory buffer, bytes1 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Appends a single byte (`bytes1`) to a dynamic buffer and returns the updated buffer.\n *\n * @param buffer The dynamic buffer to which the byte will be appended.\n * @param data The single byte (`bytes1`) to append to the buffer.\n * @return result The updated dynamic buffer after appending the byte.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean before use.\n * 2. Append the provided byte (`data`) to the buffer using the `p` function, which handles the actual appending logic.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "pBytes3",
            "parameters": "DynamicBuffer memory buffer, bytes3 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes3(DynamicBuffer memory buffer, bytes3 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 3));\n    }",
            "start": "582",
            "end": "589",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes3DynamicBuffer memory buffer, bytes3 data",
            "full_signature": "function pBytes3(DynamicBuffer memory buffer, bytes3 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes3DynamicBuffer memory buffer, bytes3 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Appends a 3-byte value (`data`) to a dynamic buffer and returns the updated buffer.\n *\n * @param buffer The dynamic buffer to which the 3-byte value will be appended.\n * @param data The 3-byte value to append to the buffer.\n * @return result The updated dynamic buffer after appending the 3-byte value.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean.\n * 2. Append the 3-byte value (`data`) to the provided buffer using the `p` function.\n * 3. Return the updated buffer as `result`.\n */"
        },
        {
            "identifier": "pBytes32",
            "parameters": "DynamicBuffer memory buffer, bytes32 data",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function pBytes32(DynamicBuffer memory buffer, bytes32 data)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        _deallocate(result);\n        result = p(buffer, _single(bytes32(data), 32));\n    }",
            "start": "872",
            "end": "879",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pBytes32DynamicBuffer memory buffer, bytes32 data",
            "full_signature": "function pBytes32(DynamicBuffer memory buffer, bytes32 data) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pBytes32DynamicBuffer memory buffer, bytes32 data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Appends a bytes32 value to a DynamicBuffer.\n *\n * @param buffer The DynamicBuffer to which the bytes32 value will be appended.\n * @param data The bytes32 value to append to the buffer.\n * @return result The updated DynamicBuffer after appending the bytes32 value.\n *\n * Steps:\n * 1. Deallocate the memory of the `result` buffer to ensure it is clean.\n * 2. Append the bytes32 value to the buffer by calling the `p` function with the buffer and the bytes32 value encoded as a single 32-byte chunk.\n * 3. Return the updated buffer.\n */"
        },
        {
            "identifier": "p",
            "parameters": "bytes memory data0, bytes memory data1",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(bytes memory data0, bytes memory data1)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(result, data0), data1);\n    }",
            "start": "890",
            "end": "896",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pbytes memory data0, bytes memory data1",
            "full_signature": "function p(bytes memory data0, bytes memory data1) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pbytes memory data0, bytes memory data1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates two byte arrays (`data0` and `data1`) into a single DynamicBuffer.\n *\n * @param data0 The first byte array to concatenate.\n * @param data1 The second byte array to concatenate.\n * @return result A DynamicBuffer containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Calls the internal `p` function with the initial `result` and `data0` to append `data0` to the buffer.\n * 2. Calls the internal `p` function again with the result from step 1 and `data1` to append `data1` to the buffer.\n * 3. Returns the final DynamicBuffer containing both `data0` and `data1`.\n */"
        },
        {
            "identifier": "p",
            "parameters": "bytes memory data0, bytes memory data1, bytes memory data2",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(bytes memory data0, bytes memory data1, bytes memory data2)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(p(result, data0), data1), data2);\n    }",
            "start": "899",
            "end": "905",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pbytes memory data0, bytes memory data1, bytes memory data2",
            "full_signature": "function p(bytes memory data0, bytes memory data1, bytes memory data2) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pbytes memory data0, bytes memory data1, bytes memory data2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates three byte arrays (`data0`, `data1`, and `data2`) into a single DynamicBuffer.\n *\n * @param data0 The first byte array to concatenate.\n * @param data1 The second byte array to concatenate.\n * @param data2 The third byte array to concatenate.\n * @return result A DynamicBuffer containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Recursively concatenate `data0`, `data1`, and `data2` into the `result` buffer.\n * 2. Return the final concatenated DynamicBuffer.\n */"
        },
        {
            "identifier": "p",
            "parameters": "bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3)\n        internal\n        pure\n        returns (DynamicBuffer memory result)\n    {\n        p(p(p(p(result, data0), data1), data2), data3);\n    }",
            "start": "908",
            "end": "914",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3",
            "full_signature": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates four byte arrays (`data0`, `data1`, `data2`, `data3`) into a single `DynamicBuffer`.\n *\n * @param data0 The first byte array to concatenate.\n * @param data1 The second byte array to concatenate.\n * @param data2 The third byte array to concatenate.\n * @param data3 The fourth byte array to concatenate.\n *\n * @return result A `DynamicBuffer` containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Recursively calls the `p` function to concatenate the byte arrays in sequence.\n * 2. Returns the final `DynamicBuffer` containing all concatenated data.\n */"
        },
        {
            "identifier": "p",
            "parameters": "bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(result, data0), data1), data2), data3), data4);\n    }",
            "start": "917",
            "end": "925",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4",
            "full_signature": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates five byte arrays (`data0`, `data1`, `data2`, `data3`, `data4`) into a single `DynamicBuffer`.\n *\n * @param data0 The first byte array to concatenate.\n * @param data1 The second byte array to concatenate.\n * @param data2 The third byte array to concatenate.\n * @param data3 The fourth byte array to concatenate.\n * @param data4 The fifth byte array to concatenate.\n *\n * @return result A `DynamicBuffer` containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Calls the internal `p` function recursively to concatenate the byte arrays in sequence.\n * 2. Returns the final `DynamicBuffer` containing all concatenated data.\n */"
        },
        {
            "identifier": "p",
            "parameters": "bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5);\n    }",
            "start": "928",
            "end": "937",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5",
            "full_signature": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A recursive function that processes multiple byte arrays and returns a DynamicBuffer.\n *\n * @param data0 The first byte array to be processed.\n * @param data1 The second byte array to be processed.\n * @param data2 The third byte array to be processed.\n * @param data3 The fourth byte array to be processed.\n * @param data4 The fifth byte array to be processed.\n * @param data5 The sixth byte array to be processed.\n *\n * @return result A DynamicBuffer containing the processed data.\n *\n * Steps:\n * 1. Recursively calls the `p` function, passing the result of the previous call along with the next byte array.\n * 2. The recursion continues until all six byte arrays are processed.\n * 3. Returns the final DynamicBuffer containing the processed data.\n */ "
        },
        {
            "identifier": "p",
            "parameters": "bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6",
            "modifiers": "pure",
            "return": "returns (DynamicBuffer memory result)",
            "body": "function p(\n        bytes memory data0,\n        bytes memory data1,\n        bytes memory data2,\n        bytes memory data3,\n        bytes memory data4,\n        bytes memory data5,\n        bytes memory data6\n    ) internal pure returns (DynamicBuffer memory result) {\n        p(p(p(p(p(p(p(result, data0), data1), data2), data3), data4), data5), data6);\n    }",
            "start": "940",
            "end": "950",
            "class": "DynamicBufferLib",
            "signature": "returns (DynamicBuffer memory result) pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6",
            "full_signature": "function p(bytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6) internal  pure returns (DynamicBuffer memory result)",
            "class_method_signature": "DynamicBufferLib.pbytes memory data0, bytes memory data1, bytes memory data2, bytes memory data3, bytes memory data4, bytes memory data5, bytes memory data6",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Concatenates multiple byte arrays into a single DynamicBuffer.\n *\n * @param data0 The first byte array to concatenate.\n * @param data1 The second byte array to concatenate.\n * @param data2 The third byte array to concatenate.\n * @param data3 The fourth byte array to concatenate.\n * @param data4 The fifth byte array to concatenate.\n * @param data5 The sixth byte array to concatenate.\n * @param data6 The seventh byte array to concatenate.\n *\n * @return result A DynamicBuffer containing the concatenated byte arrays.\n *\n * Steps:\n * 1. Recursively calls the `p` function to concatenate the byte arrays in sequence.\n * 2. Returns the final concatenated result as a DynamicBuffer.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EfficientHashLib.sol": [
        {
            "identifier": "hash",
            "parameters": "bytes32 v0",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }",
            "start": "20",
            "end": "26",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0",
            "full_signature": "function hash(bytes32 v0) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a single bytes32 value.\n *\n * @param v0 The bytes32 value to be hashed.\n * @return result The resulting bytes32 hash of the input value.\n *\n * Steps:\n * 1. Store the input value `v0` in memory at position 0x00.\n * 2. Compute the Keccak-256 hash of the 32 bytes stored at memory position 0x00.\n * 3. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for efficient memory handling and hash computation.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256 v0) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            result := keccak256(0x00, 0x20)\n        }\n    }",
            "start": "29",
            "end": "35",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0",
            "full_signature": "function hash(uint256 v0) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes a given uint256 value using the keccak256 algorithm.\n *\n * @param v0 The uint256 value to be hashed.\n * @return result The resulting bytes32 hash of the input value.\n *\n * Steps:\n * 1. Store the input value `v0` in memory at position 0x00.\n * 2. Compute the keccak256 hash of the 32 bytes starting at memory position 0x00.\n * 3. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for efficient memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32 v0, bytes32 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "38",
            "end": "45",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1",
            "full_signature": "function hash(bytes32 v0, bytes32 v1) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of two concatenated 32-byte values.\n *\n * @param v0 The first 32-byte value to be hashed.\n * @param v1 The second 32-byte value to be hashed.\n * @return result The resulting 32-byte Keccak-256 hash of the concatenated values.\n *\n * Steps:\n * 1. Store the first 32-byte value (`v0`) at memory location `0x00`.\n * 2. Store the second 32-byte value (`v1`) at memory location `0x20`.\n * 3. Compute the Keccak-256 hash of the 64-byte data starting at memory location `0x00`.\n * 4. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256 v0, uint256 v1) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, v0)\n            mstore(0x20, v1)\n            result := keccak256(0x00, 0x40)\n        }\n    }",
            "start": "48",
            "end": "55",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1",
            "full_signature": "function hash(uint256 v0, uint256 v1) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of two 256-bit values.\n *\n * @param v0 The first 256-bit value to be hashed.\n * @param v1 The second 256-bit value to be hashed.\n * @return result The Keccak-256 hash of the concatenated values `v0` and `v1`.\n *\n * Steps:\n * 1. Store `v0` in memory at position `0x00`.\n * 2. Store `v1` in memory at position `0x20`.\n * 3. Compute the Keccak-256 hash of the 64-byte memory range starting at `0x00`.\n * 4. Return the resulting hash.\n *\n * @dev This function uses inline assembly for efficient memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }",
            "start": "58",
            "end": "67",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes three bytes32 values together using the Keccak-256 hash function.\n *\n * @param v0 The first bytes32 value to be hashed.\n * @param v1 The second bytes32 value to be hashed.\n * @param v2 The third bytes32 value to be hashed.\n * @return result The resulting bytes32 hash of the three input values.\n *\n * Steps:\n * 1. Load the free memory pointer into `m`.\n * 2. Store `v0` at the memory location pointed to by `m`.\n * 3. Store `v1` at the memory location `m + 0x20`.\n * 4. Store `v2` at the memory location `m + 0x40`.\n * 5. Compute the Keccak-256 hash of the 96 bytes (0x60 in hex) starting at memory location `m`.\n * 6. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256 v0, uint256 v1, uint256 v2) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            result := keccak256(m, 0x60)\n        }\n    }",
            "start": "70",
            "end": "79",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of three 256-bit unsigned integers.\n *\n * @param v0 The first 256-bit unsigned integer to be hashed.\n * @param v1 The second 256-bit unsigned integer to be hashed.\n * @param v2 The third 256-bit unsigned integer to be hashed.\n *\n * @return result The resulting 32-byte Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store `v0` at the allocated memory location.\n * 3. Store `v1` at the memory location offset by 32 bytes (0x20).\n * 4. Store `v2` at the memory location offset by 64 bytes (0x40).\n * 5. Compute the Keccak-256 hash of the concatenated values stored in memory.\n * 6. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }",
            "start": "82",
            "end": "96",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of four 32-byte values.\n *\n * @param v0 The first 32-byte value to be hashed.\n * @param v1 The second 32-byte value to be hashed.\n * @param v2 The third 32-byte value to be hashed.\n * @param v3 The fourth 32-byte value to be hashed.\n * @return result The resulting 32-byte Keccak-256 hash.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each input value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated 128-byte data.\n * 4. Return the computed hash.\n *\n * @dev This function uses inline assembly for efficient memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            result := keccak256(m, 0x80)\n        }\n    }",
            "start": "99",
            "end": "113",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of four 256-bit unsigned integers.\n *\n * @param v0 The first 256-bit unsigned integer to be hashed.\n * @param v1 The second 256-bit unsigned integer to be hashed.\n * @param v2 The third 256-bit unsigned integer to be hashed.\n * @param v3 The fourth 256-bit unsigned integer to be hashed.\n *\n * @return result The resulting 256-bit hash as a `bytes32` value.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store each input value (`v0`, `v1`, `v2`, `v3`) sequentially in memory.\n * 3. Compute the Keccak-256 hash of the 128 bytes of memory starting at the allocated pointer.\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }",
            "start": "116",
            "end": "131",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of five 32-byte values.\n *\n * @param v0 The first 32-byte value to be hashed.\n * @param v1 The second 32-byte value to be hashed.\n * @param v2 The third 32-byte value to be hashed.\n * @param v3 The fourth 32-byte value to be hashed.\n * @param v4 The fifth 32-byte value to be hashed.\n * @return result The resulting 32-byte Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store each input value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated 160 bytes (5 * 32 bytes) of data.\n * 4. Return the computed hash.\n *\n * @dev This function uses inline assembly for memory-safe operations and efficiency.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            result := keccak256(m, 0xa0)\n        }\n    }",
            "start": "134",
            "end": "149",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of five 256-bit unsigned integers.\n *\n * @param v0 The first 256-bit unsigned integer to be hashed.\n * @param v1 The second 256-bit unsigned integer to be hashed.\n * @param v2 The third 256-bit unsigned integer to be hashed.\n * @param v3 The fourth 256-bit unsigned integer to be hashed.\n * @param v4 The fifth 256-bit unsigned integer to be hashed.\n *\n * @return result The Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each input value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the 160-byte (0xa0) memory segment starting at the allocated memory address.\n * 4. Return the computed hash.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }",
            "start": "152",
            "end": "168",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of six 32-byte values.\n *\n * @param v0 The first 32-byte value to be hashed.\n * @param v1 The second 32-byte value to be hashed.\n * @param v2 The third 32-byte value to be hashed.\n * @param v3 The fourth 32-byte value to be hashed.\n * @param v4 The fifth 32-byte value to be hashed.\n * @param v5 The sixth 32-byte value to be hashed.\n * @return result The Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Load the free memory pointer into `m`.\n * 2. Store each input value sequentially in memory starting at `m`.\n * 3. Compute the Keccak-256 hash of the 192-byte (0xc0) memory segment starting at `m`.\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            result := keccak256(m, 0xc0)\n        }\n    }",
            "start": "171",
            "end": "187",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of six 256-bit unsigned integers.\n *\n * @param v0 The first 256-bit unsigned integer to be hashed.\n * @param v1 The second 256-bit unsigned integer to be hashed.\n * @param v2 The third 256-bit unsigned integer to be hashed.\n * @param v3 The fourth 256-bit unsigned integer to be hashed.\n * @param v4 The fifth 256-bit unsigned integer to be hashed.\n * @param v5 The sixth 256-bit unsigned integer to be hashed.\n *\n * @return result The Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store each input value sequentially in memory, starting from the allocated address.\n * 3. Compute the Keccak-256 hash of the concatenated values stored in memory.\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }",
            "start": "190",
            "end": "211",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of the concatenated input bytes32 values.\n *\n * @param v0 The first bytes32 value to be hashed.\n * @param v1 The second bytes32 value to be hashed.\n * @param v2 The third bytes32 value to be hashed.\n * @param v3 The fourth bytes32 value to be hashed.\n * @param v4 The fifth bytes32 value to be hashed.\n * @param v5 The sixth bytes32 value to be hashed.\n * @param v6 The seventh bytes32 value to be hashed.\n * @return result The Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`mload(0x40)`).\n * 2. Store each input bytes32 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated values stored in memory.\n * 4. Return the computed hash as the result.\n *\n * Note: This function uses low-level assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            result := keccak256(m, 0xe0)\n        }\n    }",
            "start": "214",
            "end": "235",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes seven uint256 values into a single bytes32 hash using Keccak-256.\n *\n * @param v0 The first uint256 value to hash.\n * @param v1 The second uint256 value to hash.\n * @param v2 The third uint256 value to hash.\n * @param v3 The fourth uint256 value to hash.\n * @param v4 The fifth uint256 value to hash.\n * @param v5 The sixth uint256 value to hash.\n * @param v6 The seventh uint256 value to hash.\n *\n * @return result The resulting bytes32 hash of the concatenated values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each uint256 value sequentially in memory, starting from the allocated address.\n * 3. Use the Keccak-256 function to hash the concatenated values in memory.\n * 4. Return the resulting hash.\n *\n * Note: This function uses inline assembly for memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }",
            "start": "238",
            "end": "261",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 8 bytes32 values.\n *\n * @param v0 The first bytes32 value to hash.\n * @param v1 The second bytes32 value to hash.\n * @param v2 The third bytes32 value to hash.\n * @param v3 The fourth bytes32 value to hash.\n * @param v4 The fifth bytes32 value to hash.\n * @param v5 The sixth bytes32 value to hash.\n * @param v6 The seventh bytes32 value to hash.\n * @param v7 The eighth bytes32 value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated bytes32 values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each bytes32 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the 256 bytes of memory (8 * 32 bytes).\n * 4. Return the computed hash.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            result := keccak256(m, 0x100)\n        }\n    }",
            "start": "264",
            "end": "287",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 8 uint256 values.\n *\n * @param v0 The first uint256 value to hash.\n * @param v1 The second uint256 value to hash.\n * @param v2 The third uint256 value to hash.\n * @param v3 The fourth uint256 value to hash.\n * @param v4 The fifth uint256 value to hash.\n * @param v5 The sixth uint256 value to hash.\n * @param v6 The seventh uint256 value to hash.\n * @param v7 The eighth uint256 value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated 8 uint256 values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each of the 8 uint256 values sequentially in memory.\n * 3. Compute the Keccak-256 hash of the 256 bytes of memory (8 * 32 bytes).\n * 4. Return the computed hash.\n *\n * Note: This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }",
            "start": "290",
            "end": "315",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes 9 bytes32 values into a single bytes32 result using Keccak256.\n *\n * @param v0 The first bytes32 value to hash.\n * @param v1 The second bytes32 value to hash.\n * @param v2 The third bytes32 value to hash.\n * @param v3 The fourth bytes32 value to hash.\n * @param v4 The fifth bytes32 value to hash.\n * @param v5 The sixth bytes32 value to hash.\n * @param v6 The seventh bytes32 value to hash.\n * @param v7 The eighth bytes32 value to hash.\n * @param v8 The ninth bytes32 value to hash.\n *\n * @return result The Keccak256 hash of the concatenated bytes32 values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each bytes32 value sequentially in memory.\n * 3. Compute the Keccak256 hash of the concatenated values.\n * 4. Return the resulting hash.\n *\n * @dev This function uses inline assembly for efficient memory manipulation.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            result := keccak256(m, 0x120)\n        }\n    }",
            "start": "318",
            "end": "343",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of up to 9 uint256 values.\n *\n * @param v0 The first uint256 value to include in the hash.\n * @param v1 The second uint256 value to include in the hash.\n * @param v2 The third uint256 value to include in the hash.\n * @param v3 The fourth uint256 value to include in the hash.\n * @param v4 The fifth uint256 value to include in the hash.\n * @param v5 The sixth uint256 value to include in the hash.\n * @param v6 The seventh uint256 value to include in the hash.\n * @param v7 The eighth uint256 value to include in the hash.\n * @param v8 The ninth uint256 value to include in the hash.\n *\n * @return result The Keccak-256 hash of the concatenated values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store each uint256 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated values in memory.\n * 4. Return the resulting hash.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }",
            "start": "346",
            "end": "373",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 10 input bytes32 values.\n *\n * @param v0 The first bytes32 value to hash.\n * @param v1 The second bytes32 value to hash.\n * @param v2 The third bytes32 value to hash.\n * @param v3 The fourth bytes32 value to hash.\n * @param v4 The fifth bytes32 value to hash.\n * @param v5 The sixth bytes32 value to hash.\n * @param v6 The seventh bytes32 value to hash.\n * @param v7 The eighth bytes32 value to hash.\n * @param v8 The ninth bytes32 value to hash.\n * @param v9 The tenth bytes32 value to hash.\n * @return result The Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each input bytes32 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated values in memory.\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            result := keccak256(m, 0x140)\n        }\n    }",
            "start": "376",
            "end": "403",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 10 uint256 values.\n *\n * @param v0 The first uint256 value to hash.\n * @param v1 The second uint256 value to hash.\n * @param v2 The third uint256 value to hash.\n * @param v3 The fourth uint256 value to hash.\n * @param v4 The fifth uint256 value to hash.\n * @param v5 The sixth uint256 value to hash.\n * @param v6 The seventh uint256 value to hash.\n * @param v7 The eighth uint256 value to hash.\n * @param v8 The ninth uint256 value to hash.\n * @param v9 The tenth uint256 value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each uint256 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated values stored in memory.\n * 4. Return the computed hash.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }",
            "start": "406",
            "end": "435",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 11 concatenated 32-byte values.\n *\n * @param v0 The first 32-byte value to hash.\n * @param v1 The second 32-byte value to hash.\n * @param v2 The third 32-byte value to hash.\n * @param v3 The fourth 32-byte value to hash.\n * @param v4 The fifth 32-byte value to hash.\n * @param v5 The sixth 32-byte value to hash.\n * @param v6 The seventh 32-byte value to hash.\n * @param v7 The eighth 32-byte value to hash.\n * @param v8 The ninth 32-byte value to hash.\n * @param v9 The tenth 32-byte value to hash.\n * @param v10 The eleventh 32-byte value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated 32-byte values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store each 32-byte value sequentially in memory, starting from the allocated address.\n * 3. Compute the Keccak-256 hash of the concatenated 352 bytes (11 * 32 bytes).\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            result := keccak256(m, 0x160)\n        }\n    }",
            "start": "438",
            "end": "467",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes 11 uint256 values into a single bytes32 hash using Keccak-256.\n *\n * @param v0 The first uint256 value to hash.\n * @param v1 The second uint256 value to hash.\n * @param v2 The third uint256 value to hash.\n * @param v3 The fourth uint256 value to hash.\n * @param v4 The fifth uint256 value to hash.\n * @param v5 The sixth uint256 value to hash.\n * @param v6 The seventh uint256 value to hash.\n * @param v7 The eighth uint256 value to hash.\n * @param v8 The ninth uint256 value to hash.\n * @param v9 The tenth uint256 value to hash.\n * @param v10 The eleventh uint256 value to hash.\n *\n * @return result The resulting bytes32 hash of the concatenated values.\n *\n * Steps:\n * 1. Load the free memory pointer (`mload(0x40)`).\n * 2. Store each input value sequentially in memory, starting from the loaded pointer.\n * 3. Compute the Keccak-256 hash of the concatenated values in memory.\n * 4. Return the computed hash as the result.\n *\n * Note: This function uses inline assembly for memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }",
            "start": "470",
            "end": "501",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 12 bytes32 values.\n *\n * @param v0 The first bytes32 value to hash.\n * @param v1 The second bytes32 value to hash.\n * @param v2 The third bytes32 value to hash.\n * @param v3 The fourth bytes32 value to hash.\n * @param v4 The fifth bytes32 value to hash.\n * @param v5 The sixth bytes32 value to hash.\n * @param v6 The seventh bytes32 value to hash.\n * @param v7 The eighth bytes32 value to hash.\n * @param v8 The ninth bytes32 value to hash.\n * @param v9 The tenth bytes32 value to hash.\n * @param v10 The eleventh bytes32 value to hash.\n * @param v11 The twelfth bytes32 value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated bytes32 values.\n *\n * Steps:\n * 1. Load the free memory pointer (`mload(0x40)`) into `m`.\n * 2. Store each of the 12 bytes32 values sequentially in memory starting at `m`.\n * 3. Compute the Keccak-256 hash of the 384 bytes (12 * 32 bytes) stored in memory.\n * 4. Return the computed hash as the result.\n *\n * Note: This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            result := keccak256(m, 0x180)\n        }\n    }",
            "start": "504",
            "end": "535",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 12 input values.\n *\n * @param v0 The first 256-bit input value.\n * @param v1 The second 256-bit input value.\n * @param v2 The third 256-bit input value.\n * @param v3 The fourth 256-bit input value.\n * @param v4 The fifth 256-bit input value.\n * @param v5 The sixth 256-bit input value.\n * @param v6 The seventh 256-bit input value.\n * @param v7 The eighth 256-bit input value.\n * @param v8 The ninth 256-bit input value.\n * @param v9 The tenth 256-bit input value.\n * @param v10 The eleventh 256-bit input value.\n * @param v11 The twelfth 256-bit input value.\n *\n * @return result The Keccak-256 hash of the concatenated input values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (0x40).\n * 2. Store each input value sequentially in memory, starting from the allocated address.\n * 3. Compute the Keccak-256 hash of the concatenated values stored in memory.\n * 4. Return the computed hash.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }",
            "start": "538",
            "end": "571",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 13 bytes32 values.\n *\n * @param v0 The first bytes32 value to hash.\n * @param v1 The second bytes32 value to hash.\n * @param v2 The third bytes32 value to hash.\n * @param v3 The fourth bytes32 value to hash.\n * @param v4 The fifth bytes32 value to hash.\n * @param v5 The sixth bytes32 value to hash.\n * @param v6 The seventh bytes32 value to hash.\n * @param v7 The eighth bytes32 value to hash.\n * @param v8 The ninth bytes32 value to hash.\n * @param v9 The tenth bytes32 value to hash.\n * @param v10 The eleventh bytes32 value to hash.\n * @param v11 The twelfth bytes32 value to hash.\n * @param v12 The thirteenth bytes32 value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated bytes32 values.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store each bytes32 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated values.\n * 4. Return the computed hash.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            result := keccak256(m, 0x1a0)\n        }\n    }",
            "start": "574",
            "end": "607",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes 13 uint256 values into a single bytes32 hash using Keccak-256.\n *\n * @param v0 The first uint256 value to hash.\n * @param v1 The second uint256 value to hash.\n * @param v2 The third uint256 value to hash.\n * @param v3 The fourth uint256 value to hash.\n * @param v4 The fifth uint256 value to hash.\n * @param v5 The sixth uint256 value to hash.\n * @param v6 The seventh uint256 value to hash.\n * @param v7 The eighth uint256 value to hash.\n * @param v8 The ninth uint256 value to hash.\n * @param v9 The tenth uint256 value to hash.\n * @param v10 The eleventh uint256 value to hash.\n * @param v11 The twelfth uint256 value to hash.\n * @param v12 The thirteenth uint256 value to hash.\n *\n * @return result The resulting bytes32 hash of the concatenated values.\n *\n * Steps:\n * 1. Load the free memory pointer (0x40) into `m`.\n * 2. Store each input value sequentially in memory, starting at `m` and incrementing by 0x20 (32 bytes) for each value.\n * 3. Compute the Keccak-256 hash of the concatenated values stored in memory, using the starting address `m` and a length of 0x1a0 (416 bytes, which is 13 * 32 bytes).\n * 4. Return the computed hash as the result.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12, bytes32 v13",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        bytes32 v0,\n        bytes32 v1,\n        bytes32 v2,\n        bytes32 v3,\n        bytes32 v4,\n        bytes32 v5,\n        bytes32 v6,\n        bytes32 v7,\n        bytes32 v8,\n        bytes32 v9,\n        bytes32 v10,\n        bytes32 v11,\n        bytes32 v12,\n        bytes32 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }",
            "start": "610",
            "end": "645",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12, bytes32 v13",
            "full_signature": "function hash(bytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12, bytes32 v13) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32 v0, bytes32 v1, bytes32 v2, bytes32 v3, bytes32 v4, bytes32 v5, bytes32 v6, bytes32 v7, bytes32 v8, bytes32 v9, bytes32 v10, bytes32 v11, bytes32 v12, bytes32 v13",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 14 input bytes32 values.\n *\n * @param v0 The first bytes32 value to hash.\n * @param v1 The second bytes32 value to hash.\n * @param v2 The third bytes32 value to hash.\n * @param v3 The fourth bytes32 value to hash.\n * @param v4 The fifth bytes32 value to hash.\n * @param v5 The sixth bytes32 value to hash.\n * @param v6 The seventh bytes32 value to hash.\n * @param v7 The eighth bytes32 value to hash.\n * @param v8 The ninth bytes32 value to hash.\n * @param v9 The tenth bytes32 value to hash.\n * @param v10 The eleventh bytes32 value to hash.\n * @param v11 The twelfth bytes32 value to hash.\n * @param v12 The thirteenth bytes32 value to hash.\n * @param v13 The fourteenth bytes32 value to hash.\n *\n * @return result The Keccak-256 hash of the concatenated bytes32 values.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`mload(0x40)`).\n * 2. Store each input bytes32 value sequentially in memory.\n * 3. Compute the Keccak-256 hash of the concatenated values in memory.\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for memory-safe operations.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12, uint256 v13",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(\n        uint256 v0,\n        uint256 v1,\n        uint256 v2,\n        uint256 v3,\n        uint256 v4,\n        uint256 v5,\n        uint256 v6,\n        uint256 v7,\n        uint256 v8,\n        uint256 v9,\n        uint256 v10,\n        uint256 v11,\n        uint256 v12,\n        uint256 v13\n    ) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(m, v0)\n            mstore(add(m, 0x20), v1)\n            mstore(add(m, 0x40), v2)\n            mstore(add(m, 0x60), v3)\n            mstore(add(m, 0x80), v4)\n            mstore(add(m, 0xa0), v5)\n            mstore(add(m, 0xc0), v6)\n            mstore(add(m, 0xe0), v7)\n            mstore(add(m, 0x100), v8)\n            mstore(add(m, 0x120), v9)\n            mstore(add(m, 0x140), v10)\n            mstore(add(m, 0x160), v11)\n            mstore(add(m, 0x180), v12)\n            mstore(add(m, 0x1a0), v13)\n            result := keccak256(m, 0x1c0)\n        }\n    }",
            "start": "648",
            "end": "683",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12, uint256 v13",
            "full_signature": "function hash(uint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12, uint256 v13) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashuint256 v0, uint256 v1, uint256 v2, uint256 v3, uint256 v4, uint256 v5, uint256 v6, uint256 v7, uint256 v8, uint256 v9, uint256 v10, uint256 v11, uint256 v12, uint256 v13",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of 14 uint256 values.\n *\n * @param v0-v13 The 14 uint256 values to be hashed.\n * @return result The resulting 32-byte Keccak-256 hash.\n *\n * Steps:\n * 1. Allocate memory at the free memory pointer (`0x40`).\n * 2. Store each of the 14 uint256 values sequentially in memory, starting from the allocated memory address.\n * 3. Compute the Keccak-256 hash of the concatenated values in memory.\n * 4. Return the computed hash as the result.\n *\n * Note: This function uses inline assembly for memory manipulation and hash computation.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes32[] memory buffer",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes32[] memory buffer) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(buffer, 0x20), shl(5, mload(buffer)))\n        }\n    }",
            "start": "690",
            "end": "695",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes32[] memory buffer",
            "full_signature": "function hash(bytes32[] memory buffer) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes32[] memory buffer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a given byte array.\n *\n * @param buffer The byte array to be hashed.\n * @return result The resulting 32-byte Keccak-256 hash of the input buffer.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level operations for efficiency.\n * 2. Calculate the hash by passing the starting address of the buffer (offset by 32 bytes) and the length of the buffer (multiplied by 32) to the `keccak256` opcode.\n * 3. Return the computed hash.\n */"
        },
        {
            "identifier": "set",
            "parameters": "bytes32[] memory buffer, uint256 i, bytes32 value",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory)",
            "body": "function set(bytes32[] memory buffer, uint256 i, bytes32 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }",
            "start": "699",
            "end": "709",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32[] memory) setbytes32[] memory buffer, uint256 i, bytes32 value",
            "full_signature": "function set(bytes32[] memory buffer, uint256 i, bytes32 value) internal  pure returns (bytes32[] memory)",
            "class_method_signature": "EfficientHashLib.setbytes32[] memory buffer, uint256 i, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a value at a specific index in a bytes32 array.\n *\n * @param buffer The bytes32 array to modify.\n * @param i The index at which to set the value.\n * @param value The value to set at the specified index.\n * @return buffer The modified bytes32 array with the new value set at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to safely modify the array in memory.\n * 2. Calculate the memory offset for the specified index.\n * 3. Store the provided value at the calculated memory offset.\n * 4. Return the modified array.\n */"
        },
        {
            "identifier": "set",
            "parameters": "bytes32[] memory buffer, uint256 i, uint256 value",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory)",
            "body": "function set(bytes32[] memory buffer, uint256 i, uint256 value)\n        internal\n        pure\n        returns (bytes32[] memory)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(add(buffer, shl(5, add(1, i))), value)\n        }\n        return buffer;\n    }",
            "start": "713",
            "end": "723",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32[] memory) setbytes32[] memory buffer, uint256 i, uint256 value",
            "full_signature": "function set(bytes32[] memory buffer, uint256 i, uint256 value) internal  pure returns (bytes32[] memory)",
            "class_method_signature": "EfficientHashLib.setbytes32[] memory buffer, uint256 i, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a value at a specific index in a bytes32 array buffer.\n *\n * @param buffer The bytes32 array buffer where the value will be set.\n * @param i The index at which the value will be set.\n * @param value The value to be set at the specified index.\n * @return The modified bytes32 array buffer with the value set at the specified index.\n *\n * Steps:\n * 1. Use inline assembly to safely modify the buffer in memory.\n * 2. Calculate the memory offset for the specified index `i`.\n * 3. Store the `value` at the calculated memory offset within the buffer.\n * 4. Return the modified buffer.\n */"
        },
        {
            "identifier": "malloc",
            "parameters": "uint256 n",
            "modifiers": "pure",
            "return": "returns (bytes32[] memory buffer)",
            "body": "function malloc(uint256 n) internal pure returns (bytes32[] memory buffer) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            buffer := mload(0x40)\n            mstore(buffer, n)\n            mstore(0x40, add(shl(5, add(1, n)), buffer))\n        }\n    }",
            "start": "726",
            "end": "733",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32[] memory buffer) mallocuint256 n",
            "full_signature": "function malloc(uint256 n) internal  pure returns (bytes32[] memory buffer)",
            "class_method_signature": "EfficientHashLib.mallocuint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Allocates a dynamic array of `bytes32` in memory with a specified length.\n *\n * @param n The length of the array to allocate.\n * @return buffer A dynamically allocated array of `bytes32` with the specified length.\n *\n * Steps:\n * 1. Load the current free memory pointer (0x40) into `buffer`.\n * 2. Store the length `n` at the start of the allocated memory (first word of the array).\n * 3. Update the free memory pointer to point to the next available memory slot after the allocated array.\n *    - The calculation `shl(5, add(1, n))` computes the size of the array in bytes (32 bytes per element).\n *    - The new free memory pointer is set to `buffer + size of the array`.\n *\n * @dev This function uses inline assembly to directly manipulate memory, ensuring efficient allocation.\n */ "
        },
        {
            "identifier": "free",
            "parameters": "bytes32[] memory buffer",
            "modifiers": "pure",
            "return": "",
            "body": "function free(bytes32[] memory buffer) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(buffer)\n            mstore(shl(6, lt(iszero(n), eq(add(shl(5, add(1, n)), buffer), mload(0x40)))), buffer)\n        }\n    }",
            "start": "737",
            "end": "743",
            "class": "EfficientHashLib",
            "signature": " freebytes32[] memory buffer",
            "full_signature": "function free(bytes32[] memory buffer) internal  pure",
            "class_method_signature": "EfficientHashLib.freebytes32[] memory buffer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Frees memory allocated for a dynamic array of `bytes32` elements.\n *\n * @param buffer The dynamic array of `bytes32` elements to be freed.\n *\n * Steps:\n * 1. Retrieve the length of the `buffer` array.\n * 2. Use inline assembly to manipulate memory:\n *    - Check if the array length is zero or if the array is located at the free memory pointer.\n *    - Adjust the memory pointer to free the allocated space for the array.\n *\n * @dev This function uses low-level assembly to optimize memory management and ensure memory safety.\n */"
        },
        {
            "identifier": "eq",
            "parameters": "bytes32 a, bytes memory b",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function eq(bytes32 a, bytes memory b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(b)), eq(a, mload(add(b, 0x20))))\n        }\n    }",
            "start": "750",
            "end": "755",
            "class": "EfficientHashLib",
            "signature": "returns (bool result) eqbytes32 a, bytes memory b",
            "full_signature": "function eq(bytes32 a, bytes memory b) internal  pure returns (bool result)",
            "class_method_signature": "EfficientHashLib.eqbytes32 a, bytes memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Compares a `bytes32` value with a `bytes` array to check for equality.\n *\n * @param a The `bytes32` value to compare.\n * @param b The `bytes` array to compare against.\n * @return result A boolean indicating whether the `bytes32` value matches the first 32 bytes of the `bytes` array.\n *\n * Steps:\n * 1. Use inline assembly for efficient memory comparison.\n * 2. Check if the length of the `bytes` array is 32 bytes (`0x20` in hexadecimal).\n * 3. Compare the `bytes32` value `a` with the first 32 bytes of the `bytes` array `b`.\n * 4. Return `true` if both conditions are met, otherwise `false`.\n */"
        },
        {
            "identifier": "eq",
            "parameters": "bytes memory a, bytes32 b",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function eq(bytes memory a, bytes32 b) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(0x20, mload(a)), eq(b, mload(add(a, 0x20))))\n        }\n    }",
            "start": "758",
            "end": "763",
            "class": "EfficientHashLib",
            "signature": "returns (bool result) eqbytes memory a, bytes32 b",
            "full_signature": "function eq(bytes memory a, bytes32 b) internal  pure returns (bool result)",
            "class_method_signature": "EfficientHashLib.eqbytes memory a, bytes32 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Compares a bytes array with a bytes32 value for equality.\n *\n * @param a The bytes array to compare.\n * @param b The bytes32 value to compare against.\n * @return result A boolean indicating whether the bytes array and bytes32 value are equal.\n *\n * Steps:\n * 1. Use inline assembly to perform a low-level comparison.\n * 2. Check if the length of the bytes array (`a`) is 32 bytes (0x20 in hexadecimal).\n * 3. Compare the bytes32 value (`b`) with the first 32 bytes of the bytes array (`a`).\n * 4. Return `true` if both conditions are met, otherwise return `false`.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes memory b, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes memory b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(end, start), sub(end, start)))\n        }\n    }",
            "start": "771",
            "end": "783",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes memory b, uint256 start, uint256 end",
            "full_signature": "function hash(bytes memory b, uint256 start, uint256 end) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes memory b, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a specific segment of a byte array.\n *\n * @param b The byte array from which to compute the hash.\n * @param start The starting index of the segment within the byte array.\n * @param end The ending index of the segment within the byte array.\n * @return result The Keccak-256 hash of the specified segment.\n *\n * Steps:\n * 1. Load the length of the byte array `b`.\n * 2. Adjust the `end` index to ensure it does not exceed the length of the byte array.\n * 3. Adjust the `start` index to ensure it does not exceed the length of the byte array.\n * 4. Compute the Keccak-256 hash of the segment from `start` to `end` using inline assembly for efficiency.\n *\n * @dev This function uses inline assembly to optimize gas usage and ensure memory safety.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes memory b, uint256 start",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes memory b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            result := keccak256(add(add(b, 0x20), start), mul(gt(n, start), sub(n, start)))\n        }\n    }",
            "start": "786",
            "end": "793",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes memory b, uint256 start",
            "full_signature": "function hash(bytes memory b, uint256 start) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes memory b, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a portion of a byte array starting from a specified index.\n *\n * @param b The byte array to be hashed.\n * @param start The starting index from which to begin hashing.\n * @return result The Keccak-256 hash of the specified portion of the byte array.\n *\n * Steps:\n * 1. Load the length of the byte array `b`.\n * 2. Adjust the `start` index to ensure it is within bounds (i.e., not greater than the length of the array).\n * 3. Compute the Keccak-256 hash of the portion of the byte array starting from the adjusted `start` index.\n * 4. Return the computed hash as the result.\n *\n * @dev This function uses inline assembly for efficient memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hash",
            "parameters": "bytes memory b",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hash(bytes memory b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := keccak256(add(b, 0x20), mload(b))\n        }\n    }",
            "start": "796",
            "end": "801",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashbytes memory b",
            "full_signature": "function hash(bytes memory b) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashbytes memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a given byte array.\n *\n * @param b The byte array to be hashed.\n * @return result The resulting 32-byte Keccak-256 hash of the input byte array.\n *\n * Steps:\n * 1. Use inline assembly to perform the hash operation efficiently.\n * 2. Calculate the hash by passing the starting address of the byte array (offset by 32 bytes) and its length to the `keccak256` opcode.\n * 3. Return the computed hash as a `bytes32` value.\n */"
        },
        {
            "identifier": "hashCalldata",
            "parameters": "bytes calldata b, uint256 start, uint256 end",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hashCalldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        pure\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }",
            "start": "805",
            "end": "818",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashCalldatabytes calldata b, uint256 start, uint256 end",
            "full_signature": "function hashCalldata(bytes calldata b, uint256 start, uint256 end) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashCalldatabytes calldata b, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a segment of calldata.\n *\n * @param b The calldata bytes from which the segment is extracted.\n * @param start The starting index of the segment within the calldata.\n * @param end The ending index of the segment within the calldata.\n * @return result The Keccak-256 hash of the specified segment of calldata.\n *\n * Steps:\n * 1. Adjust the `end` index to ensure it does not exceed the length of the calldata.\n * 2. Adjust the `start` index to ensure it does not exceed the length of the calldata.\n * 3. Calculate the length of the segment to be hashed (`n`).\n * 4. Copy the specified segment of calldata into memory.\n * 5. Compute the Keccak-256 hash of the copied segment and return the result.\n *\n * @dev This function uses inline assembly for efficient memory manipulation and hashing.\n */"
        },
        {
            "identifier": "hashCalldata",
            "parameters": "bytes calldata b, uint256 start",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hashCalldata(bytes calldata b, uint256 start) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := keccak256(mload(0x40), n)\n        }\n    }",
            "start": "821",
            "end": "829",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashCalldatabytes calldata b, uint256 start",
            "full_signature": "function hashCalldata(bytes calldata b, uint256 start) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashCalldatabytes calldata b, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of a portion of the calldata starting from a specified index.\n *\n * @param b The calldata bytes to be hashed.\n * @param start The starting index from which to begin hashing the calldata.\n * @return result The Keccak-256 hash of the specified portion of the calldata.\n *\n * Steps:\n * 1. Adjust the `start` index to ensure it does not exceed the length of the calldata.\n * 2. Calculate the length of the data to be hashed (`n`), ensuring it does not exceed the remaining calldata.\n * 3. Copy the relevant portion of the calldata into memory.\n * 4. Compute the Keccak-256 hash of the copied data and return the result.\n *\n * @dev This function uses inline assembly for low-level memory manipulation to optimize gas usage.\n */"
        },
        {
            "identifier": "hashCalldata",
            "parameters": "bytes calldata b",
            "modifiers": "pure",
            "return": "returns (bytes32 result)",
            "body": "function hashCalldata(bytes calldata b) internal pure returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := keccak256(mload(0x40), b.length)\n        }\n    }",
            "start": "832",
            "end": "838",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) hashCalldatabytes calldata b",
            "full_signature": "function hashCalldata(bytes calldata b) internal  pure returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.hashCalldatabytes calldata b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the Keccak-256 hash of the provided calldata.\n *\n * @param b The calldata to be hashed.\n * @return result The Keccak-256 hash of the provided calldata.\n *\n * Steps:\n * 1. Copy the calldata into memory starting at the free memory pointer (0x40).\n * 2. Compute the Keccak-256 hash of the copied calldata using its length.\n * 3. Return the computed hash.\n *\n * @dev This function uses inline assembly to efficiently copy calldata into memory and compute the hash.\n */"
        },
        {
            "identifier": "sha2",
            "parameters": "bytes32 b",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2(bytes32 b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, b)\n            result := mload(staticcall(gas(), 2, 0x00, 0x20, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "845",
            "end": "852",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2bytes32 b",
            "full_signature": "function sha2(bytes32 b) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2bytes32 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA-2 hash of a given bytes32 input using inline assembly.\n *\n * @param b The input bytes32 value to be hashed.\n * @return result The resulting SHA-2 hash as a bytes32 value.\n *\n * Steps:\n * 1. Store the input bytes32 value `b` in memory at position 0x00.\n * 2. Use the `staticcall` opcode to invoke the SHA-2 precompiled contract (address 2) with the input data.\n * 3. Load the result from memory at position 0x01 and return it.\n * 4. If the `returndatasize` is zero, revert the transaction to ensure the operation was successful.\n *\n * @dev This function uses inline assembly for low-level operations and is marked as memory-safe.\n */"
        },
        {
            "identifier": "sha2",
            "parameters": "bytes memory b, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2(bytes memory b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            end := xor(end, mul(xor(end, n), lt(n, end)))\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(end, start), sub(end, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "856",
            "end": "871",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2bytes memory b, uint256 start, uint256 end",
            "full_signature": "function sha2(bytes memory b, uint256 start, uint256 end) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2bytes memory b, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA-256 hash of a portion of a byte array.\n *\n * @param b The byte array from which to compute the hash.\n * @param start The starting index of the byte array to include in the hash.\n * @param end The ending index of the byte array to include in the hash.\n * @return result The SHA-256 hash of the specified portion of the byte array.\n *\n * Steps:\n * 1. Load the length of the byte array `b`.\n * 2. Adjust the `end` index to ensure it does not exceed the length of the byte array.\n * 3. Adjust the `start` index to ensure it does not exceed the length of the byte array.\n * 4. Compute the SHA-256 hash of the specified portion of the byte array using inline assembly.\n * 5. If the return data size is zero, revert the transaction (invalid operation).\n */"
        },
        {
            "identifier": "sha2",
            "parameters": "bytes memory b, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2(bytes memory b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(b)\n            start := xor(start, mul(xor(start, n), lt(n, start)))\n            // forgefmt: disable-next-item\n            result := mload(staticcall(gas(), 2, add(add(b, 0x20), start),\n                mul(gt(n, start), sub(n, start)), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "874",
            "end": "884",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2bytes memory b, uint256 start",
            "full_signature": "function sha2(bytes memory b, uint256 start) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2bytes memory b, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA-2 hash of a portion of a byte array starting from a specified index.\n *\n * @param b The byte array from which to compute the hash.\n * @param start The starting index within the byte array from which to begin hashing.\n * @return result The resulting SHA-2 hash as a bytes32 value.\n *\n * Steps:\n * 1. Load the length of the byte array `b`.\n * 2. Adjust the `start` index to ensure it is within bounds (i.e., if `start` is greater than the length, it is set to the length).\n * 3. Use the `staticcall` opcode to compute the SHA-2 hash of the specified portion of the byte array.\n * 4. If the call fails (i.e., `returndatasize` is zero), revert the transaction.\n * 5. Return the computed hash as a bytes32 value.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and gas optimization.\n */"
        },
        {
            "identifier": "sha2",
            "parameters": "bytes memory b",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2(bytes memory b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(staticcall(gas(), 2, add(b, 0x20), mload(b), 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "887",
            "end": "893",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2bytes memory b",
            "full_signature": "function sha2(bytes memory b) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2bytes memory b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA-256 hash of the input bytes using inline assembly.\n *\n * @param b The input bytes to be hashed.\n * @return result The resulting SHA-256 hash as a bytes32 value.\n *\n * Steps:\n * 1. Use inline assembly to call the SHA-256 precompiled contract (address 2).\n * 2. Pass the input bytes to the precompiled contract.\n * 3. Check if the return data size is zero, and revert if true (indicating an error).\n * 4. Return the computed hash.\n *\n * @dev This function uses low-level assembly to interact with the EVM's precompiled SHA-256 contract.\n */"
        },
        {
            "identifier": "sha2Calldata",
            "parameters": "bytes calldata b, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2Calldata(bytes calldata b, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes32 result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            end := xor(end, mul(xor(end, b.length), lt(b.length, end)))\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(end, start), sub(end, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "897",
            "end": "911",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2Calldatabytes calldata b, uint256 start, uint256 end",
            "full_signature": "function sha2Calldata(bytes calldata b, uint256 start, uint256 end) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2Calldatabytes calldata b, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA-256 hash of a specified segment of calldata.\n *\n * @param b The calldata bytes from which the segment is extracted.\n * @param start The starting index of the segment within the calldata.\n * @param end The ending index of the segment within the calldata.\n * @return result The SHA-256 hash of the specified segment.\n *\n * Steps:\n * 1. Adjust the `end` and `start` indices to ensure they are within the bounds of the calldata length.\n * 2. Calculate the length of the segment (`n`) to be hashed.\n * 3. Copy the specified segment of calldata into memory.\n * 4. Compute the SHA-256 hash of the segment using the `staticcall` opcode.\n * 5. Return the computed hash.\n * 6. If the `returndatasize` is zero, revert the transaction (invalid operation).\n *\n * @dev This function uses inline assembly for low-level memory manipulation and gas optimization.\n */"
        },
        {
            "identifier": "sha2Calldata",
            "parameters": "bytes calldata b, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2Calldata(bytes calldata b, uint256 start) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            start := xor(start, mul(xor(start, b.length), lt(b.length, start)))\n            let n := mul(gt(b.length, start), sub(b.length, start))\n            calldatacopy(mload(0x40), add(b.offset, start), n)\n            result := mload(staticcall(gas(), 2, mload(0x40), n, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "914",
            "end": "923",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2Calldatabytes calldata b, uint256 start",
            "full_signature": "function sha2Calldata(bytes calldata b, uint256 start) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2Calldatabytes calldata b, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA2 hash of a portion of the calldata starting from a specified index.\n *\n * @param b The calldata bytes from which the hash will be computed.\n * @param start The starting index within the calldata from which to begin the hash computation.\n * @return result The computed SHA2 hash as a bytes32 value.\n *\n * Steps:\n * 1. Adjust the `start` index to ensure it is within the bounds of the calldata length.\n * 2. Calculate the length of the data to be hashed (`n`), ensuring it does not exceed the calldata length.\n * 3. Copy the relevant portion of the calldata into memory.\n * 4. Compute the SHA2 hash of the copied data using the `staticcall` opcode.\n * 5. If the hash computation fails (i.e., no return data), revert the transaction.\n *\n * @dev This function uses low-level assembly to optimize gas usage and ensure memory safety.\n */"
        },
        {
            "identifier": "sha2Calldata",
            "parameters": "bytes calldata b",
            "modifiers": "view",
            "return": "returns (bytes32 result)",
            "body": "function sha2Calldata(bytes calldata b) internal view returns (bytes32 result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            calldatacopy(mload(0x40), b.offset, b.length)\n            result := mload(staticcall(gas(), 2, mload(0x40), b.length, 0x01, 0x20))\n            if iszero(returndatasize()) { invalid() }\n        }\n    }",
            "start": "926",
            "end": "933",
            "class": "EfficientHashLib",
            "signature": "returns (bytes32 result) sha2Calldatabytes calldata b",
            "full_signature": "function sha2Calldata(bytes calldata b) internal  view returns (bytes32 result)",
            "class_method_signature": "EfficientHashLib.sha2Calldatabytes calldata b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the SHA-256 hash of the provided calldata bytes.\n *\n * @param b The calldata bytes to be hashed.\n * @return result The SHA-256 hash of the input bytes.\n *\n * Steps:\n * 1. Copy the calldata bytes to memory starting at the free memory pointer (`mload(0x40)`).\n * 2. Perform a static call to the SHA-256 precompiled contract (address `0x02`) with the copied data.\n * 3. Store the result of the SHA-256 computation in the `result` variable.\n * 4. If the return data size is zero, revert the transaction (invalid operation).\n *\n * @dev This function uses inline assembly for low-level memory manipulation and interaction with the SHA-256 precompiled contract.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/Lifebuoy.sol": [
        {
            "identifier": "",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "constructor() payable {\n        bytes32 hash;\n        uint256 deployer = uint160(_lifebuoyDefaultDeployer());\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, address())\n            mstore(0x20, deployer)\n            hash := keccak256(0x00, 0x40)\n        }\n        _lifebuoyDeployerHash = hash;\n    }",
            "start": "105",
            "end": "115",
            "class": "Lifebuoy",
            "signature": " ",
            "full_signature": "constructor ()",
            "class_method_signature": "Lifebuoy.",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract with a deployer hash derived from the contract's address and a default deployer address.\n *\n * Steps:\n * 1. Retrieve the default deployer address using `_lifebuoyDefaultDeployer()`.\n * 2. Use inline assembly to:\n *    - Store the contract's address in memory at position 0x00.\n *    - Store the deployer address in memory at position 0x20.\n *    - Compute the keccak256 hash of the concatenated data (0x00 to 0x40).\n * 3. Assign the computed hash to the `_lifebuoyDeployerHash` state variable.\n *\n * @dev This constructor is payable, allowing it to receive Ether during deployment.\n */ "
        },
        {
            "identifier": "rescueETH",
            "parameters": "address to, uint256 amount",
            "modifiers": "onlyRescuer(_LIFEBUOY_RESCUE_ETH_LOCK)",
            "return": "",
            "body": "function rescueETH(address to, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ETH_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(call(gas(), to, amount, codesize(), 0x00, codesize(), 0x00)) {\n                mstore(0x00, 0x7ec62e76) // `RescueTransferFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "133",
            "end": "146",
            "class": "Lifebuoy",
            "signature": " rescueETHaddress to, uint256 amount",
            "full_signature": "function rescueETH(address to, uint256 amount) public virtual onlyRescuer(_LIFEBUOY_RESCUE_ETH_LOCK)",
            "class_method_signature": "Lifebuoy.rescueETHaddress to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Rescues ETH from the contract and transfers it to a specified address.\n * @dev This function is only callable by a designated rescuer, and it uses low-level assembly for gas efficiency.\n *\n * @param to The address to which the ETH will be transferred.\n * @param amount The amount of ETH (in wei) to transfer.\n *\n * Steps:\n * 1. Check if the caller is authorized as a rescuer using the `onlyRescuer` modifier.\n * 2. Use low-level assembly to perform the ETH transfer:\n *    - Attempt to call the `to` address with the specified `amount` of ETH.\n *    - If the transfer fails, revert with the error `RescueTransferFailed()`.\n *\n * @dev The function is marked as `payable` to allow ETH transfers, and it is `virtual` to allow overriding in derived contracts.\n */"
        },
        {
            "identifier": "rescueERC20",
            "parameters": "address token, address to, uint256 amount",
            "modifiers": "onlyRescuer(_LIFEBUOY_RESCUE_ERC20_LOCK)",
            "return": "",
            "body": "function rescueERC20(address token, address to, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC20_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, amount) // Store the `amount` argument.\n            // `RescueTransferFailed()` and `transfer(address,uint256)`.\n            mstore(0x00, shl(96, 0x7ec62e76a9059cbb))\n            if iszero(call(gas(), token, callvalue(), 0x10, 0x44, codesize(), 0x00)) {\n                revert(0x0c, 0x04)\n            }\n            mstore(0x34, 0) // Restore the part of the free memory pointer that was overwritten.\n        }\n    }",
            "start": "150",
            "end": "167",
            "class": "Lifebuoy",
            "signature": " rescueERC20address token, address to, uint256 amount",
            "full_signature": "function rescueERC20(address token, address to, uint256 amount) public virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC20_LOCK)",
            "class_method_signature": "Lifebuoy.rescueERC20address token, address to, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Rescues ERC20 tokens from the contract and transfers them to a specified address.\n *\n * @param token The address of the ERC20 token to be rescued.\n * @param to The address to which the rescued tokens will be transferred.\n * @param amount The amount of tokens to rescue and transfer.\n *\n * Requirements:\n * - The caller must have the `onlyRescuer` modifier, which ensures that only authorized addresses can perform this operation.\n *\n * Steps:\n * 1. Store the `to` and `amount` arguments in memory.\n * 2. Use inline assembly to perform a low-level call to the ERC20 token's `transfer` function.\n * 3. If the call fails, revert with an error indicating that the transfer failed.\n * 4. Restore the overwritten part of the free memory pointer.\n *\n * @dev This function uses inline assembly for gas efficiency and memory safety.\n */"
        },
        {
            "identifier": "rescueERC721",
            "parameters": "address token, address to, uint256 id",
            "modifiers": "onlyRescuer(_LIFEBUOY_RESCUE_ERC721_LOCK)",
            "return": "",
            "body": "function rescueERC721(address token, address to, uint256 id)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC721_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, id) // Store the `id` argument.\n            mstore(0x40, shr(96, shl(96, to))) // Store the `to` argument.\n            mstore(0x20, address()) // Store the `from` argument.\n            // `RescueTransferFailed()` and `transferFrom(address,address,uint256)`.\n            mstore(0x00, 0x7ec62e7623b872dd)\n            if iszero(call(gas(), token, callvalue(), 0x1c, 0x64, codesize(), 0x00)) {\n                revert(0x18, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "171",
            "end": "191",
            "class": "Lifebuoy",
            "signature": " rescueERC721address token, address to, uint256 id",
            "full_signature": "function rescueERC721(address token, address to, uint256 id) public virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC721_LOCK)",
            "class_method_signature": "Lifebuoy.rescueERC721address token, address to, uint256 id",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Rescues an ERC721 token from the contract and transfers it to a specified address.\n *\n * @dev This function is marked as `payable` and can only be called by an address with the `onlyRescuer` modifier.\n * It uses low-level assembly to interact with the ERC721 token contract.\n *\n * @param token The address of the ERC721 token contract.\n * @param to The address to which the token will be transferred.\n * @param id The ID of the ERC721 token to be rescued.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the `id` argument in memory.\n * 3. Store the `to` argument in memory.\n * 4. Store the `from` argument (the current contract's address) in memory.\n * 5. Prepare the function selector for `transferFrom(address,address,uint256)`.\n * 6. Execute a low-level call to the ERC721 token contract to transfer the token.\n * 7. If the call fails, revert with an error.\n * 8. Restore the zero slot and free memory pointer to their original states.\n */"
        },
        {
            "identifier": "rescueERC1155",
            "parameters": "address token, address to, uint256 id, uint256 amount, bytes calldata data",
            "modifiers": "onlyRescuer(_LIFEBUOY_RESCUE_ERC1155_LOCK)",
            "return": "",
            "body": "function rescueERC1155(\n        address token,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) public payable virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC1155_LOCK) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            // `RescueTransferFailed()` and `safeTransferFrom(address,address,uint256,uint256,bytes)`.\n            mstore(m, 0x7ec62e76f242432a)\n            mstore(add(0x20, m), address()) // Store the `from` argument.\n            mstore(add(0x40, m), shr(96, shl(96, to))) // Store the `to` argument.\n            mstore(add(0x60, m), id) // Store the `id` argument.\n            mstore(add(0x80, m), amount) // Store the `amount` argument.\n            mstore(add(0xa0, m), 0xa0) // Store the offset to `data`.\n            mstore(add(0xc0, m), data.length)\n            calldatacopy(add(m, 0xe0), data.offset, data.length)\n            // forgefmt: disable-next-item\n            if iszero(\n                call(gas(), token, callvalue(), add(m, 0x1c), add(0xc4, data.length), codesize(), 0x00)\n            ) { revert(add(m, 0x18), 0x04) }\n        }\n    }",
            "start": "195",
            "end": "219",
            "class": "Lifebuoy",
            "signature": " rescueERC1155address token, address to, uint256 id, uint256 amount, bytes calldata data",
            "full_signature": "function rescueERC1155(address token, address to, uint256 id, uint256 amount, bytes calldata data) public virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC1155_LOCK)",
            "class_method_signature": "Lifebuoy.rescueERC1155address token, address to, uint256 id, uint256 amount, bytes calldata data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Rescues ERC1155 tokens from a specified contract and transfers them to a designated address.\n *\n * @param token The address of the ERC1155 token contract.\n * @param to The address to which the tokens will be transferred.\n * @param id The ID of the token to be transferred.\n * @param amount The amount of tokens to be transferred.\n * @param data Additional data to be passed with the transfer.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Prepare the function selector and arguments for the `safeTransferFrom` call.\n * 3. Store the `from` argument (current contract address).\n * 4. Store the `to` argument (recipient address).\n * 5. Store the `id` argument (token ID).\n * 6. Store the `amount` argument (amount of tokens).\n * 7. Store the offset to `data` and the length of `data`.\n * 8. Copy the `data` from calldata to memory.\n * 9. Execute the `safeTransferFrom` call on the ERC1155 token contract.\n * 10. If the call fails, revert with the error message \"RescueTransferFailed\".\n *\n * @dev This function is restricted to the `onlyRescuer` modifier, which ensures that only authorized addresses can execute it.\n */ "
        },
        {
            "identifier": "rescueERC6909",
            "parameters": "address token, address to, uint256 id, uint256 amount",
            "modifiers": "onlyRescuer(_LIFEBUOY_RESCUE_ERC6909_LOCK)",
            "return": "",
            "body": "function rescueERC6909(address token, address to, uint256 id, uint256 amount)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_RESCUE_ERC6909_LOCK)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x14, to) // Store the `to` argument.\n            mstore(0x34, id) // Store the `id` argument.\n            mstore(0x54, amount) // Store the `amount` argument.\n            // `RescueTransferFailed()` and `transfer(address,uint256,uint256)`.\n            mstore(0x00, shl(96, 0x7ec62e76095bcdb6))\n            if iszero(call(gas(), token, callvalue(), 0x10, 0x64, codesize(), 0x00)) {\n                revert(0x0c, 0x04)\n            }\n            mstore(0x60, 0) // Restore the zero slot to zero.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "223",
            "end": "243",
            "class": "Lifebuoy",
            "signature": " rescueERC6909address token, address to, uint256 id, uint256 amount",
            "full_signature": "function rescueERC6909(address token, address to, uint256 id, uint256 amount) public virtual onlyRescuer(_LIFEBUOY_RESCUE_ERC6909_LOCK)",
            "class_method_signature": "Lifebuoy.rescueERC6909address token, address to, uint256 id, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Rescues ERC6909 tokens from a specified contract and transfers them to a designated address.\n * @dev This function is marked as `payable` and can only be called by an authorized rescuer.\n *      It uses low-level assembly to interact with the token contract directly.\n *\n * @param token The address of the ERC6909 token contract.\n * @param to The address to which the tokens will be transferred.\n * @param id The ID of the token to be rescued.\n * @param amount The amount of tokens to be rescued.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the `to`, `id`, and `amount` arguments in memory.\n * 3. Prepare the function selector for the `transfer` function of the ERC6909 token contract.\n * 4. Execute a low-level call to the token contract to transfer the tokens.\n * 5. If the call fails, revert with an error message.\n * 6. Restore the zero slot and free memory pointer to their original states.\n */"
        },
        {
            "identifier": "lockRescue",
            "parameters": "uint256 locksToSet",
            "modifiers": "onlyRescuer(_LIFEBUOY_LOCK_RESCUE_LOCK)",
            "return": "",
            "body": "function lockRescue(uint256 locksToSet)\n        public\n        payable\n        virtual\n        onlyRescuer(_LIFEBUOY_LOCK_RESCUE_LOCK)\n    {\n        _lockRescue(locksToSet);\n    }",
            "start": "259",
            "end": "266",
            "class": "Lifebuoy",
            "signature": " lockRescueuint256 locksToSet",
            "full_signature": "function lockRescue(uint256 locksToSet) public virtual onlyRescuer(_LIFEBUOY_LOCK_RESCUE_LOCK)",
            "class_method_signature": "Lifebuoy.lockRescueuint256 locksToSet",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Allows the rescuer to lock a specified number of rescue operations.\n *\n * @param locksToSet The number of rescue locks to set.\n *\n * Requirements:\n * - The caller must have the `_LIFEBUOY_LOCK_RESCUE_LOCK` role.\n *\n * Steps:\n * 1. Calls the internal `_lockRescue` function to set the specified number of rescue locks.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibRLP.sol": [
        {
            "identifier": "List",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct List {\n        // Do NOT modify the `_data` directly.\n        uint256 _data;\n    }",
            "start": "13",
            "end": "16",
            "class": "LibRLP",
            "signature": " List",
            "full_signature": "function List()",
            "class_method_signature": "LibRLP.List",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct named `List` with a single field `_data`.\n *\n * @dev The `_data` field is a `uint256` value. The comment warns against modifying `_data` directly,\n * suggesting that it should be managed through specific functions or logic.\n */ "
        },
        {
            "identifier": "computeAddress",
            "parameters": "address deployer, uint256 nonce",
            "modifiers": "pure",
            "return": "returns (address deployed)",
            "body": "function computeAddress(address deployer, uint256 nonce)\n        internal\n        pure\n        returns (address deployed)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                // The integer zero is treated as an empty byte string,\n                // and as a result it only has a length prefix, 0x80,\n                // computed via `0x80 + 0`.\n\n                // A one-byte integer in the [0x00, 0x7f] range uses its\n                // own value as a length prefix,\n                // there is no additional `0x80 + length` prefix that precedes it.\n                if iszero(gt(nonce, 0x7f)) {\n                    mstore(0x00, deployer)\n                    // Using `mstore8` instead of `or` naturally cleans\n                    // any dirty upper bits of `deployer`.\n                    mstore8(0x0b, 0x94)\n                    mstore8(0x0a, 0xd6)\n                    // `shl` 7 is equivalent to multiplying by 0x80.\n                    mstore8(0x20, or(shl(7, iszero(nonce)), nonce))\n                    deployed := keccak256(0x0a, 0x17)\n                    break\n                }\n                let i := 8\n                // Just use a loop to generalize all the way with minimal bytecode size.\n                for {} shr(i, nonce) { i := add(i, 8) } {}\n                // `shr` 3 is equivalent to dividing by 8.\n                i := shr(3, i)\n                // Store in descending slot sequence to overlap the values correctly.\n                mstore(i, nonce)\n                mstore(0x00, shl(8, deployer))\n                mstore8(0x1f, add(0x80, i))\n                mstore8(0x0a, 0x94)\n                mstore8(0x09, add(0xd6, i))\n                deployed := keccak256(0x09, add(0x17, i))\n                break\n            }\n        }\n    }",
            "start": "46",
            "end": "87",
            "class": "LibRLP",
            "signature": "returns (address deployed) computeAddressaddress deployer, uint256 nonce",
            "full_signature": "function computeAddress(address deployer, uint256 nonce) internal  pure returns (address deployed)",
            "class_method_signature": "LibRLP.computeAddressaddress deployer, uint256 nonce",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the address of a contract that would be deployed by a specific deployer with a given nonce.\n *\n * @param deployer The address of the deployer.\n * @param nonce The nonce used in the deployment.\n * @return deployed The computed address of the contract that would be deployed.\n *\n * Steps:\n * 1. Check if the nonce is within the range [0x00, 0x7f].\n * 2. If the nonce is within the range:\n *    - Store the deployer address in memory.\n *    - Store specific byte values (0x94 and 0xd6) in memory.\n *    - Store the nonce in memory, shifted appropriately.\n *    - Compute the keccak256 hash of the memory segment to derive the deployed address.\n * 3. If the nonce is outside the range:\n *    - Determine the number of bytes required to represent the nonce.\n *    - Store the nonce and deployer address in memory, with appropriate shifts and offsets.\n *    - Compute the keccak256 hash of the memory segment to derive the deployed address.\n *\n * @dev This function uses low-level assembly to optimize gas usage and handle nonces of varying sizes.\n */"
        },
        {
            "identifier": "p",
            "parameters": "List memory list, uint256 x",
            "modifiers": "pure",
            "return": "returns (List memory result)",
            "body": "function p(List memory list, uint256 x) internal pure returns (List memory result) {\n        result._data = x << 48;\n        _updateTail(list, result);\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If `x` is too big, we cannot pack it inline with the node.\n            // We'll have to allocate a new slot for `x` and store the pointer to it in the node.\n            if shr(208, x) {\n                let m := mload(0x40)\n                mstore(m, x)\n                mstore(0x40, add(m, 0x20))\n                mstore(result, shl(40, or(1, shl(8, m))))\n            }\n        }\n        result = list;\n    }",
            "start": "129",
            "end": "144",
            "class": "LibRLP",
            "signature": "returns (List memory result) pList memory list, uint256 x",
            "full_signature": "function p(List memory list, uint256 x) internal  pure returns (List memory result)",
            "class_method_signature": "LibRLP.pList memory list, uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Processes a list and a value `x` to update the list's tail and handle memory allocation for large values of `x`.\n *\n * @param list The input list to be processed.\n * @param x The value to be packed into the list or stored separately if too large.\n * @return result The updated list after processing.\n *\n * Steps:\n * 1. Shift `x` left by 48 bits and store it in `result._data`.\n * 2. Update the tail of the list using the `_updateTail` function.\n * 3. Use inline assembly to handle memory allocation for large values of `x`:\n *    - If `x` is too large (checked by shifting right by 208 bits), allocate a new memory slot for `x`.\n *    - Store `x` in the allocated memory slot.\n *    - Update the free memory pointer (`mstore(0x40, ...)`).\n *    - Store the pointer to the allocated memory slot in the result list, with additional metadata.\n * 4. Return the updated list.\n */"
        },
        {
            "identifier": "p",
            "parameters": "List memory list, address x",
            "modifiers": "pure",
            "return": "returns (List memory result)",
            "body": "function p(List memory list, address x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(4, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "start": "147",
            "end": "154",
            "class": "LibRLP",
            "signature": "returns (List memory result) pList memory list, address x",
            "full_signature": "function p(List memory list, address x) internal  pure returns (List memory result)",
            "class_method_signature": "LibRLP.pList memory list, address x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to manipulate a linked list by adding a new node with the given address `x`.\n *\n * @param list The linked list to be updated.\n * @param x The address to be added to the linked list.\n * @return result The updated linked list after adding the new node.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations:\n *    - Store the new node's data in memory, combining the address `x` with specific bit shifts and masks.\n *    - The result is stored in the `result` variable.\n * 2. Update the tail of the linked list to include the new node.\n * 3. Return the updated linked list.\n *\n * @dev This function uses low-level assembly for memory manipulation, ensuring efficiency but requiring careful handling.\n */"
        },
        {
            "identifier": "p",
            "parameters": "List memory list, bool x",
            "modifiers": "pure",
            "return": "returns (List memory result)",
            "body": "function p(List memory list, bool x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(48, iszero(iszero(x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "start": "157",
            "end": "164",
            "class": "LibRLP",
            "signature": "returns (List memory result) pList memory list, bool x",
            "full_signature": "function p(List memory list, bool x) internal  pure returns (List memory result)",
            "class_method_signature": "LibRLP.pList memory list, bool x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function that processes a list and a boolean value, updating the list's tail.\n *\n * @param list The input list to be processed.\n * @param x The boolean value used to determine the result.\n * @return result The updated list after processing.\n *\n * Steps:\n * 1. Use inline assembly to store a value in the result based on the boolean `x`:\n *    - If `x` is true, store `1` shifted left by 48 bits.\n *    - If `x` is false, store `0`.\n * 2. Update the tail of the input list with the result.\n * 3. Return the updated list as the final result.\n */ "
        },
        {
            "identifier": "p",
            "parameters": "List memory list, bytes memory x",
            "modifiers": "pure",
            "return": "returns (List memory result)",
            "body": "function p(List memory list, bytes memory x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(2, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "start": "167",
            "end": "174",
            "class": "LibRLP",
            "signature": "returns (List memory result) pList memory list, bytes memory x",
            "full_signature": "function p(List memory list, bytes memory x) internal  pure returns (List memory result)",
            "class_method_signature": "LibRLP.pList memory list, bytes memory x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to process a list and a byte array, returning a modified list.\n *\n * @param list The input list to be processed.\n * @param x The byte array to be used in the processing.\n * @return result The modified list after processing.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations:\n *    - Shift the byte array `x` and combine it with specific bit patterns.\n *    - Store the result in the memory location of `result`.\n * 2. Call the internal `_updateTail` function to update the tail of the list with the new result.\n * 3. Return the modified list as the final result.\n *\n * @dev This function uses low-level assembly for memory manipulation, which is memory-safe.\n */ "
        },
        {
            "identifier": "p",
            "parameters": "List memory list, List memory x",
            "modifiers": "pure",
            "return": "returns (List memory result)",
            "body": "function p(List memory list, List memory x) internal pure returns (List memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(result, shl(40, or(3, shl(8, x))))\n        }\n        _updateTail(list, result);\n        result = list;\n    }",
            "start": "177",
            "end": "184",
            "class": "LibRLP",
            "signature": "returns (List memory result) pList memory list, List memory x",
            "full_signature": "function p(List memory list, List memory x) internal  pure returns (List memory result)",
            "class_method_signature": "LibRLP.pList memory list, List memory x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to process and update a linked list.\n *\n * @param list The original linked list to be processed.\n * @param x The linked list element to be added or modified.\n * @return result The updated linked list after processing.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations:\n *    - Store the modified value of `x` (shifted and combined with a flag) into the result.\n * 2. Update the tail of the original list (`list`) with the new result.\n * 3. Return the updated list as the final result.\n *\n * @dev This function uses inline assembly for memory-safe operations and assumes the caller ensures proper memory handling.\n */ "
        },
        {
            "identifier": "encode",
            "parameters": "List memory list",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function encode(List memory list) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function encodeUint(x_, o_) -> _o {\n                _o := add(o_, 1)\n                if iszero(gt(x_, 0x7f)) {\n                    mstore8(o_, or(shl(7, iszero(x_)), x_)) // Copy `x_`.\n                    leave\n                }\n                let r_ := shl(7, lt(0xffffffffffffffffffffffffffffffff, x_))\n                r_ := or(r_, shl(6, lt(0xffffffffffffffff, shr(r_, x_))))\n                r_ := or(r_, shl(5, lt(0xffffffff, shr(r_, x_))))\n                r_ := or(r_, shl(4, lt(0xffff, shr(r_, x_))))\n                r_ := or(shr(3, r_), lt(0xff, shr(r_, x_)))\n                mstore8(o_, add(r_, 0x81)) // Store the prefix.\n                mstore(0x00, x_)\n                mstore(_o, mload(xor(31, r_))) // Copy `x_`.\n                _o := add(add(1, r_), _o)\n            }\n            function encodeAddress(x_, o_) -> _o {\n                _o := add(o_, 0x15)\n                mstore(o_, shl(88, x_))\n                mstore8(o_, 0x94)\n            }\n            function encodeBytes(x_, o_, c_) -> _o {\n                _o := add(o_, 1)\n                let n_ := mload(x_)\n                if iszero(gt(n_, 55)) {\n                    let f_ := mload(add(0x20, x_))\n                    if iszero(and(eq(1, n_), lt(byte(0, f_), 0x80))) {\n                        mstore8(o_, add(n_, c_)) // Store the prefix.\n                        mstore(add(0x21, o_), mload(add(0x40, x_)))\n                        mstore(_o, f_)\n                        _o := add(n_, _o)\n                        leave\n                    }\n                    mstore(o_, f_) // Copy `x_`.\n                    leave\n                }\n                returndatacopy(returndatasize(), returndatasize(), shr(32, n_))\n                let r_ := add(1, add(lt(0xff, n_), add(lt(0xffff, n_), lt(0xffffff, n_))))\n                mstore(o_, shl(248, add(r_, add(c_, 55)))) // Store the prefix.\n                // Copy `x`.\n                let i_ := add(r_, _o)\n                _o := add(i_, n_)\n                for { let d_ := sub(add(0x20, x_), i_) } 1 {} {\n                    mstore(i_, mload(add(d_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, _o)) { break }\n                }\n                mstore(o_, or(mload(o_), shl(sub(248, shl(3, r_)), n_))) // Store the prefix.\n            }\n            function encodeList(l_, o_) -> _o {\n                if iszero(mload(l_)) {\n                    mstore8(o_, 0xc0)\n                    _o := add(o_, 1)\n                    leave\n                }\n                let j_ := add(o_, 0x20)\n                for { let h_ := l_ } 1 {} {\n                    h_ := and(mload(h_), 0xffffffffff)\n                    if iszero(h_) { break }\n                    let t_ := byte(26, mload(h_))\n                    if iszero(gt(t_, 1)) {\n                        if iszero(t_) {\n                            j_ := encodeUint(shr(48, mload(h_)), j_)\n                            continue\n                        }\n                        j_ := encodeUint(mload(shr(48, mload(h_))), j_)\n                        continue\n                    }\n                    if eq(t_, 2) {\n                        j_ := encodeBytes(shr(48, mload(h_)), j_, 0x80)\n                        continue\n                    }\n                    if eq(t_, 3) {\n                        j_ := encodeList(shr(48, mload(h_)), j_)\n                        continue\n                    }\n                    j_ := encodeAddress(shr(48, mload(h_)), j_)\n                }\n                let n_ := sub(j_, add(o_, 0x20))\n                if iszero(gt(n_, 55)) {\n                    mstore8(o_, add(n_, 0xc0)) // Store the prefix.\n                    mstore(add(0x01, o_), mload(add(0x20, o_)))\n                    mstore(add(0x21, o_), mload(add(0x40, o_)))\n                    _o := add(n_, add(0x01, o_))\n                    leave\n                }\n                mstore(o_, n_)\n                _o := encodeBytes(o_, o_, 0xc0)\n            }\n            result := mload(0x40)\n            let begin := add(result, 0x20)\n            let end := encodeList(list, begin)\n            mstore(result, sub(end, begin)) // Store the length of `result`.\n            mstore(end, 0) // Zeroize the slot after `result`.\n            mstore(0x40, add(end, 0x20)) // Allocate memory for `result`.\n        }\n    }",
            "start": "187",
            "end": "286",
            "class": "LibRLP",
            "signature": "returns (bytes memory result) encodeList memory list",
            "full_signature": "function encode(List memory list) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibRLP.encodeList memory list",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes a list of data into a byte array using a custom encoding scheme.\n *\n * The function uses low-level assembly to optimize memory usage and performance. It supports encoding\n * different types of data, including integers, addresses, byte arrays, and nested lists.\n *\n * Steps:\n * 1. Define helper functions for encoding specific data types:\n *    - `encodeUint`: Encodes an unsigned integer.\n *    - `encodeAddress`: Encodes an Ethereum address.\n *    - `encodeBytes`: Encodes a byte array.\n *    - `encodeList`: Encodes a list of data, recursively handling nested lists.\n *\n * 2. Initialize the result byte array and allocate memory for it.\n * 3. Use the `encodeList` function to encode the provided list into the result byte array.\n * 4. Store the length of the encoded result and zeroize the memory slot after the result.\n * 5. Allocate additional memory for the result to ensure proper memory management.\n *\n * @param list The list of data to be encoded.\n * @return result The encoded byte array.\n *\n * Note: This function uses assembly for memory-safe operations and optimizations.\n */"
        },
        {
            "identifier": "encode",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function encode(uint256 x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for {} 1 {} {\n                result := mload(0x40)\n                if iszero(gt(x, 0x7f)) {\n                    mstore(result, 1) // Store the length of `result`.\n                    mstore(add(result, 0x20), shl(248, or(shl(7, iszero(x)), x))) // Copy `x`.\n                    mstore(0x40, add(result, 0x40)) // Allocate memory for `result`.\n                    break\n                }\n                let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n                r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n                r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n                r := or(r, shl(4, lt(0xffff, shr(r, x))))\n                r := add(2, or(shr(3, r), lt(0xff, shr(r, x))))\n                mstore(add(r, result), x) // Copy `x`.\n                mstore(add(result, 1), add(r, 0x7f)) // Store the prefix.\n                mstore(result, r) // Store the length of `result`.\n                mstore(add(r, add(result, 0x20)), 0) // Zeroize the slot after `result`.\n                mstore(0x40, add(result, 0x60)) // Allocate memory for `result`.\n                break\n            }\n        }\n    }",
            "start": "289",
            "end": "313",
            "class": "LibRLP",
            "signature": "returns (bytes memory result) encodeuint256 x",
            "full_signature": "function encode(uint256 x) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibRLP.encodeuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes a uint256 value into a bytes memory result using low-level assembly for efficiency.\n *\n * @param x The uint256 value to be encoded.\n * @return result The encoded bytes memory representation of `x`.\n *\n * Steps:\n * 1. Allocate memory for the result using `mload(0x40)`.\n * 2. If `x` is less than or equal to 0x7f (127 in decimal), encode it directly:\n *    - Store the length of the result as 1.\n *    - Copy `x` into the result, shifted appropriately.\n *    - Allocate memory for the result.\n * 3. If `x` is greater than 0x7f, calculate the number of bytes required to represent `x`:\n *    - Determine the number of leading zeros and calculate the required bytes.\n *    - Store the prefix and length of the result.\n *    - Copy `x` into the result.\n *    - Zeroize the slot after the result to ensure memory safety.\n *    - Allocate memory for the result.\n * 4. Return the encoded bytes memory result.\n */"
        },
        {
            "identifier": "encode",
            "parameters": "address x",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function encode(address x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 0x15)\n            let o := add(0x20, result)\n            mstore(o, shl(88, x))\n            mstore8(o, 0x94)\n            mstore(0x40, add(0x20, o))\n        }\n    }",
            "start": "316",
            "end": "326",
            "class": "LibRLP",
            "signature": "returns (bytes memory result) encodeaddress x",
            "full_signature": "function encode(address x) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibRLP.encodeaddress x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes an address into a bytes memory format using low-level assembly.\n *\n * @param x The address to be encoded.\n * @return result The encoded bytes representation of the address.\n *\n * Steps:\n * 1. Load the free memory pointer (`0x40`) into `result`.\n * 2. Store the value `0x15` at the start of `result` (likely a prefix or identifier).\n * 3. Calculate the offset `o` by adding `0x20` (32 bytes) to `result`.\n * 4. Store the address `x` shifted left by 88 bits at the offset `o`.\n * 5. Store the byte `0x94` at the end of the encoded data.\n * 6. Update the free memory pointer to point to the next available memory slot.\n *\n * Note: This function uses inline assembly for memory manipulation, which is not memory-safe in Solidity.\n */"
        },
        {
            "identifier": "encode",
            "parameters": "bool x",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function encode(bool x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            mstore(result, 1)\n            mstore(add(0x20, result), shl(add(0xf8, mul(7, iszero(x))), 0x01))\n            mstore(0x40, add(0x40, result))\n        }\n    }",
            "start": "329",
            "end": "337",
            "class": "LibRLP",
            "signature": "returns (bytes memory result) encodebool x",
            "full_signature": "function encode(bool x) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibRLP.encodebool x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes a boolean value into a bytes array using low-level assembly.\n *\n * @param x The boolean value to be encoded.\n * @return result A bytes array containing the encoded boolean value.\n *\n * Steps:\n * 1. Allocate memory for the result by loading the free memory pointer (`0x40`).\n * 2. Store the length of the result (1 byte) at the start of the result.\n * 3. Store the encoded boolean value (either `0x01` for `true` or `0x00` for `false`) at the next memory location.\n * 4. Update the free memory pointer to point to the next available memory slot.\n *\n * Note: This function uses inline assembly for memory manipulation, which is memory-safe.\n */"
        },
        {
            "identifier": "encode",
            "parameters": "bytes memory x",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function encode(bytes memory x) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := x\n\n            for {} iszero(and(eq(1, mload(x)), lt(byte(0, mload(add(x, 0x20))), 0x80))) {} {\n                result := mload(0x40)\n                let n := mload(x) // Length of `x`.\n                if iszero(gt(n, 55)) {\n                    mstore(0x40, add(result, 0x60))\n                    mstore(add(0x41, result), mload(add(0x40, x)))\n                    mstore(add(0x21, result), mload(add(0x20, x)))\n                    mstore(add(1, result), add(n, 0x80)) // Store the prefix.\n                    mstore(result, add(1, n)) // Store the length of `result`.\n                    mstore(add(add(result, 0x21), n), 0) // Zeroize the slot after `result`.\n                    break\n                }\n                returndatacopy(returndatasize(), returndatasize(), shr(32, n))\n                let r := add(2, add(lt(0xff, n), add(lt(0xffff, n), lt(0xffffff, n))))\n                // Copy `x`.\n                let i := add(r, add(0x20, result))\n                let end := add(i, n)\n                for { let d := sub(add(0x20, x), i) } 1 {} {\n                    mstore(i, mload(add(d, i)))\n                    i := add(i, 0x20)\n                    if iszero(lt(i, end)) { break }\n                }\n                mstore(add(r, result), n) // Store the prefix.\n                mstore(add(1, result), add(r, 0xb6)) // Store the prefix.\n                mstore(result, add(r, n)) // Store the length of `result`.\n                mstore(end, 0) // Zeroize the slot after `result`.\n                mstore(0x40, add(end, 0x20)) // Allocate memory.\n                break\n            }\n        }\n    }",
            "start": "340",
            "end": "375",
            "class": "LibRLP",
            "signature": "returns (bytes memory result) encodebytes memory x",
            "full_signature": "function encode(bytes memory x) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibRLP.encodebytes memory x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Encodes a byte array into a specific format using low-level assembly.\n *\n * @dev This function uses inline assembly to optimize memory usage and performance.\n * It handles encoding of byte arrays, particularly for cases where the byte array\n * is short (<= 55 bytes) or long (> 55 bytes). The function ensures memory safety\n * and proper allocation.\n *\n * @param x The byte array to be encoded.\n * @return result The encoded byte array.\n *\n * Steps:\n * 1. Check if the byte array is already in the correct format (single byte and less than 0x80).\n *    If so, return the byte array as is.\n * 2. If the byte array is short (<= 55 bytes):\n *    - Allocate memory for the result.\n *    - Copy the byte array into the result with a specific prefix.\n *    - Store the length of the result.\n *    - Zeroize the slot after the result.\n * 3. If the byte array is long (> 55 bytes):\n *    - Calculate the required prefix length based on the size of the byte array.\n *    - Copy the byte array into the result with the appropriate prefix.\n *    - Store the length of the result.\n *    - Zeroize the slot after the result.\n *    - Allocate additional memory if necessary.\n * 4. Return the encoded byte array.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EnumerableMapLib.sol": [
        {
            "identifier": "AddressToUint256Map",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct AddressToUint256Map {\n        EnumerableSetLib.AddressSet _keys;\n        mapping(address => uint256) _values;\n    }",
            "start": "64",
            "end": "67",
            "class": "EnumerableMapLib",
            "signature": " AddressToUint256Map",
            "full_signature": "function AddressToUint256Map()",
            "class_method_signature": "EnumerableMapLib.AddressToUint256Map",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function AddressSet()', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Defines a mapping structure that associates addresses with uint256 values.\n *\n * The structure consists of:\n * 1. `_keys`: An enumerable set of addresses (using `EnumerableSetLib.AddressSet`) to keep track of all keys in the mapping.\n * 2. `_values`: A mapping from addresses to uint256 values, storing the actual data associated with each address.\n *\n * This structure allows for efficient storage and retrieval of uint256 values by address, while also enabling enumeration of all keys in the mapping.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "81",
            "end": "87",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setBytes32ToBytes32Map storage map, bytes32 key, bytes32 value",
            "full_signature": "function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setBytes32ToBytes32Map storage map, bytes32 key, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in a `Bytes32ToBytes32Map` storage map.\n *\n * @param map The storage map where the key-value pair will be set.\n * @param key The key to be added or updated in the map.\n * @param value The value to be associated with the key.\n *\n * @return bool Returns `true` if the key was added to the map, or `false` if the key already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `_values` mapping of the `map`.\n * 2. Attempt to add the `key` to the `_keys` set in the `map` using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was newly added or already existed.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Bytes32ToBytes32Map storage map, bytes32 key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "91",
            "end": "94",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeBytes32ToBytes32Map storage map, bytes32 key",
            "full_signature": "function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeBytes32ToBytes32Map storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from a `Bytes32ToBytes32Map` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The key of the key-value pair to be removed.\n *\n * @return bool Returns `true` if the key was found and removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from the `_keys` set.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Bytes32ToBytes32Map storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (bytes32 key, bytes32 value)",
            "body": "function at(Bytes32ToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "107",
            "end": "113",
            "class": "EnumerableMapLib",
            "signature": "returns (bytes32 key, bytes32 value) atBytes32ToBytes32Map storage map, uint256 i",
            "full_signature": "function at(Bytes32ToBytes32Map storage map, uint256 i) internal  view returns (bytes32 key, bytes32 value)",
            "class_method_signature": "EnumerableMapLib.atBytes32ToBytes32Map storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key and value at a specific index in a Bytes32ToBytes32Map.\n *\n * @param map The storage map from which to retrieve the key-value pair.\n * @param i The index of the key-value pair to retrieve.\n * @return key The key at the specified index.\n * @return value The value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `map._keys` set using `EnumerableSetLib.at`.\n * 2. Use the retrieved key to fetch the corresponding value from `map._values`.\n * 3. Return both the key and value.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "Bytes32ToBytes32Map storage map, bytes32 key",
            "modifiers": "view",
            "return": "returns (bool exists, bytes32 value)",
            "body": "function tryGet(Bytes32ToBytes32Map storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "start": "116",
            "end": "122",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, bytes32 value) tryGetBytes32ToBytes32Map storage map, bytes32 key",
            "full_signature": "function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal  view returns (bool exists, bytes32 value)",
            "class_method_signature": "EnumerableMapLib.tryGetBytes32ToBytes32Map storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value from a `Bytes32ToBytes32Map` storage map using a given key.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key to look up in the map.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The value associated with the key, or `bytes32(0)` if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key is non-zero or if the key exists in the map.\n * 2. Return a boolean indicating the existence of the key and the associated value.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Bytes32ToBytes32Map storage map, bytes32 key",
            "modifiers": "view",
            "return": "returns (bytes32 value)",
            "body": "function get(Bytes32ToBytes32Map storage map, bytes32 key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "125",
            "end": "131",
            "class": "EnumerableMapLib",
            "signature": "returns (bytes32 value) getBytes32ToBytes32Map storage map, bytes32 key",
            "full_signature": "function get(Bytes32ToBytes32Map storage map, bytes32 key) internal  view returns (bytes32 value)",
            "class_method_signature": "EnumerableMapLib.getBytes32ToBytes32Map storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a given key from a `Bytes32ToBytes32Map` storage map.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key for which to retrieve the associated value.\n * @return value The value associated with the provided key.\n *\n * Steps:\n * 1. Attempt to retrieve the value associated with the key from the map.\n * 2. If the value is `bytes32(0)` (default value), check if the key exists in the map using the `contains` function.\n * 3. If the key does not exist, revert with a \"not found\" error.\n * 4. Return the retrieved value.\n */ "
        },
        {
            "identifier": "set",
            "parameters": "Bytes32ToUint256Map storage map, bytes32 key, uint256 value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "140",
            "end": "146",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setBytes32ToUint256Map storage map, bytes32 key, uint256 value",
            "full_signature": "function set(Bytes32ToUint256Map storage map, bytes32 key, uint256 value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setBytes32ToUint256Map storage map, bytes32 key, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a value in a `Bytes32ToUint256Map` storage map for a given key.\n *\n * @param map The storage map where the key-value pair will be stored.\n * @param key The bytes32 key to be associated with the value.\n * @param value The uint256 value to be stored in the map.\n *\n * @return bool Returns `true` if the key was added to the map, or `false` if the key already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` mapping.\n * 2. Add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was newly added.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Bytes32ToUint256Map storage map, bytes32 key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(Bytes32ToUint256Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "150",
            "end": "153",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeBytes32ToUint256Map storage map, bytes32 key",
            "full_signature": "function remove(Bytes32ToUint256Map storage map, bytes32 key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeBytes32ToUint256Map storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from the `Bytes32ToUint256Map` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The key of the key-value pair to be removed.\n * @return A boolean indicating whether the key was successfully removed from the map.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from the `_keys` set.\n */ "
        },
        {
            "identifier": "at",
            "parameters": "Bytes32ToUint256Map storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (bytes32 key, uint256 value)",
            "body": "function at(Bytes32ToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "166",
            "end": "172",
            "class": "EnumerableMapLib",
            "signature": "returns (bytes32 key, uint256 value) atBytes32ToUint256Map storage map, uint256 i",
            "full_signature": "function at(Bytes32ToUint256Map storage map, uint256 i) internal  view returns (bytes32 key, uint256 value)",
            "class_method_signature": "EnumerableMapLib.atBytes32ToUint256Map storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in a Bytes32ToUint256Map.\n *\n * @param map The storage reference to the Bytes32ToUint256Map.\n * @param i The index of the key-value pair to retrieve.\n * @return key The key at the specified index.\n * @return value The value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `_keys` set in the map.\n * 2. Use the retrieved key to fetch the corresponding value from the `_values` mapping in the map.\n * 3. Return both the key and the value.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "Bytes32ToUint256Map storage map, bytes32 key",
            "modifiers": "view",
            "return": "returns (bool exists, uint256 value)",
            "body": "function tryGet(Bytes32ToUint256Map storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "start": "175",
            "end": "181",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, uint256 value) tryGetBytes32ToUint256Map storage map, bytes32 key",
            "full_signature": "function tryGet(Bytes32ToUint256Map storage map, bytes32 key) internal  view returns (bool exists, uint256 value)",
            "class_method_signature": "EnumerableMapLib.tryGetBytes32ToUint256Map storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value from a `Bytes32ToUint256Map` storage map using a given key.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key associated with the value to retrieve.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The value associated with the key, or 0 if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key is non-zero or if the key exists in the map.\n * 2. Return a boolean indicating the existence of the key and the associated value.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Bytes32ToUint256Map storage map, bytes32 key",
            "modifiers": "view",
            "return": "returns (uint256 value)",
            "body": "function get(Bytes32ToUint256Map storage map, bytes32 key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "184",
            "end": "190",
            "class": "EnumerableMapLib",
            "signature": "returns (uint256 value) getBytes32ToUint256Map storage map, bytes32 key",
            "full_signature": "function get(Bytes32ToUint256Map storage map, bytes32 key) internal  view returns (uint256 value)",
            "class_method_signature": "EnumerableMapLib.getBytes32ToUint256Map storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a specific key in a `Bytes32ToUint256Map` storage mapping.\n * \n * @param map The storage mapping of type `Bytes32ToUint256Map` from which to retrieve the value.\n * @param key The bytes32 key for which the associated value is to be retrieved.\n * \n * @return value The uint256 value associated with the provided key. If the key does not exist in the mapping, \n *               the function will revert with a \"not found\" error.\n * \n * Steps:\n * 1. Attempt to retrieve the value associated with the key from the `map._values` mapping.\n * 2. If the retrieved value is 0, check if the key exists in the mapping using the `contains` function.\n * 3. If the key does not exist, revert with a \"not found\" error.\n * 4. Return the retrieved value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Bytes32ToAddressMap storage map, bytes32 key, address value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(Bytes32ToAddressMap storage map, bytes32 key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "199",
            "end": "205",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setBytes32ToAddressMap storage map, bytes32 key, address value",
            "full_signature": "function set(Bytes32ToAddressMap storage map, bytes32 key, address value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setBytes32ToAddressMap storage map, bytes32 key, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in a `Bytes32ToAddressMap` storage map.\n *\n * @param map The storage map where the key-value pair will be set.\n * @param key The key (of type `bytes32`) to be associated with the value.\n * @param value The address value to be associated with the key.\n *\n * @return bool Returns `true` if the key was added to the map, or `false` if the key already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` mapping.\n * 2. Attempt to add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was added or already existed.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Bytes32ToAddressMap storage map, bytes32 key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "209",
            "end": "212",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeBytes32ToAddressMap storage map, bytes32 key",
            "full_signature": "function remove(Bytes32ToAddressMap storage map, bytes32 key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeBytes32ToAddressMap storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from the `Bytes32ToAddressMap` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The key of the key-value pair to be removed.\n *\n * @return bool Returns `true` if the key was found and removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from `EnumerableSetLib.remove`.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Bytes32ToAddressMap storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (bytes32 key, address value)",
            "body": "function at(Bytes32ToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (bytes32 key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "225",
            "end": "231",
            "class": "EnumerableMapLib",
            "signature": "returns (bytes32 key, address value) atBytes32ToAddressMap storage map, uint256 i",
            "full_signature": "function at(Bytes32ToAddressMap storage map, uint256 i) internal  view returns (bytes32 key, address value)",
            "class_method_signature": "EnumerableMapLib.atBytes32ToAddressMap storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in a Bytes32ToAddressMap.\n *\n * @param map The storage reference to the Bytes32ToAddressMap.\n * @param i The index of the key-value pair to retrieve.\n * @return key The key at the specified index.\n * @return value The address value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `_keys` set in the map.\n * 2. Use the retrieved key to fetch the corresponding address value from the `_values` mapping.\n * 3. Return both the key and the address value.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "Bytes32ToAddressMap storage map, bytes32 key",
            "modifiers": "view",
            "return": "returns (bool exists, address value)",
            "body": "function tryGet(Bytes32ToAddressMap storage map, bytes32 key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "start": "234",
            "end": "240",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, address value) tryGetBytes32ToAddressMap storage map, bytes32 key",
            "full_signature": "function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal  view returns (bool exists, address value)",
            "class_method_signature": "EnumerableMapLib.tryGetBytes32ToAddressMap storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value from a `Bytes32ToAddressMap` storage map using a given key.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key associated with the value to retrieve.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The address value associated with the key, or `address(0)` if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key in the map is not `address(0)`.\n * 2. If the value is `address(0)`, check if the key exists in the map using the `contains` function.\n * 3. Return a tuple containing:\n *    - `exists`: A boolean indicating whether the key exists in the map.\n *    - `value`: The address value associated with the key, or `address(0)` if the key does not exist.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Bytes32ToAddressMap storage map, bytes32 key",
            "modifiers": "view",
            "return": "returns (address value)",
            "body": "function get(Bytes32ToAddressMap storage map, bytes32 key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "243",
            "end": "249",
            "class": "EnumerableMapLib",
            "signature": "returns (address value) getBytes32ToAddressMap storage map, bytes32 key",
            "full_signature": "function get(Bytes32ToAddressMap storage map, bytes32 key) internal  view returns (address value)",
            "class_method_signature": "EnumerableMapLib.getBytes32ToAddressMap storage map, bytes32 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the address associated with a given key from a `Bytes32ToAddressMap` storage map.\n *\n * @param map The storage map of type `Bytes32ToAddressMap` to query.\n * @param key The bytes32 key to look up in the map.\n * @return value The address associated with the provided key.\n *\n * Steps:\n * 1. Attempt to retrieve the address value associated with the key from the map.\n * 2. If the retrieved value is `address(0)`, check if the key exists in the map using the `contains` function.\n * 3. If the key does not exist, revert with a \"not found\" error.\n * 4. Return the retrieved address value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint256ToBytes32Map storage map, uint256 key, bytes32 value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "258",
            "end": "264",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setUint256ToBytes32Map storage map, uint256 key, bytes32 value",
            "full_signature": "function set(Uint256ToBytes32Map storage map, uint256 key, bytes32 value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setUint256ToBytes32Map storage map, uint256 key, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in a Uint256ToBytes32Map storage mapping.\n *\n * @param map The storage mapping to update.\n * @param key The key to set in the mapping.\n * @param value The value to associate with the key.\n * @return bool Returns `true` if the key was added to the mapping, `false` if it already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` storage mapping.\n * 2. Add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was newly added.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Uint256ToBytes32Map storage map, uint256 key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(Uint256ToBytes32Map storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "268",
            "end": "271",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeUint256ToBytes32Map storage map, uint256 key",
            "full_signature": "function remove(Uint256ToBytes32Map storage map, uint256 key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeUint256ToBytes32Map storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from the `Uint256ToBytes32Map` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The key of the key-value pair to be removed.\n *\n * @return bool Returns `true` if the key was found and removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from `EnumerableSetLib.remove`.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Uint256ToBytes32Map storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (uint256 key, bytes32 value)",
            "body": "function at(Uint256ToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "284",
            "end": "290",
            "class": "EnumerableMapLib",
            "signature": "returns (uint256 key, bytes32 value) atUint256ToBytes32Map storage map, uint256 i",
            "full_signature": "function at(Uint256ToBytes32Map storage map, uint256 i) internal  view returns (uint256 key, bytes32 value)",
            "class_method_signature": "EnumerableMapLib.atUint256ToBytes32Map storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key and value at a specific index in a Uint256ToBytes32Map.\n *\n * @param map The storage map from which to retrieve the key-value pair.\n * @param i The index at which to retrieve the key-value pair.\n * @return key The key at the specified index.\n * @return value The value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `map._keys` set using `EnumerableSetLib.at`.\n * 2. Use the retrieved key to fetch the corresponding value from `map._values`.\n * 3. Return the key and value as a tuple.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "Uint256ToBytes32Map storage map, uint256 key",
            "modifiers": "view",
            "return": "returns (bool exists, bytes32 value)",
            "body": "function tryGet(Uint256ToBytes32Map storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "start": "293",
            "end": "299",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, bytes32 value) tryGetUint256ToBytes32Map storage map, uint256 key",
            "full_signature": "function tryGet(Uint256ToBytes32Map storage map, uint256 key) internal  view returns (bool exists, bytes32 value)",
            "class_method_signature": "EnumerableMapLib.tryGetUint256ToBytes32Map storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value from a `Uint256ToBytes32Map` storage map for a given key.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key for which to retrieve the value.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The value associated with the key, or `bytes32(0)` if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key is non-zero or if the key exists in the map.\n * 2. Return a tuple containing:\n *    - `exists`: A boolean indicating whether the key exists in the map.\n *    - `value`: The value associated with the key, or `bytes32(0)` if the key does not exist.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Uint256ToBytes32Map storage map, uint256 key",
            "modifiers": "view",
            "return": "returns (bytes32 value)",
            "body": "function get(Uint256ToBytes32Map storage map, uint256 key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "302",
            "end": "308",
            "class": "EnumerableMapLib",
            "signature": "returns (bytes32 value) getUint256ToBytes32Map storage map, uint256 key",
            "full_signature": "function get(Uint256ToBytes32Map storage map, uint256 key) internal  view returns (bytes32 value)",
            "class_method_signature": "EnumerableMapLib.getUint256ToBytes32Map storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a given key from a `Uint256ToBytes32Map` storage map.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key for which to retrieve the associated value.\n * @return value The value associated with the provided key.\n *\n * Steps:\n * 1. Attempt to retrieve the value from the map using the provided key.\n * 2. If the retrieved value is `bytes32(0)`, check if the key exists in the map using the `contains` function.\n * 3. If the key does not exist, revert with a \"not found\" error.\n * 4. Return the retrieved value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint256ToUint256Map storage map, uint256 key, uint256 value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(Uint256ToUint256Map storage map, uint256 key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "317",
            "end": "323",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setUint256ToUint256Map storage map, uint256 key, uint256 value",
            "full_signature": "function set(Uint256ToUint256Map storage map, uint256 key, uint256 value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setUint256ToUint256Map storage map, uint256 key, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in a Uint256ToUint256Map storage map.\n *\n * @param map The storage map where the key-value pair will be set.\n * @param key The key to be set in the map.\n * @param value The value to be associated with the key in the map.\n *\n * @return bool Returns `true` if the key was added to the map, or `false` if the key already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` mapping.\n * 2. Add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was newly added or already existed.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Uint256ToUint256Map storage map, uint256 key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(Uint256ToUint256Map storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "327",
            "end": "330",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeUint256ToUint256Map storage map, uint256 key",
            "full_signature": "function remove(Uint256ToUint256Map storage map, uint256 key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeUint256ToUint256Map storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from a Uint256ToUint256Map storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The key of the key-value pair to be removed.\n * @return bool Returns `true` if the key was successfully removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key in the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from `EnumerableSetLib.remove`.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Uint256ToUint256Map storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (uint256 key, uint256 value)",
            "body": "function at(Uint256ToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "343",
            "end": "349",
            "class": "EnumerableMapLib",
            "signature": "returns (uint256 key, uint256 value) atUint256ToUint256Map storage map, uint256 i",
            "full_signature": "function at(Uint256ToUint256Map storage map, uint256 i) internal  view returns (uint256 key, uint256 value)",
            "class_method_signature": "EnumerableMapLib.atUint256ToUint256Map storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in a Uint256ToUint256Map.\n *\n * @param map The storage reference to the Uint256ToUint256Map.\n * @param i The index of the key-value pair to retrieve.\n * @return key The key at the specified index.\n * @return value The value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `_keys` set in the map.\n * 2. Use the retrieved key to fetch the corresponding value from the `_values` mapping in the map.\n * 3. Return both the key and the value.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "Uint256ToUint256Map storage map, uint256 key",
            "modifiers": "view",
            "return": "returns (bool exists, uint256 value)",
            "body": "function tryGet(Uint256ToUint256Map storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "start": "352",
            "end": "358",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, uint256 value) tryGetUint256ToUint256Map storage map, uint256 key",
            "full_signature": "function tryGet(Uint256ToUint256Map storage map, uint256 key) internal  view returns (bool exists, uint256 value)",
            "class_method_signature": "EnumerableMapLib.tryGetUint256ToUint256Map storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value associated with a given key from a Uint256ToUint256Map storage map.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key associated with the value to retrieve.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The value associated with the key, or 0 if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key is non-zero or if the key exists in the map.\n * 2. Return a tuple containing a boolean indicating the existence of the key and the associated value.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Uint256ToUint256Map storage map, uint256 key",
            "modifiers": "view",
            "return": "returns (uint256 value)",
            "body": "function get(Uint256ToUint256Map storage map, uint256 key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "361",
            "end": "367",
            "class": "EnumerableMapLib",
            "signature": "returns (uint256 value) getUint256ToUint256Map storage map, uint256 key",
            "full_signature": "function get(Uint256ToUint256Map storage map, uint256 key) internal  view returns (uint256 value)",
            "class_method_signature": "EnumerableMapLib.getUint256ToUint256Map storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a given key from a Uint256ToUint256Map storage map.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The key for which to retrieve the associated value.\n * @return value The value associated with the provided key.\n *\n * Steps:\n * 1. Attempt to retrieve the value from the map using the provided key.\n * 2. If the retrieved value is 0 and the key does not exist in the map, revert with a \"not found\" error.\n * 3. Return the retrieved value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "Uint256ToAddressMap storage map, uint256 key, address value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(Uint256ToAddressMap storage map, uint256 key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "376",
            "end": "382",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setUint256ToAddressMap storage map, uint256 key, address value",
            "full_signature": "function set(Uint256ToAddressMap storage map, uint256 key, address value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setUint256ToAddressMap storage map, uint256 key, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in the `Uint256ToAddressMap` storage map.\n *\n * @param map The storage map where the key-value pair will be set.\n * @param key The uint256 key to be set in the map.\n * @param value The address value to be associated with the key.\n *\n * @return bool Returns `true` if the key was successfully added to the map, `false` if the key already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` mapping.\n * 2. Attempt to add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `EnumerableSetLib.add` operation, which indicates whether the key was added or already existed.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "Uint256ToAddressMap storage map, uint256 key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(Uint256ToAddressMap storage map, uint256 key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "386",
            "end": "389",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeUint256ToAddressMap storage map, uint256 key",
            "full_signature": "function remove(Uint256ToAddressMap storage map, uint256 key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeUint256ToAddressMap storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from a `Uint256ToAddressMap` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The key of the key-value pair to be removed.\n *\n * @return bool Returns `true` if the key was present and successfully removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from `EnumerableSetLib.remove`.\n */"
        },
        {
            "identifier": "at",
            "parameters": "Uint256ToAddressMap storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (uint256 key, address value)",
            "body": "function at(Uint256ToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (uint256 key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "402",
            "end": "408",
            "class": "EnumerableMapLib",
            "signature": "returns (uint256 key, address value) atUint256ToAddressMap storage map, uint256 i",
            "full_signature": "function at(Uint256ToAddressMap storage map, uint256 i) internal  view returns (uint256 key, address value)",
            "class_method_signature": "EnumerableMapLib.atUint256ToAddressMap storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in a Uint256ToAddressMap.\n *\n * @param map The storage reference to the Uint256ToAddressMap.\n * @param i The index of the key-value pair to retrieve.\n * @return key The key at the specified index.\n * @return value The corresponding address value at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `map._keys` set.\n * 2. Use the retrieved key to fetch the corresponding address value from `map._values`.\n * 3. Return the key-value pair.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "Uint256ToAddressMap storage map, uint256 key",
            "modifiers": "view",
            "return": "returns (bool exists, address value)",
            "body": "function tryGet(Uint256ToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "start": "411",
            "end": "417",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, address value) tryGetUint256ToAddressMap storage map, uint256 key",
            "full_signature": "function tryGet(Uint256ToAddressMap storage map, uint256 key) internal  view returns (bool exists, address value)",
            "class_method_signature": "EnumerableMapLib.tryGetUint256ToAddressMap storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve an address value associated with a given key from a Uint256ToAddressMap storage map.\n *\n * @param map The storage map to query.\n * @param key The key to look up in the map.\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The address value associated with the key, or address(0) if the key does not exist.\n *\n * Steps:\n * 1. Check if the key exists in the map by retrieving the value associated with the key.\n * 2. If the value is not address(0), or if the key is contained in the map, set `exists` to true.\n * 3. Return the `exists` flag and the retrieved `value`.\n */"
        },
        {
            "identifier": "get",
            "parameters": "Uint256ToAddressMap storage map, uint256 key",
            "modifiers": "view",
            "return": "returns (address value)",
            "body": "function get(Uint256ToAddressMap storage map, uint256 key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "420",
            "end": "426",
            "class": "EnumerableMapLib",
            "signature": "returns (address value) getUint256ToAddressMap storage map, uint256 key",
            "full_signature": "function get(Uint256ToAddressMap storage map, uint256 key) internal  view returns (address value)",
            "class_method_signature": "EnumerableMapLib.getUint256ToAddressMap storage map, uint256 key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the address associated with a given key from a Uint256ToAddressMap storage mapping.\n *\n * @param map The storage mapping of type `Uint256ToAddressMap` to query.\n * @param key The uint256 key to look up in the mapping.\n * @return value The address associated with the provided key.\n *\n * Steps:\n * 1. Attempt to retrieve the address value from the mapping using the provided key.\n * 2. If the retrieved value is `address(0)` and the key is not present in the mapping, revert with a \"not found\" error.\n * 3. Return the retrieved address value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "AddressToBytes32Map storage map, address key, bytes32 value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(AddressToBytes32Map storage map, address key, bytes32 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "435",
            "end": "441",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setAddressToBytes32Map storage map, address key, bytes32 value",
            "full_signature": "function set(AddressToBytes32Map storage map, address key, bytes32 value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setAddressToBytes32Map storage map, address key, bytes32 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in the `AddressToBytes32Map` storage map.\n *\n * @param map The storage map where the key-value pair will be stored.\n * @param key The address key to be added or updated in the map.\n * @param value The bytes32 value to be associated with the key.\n *\n * @return bool Returns `true` if the key was added to the map, or `false` if the key already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` mapping.\n * 2. Attempt to add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was newly added or already existed.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "AddressToBytes32Map storage map, address key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(AddressToBytes32Map storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "445",
            "end": "448",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeAddressToBytes32Map storage map, address key",
            "full_signature": "function remove(AddressToBytes32Map storage map, address key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeAddressToBytes32Map storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from the `AddressToBytes32Map` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The address key to be removed from the map.\n *\n * @return bool Returns `true` if the key was successfully removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using `EnumerableSetLib.remove`.\n * 3. Return the result of the removal operation from `EnumerableSetLib.remove`.\n */"
        },
        {
            "identifier": "at",
            "parameters": "AddressToBytes32Map storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (address key, bytes32 value)",
            "body": "function at(AddressToBytes32Map storage map, uint256 i)\n        internal\n        view\n        returns (address key, bytes32 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "461",
            "end": "467",
            "class": "EnumerableMapLib",
            "signature": "returns (address key, bytes32 value) atAddressToBytes32Map storage map, uint256 i",
            "full_signature": "function at(AddressToBytes32Map storage map, uint256 i) internal  view returns (address key, bytes32 value)",
            "class_method_signature": "EnumerableMapLib.atAddressToBytes32Map storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in an `AddressToBytes32Map`.\n *\n * @param map The storage map from which to retrieve the key-value pair.\n * @param i The index of the key-value pair to retrieve.\n * @return key The address key at the specified index.\n * @return value The bytes32 value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `_keys` set in the map.\n * 2. Use the retrieved key to fetch the corresponding value from the `_values` mapping in the map.\n * 3. Return the key-value pair.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "AddressToBytes32Map storage map, address key",
            "modifiers": "view",
            "return": "returns (bool exists, bytes32 value)",
            "body": "function tryGet(AddressToBytes32Map storage map, address key)\n        internal\n        view\n        returns (bool exists, bytes32 value)\n    {\n        exists = (value = map._values[key]) != bytes32(0) || contains(map, key);\n    }",
            "start": "470",
            "end": "476",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, bytes32 value) tryGetAddressToBytes32Map storage map, address key",
            "full_signature": "function tryGet(AddressToBytes32Map storage map, address key) internal  view returns (bool exists, bytes32 value)",
            "class_method_signature": "EnumerableMapLib.tryGetAddressToBytes32Map storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value from an `AddressToBytes32Map` storage map for a given address key.\n *\n * @param map The storage map from which to retrieve the value.\n * @param key The address key for which to retrieve the value.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The bytes32 value associated with the key, or `bytes32(0)` if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key is non-zero or if the key exists in the map.\n * 2. Return a tuple containing:\n *    - `exists`: A boolean indicating whether the key exists in the map.\n *    - `value`: The bytes32 value associated with the key, or `bytes32(0)` if the key does not exist.\n */"
        },
        {
            "identifier": "get",
            "parameters": "AddressToBytes32Map storage map, address key",
            "modifiers": "view",
            "return": "returns (bytes32 value)",
            "body": "function get(AddressToBytes32Map storage map, address key)\n        internal\n        view\n        returns (bytes32 value)\n    {\n        if ((value = map._values[key]) == bytes32(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "479",
            "end": "485",
            "class": "EnumerableMapLib",
            "signature": "returns (bytes32 value) getAddressToBytes32Map storage map, address key",
            "full_signature": "function get(AddressToBytes32Map storage map, address key) internal  view returns (bytes32 value)",
            "class_method_signature": "EnumerableMapLib.getAddressToBytes32Map storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a given address key from an `AddressToBytes32Map` storage map.\n *\n * @dev This function checks if the value for the given key is `bytes32(0)`. If it is, it further checks if the key exists in the map using the `contains` function. If the key does not exist, it reverts with a \"not found\" error.\n *\n * @param map The storage map of type `AddressToBytes32Map` from which to retrieve the value.\n * @param key The address key for which to retrieve the associated value.\n * @return value The bytes32 value associated with the given key. If the key does not exist, the function reverts.\n *\n * Steps:\n * 1. Attempt to retrieve the value associated with the key from the map.\n * 2. If the value is `bytes32(0)`, check if the key exists in the map using the `contains` function.\n * 3. If the key does not exist, revert with a \"not found\" error.\n * 4. Return the retrieved value.\n */ "
        },
        {
            "identifier": "set",
            "parameters": "AddressToUint256Map storage map, address key, uint256 value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(AddressToUint256Map storage map, address key, uint256 value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "494",
            "end": "500",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setAddressToUint256Map storage map, address key, uint256 value",
            "full_signature": "function set(AddressToUint256Map storage map, address key, uint256 value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setAddressToUint256Map storage map, address key, uint256 value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a value for a specific address in the AddressToUint256Map storage.\n *\n * @param map The storage map where the key-value pair will be stored.\n * @param key The address to which the value will be associated.\n * @param value The uint256 value to be stored for the given address.\n *\n * @return bool Returns `true` if the key was added to the map, `false` if it already existed.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `map._values` mapping.\n * 2. Add the `key` to the `map._keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, which indicates whether the key was newly added.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "AddressToUint256Map storage map, address key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(AddressToUint256Map storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "504",
            "end": "507",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeAddressToUint256Map storage map, address key",
            "full_signature": "function remove(AddressToUint256Map storage map, address key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeAddressToUint256Map storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from the `AddressToUint256Map` storage map.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The address key to be removed from the map.\n *\n * @return bool Returns `true` if the key was successfully removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using the `EnumerableSetLib.remove` function.\n * 3. Return the result of the removal operation from the `EnumerableSetLib.remove` function.\n */"
        },
        {
            "identifier": "at",
            "parameters": "AddressToUint256Map storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (address key, uint256 value)",
            "body": "function at(AddressToUint256Map storage map, uint256 i)\n        internal\n        view\n        returns (address key, uint256 value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "520",
            "end": "526",
            "class": "EnumerableMapLib",
            "signature": "returns (address key, uint256 value) atAddressToUint256Map storage map, uint256 i",
            "full_signature": "function at(AddressToUint256Map storage map, uint256 i) internal  view returns (address key, uint256 value)",
            "class_method_signature": "EnumerableMapLib.atAddressToUint256Map storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in an `AddressToUint256Map`.\n *\n * @param map The storage map from which to retrieve the key-value pair.\n * @param i The index of the key-value pair to retrieve.\n * @return key The address key at the specified index.\n * @return value The uint256 value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `_keys` set in the map.\n * 2. Use the retrieved key to fetch the corresponding value from the `_values` mapping in the map.\n * 3. Return the key-value pair.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "AddressToUint256Map storage map, address key",
            "modifiers": "view",
            "return": "returns (bool exists, uint256 value)",
            "body": "function tryGet(AddressToUint256Map storage map, address key)\n        internal\n        view\n        returns (bool exists, uint256 value)\n    {\n        exists = (value = map._values[key]) != uint256(0) || contains(map, key);\n    }",
            "start": "529",
            "end": "535",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, uint256 value) tryGetAddressToUint256Map storage map, address key",
            "full_signature": "function tryGet(AddressToUint256Map storage map, address key) internal  view returns (bool exists, uint256 value)",
            "class_method_signature": "EnumerableMapLib.tryGetAddressToUint256Map storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value associated with a given address key from an `AddressToUint256Map`.\n *\n * @param map The storage reference to the `AddressToUint256Map` from which to retrieve the value.\n * @param key The address key for which to retrieve the associated value.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The value associated with the key, or 0 if the key does not exist.\n *\n * Steps:\n * 1. Check if the value associated with the key is non-zero or if the key exists in the map.\n * 2. Return a tuple containing:\n *    - `exists`: A boolean indicating whether the key exists in the map.\n *    - `value`: The value associated with the key, or 0 if the key does not exist.\n */"
        },
        {
            "identifier": "get",
            "parameters": "AddressToUint256Map storage map, address key",
            "modifiers": "view",
            "return": "returns (uint256 value)",
            "body": "function get(AddressToUint256Map storage map, address key)\n        internal\n        view\n        returns (uint256 value)\n    {\n        if ((value = map._values[key]) == uint256(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "538",
            "end": "544",
            "class": "EnumerableMapLib",
            "signature": "returns (uint256 value) getAddressToUint256Map storage map, address key",
            "full_signature": "function get(AddressToUint256Map storage map, address key) internal  view returns (uint256 value)",
            "class_method_signature": "EnumerableMapLib.getAddressToUint256Map storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a given address key from an `AddressToUint256Map`.\n *\n * @param map The storage reference to the `AddressToUint256Map` mapping.\n * @param key The address key to look up in the map.\n * @return value The value associated with the address key.\n *\n * Steps:\n * 1. Attempt to retrieve the value associated with the provided address key from the map.\n * 2. If the value is `0` and the key is not found in the map, revert with a \"not found\" error.\n * 3. Return the retrieved value.\n */"
        },
        {
            "identifier": "set",
            "parameters": "AddressToAddressMap storage map, address key, address value",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function set(AddressToAddressMap storage map, address key, address value)\n        internal\n        returns (bool)\n    {\n        map._values[key] = value;\n        return EnumerableSetLib.add(map._keys, key);\n    }",
            "start": "553",
            "end": "559",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) setAddressToAddressMap storage map, address key, address value",
            "full_signature": "function set(AddressToAddressMap storage map, address key, address value) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.setAddressToAddressMap storage map, address key, address value",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Sets a key-value pair in an `AddressToAddressMap` storage mapping.\n *\n * @param map The storage mapping of type `AddressToAddressMap` where the key-value pair will be stored.\n * @param key The address key to be added or updated in the mapping.\n * @param value The address value associated with the key.\n *\n * @return bool Returns `true` if the key was added to the `_keys` set (i.e., it was not already present), otherwise `false`.\n *\n * Steps:\n * 1. Assign the provided `value` to the `key` in the `_values` mapping of the `map`.\n * 2. Add the `key` to the `_keys` set using `EnumerableSetLib.add`.\n * 3. Return the result of the `add` operation, indicating whether the key was newly added.\n */"
        },
        {
            "identifier": "remove",
            "parameters": "AddressToAddressMap storage map, address key",
            "modifiers": "",
            "return": "returns (bool)",
            "body": "function remove(AddressToAddressMap storage map, address key) internal returns (bool) {\n        delete map._values[key];\n        return EnumerableSetLib.remove(map._keys, key);\n    }",
            "start": "563",
            "end": "566",
            "class": "EnumerableMapLib",
            "signature": "returns (bool) removeAddressToAddressMap storage map, address key",
            "full_signature": "function remove(AddressToAddressMap storage map, address key) internal   returns (bool)",
            "class_method_signature": "EnumerableMapLib.removeAddressToAddressMap storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function remove(Int256Set storage set, int256 value) internal   returns (bool result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function remove(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function remove(AddressSet storage set, address value) internal   returns (bool result)', 'function remove(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function remove(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Removes a key-value pair from the `AddressToAddressMap` storage.\n *\n * @param map The storage map from which the key-value pair will be removed.\n * @param key The address key to be removed from the map.\n *\n * @return bool Returns `true` if the key was successfully removed, otherwise `false`.\n *\n * Steps:\n * 1. Delete the value associated with the provided key from the `_values` mapping.\n * 2. Remove the key from the `_keys` set using the `EnumerableSetLib.remove` function.\n * 3. Return the result of the removal operation from the `EnumerableSetLib.remove` function.\n */"
        },
        {
            "identifier": "at",
            "parameters": "AddressToAddressMap storage map, uint256 i",
            "modifiers": "view",
            "return": "returns (address key, address value)",
            "body": "function at(AddressToAddressMap storage map, uint256 i)\n        internal\n        view\n        returns (address key, address value)\n    {\n        value = map._values[key = EnumerableSetLib.at(map._keys, i)];\n    }",
            "start": "579",
            "end": "585",
            "class": "EnumerableMapLib",
            "signature": "returns (address key, address value) atAddressToAddressMap storage map, uint256 i",
            "full_signature": "function at(AddressToAddressMap storage map, uint256 i) internal  view returns (address key, address value)",
            "class_method_signature": "EnumerableMapLib.atAddressToAddressMap storage map, uint256 i",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function at(Uint256Set storage set, uint256 i) internal  view returns (uint256 result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function at(AddressSet storage set, uint256 i) internal  view returns (address result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function at(Uint8Set storage set, uint256 i) internal  view returns (uint8 result)', 'function at(Bytes32Set storage set, uint256 i) internal  view returns (bytes32 result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function at(Int256Set storage set, uint256 i) internal  view returns (int256 result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Retrieves the key-value pair at a specific index in an `AddressToAddressMap`.\n *\n * @param map The storage reference to the `AddressToAddressMap` to query.\n * @param i The index of the key-value pair to retrieve.\n * @return key The address key at the specified index.\n * @return value The address value associated with the key at the specified index.\n *\n * Steps:\n * 1. Retrieve the key at the specified index `i` from the `_keys` set in the map.\n * 2. Use the retrieved key to fetch the corresponding value from the `_values` mapping in the map.\n * 3. Return the key-value pair.\n */"
        },
        {
            "identifier": "tryGet",
            "parameters": "AddressToAddressMap storage map, address key",
            "modifiers": "view",
            "return": "returns (bool exists, address value)",
            "body": "function tryGet(AddressToAddressMap storage map, address key)\n        internal\n        view\n        returns (bool exists, address value)\n    {\n        exists = (value = map._values[key]) != address(0) || contains(map, key);\n    }",
            "start": "588",
            "end": "594",
            "class": "EnumerableMapLib",
            "signature": "returns (bool exists, address value) tryGetAddressToAddressMap storage map, address key",
            "full_signature": "function tryGet(AddressToAddressMap storage map, address key) internal  view returns (bool exists, address value)",
            "class_method_signature": "EnumerableMapLib.tryGetAddressToAddressMap storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Attempts to retrieve a value from an `AddressToAddressMap` for a given key.\n *\n * @param map The storage reference to the `AddressToAddressMap` from which to retrieve the value.\n * @param key The address key for which to retrieve the associated value.\n *\n * @return exists A boolean indicating whether the key exists in the map.\n * @return value The address value associated with the key, or `address(0)` if the key does not exist.\n *\n * Steps:\n * 1. Check if the value for the given key is non-zero or if the key exists in the map.\n * 2. Return a tuple containing:\n *    - `exists`: A boolean indicating whether the key exists in the map.\n *    - `value`: The address value associated with the key, or `address(0)` if the key does not exist.\n */"
        },
        {
            "identifier": "get",
            "parameters": "AddressToAddressMap storage map, address key",
            "modifiers": "view",
            "return": "returns (address value)",
            "body": "function get(AddressToAddressMap storage map, address key)\n        internal\n        view\n        returns (address value)\n    {\n        if ((value = map._values[key]) == address(0)) if (!contains(map, key)) _revertNotFound();\n    }",
            "start": "597",
            "end": "603",
            "class": "EnumerableMapLib",
            "signature": "returns (address value) getAddressToAddressMap storage map, address key",
            "full_signature": "function get(AddressToAddressMap storage map, address key) internal  view returns (address value)",
            "class_method_signature": "EnumerableMapLib.getAddressToAddressMap storage map, address key",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {EnumerableSetLib} from \"./EnumerableSetLib.sol\";"
            ],
            "context": "{'function values(AddressSet storage set) internal  view returns (address[] memory result)', 'function add(Bytes32Set storage set, bytes32 value) internal   returns (bool result)', 'function add(Uint8Set storage set, uint8 value) internal   returns (bool result)', 'function contains(Uint8Set storage set, uint8 value) internal  view returns (bool result)', 'function add(Int256Set storage set, int256 value) internal   returns (bool result)', 'function values(Uint8Set storage set) internal  view returns (uint8[] memory result)', 'function add(Uint256Set storage set, uint256 value) internal   returns (bool result)', 'function contains(Bytes32Set storage set, bytes32 value) internal  view returns (bool result)', 'function contains(Int256Set storage set, int256 value) internal  view returns (bool result)', 'function contains(AddressSet storage set, address value) internal  view returns (bool result)', 'function contains(Uint256Set storage set, uint256 value) internal  view returns (bool result)', 'function values(Int256Set storage set) internal  view returns (int256[] memory result)', 'function add(AddressSet storage set, address value) internal   returns (bool result)', 'function values(Bytes32Set storage set) internal  view returns (bytes32[] memory result)', 'function values(Uint256Set storage set) internal  view returns (uint256[] memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the value associated with a given key from an `AddressToAddressMap`.\n * \n * @param map The storage reference to the `AddressToAddressMap` from which to retrieve the value.\n * @param key The address key for which to retrieve the associated value.\n * \n * @return value The address value associated with the provided key.\n * \n * Steps:\n * 1. Attempt to retrieve the value associated with the key from the map.\n * 2. If the retrieved value is `address(0)` and the key is not present in the map, revert with a \"not found\" error.\n * 3. Return the retrieved value.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ReentrancyGuard.sol": [
        {
            "identifier": "nonReentrant",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier nonReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n            sstore(_REENTRANCY_GUARD_SLOT, address())\n        }\n        _;\n        /// @solidity memory-safe-assembly\n        assembly {\n            sstore(_REENTRANCY_GUARD_SLOT, codesize())\n        }\n    }",
            "start": "28",
            "end": "42",
            "class": "ReentrancyGuard",
            "signature": " nonReentrant",
            "full_signature": "function nonReentrant()  virtual",
            "class_method_signature": "ReentrancyGuard.nonReentrant",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A modifier to prevent reentrancy attacks.\n *\n * Steps:\n * 1. Check if the reentrancy guard slot (`_REENTRANCY_GUARD_SLOT`) is already set to the current contract's address.\n *    - If true, revert with the error `Reentrancy()`.\n * 2. Set the reentrancy guard slot to the current contract's address to mark the start of a non-reentrant execution.\n * 3. Execute the function body (`_`).\n * 4. After the function execution, reset the reentrancy guard slot to `codesize()` (a non-zero value) to allow future calls.\n *\n * This modifier ensures that the function cannot be re-entered while it is still executing, protecting against reentrancy attacks.\n */"
        },
        {
            "identifier": "nonReadReentrant",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier nonReadReentrant() virtual {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if eq(sload(_REENTRANCY_GUARD_SLOT), address()) {\n                mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                revert(0x1c, 0x04)\n            }\n        }\n        _;\n    }",
            "start": "45",
            "end": "54",
            "class": "ReentrancyGuard",
            "signature": " nonReadReentrant",
            "full_signature": "function nonReadReentrant()  virtual",
            "class_method_signature": "ReentrancyGuard.nonReadReentrant",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A modifier to prevent reentrancy attacks by ensuring that the function cannot be re-entered.\n *\n * Steps:\n * 1. Check if the current contract's address is stored in the reentrancy guard slot.\n * 2. If the condition is true, revert with the error \"Reentrancy()\".\n * 3. If the condition is false, allow the function to proceed.\n *\n * @dev This modifier uses low-level assembly to directly interact with storage and memory.\n * The reentrancy guard slot is checked to ensure that the function is not being re-entered.\n * If a reentrancy attempt is detected, the transaction is reverted with a custom error.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/FixedPointMathLib.sol": [
        {
            "identifier": "mulWad",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function mulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if gt(x, div(not(0), y)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := div(mul(x, y), WAD)\n        }\n    }",
            "start": "64",
            "end": "76",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) mulWaduint256 x, uint256 y",
            "full_signature": "function mulWad(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.mulWaduint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Multiplies two unsigned integers (`x` and `y`) and divides the result by `WAD` (10^18), \n *         ensuring no overflow occurs during the multiplication.\n *\n * @dev This function uses inline assembly for gas optimization and checks for overflow before performing the multiplication.\n *      If an overflow is detected, the function reverts with the error `MulWadFailed()`.\n *\n * @param x The first unsigned integer to multiply.\n * @param y The second unsigned integer to multiply.\n * @return z The result of `(x * y) / WAD`, where `WAD` is 10^18.\n *\n * Steps:\n * 1. Check if `x` is greater than `(type(uint256).max / y)` to prevent overflow.\n * 2. If an overflow is detected and `y` is not zero, revert with the error `MulWadFailed()`.\n * 3. Perform the multiplication of `x` and `y`.\n * 4. Divide the result by `WAD` (10^18) to get the final value.\n * 5. Return the result.\n */"
        },
        {
            "identifier": "sMulWad",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function sMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require((x == 0 || z / x == y) && !(x == -1 && y == type(int256).min))`.\n            if iszero(gt(or(iszero(x), eq(sdiv(z, x), y)), lt(not(x), eq(y, shl(255, 1))))) {\n                mstore(0x00, 0xedcd4dd4) // `SMulWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, WAD)\n        }\n    }",
            "start": "79",
            "end": "90",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) sMulWadint256 x, int256 y",
            "full_signature": "function sMulWad(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.sMulWadint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Multiplies two signed integers (`x` and `y`) and divides the result by `WAD` (1e18), \n * ensuring no overflow or underflow occurs during the operation.\n *\n * @dev This function uses inline assembly for gas optimization and checks for overflow/underflow conditions.\n * If the multiplication or division fails (e.g., due to overflow or division by zero), the function reverts\n * with the custom error `SMulWadFailed()`.\n *\n * @param x The first signed integer to multiply.\n * @param y The second signed integer to multiply.\n * @return z The result of the multiplication divided by `WAD`.\n *\n * Steps:\n * 1. Multiply `x` and `y` using inline assembly.\n * 2. Check for overflow or underflow conditions:\n *    - Ensure `x` is not zero or that the division of the result by `x` equals `y`.\n *    - Ensure `x` is not -1 and `y` is not the minimum value of `int256` (to avoid edge cases).\n * 3. If the checks fail, revert with the custom error `SMulWadFailed()`.\n * 4. Divide the result by `WAD` (1e18) to normalize the value.\n */"
        },
        {
            "identifier": "rawMulWad",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawMulWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, y), WAD)\n        }\n    }",
            "start": "93",
            "end": "98",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawMulWaduint256 x, uint256 y",
            "full_signature": "function rawMulWad(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawMulWaduint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Multiplies two raw integers and divides the result by `WAD` (10^18) to handle fixed-point arithmetic.\n *\n * @param x The first raw integer to multiply.\n * @param y The second raw integer to multiply.\n * @return z The result of the multiplication divided by `WAD`, ensuring fixed-point precision.\n *\n * Steps:\n * 1. Multiply `x` and `y` using the `mul` assembly instruction.\n * 2. Divide the result by `WAD` using the `div` assembly instruction to maintain fixed-point precision.\n * 3. Return the result as `z`.\n *\n * @dev This function uses inline assembly for gas efficiency and is marked as `pure` since it does not modify state.\n */"
        },
        {
            "identifier": "rawSMulWad",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawSMulWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, y), WAD)\n        }\n    }",
            "start": "101",
            "end": "106",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawSMulWadint256 x, int256 y",
            "full_signature": "function rawSMulWad(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawSMulWadint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a raw signed multiplication of two integers and divides the result by `WAD` (10^18).\n * This is typically used for fixed-point arithmetic operations.\n *\n * @param x The first signed integer to multiply.\n * @param y The second signed integer to multiply.\n * @return z The result of the multiplication divided by `WAD`.\n *\n * Steps:\n * 1. Multiply `x` and `y` using the `mul` assembly instruction.\n * 2. Divide the result by `WAD` using the `sdiv` assembly instruction.\n * 3. Return the result as `z`.\n *\n * @dev This function uses inline assembly for gas efficiency and is marked as memory-safe.\n */"
        },
        {
            "identifier": "mulWadUp",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function mulWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(y == 0 || x <= type(uint256).max / y)`.\n            if iszero(eq(div(z, y), x)) {\n                if y {\n                    mstore(0x00, 0xbac65e5b) // `MulWadFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n            z := add(iszero(iszero(mod(z, WAD))), div(z, WAD))\n        }\n    }",
            "start": "109",
            "end": "122",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) mulWadUpuint256 x, uint256 y",
            "full_signature": "function mulWadUp(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.mulWadUpuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Multiplies two unsigned integers (`x` and `y`) and rounds up the result to the nearest WAD (1e18).\n * @dev This function uses inline assembly for gas efficiency and checks for overflow.\n * If an overflow occurs, it reverts with the custom error `MulWadFailed()`.\n *\n * @param x The first unsigned integer to multiply.\n * @param y The second unsigned integer to multiply.\n * @return z The result of `x * y`, rounded up to the nearest WAD.\n *\n * Steps:\n * 1. Multiply `x` and `y` using inline assembly.\n * 2. Check for overflow by verifying if `z / y == x`. If not, revert with `MulWadFailed()`.\n * 3. Round up the result by adding 1 if there is a remainder when dividing by WAD.\n * 4. Return the final result.\n */"
        },
        {
            "identifier": "divWad",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function divWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(mul(x, WAD), y)\n        }\n    }",
            "start": "133",
            "end": "143",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) divWaduint256 x, uint256 y",
            "full_signature": "function divWad(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.divWaduint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Divides two numbers with a fixed-point arithmetic adjustment using WAD (1e18).\n *\n * @dev This function performs a division operation where the result is scaled by WAD (1e18).\n * It ensures that the division is safe and reverts if the divisor is zero or if the result would overflow.\n *\n * @param x The numerator in the division operation.\n * @param y The denominator in the division operation.\n * @return z The result of the division, scaled by WAD.\n *\n * Steps:\n * 1. Check if the denominator `y` is zero or if the numerator `x` is too large, which would cause an overflow.\n * 2. If either condition is true, revert with the error `DivWadFailed()`.\n * 3. Otherwise, perform the division operation, scaling the result by WAD.\n * 4. Return the scaled result.\n */"
        },
        {
            "identifier": "sDivWad",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function sDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, WAD)\n            // Equivalent to `require(y != 0 && ((x * WAD) / WAD == x))`.\n            if iszero(mul(y, eq(sdiv(z, WAD), x))) {\n                mstore(0x00, 0x5c43740d) // `SDivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := sdiv(z, y)\n        }\n    }",
            "start": "146",
            "end": "157",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) sDivWadint256 x, int256 y",
            "full_signature": "function sDivWad(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.sDivWadint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Safely divides two signed integers scaled by `WAD` (1e18) to handle fixed-point arithmetic.\n *\n * @param x The numerator, scaled by `WAD`.\n * @param y The denominator, scaled by `WAD`.\n * @return z The result of the division, scaled by `WAD`.\n *\n * Steps:\n * 1. Multiply `x` by `WAD` to maintain fixed-point precision.\n * 2. Check for division by zero and ensure the multiplication does not overflow.\n * 3. If the checks fail, revert with the error `SDivWadFailed()`.\n * 4. Perform the division of `z` by `y` and return the result.\n *\n * @dev This function uses inline assembly for gas efficiency and precision handling.\n */"
        },
        {
            "identifier": "rawDivWad",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawDivWad(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(mul(x, WAD), y)\n        }\n    }",
            "start": "160",
            "end": "165",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawDivWaduint256 x, uint256 y",
            "full_signature": "function rawDivWad(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawDivWaduint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a division operation with a fixed-point arithmetic adjustment using WAD (1e18) as the scaling factor.\n *\n * @param x The numerator in the division operation.\n * @param y The denominator in the division operation.\n * @return z The result of the division, scaled by WAD.\n *\n * Steps:\n * 1. Multiply `x` by WAD (1e18) to adjust for fixed-point arithmetic.\n * 2. Divide the result by `y` to get the final scaled value.\n * 3. Return the result as `z`.\n *\n * @dev This function uses inline assembly for gas efficiency and memory safety.\n */"
        },
        {
            "identifier": "rawSDivWad",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawSDivWad(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(mul(x, WAD), y)\n        }\n    }",
            "start": "168",
            "end": "173",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawSDivWadint256 x, int256 y",
            "full_signature": "function rawSDivWad(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawSDivWadint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a signed division of two integers scaled by `WAD` (1e18).\n *\n * @param x The numerator, a signed integer.\n * @param y The denominator, a signed integer.\n * @return z The result of the division, scaled by `WAD`.\n *\n * Steps:\n * 1. Multiply `x` by `WAD` (1e18) to scale it.\n * 2. Perform signed division (`sdiv`) of the scaled `x` by `y`.\n * 3. Return the result `z`.\n *\n * @dev This function uses inline assembly for gas efficiency and is marked as memory-safe.\n */"
        },
        {
            "identifier": "divWadUp",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function divWadUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `require(y != 0 && x <= type(uint256).max / WAD)`.\n            if iszero(mul(y, lt(x, add(1, div(not(0), WAD))))) {\n                mstore(0x00, 0x7c5f487d) // `DivWadFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(mul(x, WAD), y))), div(mul(x, WAD), y))\n        }\n    }",
            "start": "176",
            "end": "186",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) divWadUpuint256 x, uint256 y",
            "full_signature": "function divWadUp(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.divWadUpuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs division of two numbers with a fixed-point decimal (WAD) and rounds up the result.\n *\n * @param x The numerator in the division operation.\n * @param y The denominator in the division operation.\n * @return z The result of the division, rounded up to the nearest integer.\n *\n * Steps:\n * 1. Check if `y` is not zero and `x` is within the valid range to prevent overflow.\n * 2. If the check fails, revert with the error `DivWadFailed()`.\n * 3. Calculate the result by multiplying `x` by `WAD`, dividing by `y`, and adding 1 if there is a remainder.\n * 4. Return the rounded-up result.\n *\n * @dev This function uses inline assembly for gas efficiency and precise control over arithmetic operations.\n */"
        },
        {
            "identifier": "expWad",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int256 r)",
            "body": "function expWad(int256 x) internal pure returns (int256 r) {\n        unchecked {\n            // When the result is less than 0.5 we return zero.\n            // This happens when `x <= (log(1e-18) * 1e18) ~ -4.15e19`.\n            if (x <= -41446531673892822313) return r;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // When the result is greater than `(2**255 - 1) / 1e18` we can not represent it as\n                // an int. This happens when `x >= floor(log((2**255 - 1) / 1e18) * 1e18) \u2248 135`.\n                if iszero(slt(x, 135305999368893231589)) {\n                    mstore(0x00, 0xa37bfec9) // `ExpOverflow()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            // `x` is now in the range `(-42, 136) * 1e18`. Convert to `(-42, 136) * 2**96`\n            // for more intermediate precision and a binary basis. This base conversion\n            // is a multiplication by 1e18 / 2**96 = 5**18 / 2**78.\n            x = (x << 78) / 5 ** 18;\n\n            // Reduce range of x to (-\u00bd ln 2, \u00bd ln 2) * 2**96 by factoring out powers\n            // of two such that exp(x) = exp(x') * 2**k, where k is an integer.\n            // Solving this gives k = round(x / log(2)) and x' = x - k * log(2).\n            int256 k = ((x << 96) / 54916777467707473351141471128 + 2 ** 95) >> 96;\n            x = x - k * 54916777467707473351141471128;\n\n            // `k` is in the range `[-61, 195]`.\n\n            // Evaluate using a (6, 7)-term rational approximation.\n            // `p` is made monic, we'll multiply by a scale factor later.\n            int256 y = x + 1346386616545796478920950773328;\n            y = ((y * x) >> 96) + 57155421227552351082224309758442;\n            int256 p = y + x - 94201549194550492254356042504812;\n            p = ((p * y) >> 96) + 28719021644029726153956944680412240;\n            p = p * x + (4385272521454847904659076985693276 << 96);\n\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n            int256 q = x - 2855989394907223263936484059900;\n            q = ((q * x) >> 96) + 50020603652535783019961831881945;\n            q = ((q * x) >> 96) - 533845033583426703283633433725380;\n            q = ((q * x) >> 96) + 3604857256930695427073651918091429;\n            q = ((q * x) >> 96) - 14423608567350463180887372962807573;\n            q = ((q * x) >> 96) + 26449188498355588339934803723976023;\n\n            /// @solidity memory-safe-assembly\n            assembly {\n                // Div in assembly because solidity adds a zero check despite the unchecked.\n                // The q polynomial won't have zeros in the domain as all its roots are complex.\n                // No scaling is necessary because p is already `2**96` too large.\n                r := sdiv(p, q)\n            }\n\n            // r should be in the range `(0.09, 0.25) * 2**96`.\n\n            // We now need to multiply r by:\n            // - The scale factor `s \u2248 6.031367120`.\n            // - The `2**k` factor from the range reduction.\n            // - The `1e18 / 2**96` factor for base conversion.\n            // We do this all at once, with an intermediate result in `2**213`\n            // basis, so the final right shift is always by a positive amount.\n            r = int256(\n                (uint256(r) * 3822833074963236453042738258902158003155416615667) >> uint256(195 - k)\n            );\n        }\n    }",
            "start": "207",
            "end": "272",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 r) expWadint256 x",
            "full_signature": "function expWad(int256 x) internal  pure returns (int256 r)",
            "class_method_signature": "FixedPointMathLib.expWadint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the exponential function of a signed fixed-point number `x` with 18 decimals precision.\n *\n * @dev This function calculates `exp(x)` where `x` is a signed fixed-point number with 18 decimals.\n * The function uses a combination of range reduction, polynomial approximation, and assembly optimizations\n * to ensure efficient and accurate computation.\n *\n * Steps:\n * 1. Handle edge cases:\n *    - If `x` is less than or equal to `-41446531673892822313`, return 0 (since `exp(x)` is negligible).\n *    - If `x` is greater than or equal to `135305999368893231589`, revert with `ExpOverflow()` (since `exp(x)` would overflow).\n *\n * 2. Convert `x` from the range `(-42, 136) * 1e18` to `(-42, 136) * 2**96` for higher precision.\n *\n * 3. Reduce the range of `x` to `(-\u00bd ln 2, \u00bd ln 2) * 2**96` by factoring out powers of two.\n *    - Compute `k = round(x / log(2))` and adjust `x` to `x' = x - k * log(2)`.\n *\n * 4. Evaluate the exponential function using a (6, 7)-term rational approximation:\n *    - Compute `y = x + 1346386616545796478920950773328`.\n *    - Compute `p` and `q` polynomials using a series of multiplications and shifts.\n *    - Divide `p` by `q` to get the intermediate result `r`.\n *\n * 5. Adjust the result `r` by:\n *    - The scale factor `s \u2248 6.031367120`.\n *    - The `2**k` factor from the range reduction.\n *    - The `1e18 / 2**96` factor for base conversion.\n *\n * 6. Return the final result as a signed fixed-point number with 18 decimals precision.\n *\n * @param x The signed fixed-point number with 18 decimals precision.\n * @return r The result of `exp(x)` as a signed fixed-point number with 18 decimals precision.\n */"
        },
        {
            "identifier": "lnWad",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int256 r)",
            "body": "function lnWad(int256 x) internal pure returns (int256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // We want to convert `x` from `10**18` fixed point to `2**96` fixed point.\n            // We do this by multiplying by `2**96 / 10**18`. But since\n            // `ln(x * C) = ln(x) + ln(C)`, we can simply do nothing here\n            // and add `ln(2**96 / 10**18)` at the end.\n\n            // Compute `k = log2(x) - 96`, `r = 159 - k = 255 - log2(x) = 255 ^ log2(x)`.\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // We place the check here for more optimal stack operations.\n            if iszero(sgt(x, 0)) {\n                mstore(0x00, 0x1615e638) // `LnWadUndefined()`.\n                revert(0x1c, 0x04)\n            }\n            // forgefmt: disable-next-item\n            r := xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff))\n\n            // Reduce range of x to (1, 2) * 2**96\n            // ln(2^k * x) = k * ln(2) + ln(x)\n            x := shr(159, shl(r, x))\n\n            // Evaluate using a (8, 8)-term rational approximation.\n            // `p` is made monic, we will multiply by a scale factor later.\n            // forgefmt: disable-next-item\n            let p := sub( // This heavily nested expression is to avoid stack-too-deep for via-ir.\n                sar(96, mul(add(43456485725739037958740375743393,\n                sar(96, mul(add(24828157081833163892658089445524,\n                sar(96, mul(add(3273285459638523848632254066296,\n                    x), x))), x))), x)), 11111509109440967052023855526967)\n            p := sub(sar(96, mul(p, x)), 45023709667254063763336534515857)\n            p := sub(sar(96, mul(p, x)), 14706773417378608786704636184526)\n            p := sub(mul(p, x), shl(96, 795164235651350426258249787498))\n            // We leave `p` in `2**192` basis so we don't need to scale it back up for the division.\n\n            // `q` is monic by convention.\n            let q := add(5573035233440673466300451813936, x)\n            q := add(71694874799317883764090561454958, sar(96, mul(x, q)))\n            q := add(283447036172924575727196451306956, sar(96, mul(x, q)))\n            q := add(401686690394027663651624208769553, sar(96, mul(x, q)))\n            q := add(204048457590392012362485061816622, sar(96, mul(x, q)))\n            q := add(31853899698501571402653359427138, sar(96, mul(x, q)))\n            q := add(909429971244387300277376558375, sar(96, mul(x, q)))\n\n            // `p / q` is in the range `(0, 0.125) * 2**96`.\n\n            // Finalization, we need to:\n            // - Multiply by the scale factor `s = 5.549\u2026`.\n            // - Add `ln(2**96 / 10**18)`.\n            // - Add `k * ln(2)`.\n            // - Multiply by `10**18 / 2**96 = 5**18 >> 78`.\n\n            // The q polynomial is known not to have zeros in the domain.\n            // No scaling required because p is already `2**96` too large.\n            p := sdiv(p, q)\n            // Multiply by the scaling factor: `s * 5**18 * 2**96`, base is now `5**18 * 2**192`.\n            p := mul(1677202110996718588342820967067443963516166, p)\n            // Add `ln(2) * k * 5**18 * 2**192`.\n            // forgefmt: disable-next-item\n            p := add(mul(16597577552685614221487285958193947469193820559219878177908093499208371, sub(159, r)), p)\n            // Add `ln(2**96 / 10**18) * 5**18 * 2**192`.\n            p := add(600920179829731861736702779321621459595472258049074101567377883020018308, p)\n            // Base conversion: mul `2**18 / 2**192`.\n            r := sar(174, p)\n        }\n    }",
            "start": "277",
            "end": "347",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 r) lnWadint256 x",
            "full_signature": "function lnWad(int256 x) internal  pure returns (int256 r)",
            "class_method_signature": "FixedPointMathLib.lnWadint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the natural logarithm of a fixed-point number `x` (in 1e18 precision) using a (8, 8)-term rational approximation.\n * @dev The function uses assembly for low-level operations to optimize gas usage and precision.\n * \n * Steps:\n * 1. Convert `x` from `10**18` fixed-point to `2**96` fixed-point by adjusting the logarithm calculation.\n * 2. Compute `k = log2(x) - 96` and `r = 159 - k` to determine the scaling factor.\n * 3. Check if `x` is greater than 0; otherwise, revert with `LnWadUndefined()` error.\n * 4. Reduce the range of `x` to (1, 2) * 2**96 for better approximation.\n * 5. Evaluate the natural logarithm using a (8, 8)-term rational approximation:\n *    - Compute the numerator `p` and denominator `q` polynomials.\n *    - Perform polynomial division `p / q` to get the intermediate result.\n * 6. Finalize the result by:\n *    - Multiplying by the scale factor `s = 5.549\u2026`.\n *    - Adding `ln(2**96 / 10**18)`.\n *    - Adding `k * ln(2)`.\n *    - Adjusting the base to `10**18 / 2**96`.\n * 7. Return the final result as a fixed-point number in 1e18 precision.\n *\n * @param x The input fixed-point number in 1e18 precision.\n * @return r The natural logarithm of `x` as a fixed-point number in 1e18 precision.\n */\nfunction lnWad(int256 x) internal pure returns (int256 r) {\n    /// @solidity memory-safe-assembly\n    assembly {\n        // Assembly code for low-level operations to compute the natural logarithm.\n        // Detailed steps are implemented in the assembly block for optimization.\n */"
        },
        {
            "identifier": "lambertW0Wad",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (int256 w)",
            "body": "function lambertW0Wad(int256 x) internal pure returns (int256 w) {\n        // forgefmt: disable-next-item\n        unchecked {\n            if ((w = x) <= -367879441171442322) revert OutOfDomain(); // `x` less than `-1/e`.\n            (int256 wad, int256 p) = (int256(WAD), x);\n            uint256 c; // Whether we need to avoid catastrophic cancellation.\n            uint256 i = 4; // Number of iterations.\n            if (w <= 0x1ffffffffffff) {\n                if (-0x4000000000000 <= w) {\n                    i = 1; // Inputs near zero only take one step to converge.\n                } else if (w <= -0x3ffffffffffffff) {\n                    i = 32; // Inputs near `-1/e` take very long to converge.\n                }\n            } else if (uint256(w >> 63) == uint256(0)) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // Inline log2 for more performance, since the range is small.\n                    let v := shr(49, w)\n                    let l := shl(3, lt(0xff, v))\n                    l := add(or(l, byte(and(0x1f, shr(shr(l, v), 0x8421084210842108cc6318c6db6d54be)),\n                        0x0706060506020504060203020504030106050205030304010505030400000000)), 49)\n                    w := sdiv(shl(l, 7), byte(sub(l, 31), 0x0303030303030303040506080c13))\n                    c := gt(l, 60)\n                    i := add(2, add(gt(l, 53), c))\n                }\n            } else {\n                int256 ll = lnWad(w = lnWad(w));\n                /// @solidity memory-safe-assembly\n                assembly {\n                    // `w = ln(x) - ln(ln(x)) + b * ln(ln(x)) / ln(x)`.\n                    w := add(sdiv(mul(ll, 1023715080943847266), w), sub(w, ll))\n                    i := add(3, iszero(shr(68, x)))\n                    c := iszero(shr(143, x))\n                }\n                if (c == uint256(0)) {\n                    do { // If `x` is big, use Newton's so that intermediate values won't overflow.\n                        int256 e = expWad(w);\n                        /// @solidity memory-safe-assembly\n                        assembly {\n                            let t := mul(w, div(e, wad))\n                            w := sub(w, sdiv(sub(t, x), div(add(e, t), wad)))\n                        }\n                        if (p <= w) break;\n                        p = w;\n                    } while (--i != uint256(0));\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        w := sub(w, sgt(w, 2))\n                    }\n                    return w;\n                }\n            }\n            do { // Otherwise, use Halley's for faster convergence.\n                int256 e = expWad(w);\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let t := add(w, wad)\n                    let s := sub(mul(w, e), mul(x, wad))\n                    w := sub(w, sdiv(mul(s, wad), sub(mul(e, t), sdiv(mul(add(t, wad), s), add(t, t)))))\n                }\n                if (p <= w) break;\n                p = w;\n            } while (--i != c);\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sub(w, sgt(w, 2))\n            }\n            // For certain ranges of `x`, we'll use the quadratic-rate recursive formula of\n            // R. Iacono and J.P. Boyd for the last iteration, to avoid catastrophic cancellation.\n            if (c == uint256(0)) return w;\n            int256 t = w | 1;\n            /// @solidity memory-safe-assembly\n            assembly {\n                x := sdiv(mul(x, wad), t)\n            }\n            x = (t * (wad + lnWad(x)));\n            /// @solidity memory-safe-assembly\n            assembly {\n                w := sdiv(x, add(wad, t))\n            }\n        }\n    }",
            "start": "353",
            "end": "434",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 w) lambertW0Wadint256 x",
            "full_signature": "function lambertW0Wad(int256 x) internal  pure returns (int256 w)",
            "class_method_signature": "FixedPointMathLib.lambertW0Wadint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the principal branch of the Lambert W function (W0) for a given input `x` in wad format.\n *\n * @dev This function is designed to handle a wide range of input values, including edge cases near zero and `-1/e`.\n * It uses a combination of Newton's method, Halley's method, and a recursive formula to ensure accurate and efficient convergence.\n *\n * @param x The input value in wad format (18 decimal places).\n * @return w The computed value of the Lambert W function for the given input.\n *\n * Steps:\n * 1. Check if `x` is less than `-1/e` (approximately -0.367879441171442322). If so, revert with `OutOfDomain`.\n * 2. Initialize variables `wad` (representing 1e18) and `p` (to track previous values of `w`).\n * 3. Determine the number of iterations (`i`) based on the magnitude of `x`:\n *    - For inputs near zero, only one iteration is needed.\n *    - For inputs near `-1/e`, up to 32 iterations may be required.\n *    - For other inputs, the number of iterations is determined by the logarithm of `x`.\n * 4. Use Newton's method for large inputs to avoid intermediate overflow.\n * 5. Use Halley's method for faster convergence in other cases.\n * 6. For certain ranges of `x`, apply a quadratic-rate recursive formula to avoid catastrophic cancellation.\n * 7. Return the computed value of `w`.\n *\n * Note: The function uses inline assembly for performance optimization, particularly for logarithmic calculations.\n */"
        },
        {
            "identifier": "fullMulEq",
            "parameters": "uint256 a, uint256 b, uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y)\n        internal\n        pure\n        returns (bool result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := and(eq(mul(a, b), mul(x, y)), eq(mulmod(x, y, not(0)), mulmod(a, b, not(0))))\n        }\n    }",
            "start": "441",
            "end": "450",
            "class": "FixedPointMathLib",
            "signature": "returns (bool result) fullMulEquint256 a, uint256 b, uint256 x, uint256 y",
            "full_signature": "function fullMulEq(uint256 a, uint256 b, uint256 x, uint256 y) internal  pure returns (bool result)",
            "class_method_signature": "FixedPointMathLib.fullMulEquint256 a, uint256 b, uint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a full multiplication equality check between two pairs of numbers.\n *\n * @param a The first multiplicand in the first multiplication.\n * @param b The first multiplier in the first multiplication.\n * @param x The second multiplicand in the second multiplication.\n * @param y The second multiplier in the second multiplication.\n * @return result A boolean indicating whether the products of the two multiplications are equal,\n *                and whether their modular products (with respect to `not(0)`) are also equal.\n *\n * Steps:\n * 1. Multiply `a` and `b` to get the first product.\n * 2. Multiply `x` and `y` to get the second product.\n * 3. Check if the two products are equal.\n * 4. Compute the modular product of `x` and `y` with respect to `not(0)` (which is equivalent to `2^256 - 1`).\n * 5. Compute the modular product of `a` and `b` with respect to `not(0)`.\n * 6. Check if the two modular products are equal.\n * 7. Return `true` if both the products and modular products are equal, otherwise return `false`.\n *\n * @dev This function uses inline assembly for low-level operations to ensure memory safety.\n */"
        },
        {
            "identifier": "fullMulDiv",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function fullMulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // 512-bit multiply `[p1 p0] = x * y`.\n            // Compute the product mod `2**256` and mod `2**256 - 1`\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that `product = p1 * 2**256 + p0`.\n\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`.\n            for {} 1 {} {\n                // If overflows.\n                if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n\n                    /*------------------- 512 by 256 division --------------------*/\n\n                    // Make division exact by subtracting the remainder from `[p1 p0]`.\n                    let r := mulmod(x, y, d) // Compute remainder using mulmod.\n                    let t := and(d, sub(0, d)) // The least significant bit of `d`. `t >= 1`.\n                    // Make sure `z` is less than `2**256`. Also prevents `d == 0`.\n                    // Placing the check here seems to give more optimal stack operations.\n                    if iszero(gt(d, p1)) {\n                        mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    d := div(d, t) // Divide `d` by `t`, which is a power of two.\n                    // Invert `d mod 2**256`\n                    // Now that `d` is an odd number, it has an inverse\n                    // modulo `2**256` such that `d * inv = 1 mod 2**256`.\n                    // Compute the inverse by starting with a seed that is correct\n                    // correct for four bits. That is, `d * inv = 1 mod 2**4`.\n                    let inv := xor(2, mul(3, d))\n                    // Now use Newton-Raphson iteration to improve the precision.\n                    // Thanks to Hensel's lifting lemma, this also works in modular\n                    // arithmetic, doubling the correct bits in each step.\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**8\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**16\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**32\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**64\n                    inv := mul(inv, sub(2, mul(d, inv))) // inverse mod 2**128\n                    z :=\n                        mul(\n                            // Divide [p1 p0] by the factors of two.\n                            // Shift in bits from `p1` into `p0`. For this we need\n                            // to flip `t` such that it is `2**256 / t`.\n                            or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                            mul(sub(2, mul(d, inv)), inv) // inverse mod 2**256\n                        )\n                    break\n                }\n                z := div(z, d)\n                break\n            }\n        }\n    }",
            "start": "455",
            "end": "512",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) fullMulDivuint256 x, uint256 y, uint256 d",
            "full_signature": "function fullMulDiv(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.fullMulDivuint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a full multiplication and division operation on three 256-bit unsigned integers.\n * This function calculates `(x * y) / d` with precision and handles overflow scenarios.\n *\n * @param x The first multiplicand.\n * @param y The second multiplicand.\n * @param d The divisor.\n * @return z The result of the operation `(x * y) / d`.\n *\n * Steps:\n * 1. Compute the product of `x` and `y` using 512-bit precision, storing the result in two 256-bit variables `p1` (upper bits) and `p0` (lower bits).\n * 2. Check for overflow conditions and handle them using the Chinese Remainder Theorem.\n * 3. If overflow occurs, compute the remainder using `mulmod` and adjust the result accordingly.\n * 4. Ensure `d` is non-zero and greater than `p1` to prevent division by zero or invalid results.\n * 5. Use Newton-Raphson iteration to compute the modular inverse of `d` modulo `2^256`.\n * 6. Perform the final division and multiplication to obtain the result `z`.\n * 7. If no overflow occurs, directly compute `z = (x * y) / d`.\n *\n * Reverts:\n * - If `d` is zero or if `d` is greater than `p1`, the function reverts with the error `FullMulDivFailed()`.\n */"
        },
        {
            "identifier": "fullMulDivUnchecked",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            let mm := mulmod(x, y, not(0))\n            let p1 := sub(mm, add(z, lt(mm, z)))\n            let t := and(d, sub(0, d))\n            let r := mulmod(x, y, d)\n            d := div(d, t)\n            let inv := xor(2, mul(3, d))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            inv := mul(inv, sub(2, mul(d, inv)))\n            z :=\n                mul(\n                    or(mul(sub(p1, gt(r, z)), add(div(sub(0, t), t), 1)), div(sub(z, r), t)),\n                    mul(sub(2, mul(d, inv)), inv)\n                )\n        }\n    }",
            "start": "517",
            "end": "542",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) fullMulDivUncheckeduint256 x, uint256 y, uint256 d",
            "full_signature": "function fullMulDivUnchecked(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.fullMulDivUncheckeduint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a full multiplication and division operation without overflow checks.\n * This function calculates `(x * y) / d` using assembly for optimized performance.\n *\n * @param x The multiplicand.\n * @param y The multiplier.\n * @param d The divisor.\n * @return z The result of the operation `(x * y) / d`.\n *\n * Steps:\n * 1. Multiply `x` and `y` to get the product `z`.\n * 2. Calculate the modulo of `x * y` with `not(0)` to get `mm`.\n * 3. Compute `p1` as `mm - (z + (mm < z))`.\n * 4. Calculate `t` as `d & (0 - d)`.\n * 5. Compute `r` as `x * y % d`.\n * 6. Divide `d` by `t` to get the new `d`.\n * 7. Calculate the inverse `inv` using a series of multiplications and subtractions.\n * 8. Compute the final result `z` using a combination of the intermediate values.\n *\n * Note: This function uses low-level assembly for efficiency and assumes that the inputs are valid.\n */"
        },
        {
            "identifier": "fullMulDivUp",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        z = fullMulDiv(x, y, d);\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mulmod(x, y, d) {\n                z := add(z, 1)\n                if iszero(z) {\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "start": "548",
            "end": "560",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) fullMulDivUpuint256 x, uint256 y, uint256 d",
            "full_signature": "function fullMulDivUp(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.fullMulDivUpuint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a full multiplication and division operation with rounding up.\n *\n * @param x The first operand for multiplication.\n * @param y The second operand for multiplication.\n * @param d The divisor for the division operation.\n * @return z The result of the operation, rounded up if there is a remainder.\n *\n * Steps:\n * 1. Calculate the result of `fullMulDiv(x, y, d)` and store it in `z`.\n * 2. Use inline assembly to check if there is a remainder when multiplying `x` and `y` and dividing by `d`.\n * 3. If there is a remainder, increment `z` by 1 to round up.\n * 4. If `z` overflows (i.e., becomes zero after incrementing), revert with the error `FullMulDivFailed()`.\n *\n * @dev This function is memory-safe and uses inline assembly for low-level operations.\n */"
        },
        {
            "identifier": "fullMulDivN",
            "parameters": "uint256 x, uint256 y, uint8 n",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function fullMulDivN(uint256 x, uint256 y, uint8 n) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Temporarily use `z` as `p0` to save gas.\n            z := mul(x, y) // Lower 256 bits of `x * y`. We'll call this `z`.\n            for {} 1 {} {\n                if iszero(or(iszero(x), eq(div(z, x), y))) {\n                    let k := and(n, 0xff) // `n`, cleaned.\n                    let mm := mulmod(x, y, not(0))\n                    let p1 := sub(mm, add(z, lt(mm, z))) // Upper 256 bits of `x * y`.\n                    //         |      p1     |      z     |\n                    // Before: | p1_0 \u00a6 p1_1 | z_0  \u00a6 z_1 |\n                    // Final:  |   0  \u00a6 p1_0 | p1_1 \u00a6 z_0 |\n                    // Check that final `z` doesn't overflow by checking that p1_0 = 0.\n                    if iszero(shr(k, p1)) {\n                        z := add(shl(sub(256, k), p1), shr(k, z))\n                        break\n                    }\n                    mstore(0x00, 0xae47f702) // `FullMulDivFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                z := shr(and(n, 0xff), z)\n                break\n            }\n        }\n    }",
            "start": "566",
            "end": "591",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) fullMulDivNuint256 x, uint256 y, uint8 n",
            "full_signature": "function fullMulDivN(uint256 x, uint256 y, uint8 n) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.fullMulDivNuint256 x, uint256 y, uint8 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a full multiplication and division operation with a specified bit shift.\n *\n * @param x The first operand for multiplication.\n * @param y The second operand for multiplication.\n * @param n The number of bits to shift the result after multiplication.\n *\n * @return z The result of the operation, which is `(x * y) >> n`.\n *\n * Steps:\n * 1. Multiply `x` and `y` to get the lower 256 bits of the product, stored in `z`.\n * 2. Check if the multiplication is valid by ensuring `z / x == y`.\n * 3. If the multiplication is valid:\n *    a. Extract the upper 256 bits of the product (`p1`).\n *    b. Shift `p1` and `z` based on the value of `n`.\n *    c. Ensure the final result does not overflow by checking that the upper bits of `p1` are zero.\n *    d. If no overflow, return the shifted result.\n * 4. If the multiplication is invalid, revert with the error `FullMulDivFailed()`.\n * 5. If no shift is needed, return the lower 256 bits of the product directly.\n *\n * @dev This function uses inline assembly for gas optimization and memory safety.\n */"
        },
        {
            "identifier": "mulDiv",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function mulDiv(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := div(z, d)\n        }\n    }",
            "start": "595",
            "end": "606",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) mulDivuint256 x, uint256 y, uint256 d",
            "full_signature": "function mulDiv(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.mulDivuint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs multiplication and division of two unsigned integers, ensuring no overflow or division by zero.\n *\n * @param x The first unsigned integer (multiplicand).\n * @param y The second unsigned integer (multiplier).\n * @param d The divisor.\n * @return z The result of the operation `(x * y) / d`.\n *\n * Steps:\n * 1. Multiply `x` and `y` to get the product.\n * 2. Check for potential overflow or division by zero:\n *    - If `x` is zero or the division of the product by `x` equals `y`, proceed.\n *    - Otherwise, revert with the error `MulDivFailed()`.\n * 3. Divide the product by `d` to get the final result.\n *\n * @dev This function uses inline assembly for gas efficiency and safety.\n */"
        },
        {
            "identifier": "mulDivUp",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function mulDivUp(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(x, y)\n            // Equivalent to `require(d != 0 && (y == 0 || x <= type(uint256).max / y))`.\n            if iszero(mul(or(iszero(x), eq(div(z, x), y)), d)) {\n                mstore(0x00, 0xad251c27) // `MulDivFailed()`.\n                revert(0x1c, 0x04)\n            }\n            z := add(iszero(iszero(mod(z, d))), div(z, d))\n        }\n    }",
            "start": "610",
            "end": "621",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) mulDivUpuint256 x, uint256 y, uint256 d",
            "full_signature": "function mulDivUp(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.mulDivUpuint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a multiplication followed by a division, rounding up the result.\n *\n * @param x The multiplicand.\n * @param y The multiplier.\n * @param d The divisor.\n * @return z The result of the operation, rounded up.\n *\n * Steps:\n * 1. Multiply `x` and `y` to get the product.\n * 2. Check for overflow or division by zero:\n *    - If `d` is zero, revert with `MulDivFailed()`.\n *    - If `x` is zero or the product divided by `x` equals `y`, proceed.\n * 3. Calculate the result by dividing the product by `d`, rounding up if there is a remainder.\n * 4. Return the result.\n *\n * @dev This function uses inline assembly for gas efficiency and safety.\n */"
        },
        {
            "identifier": "invMod",
            "parameters": "uint256 a, uint256 n",
            "modifiers": "pure",
            "return": "returns (uint256 x)",
            "body": "function invMod(uint256 a, uint256 n) internal pure returns (uint256 x) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let g := n\n            let r := mod(a, n)\n            for { let y := 1 } 1 {} {\n                let q := div(g, r)\n                let t := g\n                g := r\n                r := sub(t, mul(r, q))\n                let u := x\n                x := y\n                y := sub(u, mul(y, q))\n                if iszero(r) { break }\n            }\n            x := mul(eq(g, 1), add(x, mul(slt(x, 0), n)))\n        }\n    }",
            "start": "624",
            "end": "641",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 x) invModuint256 a, uint256 n",
            "full_signature": "function invMod(uint256 a, uint256 n) internal  pure returns (uint256 x)",
            "class_method_signature": "FixedPointMathLib.invModuint256 a, uint256 n",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the modular inverse of `a` modulo `n` using the Extended Euclidean Algorithm.\n *\n * @param a The number for which the modular inverse is to be computed.\n * @param n The modulus.\n * @return x The modular inverse of `a` modulo `n`. If no inverse exists, returns 0.\n *\n * Steps:\n * 1. Initialize `g` with `n` and `r` with `a % n`.\n * 2. Use a loop to iteratively compute the greatest common divisor (GCD) of `a` and `n`.\n * 3. During the loop, update the values of `g`, `r`, `x`, and `y` using the Extended Euclidean Algorithm.\n * 4. If `r` becomes zero, break the loop.\n * 5. If the GCD (`g`) is 1, compute the modular inverse `x` and adjust it to be positive if necessary.\n * 6. If the GCD is not 1, return 0 (indicating no modular inverse exists).\n *\n * @dev This function uses inline assembly for efficient computation.\n */"
        },
        {
            "identifier": "zeroFloorSub",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function zeroFloorSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(gt(x, y), sub(x, y))\n        }\n    }",
            "start": "657",
            "end": "662",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) zeroFloorSubuint256 x, uint256 y",
            "full_signature": "function zeroFloorSub(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.zeroFloorSubuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a subtraction operation with a floor of zero.\n * @dev This function subtracts `y` from `x` and returns the result. If `y` is greater than `x`, it returns zero.\n * @param x The minuend (the number from which another number is to be subtracted).\n * @param y The subtrahend (the number to be subtracted from the minuend).\n * @return z The result of the subtraction, or zero if `y` is greater than `x`.\n *\n * Steps:\n * 1. Check if `x` is greater than `y`.\n * 2. If true, subtract `y` from `x` and return the result.\n * 3. If false, return zero.\n *\n * @solidity This function uses assembly for gas optimization and memory safety.\n */"
        },
        {
            "identifier": "ternary",
            "parameters": "bool condition, uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function ternary(bool condition, uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }",
            "start": "665",
            "end": "670",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) ternarybool condition, uint256 x, uint256 y",
            "full_signature": "function ternary(bool condition, uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.ternarybool condition, uint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A utility function that performs a ternary operation using inline assembly.\n *\n * @param condition A boolean condition to evaluate.\n * @param x The first value to consider if the condition is true.\n * @param y The second value to consider if the condition is false.\n * @return z The result of the ternary operation, which is either `x` or `y` based on the condition.\n *\n * Steps:\n * 1. Use inline assembly to perform the ternary operation.\n * 2. If the condition is true, `z` is set to `x`.\n * 3. If the condition is false, `z` is set to `y`.\n * 4. The result is returned as `z`.\n *\n * Note: This function uses low-level assembly for optimization and memory safety.\n */"
        },
        {
            "identifier": "ternary",
            "parameters": "bool condition, bytes32 x, bytes32 y",
            "modifiers": "pure",
            "return": "returns (bytes32 z)",
            "body": "function ternary(bool condition, bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }",
            "start": "673",
            "end": "678",
            "class": "FixedPointMathLib",
            "signature": "returns (bytes32 z) ternarybool condition, bytes32 x, bytes32 y",
            "full_signature": "function ternary(bool condition, bytes32 x, bytes32 y) internal  pure returns (bytes32 z)",
            "class_method_signature": "FixedPointMathLib.ternarybool condition, bytes32 x, bytes32 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A utility function that implements a ternary operation using inline assembly.\n * \n * @param condition A boolean condition that determines which value to return.\n * @param x The first value to consider.\n * @param y The second value to consider.\n * @return z The result of the ternary operation: returns `x` if `condition` is true, otherwise returns `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform a bitwise XOR operation between `x` and the result of `(x XOR y) * (1 - condition)`.\n * 2. If `condition` is true, `iszero(condition)` evaluates to 0, making the result `x`.\n * 3. If `condition` is false, `iszero(condition)` evaluates to 1, making the result `y`.\n *\n * @dev This function is marked as `internal pure` and uses `memory-safe-assembly` to ensure safety and efficiency.\n */"
        },
        {
            "identifier": "ternary",
            "parameters": "bool condition, address x, address y",
            "modifiers": "pure",
            "return": "returns (address z)",
            "body": "function ternary(bool condition, address x, address y) internal pure returns (address z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), iszero(condition)))\n        }\n    }",
            "start": "681",
            "end": "686",
            "class": "FixedPointMathLib",
            "signature": "returns (address z) ternarybool condition, address x, address y",
            "full_signature": "function ternary(bool condition, address x, address y) internal  pure returns (address z)",
            "class_method_signature": "FixedPointMathLib.ternarybool condition, address x, address y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A utility function that performs a ternary operation on addresses using inline assembly.\n *\n * @param condition A boolean condition to evaluate.\n * @param x The first address to consider if the condition is true.\n * @param y The second address to consider if the condition is false.\n * @return z The result of the ternary operation, which will be `x` if `condition` is true, otherwise `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the ternary operation:\n *    - If `condition` is true, `z` is set to `x`.\n *    - If `condition` is false, `z` is set to `y`.\n * 2. The operation is memory-safe and uses bitwise XOR and multiplication to achieve the result.\n */"
        },
        {
            "identifier": "rpow",
            "parameters": "uint256 x, uint256 y, uint256 b",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rpow(uint256 x, uint256 y, uint256 b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mul(b, iszero(y)) // `0 ** 0 = 1`. Otherwise, `0 ** n = 0`.\n            if x {\n                z := xor(b, mul(xor(b, x), and(y, 1))) // `z = isEven(y) ? scale : x`\n                let half := shr(1, b) // Divide `b` by 2.\n                // Divide `y` by 2 every iteration.\n                for { y := shr(1, y) } y { y := shr(1, y) } {\n                    let xx := mul(x, x) // Store x squared.\n                    let xxRound := add(xx, half) // Round to the nearest number.\n                    // Revert if `xx + half` overflowed, or if `x ** 2` overflows.\n                    if or(lt(xxRound, xx), shr(128, x)) {\n                        mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                        revert(0x1c, 0x04)\n                    }\n                    x := div(xxRound, b) // Set `x` to scaled `xxRound`.\n                    // If `y` is odd:\n                    if and(y, 1) {\n                        let zx := mul(z, x) // Compute `z * x`.\n                        let zxRound := add(zx, half) // Round to the nearest number.\n                        // If `z * x` overflowed or `zx + half` overflowed:\n                        if or(xor(div(zx, x), z), lt(zxRound, zx)) {\n                            // Revert if `x` is non-zero.\n                            if x {\n                                mstore(0x00, 0x49f7642b) // `RPowOverflow()`.\n                                revert(0x1c, 0x04)\n                            }\n                        }\n                        z := div(zxRound, b) // Return properly scaled `zxRound`.\n                    }\n                }\n            }\n        }\n    }",
            "start": "690",
            "end": "724",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rpowuint256 x, uint256 y, uint256 b",
            "full_signature": "function rpow(uint256 x, uint256 y, uint256 b) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rpowuint256 x, uint256 y, uint256 b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the result of `x` raised to the power of `y`, scaled by `b`.\n * @dev This function uses low-level assembly for optimized performance and handles edge cases like overflow.\n * \n * @param x The base value.\n * @param y The exponent value.\n * @param b The scaling factor.\n * @return z The result of `x^y` scaled by `b`.\n *\n * Steps:\n * 1. Initialize `z` to `b` if `y` is zero (handling the case `0^0 = 1`). Otherwise, `z` is set to 0.\n * 2. If `x` is non-zero:\n *    - Adjust `z` based on whether `y` is even or odd.\n *    - Compute `x^2` and round it to the nearest value using `b`.\n *    - Revert if overflow occurs during squaring or rounding.\n *    - Update `x` to the scaled squared value.\n *    - If `y` is odd, compute `z * x`, round it, and update `z` to the scaled result.\n *    - Revert if overflow occurs during multiplication or rounding.\n * 3. Return the final scaled result `z`.\n *\n * Edge Cases:\n * - If `x` is zero and `y` is zero, the result is `b` (interpreted as 1 scaled by `b`).\n * - If `x` is zero and `y` is non-zero, the result is 0.\n * - Reverts if overflow occurs during any computation.\n */"
        },
        {
            "identifier": "sqrt",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function sqrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // `floor(sqrt(2**15)) = 181`. `sqrt(2**15) - 181 = 2.84`.\n            z := 181 // The \"correct\" value is 1, but this saves a multiplication later.\n\n            // This segment is to get a reasonable initial estimate for the Babylonian method. With a bad\n            // start, the correct # of bits increases ~linearly each iteration instead of ~quadratically.\n\n            // Let `y = x / 2**r`. We check `y >= 2**(k + 8)`\n            // but shift right by `k` bits to ensure that if `x >= 256`, then `y >= 256`.\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffffff, shr(r, x))))\n            z := shl(shr(1, r), z)\n\n            // Goal was to get `z*z*y` within a small factor of `x`. More iterations could\n            // get y in a tighter range. Currently, we will have y in `[256, 256*(2**16))`.\n            // We ensured `y >= 256` so that the relative difference between `y` and `y+1` is small.\n            // That's not possible if `x < 256` but we can just verify those cases exhaustively.\n\n            // Now, `z*z*y <= x < z*z*(y+1)`, and `y <= 2**(16+8)`, and either `y >= 256`, or `x < 256`.\n            // Correctness can be checked exhaustively for `x < 256`, so we assume `y >= 256`.\n            // Then `z*sqrt(y)` is within `sqrt(257)/sqrt(256)` of `sqrt(x)`, or about 20bps.\n\n            // For `s` in the range `[1/256, 256]`, the estimate `f(s) = (181/1024) * (s+1)`\n            // is in the range `(1/2.84 * sqrt(s), 2.84 * sqrt(s))`,\n            // with largest error when `s = 1` and when `s = 256` or `1/256`.\n\n            // Since `y` is in `[256, 256*(2**16))`, let `a = y/65536`, so that `a` is in `[1/256, 256)`.\n            // Then we can estimate `sqrt(y)` using\n            // `sqrt(65536) * 181/1024 * (a + 1) = 181/4 * (y + 65536)/65536 = 181 * (y + 65536)/2**18`.\n\n            // There is no overflow risk here since `y < 2**136` after the first branch above.\n            z := shr(18, mul(z, add(shr(r, x), 65536))) // A `mul()` is saved from starting `z` at 181.\n\n            // Given the worst case multiplicative error of 2.84 above, 7 iterations should be enough.\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n            z := shr(1, add(z, div(x, z)))\n\n            // If `x+1` is a perfect square, the Babylonian method cycles between\n            // `floor(sqrt(x))` and `ceil(sqrt(x))`. This statement ensures we return floor.\n            // See: https://en.wikipedia.org/wiki/Integer_square_root#Using_only_integer_division\n            z := sub(z, lt(div(x, z), z))\n        }\n    }",
            "start": "727",
            "end": "778",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) sqrtuint256 x",
            "full_signature": "function sqrt(uint256 x) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.sqrtuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the integer square root of a given number using the Babylonian method.\n *\n * @dev This function uses assembly for optimized performance and memory safety.\n * The Babylonian method is an iterative algorithm for approximating the square root.\n *\n * Steps:\n * 1. Initialize `z` with an initial estimate of 181, which is a reasonable starting point for the algorithm.\n * 2. Calculate an initial shift value `r` based on the magnitude of `x` to improve the initial estimate.\n * 3. Adjust `z` based on the calculated shift value `r`.\n * 4. Perform 7 iterations of the Babylonian method to refine the estimate of the square root:\n *    - Each iteration updates `z` using the formula `z = (z + x / z) / 2`.\n * 5. Ensure the final result is the floor of the square root by adjusting `z` if necessary.\n *\n * @param x The number to compute the square root of.\n * @return z The integer square root of `x`.\n */"
        },
        {
            "identifier": "cbrt",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function cbrt(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // Makeshift lookup table to nudge the approximate log2 result.\n            z := div(shl(div(r, 3), shl(lt(0xf, shr(r, x)), 0xf)), xor(7, mod(r, 3)))\n            // Newton-Raphson's.\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            z := div(add(add(div(x, mul(z, z)), z), z), 3)\n            // Round down.\n            z := sub(z, lt(div(x, mul(z, z)), z))\n        }\n    }",
            "start": "785",
            "end": "806",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) cbrtuint256 x",
            "full_signature": "function cbrt(uint256 x) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.cbrtuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the cube root of a given unsigned integer `x` using a combination of bitwise operations and the Newton-Raphson method.\n *\n * @param x The unsigned integer for which the cube root is to be computed.\n * @return z The cube root of `x`, rounded down to the nearest integer.\n *\n * Steps:\n * 1. Use bitwise operations to approximate the log2 of `x` and determine an initial guess for the cube root.\n * 2. Refine the initial guess using the Newton-Raphson method, iterating multiple times to improve accuracy.\n * 3. Round down the final result to ensure it is an integer.\n *\n * The function uses inline assembly for efficiency and memory safety.\n */"
        },
        {
            "identifier": "sqrtWad",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function sqrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 18) return sqrt(x * 10 ** 18);\n            z = (1 + sqrt(x)) * 10 ** 9;\n            z = (fullMulDivUnchecked(x, 10 ** 18, z) + z) >> 1;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sub(z, gt(999999999999999999, sub(mulmod(z, z, x), 1))) // Round down.\n        }\n    }",
            "start": "809",
            "end": "819",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) sqrtWaduint256 x",
            "full_signature": "function sqrtWad(uint256 x) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.sqrtWaduint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the square root of a given value scaled by 10^18 (WAD) with precision.\n *\n * @param x The input value to compute the square root for.\n * @return z The square root of the input value, scaled by 10^9 for precision.\n *\n * Steps:\n * 1. Check if the input value `x` is small enough to avoid overflow when scaled by 10^18.\n *    - If true, compute the square root of `x * 10^18` directly.\n * 2. For larger values, compute an initial approximation of the square root using `sqrt(x)`.\n *    - Scale the result by 10^9 for precision.\n * 3. Refine the approximation using the fullMulDivUnchecked function to improve accuracy.\n * 4. Use assembly to round down the result to ensure it is within the correct bounds.\n *\n * @dev This function is optimized for gas efficiency and precision, using unchecked blocks and assembly.\n */"
        },
        {
            "identifier": "cbrtWad",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function cbrtWad(uint256 x) internal pure returns (uint256 z) {\n        unchecked {\n            if (x <= type(uint256).max / 10 ** 36) return cbrt(x * 10 ** 36);\n            z = (1 + cbrt(x)) * 10 ** 12;\n            z = (fullMulDivUnchecked(x, 10 ** 36, z * z) + z + z) / 3;\n        }\n        /// @solidity memory-safe-assembly\n        assembly {\n            let p := x\n            for {} 1 {} {\n                if iszero(shr(229, p)) {\n                    if iszero(shr(199, p)) {\n                        p := mul(p, 100000000000000000) // 10 ** 17.\n                        break\n                    }\n                    p := mul(p, 100000000) // 10 ** 8.\n                    break\n                }\n                if iszero(shr(249, p)) { p := mul(p, 100) }\n                break\n            }\n            let t := mulmod(mul(z, z), z, p)\n            z := sub(z, gt(lt(t, shr(1, p)), iszero(t))) // Round down.\n        }\n    }",
            "start": "824",
            "end": "848",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) cbrtWaduint256 x",
            "full_signature": "function cbrtWad(uint256 x) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.cbrtWaduint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the cube root of a given value `x` scaled by 10^18 (Wad precision).\n * \n * @dev This function uses an internal pure function to calculate the cube root of `x` with high precision.\n * It handles edge cases where `x` is too large by scaling it down and then performing the calculation.\n * The function uses unchecked arithmetic for gas optimization and assembly for low-level operations.\n * \n * @param x The input value for which the cube root is to be calculated, scaled by 10^18.\n * @return z The cube root of `x`, scaled by 10^18.\n * \n * Steps:\n * 1. Check if `x` is within a safe range for direct calculation. If so, compute the cube root directly.\n * 2. Otherwise, compute an initial approximation of the cube root and refine it using the Newton-Raphson method.\n * 3. Use assembly to handle large values of `x` by scaling it down to avoid overflow.\n * 4. Perform a final adjustment to ensure the result is rounded down correctly.\n */"
        },
        {
            "identifier": "factorial",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function factorial(uint256 x) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := 1\n            if iszero(lt(x, 58)) {\n                mstore(0x00, 0xaba0f2a2) // `FactorialOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            for {} x { x := sub(x, 1) } { z := mul(z, x) }\n        }\n    }",
            "start": "851",
            "end": "861",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) factorialuint256 x",
            "full_signature": "function factorial(uint256 x) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.factorialuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the factorial of a given number `x` using inline assembly for gas efficiency.\n *\n * @param x The number to compute the factorial for. Must be less than 58 to prevent overflow.\n * @return z The factorial of `x`.\n *\n * Steps:\n * 1. Initialize `z` to 1.\n * 2. Check if `x` is greater than or equal to 58. If true, revert with an overflow error.\n * 3. Use a loop to multiply `z` by `x` and decrement `x` until `x` is 0.\n * 4. Return the computed factorial `z`.\n *\n * @dev This function uses inline assembly for gas optimization and checks for overflow to ensure safe\n */"
        },
        {
            "identifier": "log2",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log2(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }",
            "start": "866",
            "end": "878",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 r) log2uint256 x",
            "full_signature": "function log2(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "FixedPointMathLib.log2uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the base-2 logarithm of a given unsigned integer `x` using bitwise operations.\n *\n * @param x The unsigned integer for which the base-2 logarithm is to be computed.\n * @return r The computed base-2 logarithm of `x`.\n *\n * Steps:\n * 1. Use bitwise operations to determine the highest set bit in `x`.\n * 2. Shift and compare `x` to progressively smaller bit masks to narrow down the result.\n * 3. Combine the results using bitwise OR operations to compute the final logarithm.\n * 4. The result is returned as an unsigned integer representing the base-2 logarithm of `x`.\n *\n * Note: This function uses inline assembly for optimized performance.\n */"
        },
        {
            "identifier": "log2Up",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log2Up(uint256 x) internal pure returns (uint256 r) {\n        r = log2(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(r, 1), x))\n        }\n    }",
            "start": "882",
            "end": "888",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 r) log2Upuint256 x",
            "full_signature": "function log2Up(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "FixedPointMathLib.log2Upuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the smallest power of 2 greater than or equal to `x` using log2.\n *\n * @param x The input value for which to calculate the log2 ceiling.\n * @return r The smallest power of 2 greater than or equal to `x`.\n *\n * Steps:\n * 1. Calculate the base-2 logarithm of `x` using the `log2` function.\n * 2. Use inline assembly to check if shifting 1 left by `r` is less than `x`.\n * 3. If true, increment `r` by 1 to ensure the result is the ceiling of log2(x).\n * 4. Return the result.\n */"
        },
        {
            "identifier": "log10",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log10(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(lt(x, 100000000000000000000000000000000000000)) {\n                x := div(x, 100000000000000000000000000000000000000)\n                r := 38\n            }\n            if iszero(lt(x, 100000000000000000000)) {\n                x := div(x, 100000000000000000000)\n                r := add(r, 20)\n            }\n            if iszero(lt(x, 10000000000)) {\n                x := div(x, 10000000000)\n                r := add(r, 10)\n            }\n            if iszero(lt(x, 100000)) {\n                x := div(x, 100000)\n                r := add(r, 5)\n            }\n            r := add(r, add(gt(x, 9), add(gt(x, 99), add(gt(x, 999), gt(x, 9999)))))\n        }\n    }",
            "start": "892",
            "end": "913",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 r) log10uint256 x",
            "full_signature": "function log10(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "FixedPointMathLib.log10uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the base-10 logarithm of a given unsigned integer `x` using assembly for optimization.\n * \n * @param x The unsigned integer for which the base-10 logarithm is to be computed.\n * @return r The base-10 logarithm of `x`, rounded down to the nearest integer.\n *\n * Steps:\n * 1. Check if `x` is greater than or equal to 10^38. If true, divide `x` by 10^38 and set `r` to 38.\n * 2. Check if `x` is greater than or equal to 10^20. If true, divide `x` by 10^20 and add 20 to `r`.\n * 3. Check if `x` is greater than or equal to 10^10. If true, divide `x` by 10^10 and add 10 to `r`.\n * 4. Check if `x` is greater than or equal to 10^5. If true, divide `x` by 10^5 and add 5 to `r`.\n * 5. Add the number of digits in `x` (minus one) to `r` by checking the magnitude of `x` against thresholds (10, 100, 1000, 10000).\n * \n * @dev This function uses assembly for efficient computation and is memory-safe.\n */"
        },
        {
            "identifier": "log10Up",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log10Up(uint256 x) internal pure returns (uint256 r) {\n        r = log10(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(exp(10, r), x))\n        }\n    }",
            "start": "917",
            "end": "923",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 r) log10Upuint256 x",
            "full_signature": "function log10Up(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "FixedPointMathLib.log10Upuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the ceiling of the base-10 logarithm of a given number.\n *\n * @param x The number for which to compute the base-10 logarithm.\n * @return r The ceiling of the base-10 logarithm of `x`.\n *\n * Steps:\n * 1. Compute the base-10 logarithm of `x` using the `log10` function.\n * 2. Use inline assembly to check if `10^r` is less than `x`.\n * 3. If `10^r` is less than `x`, increment `r` by 1 to get the ceiling value.\n * 4. Return the computed value `r`.\n *\n * @dev This function uses inline assembly for efficiency and memory safety.\n */"
        },
        {
            "identifier": "log256",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log256(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(shr(3, r), lt(0xff, shr(r, x)))\n        }\n    }",
            "start": "927",
            "end": "936",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 r) log256uint256 x",
            "full_signature": "function log256(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "FixedPointMathLib.log256uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the logarithm base 256 of a given unsigned integer `x` using bitwise operations.\n *\n * @param x The unsigned integer for which the logarithm base 256 is to be computed.\n * @return r The logarithm base 256 of `x`.\n *\n * Steps:\n * 1. Use bitwise operations to determine the highest set bit in `x`.\n * 2. Shift and compare `x` to progressively smaller bit masks to find the logarithm.\n * 3. Return the computed logarithm value.\n *\n * @dev This function uses inline assembly for efficient bitwise operations.\n */"
        },
        {
            "identifier": "log256Up",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function log256Up(uint256 x) internal pure returns (uint256 r) {\n        r = log256(x);\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := add(r, lt(shl(shl(3, r), 1), x))\n        }\n    }",
            "start": "940",
            "end": "946",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 r) log256Upuint256 x",
            "full_signature": "function log256Up(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "FixedPointMathLib.log256Upuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the logarithm base 256 of `x` and rounds up the result.\n *\n * @param x The input value for which the logarithm is to be computed.\n * @return r The logarithm base 256 of `x`, rounded up.\n *\n * Steps:\n * 1. Compute the logarithm base 256 of `x` using the `log256` function.\n * 2. Use inline assembly to check if the result should be rounded up:\n *    - Shift `1` left by `3 * r` bits (equivalent to multiplying by 2^(3*r)).\n *    - Compare the shifted value with `x`.\n *    - If the shifted value is less than `x`, increment `r` by 1.\n * 3. Return the rounded-up result.\n *\n * @dev This function uses inline assembly for precise control over the rounding logic.\n */"
        },
        {
            "identifier": "sci",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 mantissa, uint256 exponent)",
            "body": "function sci(uint256 x) internal pure returns (uint256 mantissa, uint256 exponent) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mantissa := x\n            if mantissa {\n                if iszero(mod(mantissa, 1000000000000000000000000000000000)) {\n                    mantissa := div(mantissa, 1000000000000000000000000000000000)\n                    exponent := 33\n                }\n                if iszero(mod(mantissa, 10000000000000000000)) {\n                    mantissa := div(mantissa, 10000000000000000000)\n                    exponent := add(exponent, 19)\n                }\n                if iszero(mod(mantissa, 1000000000000)) {\n                    mantissa := div(mantissa, 1000000000000)\n                    exponent := add(exponent, 12)\n                }\n                if iszero(mod(mantissa, 1000000)) {\n                    mantissa := div(mantissa, 1000000)\n                    exponent := add(exponent, 6)\n                }\n                if iszero(mod(mantissa, 10000)) {\n                    mantissa := div(mantissa, 10000)\n                    exponent := add(exponent, 4)\n                }\n                if iszero(mod(mantissa, 100)) {\n                    mantissa := div(mantissa, 100)\n                    exponent := add(exponent, 2)\n                }\n                if iszero(mod(mantissa, 10)) {\n                    mantissa := div(mantissa, 10)\n                    exponent := add(exponent, 1)\n                }\n            }\n        }\n    }",
            "start": "950",
            "end": "985",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 mantissa, uint256 exponent) sciuint256 x",
            "full_signature": "function sci(uint256 x) internal  pure returns (uint256 mantissa, uint256 exponent)",
            "class_method_signature": "FixedPointMathLib.sciuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to decompose a number into its mantissa and exponent components.\n *\n * @param x The input number to be decomposed.\n * @return mantissa The mantissa component of the number.\n * @return exponent The exponent component of the number.\n *\n * Steps:\n * 1. Assign the input value `x` to `mantissa`.\n * 2. If `mantissa` is non-zero, perform a series of checks to determine the exponent:\n *    - If `mantissa` is divisible by 10^33, divide `mantissa` by 10^33 and set `exponent` to 33.\n *    - If `mantissa` is divisible by 10^19, divide `mantissa` by 10^19 and add 19 to `exponent`.\n *    - If `mantissa` is divisible by 10^12, divide `mantissa` by 10^12 and add 12 to `exponent`.\n *    - If `mantissa` is divisible by 10^6, divide `mantissa` by 10^6 and add 6 to `exponent`.\n *    - If `mantissa` is divisible by 10^4, divide `mantissa` by 10^4 and add 4 to `exponent`.\n *    - If `mantissa` is divisible by 10^2, divide `mantissa` by 10^2 and add 2 to `exponent`.\n *    - If `mantissa` is divisible by 10, divide `mantissa` by 10 and add 1 to `exponent`.\n * 3. The final `mantissa` and `exponent` values are returned.\n *\n * @dev This function uses inline assembly for efficiency and is memory-safe.\n */"
        },
        {
            "identifier": "packSci",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 packed)",
            "body": "function packSci(uint256 x) internal pure returns (uint256 packed) {\n        (x, packed) = sci(x); // Reuse for `mantissa` and `exponent`.\n        /// @solidity memory-safe-assembly\n        assembly {\n            if shr(249, x) {\n                mstore(0x00, 0xce30380c) // `MantissaOverflow()`.\n                revert(0x1c, 0x04)\n            }\n            packed := or(shl(7, x), packed)\n        }\n    }",
            "start": "995",
            "end": "1005",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 packed) packSciuint256 x",
            "full_signature": "function packSci(uint256 x) internal  pure returns (uint256 packed)",
            "class_method_signature": "FixedPointMathLib.packSciuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Packs a scientific notation value into a single uint256.\n *\n * @param x The input value to be packed.\n * @return packed The packed value combining the mantissa and exponent.\n *\n * Steps:\n * 1. Call the `sci` function to decompose `x` into mantissa and exponent.\n * 2. Use inline assembly to perform low-level operations:\n *    - Check if the mantissa exceeds the allowed size (249 bits). If so, revert with `MantissaOverflow()`.\n *    - Pack the mantissa and exponent into a single uint256 by shifting the mantissa left by 7 bits and combining it with the exponent.\n *\n * @dev This function is memory-safe and uses assembly for efficient bit manipulation.\n */"
        },
        {
            "identifier": "unpackSci",
            "parameters": "uint256 packed",
            "modifiers": "pure",
            "return": "returns (uint256 unpacked)",
            "body": "function unpackSci(uint256 packed) internal pure returns (uint256 unpacked) {\n        unchecked {\n            unpacked = (packed >> 7) * 10 ** (packed & 0x7f);\n        }\n    }",
            "start": "1008",
            "end": "1012",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 unpacked) unpackSciuint256 packed",
            "full_signature": "function unpackSci(uint256 packed) internal  pure returns (uint256 unpacked)",
            "class_method_signature": "FixedPointMathLib.unpackSciuint256 packed",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Unpacks a packed scientific notation value into its expanded form.\n *\n * @param packed The packed value containing the coefficient and exponent in a single uint256.\n * @return unpacked The unpacked value in its expanded form.\n *\n * Steps:\n * 1. Extract the coefficient by shifting the packed value right by 7 bits.\n * 2. Extract the exponent by masking the packed value with 0x7f (lower 7 bits).\n * 3. Calculate the unpacked value by multiplying the coefficient by 10 raised to the power of the exponent.\n * 4. The operation is performed in an unchecked block to avoid overflow checks.\n */"
        },
        {
            "identifier": "avg",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function avg(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = (x & y) + ((x ^ y) >> 1);\n        }\n    }",
            "start": "1015",
            "end": "1019",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) avguint256 x, uint256 y",
            "full_signature": "function avg(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.avguint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the average of two unsigned integers (x and y) without overflow.\n *\n * @param x The first unsigned integer.\n * @param y The second unsigned integer.\n * @return z The average of x and y, calculated as (x & y) + ((x ^ y) >> 1).\n *\n * Steps:\n * 1. Use bitwise operations to calculate the average:\n *    - `x & y` computes the common bits between x and y.\n *    - `x ^ y` computes the differing bits between x and y.\n *    - `(x ^ y) >> 1` shifts the differing bits right by 1 (equivalent to dividing by 2).\n *    - Adding the results of the above operations gives the average.\n * 2. The `unchecked` block ensures that overflow checks are disabled for this calculation.\n */"
        },
        {
            "identifier": "avg",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function avg(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }",
            "start": "1022",
            "end": "1026",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) avgint256 x, int256 y",
            "full_signature": "function avg(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.avgint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the average of two signed integers (x and y) using bitwise operations.\n *\n * @param x The first signed integer.\n * @param y The second signed integer.\n * @return z The average of x and y, calculated as (x >> 1) + (y >> 1) + (x & y & 1).\n *\n * Steps:\n * 1. Right-shift x by 1 bit (equivalent to dividing by 2).\n * 2. Right-shift y by 1 bit (equivalent to dividing by 2).\n * 3. Add the results of steps 1 and 2.\n * 4. Add the least significant bit (LSB) of both x and y to handle rounding for odd numbers.\n * 5. Return the result as the average.\n *\n * Note: The function uses `unchecked` to disable overflow checks, assuming the inputs are within safe bounds.\n */"
        },
        {
            "identifier": "abs",
            "parameters": "int256 x",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function abs(int256 x) internal pure returns (uint256 z) {\n        unchecked {\n            z = (uint256(x) + uint256(x >> 255)) ^ uint256(x >> 255);\n        }\n    }",
            "start": "1029",
            "end": "1033",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) absint256 x",
            "full_signature": "function abs(int256 x) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.absint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the absolute value of a signed integer.\n *\n * @param x The signed integer whose absolute value is to be computed.\n * @return z The absolute value of `x` as an unsigned integer.\n *\n * Steps:\n * 1. Use unchecked arithmetic to avoid overflow checks.\n * 2. Calculate the absolute value by adding `x` to the result of a bitwise shift of `x` by 255 bits,\n *    then XOR the result with the same shifted value.\n * 3. Return the computed absolute value.\n */"
        },
        {
            "identifier": "dist",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function dist(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, gt(x, y)), sub(y, x)), gt(x, y))\n        }\n    }",
            "start": "1036",
            "end": "1041",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) distuint256 x, uint256 y",
            "full_signature": "function dist(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.distuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the absolute difference between two unsigned integers `x` and `y`.\n *\n * @dev This function uses inline assembly to efficiently calculate the absolute difference.\n *      The assembly code performs the following steps:\n *      1. Checks if `x` is greater than `y` using `gt(x, y)`.\n *      2. If `x` is greater than `y`, it calculates `x - y`.\n *      3. If `y` is greater than `x`, it calculates `y - x`.\n *      4. Uses bitwise XOR and subtraction to handle the conditional logic efficiently.\n *\n * @param x The first unsigned integer.\n * @param y The second unsigned integer.\n * @return z The absolute difference between `x` and `y`.\n */"
        },
        {
            "identifier": "dist",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function dist(int256 x, int256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := add(xor(sub(0, sgt(x, y)), sub(y, x)), sgt(x, y))\n        }\n    }",
            "start": "1044",
            "end": "1049",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) distint256 x, int256 y",
            "full_signature": "function dist(int256 x, int256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.distint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the absolute difference between two signed integers `x` and `y`.\n *\n * @param x The first signed integer.\n * @param y The second signed integer.\n * @return z The absolute difference between `x` and `y` as an unsigned integer.\n *\n * Steps:\n * 1. Use inline assembly to perform the calculation:\n *    - Compute the difference between `y` and `x`.\n *    - Use `sgt` (signed greater than) to determine if `x` is greater than `y`.\n *    - Adjust the result based on the comparison to ensure the absolute difference.\n * 2. Return the result as an unsigned integer.\n *\n * @dev This function uses low-level assembly for efficient computation.\n */"
        },
        {
            "identifier": "min",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function min(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), lt(y, x)))\n        }\n    }",
            "start": "1052",
            "end": "1057",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) minuint256 x, uint256 y",
            "full_signature": "function min(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.minuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the minimum of two unsigned integers using inline assembly for gas efficiency.\n *\n * @param x The first unsigned integer to compare.\n * @param y The second unsigned integer to compare.\n * @return z The smaller of the two integers, `x` or `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the comparison and computation.\n * 2. If `y` is less than `x`, return `y`; otherwise, return `x`.\n * 3. The result is stored in `z` and returned.\n */ "
        },
        {
            "identifier": "min",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function min(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), slt(y, x)))\n        }\n    }",
            "start": "1060",
            "end": "1065",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) minint256 x, int256 y",
            "full_signature": "function min(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.minint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the minimum of two signed integers `x` and `y`.\n *\n * @param x The first signed integer to compare.\n * @param y The second signed integer to compare.\n * @return z The smaller of the two integers (`x` or `y`).\n *\n * @dev This function uses low-level assembly to efficiently compute the minimum value.\n *      It leverages bitwise operations and the `slt` (signed less-than) instruction.\n *      The result is stored in `z`.\n */"
        },
        {
            "identifier": "max",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function max(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), gt(y, x)))\n        }\n    }",
            "start": "1068",
            "end": "1073",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) maxuint256 x, uint256 y",
            "full_signature": "function max(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.maxuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns the maximum of two unsigned integers using low-level assembly for optimization.\n *\n * @param x The first unsigned integer to compare.\n * @param y The second unsigned integer to compare.\n * @return z The maximum value between `x` and `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the comparison and calculation.\n * 2. Calculate the result using bitwise XOR and multiplication operations.\n * 3. Return the maximum value.\n *\n * @dev This function is marked as `internal` and `pure`, meaning it can only be called within the contract\n * and does not modify the state or read from it. The assembly block ensures memory safety.\n */"
        },
        {
            "identifier": "max",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function max(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, y), sgt(y, x)))\n        }\n    }",
            "start": "1076",
            "end": "1081",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) maxint256 x, int256 y",
            "full_signature": "function max(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.maxint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns the maximum of two signed integers `x` and `y`.\n *\n * @param x The first signed integer to compare.\n * @param y The second signed integer to compare.\n * @return z The larger of the two integers (`x` or `y`).\n *\n * Steps:\n * 1. Use inline assembly to perform the comparison and calculation.\n * 2. Calculate the result using bitwise XOR and the `sgt` (signed greater than) operation.\n * 3. Return the larger integer as `z`.\n */"
        },
        {
            "identifier": "clamp",
            "parameters": "uint256 x, uint256 minValue, uint256 maxValue",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function clamp(uint256 x, uint256 minValue, uint256 maxValue)\n        internal\n        pure\n        returns (uint256 z)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), gt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), lt(maxValue, z)))\n        }\n    }",
            "start": "1084",
            "end": "1094",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) clampuint256 x, uint256 minValue, uint256 maxValue",
            "full_signature": "function clamp(uint256 x, uint256 minValue, uint256 maxValue) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.clampuint256 x, uint256 minValue, uint256 maxValue",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clamps a value `x` between `minValue` and `maxValue`.\n *\n * @dev This function ensures that `x` is not less than `minValue` and not greater than `maxValue`.\n * If `x` is less than `minValue`, it returns `minValue`. If `x` is greater than `maxValue`, it returns `maxValue`.\n * Otherwise, it returns `x` unchanged.\n *\n * @param x The value to be clamped.\n * @param minValue The minimum allowed value.\n * @param maxValue The maximum allowed value.\n * @return z The clamped value, which is either `minValue`, `maxValue`, or `x` itself.\n *\n * Steps:\n * 1. Use inline assembly to perform the clamping operation efficiently.\n * 2. First, check if `x` is less than `minValue`. If true, set `z` to `minValue`.\n * 3. Then, check if `z` (which is now either `x` or `minValue`) is greater than `maxValue`. If true, set `z` to `maxValue`.\n * 4. Return the final clamped value `z`.\n */"
        },
        {
            "identifier": "clamp",
            "parameters": "int256 x, int256 minValue, int256 maxValue",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function clamp(int256 x, int256 minValue, int256 maxValue) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := xor(x, mul(xor(x, minValue), sgt(minValue, x)))\n            z := xor(z, mul(xor(z, maxValue), slt(maxValue, z)))\n        }\n    }",
            "start": "1097",
            "end": "1103",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) clampint256 x, int256 minValue, int256 maxValue",
            "full_signature": "function clamp(int256 x, int256 minValue, int256 maxValue) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.clampint256 x, int256 minValue, int256 maxValue",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clamps a value `x` between `minValue` and `maxValue`.\n *\n * @param x The value to be clamped.\n * @param minValue The minimum allowed value.\n * @param maxValue The maximum allowed value.\n * @return z The clamped value, which will be:\n *           - `minValue` if `x` is less than `minValue`.\n *           - `maxValue` if `x` is greater than `maxValue`.\n *           - `x` if it is within the range [minValue, maxValue].\n *\n * @dev This function uses low-level assembly to perform the clamping operation efficiently.\n *      The assembly code ensures memory safety by using the `xor` and `mul` operations to\n *      conditionally adjust the value of `x` based on the comparison with `minValue` and `maxValue`.\n */"
        },
        {
            "identifier": "gcd",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function gcd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { z := x } y {} {\n                let t := y\n                y := mod(z, y)\n                z := t\n            }\n        }\n    }",
            "start": "1106",
            "end": "1115",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) gcduint256 x, uint256 y",
            "full_signature": "function gcd(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.gcduint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.\n *\n * @param x The first number.\n * @param y The second number.\n * @return z The greatest common divisor of `x` and `y`.\n *\n * Steps:\n * 1. Initialize `z` with the value of `x`.\n * 2. Use a loop to repeatedly apply the Euclidean algorithm:\n *    a. Store the current value of `y` in `t`.\n *    b. Update `y` to be the remainder of `z` divided by `y`.\n *    c. Update `z` to be the value of `t`.\n * 3. The loop continues until `y` becomes zero, at which point `z` holds the GCD.\n *\n * @dev This function uses inline assembly for efficient computation.\n */"
        },
        {
            "identifier": "lerp",
            "parameters": "uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end",
            "modifiers": "pure",
            "return": "returns (uint256)",
            "body": "function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end)\n        internal\n        pure\n        returns (uint256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        unchecked {\n            if (b >= a) return a + fullMulDiv(b - a, t - begin, end - begin);\n            return a - fullMulDiv(a - b, t - begin, end - begin);\n        }\n    }",
            "start": "1121",
            "end": "1133",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256) lerpuint256 a, uint256 b, uint256 t, uint256 begin, uint256 end",
            "full_signature": "function lerp(uint256 a, uint256 b, uint256 t, uint256 begin, uint256 end) internal  pure returns (uint256)",
            "class_method_signature": "FixedPointMathLib.lerpuint256 a, uint256 b, uint256 t, uint256 begin, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs linear interpolation (lerp) between two values `a` and `b` based on a parameter `t` within a range [begin, end].\n *\n * @param a The starting value of the interpolation.\n * @param b The ending value of the interpolation.\n * @param t The parameter determining the interpolation point.\n * @param begin The start of the interpolation range.\n * @param end The end of the interpolation range.\n * @return The interpolated value between `a` and `b` based on `t`.\n *\n * Steps:\n * 1. If `begin` is greater than `end`, invert `t`, `begin`, and `end` to handle reverse ranges.\n * 2. If `t` is less than or equal to `begin`, return `a`.\n * 3. If `t` is greater than or equal to `end`, return `b`.\n * 4. If `b` is greater than or equal to `a`, calculate the interpolation using `a + fullMulDiv(b - a, t - begin, end - begin)`.\n * 5. If `b` is less than `a`, calculate the interpolation using `a - fullMulDiv(a - b, t - begin, end - begin)`.\n * 6. The calculations are performed in an unchecked block to avoid overflow checks.\n */"
        },
        {
            "identifier": "lerp",
            "parameters": "int256 a, int256 b, int256 t, int256 begin, int256 end",
            "modifiers": "pure",
            "return": "returns (int256)",
            "body": "function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end)\n        internal\n        pure\n        returns (int256)\n    {\n        if (begin > end) (t, begin, end) = (~t, ~begin, ~end);\n        if (t <= begin) return a;\n        if (t >= end) return b;\n        // forgefmt: disable-next-item\n        unchecked {\n            if (b >= a) return int256(uint256(a) + fullMulDiv(uint256(b - a),\n                uint256(t - begin), uint256(end - begin)));\n            return int256(uint256(a) - fullMulDiv(uint256(a - b),\n                uint256(t - begin), uint256(end - begin)));\n        }\n    }",
            "start": "1139",
            "end": "1154",
            "class": "FixedPointMathLib",
            "signature": "returns (int256) lerpint256 a, int256 b, int256 t, int256 begin, int256 end",
            "full_signature": "function lerp(int256 a, int256 b, int256 t, int256 begin, int256 end) internal  pure returns (int256)",
            "class_method_signature": "FixedPointMathLib.lerpint256 a, int256 b, int256 t, int256 begin, int256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs linear interpolation (lerp) between two values `a` and `b` based on a parameter `t` within a range [begin, end].\n *\n * @param a The starting value of the interpolation.\n * @param b The ending value of the interpolation.\n * @param t The parameter determining the interpolation point.\n * @param begin The start of the interpolation range.\n * @param end The end of the interpolation range.\n *\n * @return int256 The interpolated value between `a` and `b` based on `t`.\n *\n * Steps:\n * 1. If `begin` is greater than `end`, invert `t`, `begin`, and `end` using bitwise NOT (~) to handle reverse ranges.\n * 2. If `t` is less than or equal to `begin`, return `a`.\n * 3. If `t` is greater than or equal to `end`, return `b`.\n * 4. If `b` is greater than or equal to `a`, calculate the interpolation using `fullMulDiv` and return the result.\n * 5. If `b` is less than `a`, calculate the interpolation using `fullMulDiv` and return the result.\n *\n * Note: The function uses unchecked arithmetic for gas optimization.\n */"
        },
        {
            "identifier": "rawAdd",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawAdd(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }",
            "start": "1166",
            "end": "1170",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawAdduint256 x, uint256 y",
            "full_signature": "function rawAdd(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawAdduint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs an unchecked addition of two unsigned integers.\n *\n * @param x The first unsigned integer to add.\n * @param y The second unsigned integer to add.\n * @return z The result of the addition, which is the sum of `x` and `y`.\n *\n * Steps:\n * 1. Use the `unchecked` block to perform the addition without overflow checks.\n * 2. Return the result of the addition.\n */"
        },
        {
            "identifier": "rawAdd",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawAdd(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x + y;\n        }\n    }",
            "start": "1173",
            "end": "1177",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawAddint256 x, int256 y",
            "full_signature": "function rawAdd(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawAddint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Adds two integers (`x` and `y`) and returns the result (`z`).\n * @dev The function uses the `unchecked` block to disable overflow checks, which can save gas.\n *\n * @param x The first integer to add.\n * @param y The second integer to add.\n * @return z The result of the addition (`x + y`).\n */"
        },
        {
            "identifier": "rawSub",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawSub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }",
            "start": "1180",
            "end": "1184",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawSubuint256 x, uint256 y",
            "full_signature": "function rawSub(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawSubuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a subtraction operation on two unsigned integers with overflow protection.\n *\n * @param x The minuend (the number from which another number is to be subtracted).\n * @param y The subtrahend (the number to be subtracted from the minuend).\n * @return z The result of the subtraction operation.\n *\n * Steps:\n * 1. Subtract `y` from `x` within an `unchecked` block to allow for overflow protection.\n * 2. Return the result of the subtraction.\n */"
        },
        {
            "identifier": "rawSub",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawSub(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x - y;\n        }\n    }",
            "start": "1187",
            "end": "1191",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawSubint256 x, int256 y",
            "full_signature": "function rawSub(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawSubint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a subtraction operation on two integers with overflow protection.\n *\n * @param x The first integer (minuend).\n * @param y The second integer (subtrahend).\n * @return z The result of the subtraction (x - y).\n *\n * Steps:\n * 1. Subtract `y` from `x` within an unchecked block to prevent overflow checks.\n * 2. Return the result of the subtraction.\n */"
        },
        {
            "identifier": "rawMul",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawMul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }",
            "start": "1194",
            "end": "1198",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawMuluint256 x, uint256 y",
            "full_signature": "function rawMul(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawMuluint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Multiplies two unsigned integers (`x` and `y`) and returns the result.\n * @dev This function uses the `unchecked` block to optimize gas usage by skipping overflow checks.\n * @param x The first unsigned integer to multiply.\n * @param y The second unsigned integer to multiply.\n * @return z The result of multiplying `x` and `y`.\n */"
        },
        {
            "identifier": "rawMul",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawMul(int256 x, int256 y) internal pure returns (int256 z) {\n        unchecked {\n            z = x * y;\n        }\n    }",
            "start": "1201",
            "end": "1205",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawMulint256 x, int256 y",
            "full_signature": "function rawMul(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawMulint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Multiplies two signed integers (`x` and `y`) and returns the result.\n * @dev The function uses the `unchecked` block to optimize gas usage by skipping overflow checks.\n * @param x The first signed integer to multiply.\n * @param y The second signed integer to multiply.\n * @return z The result of multiplying `x` and `y`.\n */"
        },
        {
            "identifier": "rawDiv",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawDiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := div(x, y)\n        }\n    }",
            "start": "1208",
            "end": "1213",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawDivuint256 x, uint256 y",
            "full_signature": "function rawDiv(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawDivuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a raw division operation on two unsigned integers using inline assembly.\n *\n * @param x The dividend (numerator) in the division operation.\n * @param y The divisor (denominator) in the division operation.\n * @return z The result of the division operation (x / y).\n *\n * Steps:\n * 1. Use inline assembly to perform the division operation.\n * 2. Store the result in the variable `z`.\n *\n * Note: This function uses low-level assembly for efficiency and assumes that `y` is not zero.\n */"
        },
        {
            "identifier": "rawSDiv",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawSDiv(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := sdiv(x, y)\n        }\n    }",
            "start": "1216",
            "end": "1221",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawSDivint256 x, int256 y",
            "full_signature": "function rawSDiv(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawSDivint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a signed integer division operation on two int256 values.\n *\n * @param x The dividend (numerator) in the division operation.\n * @param y The divisor (denominator) in the division operation.\n * @return z The result of the signed division of `x` by `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the signed division (`sdiv`) operation.\n * 2. Return the result of the division.\n *\n * @dev This function is marked as `pure` and `internal`, meaning it does not modify the state and can only be called internally within the contract.\n */"
        },
        {
            "identifier": "rawMod",
            "parameters": "uint256 x, uint256 y",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawMod(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mod(x, y)\n        }\n    }",
            "start": "1224",
            "end": "1229",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawModuint256 x, uint256 y",
            "full_signature": "function rawMod(uint256 x, uint256 y) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawModuint256 x, uint256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a raw modulo operation on two unsigned integers using inline assembly.\n *\n * @param x The dividend (the number to be divided).\n * @param y The divisor (the number to divide by).\n * @return z The remainder of the division of `x` by `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the modulo operation (`mod(x, y)`).\n * 2. Return the result of the modulo operation.\n *\n * @dev This function is marked as `internal` and `pure`, meaning it does not modify the state and can only be called internally.\n */"
        },
        {
            "identifier": "rawSMod",
            "parameters": "int256 x, int256 y",
            "modifiers": "pure",
            "return": "returns (int256 z)",
            "body": "function rawSMod(int256 x, int256 y) internal pure returns (int256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := smod(x, y)\n        }\n    }",
            "start": "1232",
            "end": "1237",
            "class": "FixedPointMathLib",
            "signature": "returns (int256 z) rawSModint256 x, int256 y",
            "full_signature": "function rawSMod(int256 x, int256 y) internal  pure returns (int256 z)",
            "class_method_signature": "FixedPointMathLib.rawSModint256 x, int256 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a signed modulo operation on two integers using inline assembly.\n *\n * @param x The dividend (integer to be divided).\n * @param y The divisor (integer to divide by).\n * @return z The result of the signed modulo operation (x % y).\n *\n * Steps:\n * 1. Use inline assembly to perform the signed modulo operation (`smod`).\n * 2. Return the result of the operation.\n *\n * @dev This function is marked as `internal pure`, meaning it can only be called internally within the contract and does not modify the state.\n */"
        },
        {
            "identifier": "rawAddMod",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawAddMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := addmod(x, y, d)\n        }\n    }",
            "start": "1240",
            "end": "1245",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawAddModuint256 x, uint256 y, uint256 d",
            "full_signature": "function rawAddMod(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawAddModuint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a raw addition modulo operation using inline assembly.\n *\n * @param x The first operand for the addition modulo operation.\n * @param y The second operand for the addition modulo operation.\n * @param d The modulus value for the operation.\n * @return z The result of the addition modulo operation (x + y) % d.\n *\n * Steps:\n * 1. Use inline assembly to perform the `addmod` operation, which adds `x` and `y` and then takes the result modulo `d`.\n * 2. Return the result of the operation.\n *\n * @dev This function is marked as `internal pure` and uses inline assembly for gas efficiency.\n */"
        },
        {
            "identifier": "rawMulMod",
            "parameters": "uint256 x, uint256 y, uint256 d",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawMulMod(uint256 x, uint256 y, uint256 d) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := mulmod(x, y, d)\n        }\n    }",
            "start": "1248",
            "end": "1253",
            "class": "FixedPointMathLib",
            "signature": "returns (uint256 z) rawMulModuint256 x, uint256 y, uint256 d",
            "full_signature": "function rawMulMod(uint256 x, uint256 y, uint256 d) internal  pure returns (uint256 z)",
            "class_method_signature": "FixedPointMathLib.rawMulModuint256 x, uint256 y, uint256 d",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a raw multiplication modulo operation using inline assembly.\n *\n * @param x The first operand for the multiplication.\n * @param y The second operand for the multiplication.\n * @param d The divisor for the modulo operation.\n * @return z The result of the operation `(x * y) % d`.\n *\n * Steps:\n * 1. Use inline assembly to perform the `mulmod` operation, which multiplies `x` and `y` and then takes the result modulo `d`.\n * 2. Return the result of the operation.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibZip.sol": [
        {
            "identifier": "flzCompress",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function flzCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function ms8(d_, v_) -> _d {\n                mstore8(d_, v_)\n                _d := add(d_, 1)\n            }\n            function u24(p_) -> _u {\n                _u := mload(p_)\n                _u := or(shl(16, byte(2, _u)), or(shl(8, byte(1, _u)), byte(0, _u)))\n            }\n            function cmp(p_, q_, e_) -> _l {\n                for { e_ := sub(e_, q_) } lt(_l, e_) { _l := add(_l, 1) } {\n                    e_ := mul(iszero(byte(0, xor(mload(add(p_, _l)), mload(add(q_, _l))))), e_)\n                }\n            }\n            function literals(runs_, src_, dest_) -> _o {\n                for { _o := dest_ } iszero(lt(runs_, 0x20)) { runs_ := sub(runs_, 0x20) } {\n                    mstore(ms8(_o, 31), mload(src_))\n                    _o := add(_o, 0x21)\n                    src_ := add(src_, 0x20)\n                }\n                if iszero(runs_) { leave }\n                mstore(ms8(_o, sub(runs_, 1)), mload(src_))\n                _o := add(1, add(_o, runs_))\n            }\n            function mt(l_, d_, o_) -> _o {\n                for { d_ := sub(d_, 1) } iszero(lt(l_, 263)) { l_ := sub(l_, 262) } {\n                    o_ := ms8(ms8(ms8(o_, add(224, shr(8, d_))), 253), and(0xff, d_))\n                }\n                if iszero(lt(l_, 7)) {\n                    _o := ms8(ms8(ms8(o_, add(224, shr(8, d_))), sub(l_, 7)), and(0xff, d_))\n                    leave\n                }\n                _o := ms8(ms8(o_, add(shl(5, l_), shr(8, d_))), and(0xff, d_))\n            }\n            function setHash(i_, v_) {\n                let p_ := add(mload(0x40), shl(2, i_))\n                mstore(p_, xor(mload(p_), shl(224, xor(shr(224, mload(p_)), v_))))\n            }\n            function getHash(i_) -> _h {\n                _h := shr(224, mload(add(mload(0x40), shl(2, i_))))\n            }\n            function hash(v_) -> _r {\n                _r := and(shr(19, mul(2654435769, v_)), 0x1fff)\n            }\n            function setNextHash(ip_, ipStart_) -> _ip {\n                setHash(hash(u24(ip_)), sub(ip_, ipStart_))\n                _ip := add(ip_, 1)\n            }\n            result := mload(0x40)\n            codecopy(result, codesize(), 0x8000) // Zeroize the hashmap.\n            let op := add(result, 0x8000)\n            let a := add(data, 0x20)\n            let ipStart := a\n            let ipLimit := sub(add(ipStart, mload(data)), 13)\n            for { let ip := add(2, a) } lt(ip, ipLimit) {} {\n                let r := 0\n                let d := 0\n                for {} 1 {} {\n                    let s := u24(ip)\n                    let h := hash(s)\n                    r := add(ipStart, getHash(h))\n                    setHash(h, sub(ip, ipStart))\n                    d := sub(ip, r)\n                    if iszero(lt(ip, ipLimit)) { break }\n                    ip := add(ip, 1)\n                    if iszero(gt(d, 0x1fff)) { if eq(s, u24(r)) { break } }\n                }\n                if iszero(lt(ip, ipLimit)) { break }\n                ip := sub(ip, 1)\n                if gt(ip, a) { op := literals(sub(ip, a), a, op) }\n                let l := cmp(add(r, 3), add(ip, 3), add(ipLimit, 9))\n                op := mt(l, d, op)\n                ip := setNextHash(setNextHash(add(ip, l), ipStart), ipStart)\n                a := ip\n            }\n            // Copy the result to compact the memory, overwriting the hashmap.\n            let end := sub(literals(sub(add(ipStart, mload(data)), a), a, op), 0x7fe0)\n            let o := add(result, 0x20)\n            mstore(result, sub(end, o)) // Store the length.\n            for {} iszero(gt(o, end)) { o := add(o, 0x20) } { mstore(o, mload(add(o, 0x7fe0))) }\n            mstore(end, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(end, 0x20)) // Allocate the memory.\n        }\n    }",
            "start": "23",
            "end": "108",
            "class": "LibZip",
            "signature": "returns (bytes memory result) flzCompressbytes memory data",
            "full_signature": "function flzCompress(bytes memory data) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibZip.flzCompressbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Compresses the input data using a custom compression algorithm.\n *\n * The function uses low-level assembly to optimize memory usage and performance.\n * It implements a custom compression algorithm that processes the input data in chunks,\n * identifies repeated patterns, and compresses them using a hash-based approach.\n *\n * Steps:\n * 1. Initialize the result memory pointer and zeroize the hashmap.\n * 2. Copy the input data into memory and set up pointers for processing.\n * 3. Iterate through the input data to identify repeated patterns using a hash function.\n * 4. For each repeated pattern, encode the length and offset of the match.\n * 5. For non-repeated data, encode it as literals.\n * 6. Update the hashmap with the current position to facilitate future pattern matching.\n * 7. After processing, copy the compressed result to a compact memory location.\n * 8. Store the length of the compressed data and allocate memory for the result.\n *\n * @param data The input data to be compressed.\n * @return result The compressed data as a byte array.\n */"
        },
        {
            "identifier": "flzDecompress",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function flzDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := mload(0x40)\n            let op := add(result, 0x20)\n            let end := add(add(data, 0x20), mload(data))\n            for { data := add(data, 0x20) } lt(data, end) {} {\n                let w := mload(data)\n                let c := byte(0, w)\n                let t := shr(5, c)\n                if iszero(t) {\n                    mstore(op, mload(add(data, 1)))\n                    data := add(data, add(2, c))\n                    op := add(op, add(1, c))\n                    continue\n                }\n                for {\n                    let g := eq(t, 7)\n                    let l := add(2, xor(t, mul(g, xor(t, add(7, byte(1, w)))))) // M\n                    let s := add(add(shl(8, and(0x1f, c)), byte(add(1, g), w)), 1) // R\n                    let r := sub(op, s)\n                    let f := xor(s, mul(gt(s, 0x20), xor(s, 0x20)))\n                    let j := 0\n                } 1 {} {\n                    mstore(add(op, j), mload(add(r, j)))\n                    j := add(j, f)\n                    if lt(j, l) { continue }\n                    data := add(data, add(2, g))\n                    op := add(op, l)\n                    break\n                }\n            }\n            mstore(result, sub(op, add(result, 0x20))) // Store the length.\n            mstore(op, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(op, 0x20)) // Allocate the memory.\n        }\n    }",
            "start": "111",
            "end": "147",
            "class": "LibZip",
            "signature": "returns (bytes memory result) flzDecompressbytes memory data",
            "full_signature": "function flzDecompress(bytes memory data) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibZip.flzDecompressbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Decompresses data using a custom algorithm (likely FLZ decompression).\n *\n * @param data The compressed data to be decompressed.\n * @return result The decompressed data as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the result and initialize pointers for the output (`op`) and the end of the input data (`end`).\n * 2. Iterate through the compressed data:\n *    - Read the current byte and determine the type of operation based on the first 3 bits.\n *    - If the operation type is 0, copy the next byte(s) directly to the output.\n *    - If the operation type is non-zero, perform a more complex copy operation involving a reference to previously decompressed data.\n * 3. Update the result length and zeroize the memory slot after the decompressed data.\n * 4. Adjust the free memory pointer to allocate memory for the decompressed data.\n *\n * Note: This function uses inline assembly for low-level memory manipulation, which is highly optimized but requires careful handling to avoid memory corruption.\n */"
        },
        {
            "identifier": "cdCompress",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function cdCompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function rle(v_, o_, d_) -> _o, _d {\n                mstore(o_, shl(240, or(and(0xff, add(d_, 0xff)), and(0x80, v_))))\n                _o := add(o_, 2)\n            }\n            result := mload(0x40)\n            let o := add(result, 0x20)\n            let z := 0 // Number of consecutive 0x00.\n            let y := 0 // Number of consecutive 0xff.\n            for { let end := add(data, mload(data)) } iszero(eq(data, end)) {} {\n                data := add(data, 1)\n                let c := byte(31, mload(data))\n                if iszero(c) {\n                    if y { o, y := rle(0xff, o, y) }\n                    z := add(z, 1)\n                    if eq(z, 0x80) { o, z := rle(0x00, o, 0x80) }\n                    continue\n                }\n                if eq(c, 0xff) {\n                    if z { o, z := rle(0x00, o, z) }\n                    y := add(y, 1)\n                    if eq(y, 0x20) { o, y := rle(0xff, o, 0x20) }\n                    continue\n                }\n                if y { o, y := rle(0xff, o, y) }\n                if z { o, z := rle(0x00, o, z) }\n                mstore8(o, c)\n                o := add(o, 1)\n            }\n            if y { o, y := rle(0xff, o, y) }\n            if z { o, z := rle(0x00, o, z) }\n            // Bitwise negate the first 4 bytes.\n            mstore(add(result, 4), not(mload(add(result, 4))))\n            mstore(result, sub(o, add(result, 0x20))) // Store the length.\n            mstore(o, 0) // Zeroize the slot after the string.\n            mstore(0x40, add(o, 0x20)) // Allocate the memory.\n        }\n    }",
            "start": "167",
            "end": "206",
            "class": "LibZip",
            "signature": "returns (bytes memory result) cdCompressbytes memory data",
            "full_signature": "function cdCompress(bytes memory data) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibZip.cdCompressbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Compresses the input data using a custom Run-Length Encoding (RLE) algorithm.\n * \n * @dev This function processes the input data byte by byte, compressing sequences of consecutive \n *      0x00 or 0xff bytes into a more compact format. The compressed data is stored in the returned \n *      `result` bytes array.\n *\n * @param data The input data to be compressed.\n * @return result The compressed data as a bytes array.\n *\n * Steps:\n * 1. Initialize the result pointer and allocate memory for the compressed data.\n * 2. Iterate through each byte of the input data:\n *    - If the byte is 0x00, increment the zero counter (`z`).\n *    - If the byte is 0xff, increment the 0xff counter (`y`).\n *    - If a non-zero or non-0xff byte is encountered, write any pending RLE sequences to the result.\n * 3. After processing all bytes, write any remaining RLE sequences to the result.\n * 4. Perform a bitwise negation on the first 4 bytes of the result.\n * 5. Store the length of the compressed data and zeroize the memory slot after the result.\n * 6. Update the free memory pointer to allocate memory for the compressed data.\n */"
        },
        {
            "identifier": "cdDecompress",
            "parameters": "bytes memory data",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function cdDecompress(bytes memory data) internal pure returns (bytes memory result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(data) {\n                result := mload(0x40)\n                let o := add(result, 0x20)\n                let s := add(data, 4)\n                let v := mload(s)\n                let end := add(data, mload(data))\n                mstore(s, not(v)) // Bitwise negate the first 4 bytes.\n                for {} lt(data, end) {} {\n                    data := add(data, 1)\n                    let c := byte(31, mload(data))\n                    if iszero(c) {\n                        data := add(data, 1)\n                        let d := byte(31, mload(data))\n                        // Fill with either 0xff or 0x00.\n                        mstore(o, not(0))\n                        if iszero(gt(d, 0x7f)) { codecopy(o, codesize(), add(d, 1)) }\n                        o := add(o, add(and(d, 0x7f), 1))\n                        continue\n                    }\n                    mstore8(o, c)\n                    o := add(o, 1)\n                }\n                mstore(s, v) // Restore the first 4 bytes.\n                mstore(result, sub(o, add(result, 0x20))) // Store the length.\n                mstore(o, 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x20)) // Allocate the memory.\n            }\n        }\n    }",
            "start": "209",
            "end": "240",
            "class": "LibZip",
            "signature": "returns (bytes memory result) cdDecompressbytes memory data",
            "full_signature": "function cdDecompress(bytes memory data) internal  pure returns (bytes memory result)",
            "class_method_signature": "LibZip.cdDecompressbytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Decompresses a compressed byte array using a custom algorithm.\n *\n * @dev This function uses inline assembly to perform low-level memory operations for efficiency.\n * It processes the input data byte by byte, handling special cases for zero bytes and compressed sequences.\n *\n * @param data The compressed byte array to be decompressed.\n * @return result The decompressed byte array.\n *\n * Steps:\n * 1. Check if the input data is non-empty.\n * 2. Allocate memory for the result and initialize pointers for the result and input data.\n * 3. Temporarily modify the first 4 bytes of the input data to facilitate decompression.\n * 4. Iterate through the input data:\n *    - If a zero byte is encountered, handle it as a special case for compressed sequences.\n *    - Otherwise, copy the byte directly to the result.\n * 5. Restore the original first 4 bytes of the input data.\n * 6. Store the length of the decompressed data in the result.\n * 7. Zeroize the memory slot after the decompressed data to ensure clean memory state.\n * 8. Update the free memory pointer to allocate memory for the decompressed data.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/EIP712.sol": [
        {
            "identifier": "",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "constructor() {\n        _cachedThis = uint256(uint160(address(this)));\n        _cachedChainId = block.chainid;\n\n        string memory name;\n        string memory version;\n        if (!_domainNameAndVersionMayChange()) (name, version) = _domainNameAndVersion();\n        bytes32 nameHash = _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(name));\n        bytes32 versionHash =\n            _domainNameAndVersionMayChange() ? bytes32(0) : keccak256(bytes(version));\n        _cachedNameHash = nameHash;\n        _cachedVersionHash = versionHash;\n\n        bytes32 separator;\n        if (!_domainNameAndVersionMayChange()) {\n            /// @solidity memory-safe-assembly\n            assembly {\n                let m := mload(0x40) // Load the free memory pointer.\n                mstore(m, _DOMAIN_TYPEHASH)\n                mstore(add(m, 0x20), nameHash)\n                mstore(add(m, 0x40), versionHash)\n                mstore(add(m, 0x60), chainid())\n                mstore(add(m, 0x80), address())\n                separator := keccak256(m, 0xa0)\n            }\n        }\n        _cachedDomainSeparator = separator;\n    }",
            "start": "38",
            "end": "65",
            "class": "EIP712",
            "signature": " ",
            "full_signature": "constructor ()",
            "class_method_signature": "EIP712.",
            "testcase": "",
            "constructor": "True",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Initializes the contract by caching the contract's address, chain ID, and domain separator.\n *\n * Steps:\n * 1. Cache the contract's address (`this`) as a uint256.\n * 2. Cache the current chain ID.\n *\n * 3. Retrieve the domain name and version if they are not expected to change.\n * 4. Compute the keccak256 hash of the domain name and version if they are not expected to change.\n * 5. Cache the computed name and version hashes.\n *\n * 6. Compute the domain separator if the domain name and version are not expected to change.\n *    - The domain separator is computed using the EIP-712 domain type hash, name hash, version hash, chain ID, and contract address.\n * 7. Cache the computed domain separator.\n */"
        },
        {
            "identifier": "eip712Domain",
            "parameters": "",
            "modifiers": "view",
            "return": "returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )",
            "body": "function eip712Domain()\n        public\n        view\n        virtual\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        fields = hex\"0f\"; // `0b01111`.\n        (name, version) = _domainNameAndVersion();\n        chainId = block.chainid;\n        verifyingContract = address(this);\n        salt = salt; // `bytes32(0)`.\n        extensions = extensions; // `new uint256[](0)`.\n    }",
            "start": "149",
            "end": "169",
            "class": "EIP712",
            "signature": "returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        ) eip712Domain",
            "full_signature": "function eip712Domain() public virtual view returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )",
            "class_method_signature": "EIP712.eip712Domain",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "public",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns the EIP-712 domain separator fields for this contract.\n *\n * The EIP-712 domain separator is used for typed structured data hashing and signing.\n *\n * @return fields A bitmask representing the fields included in the domain separator.\n * @return name The name of the domain (e.g., the contract name).\n * @return version The version of the domain (e.g., the contract version).\n * @return chainId The chain ID of the current network.\n * @return verifyingContract The address of the current contract.\n * @return salt A salt value (default is `bytes32(0)`).\n * @return extensions An array of extension values (default is an empty array).\n *\n * Steps:\n * 1. Set the `fields` bitmask to `0x0f` (indicating the inclusion of name, version, chainId, verifyingContract, and salt).\n * 2. Retrieve the domain name and version using the internal `_domainNameAndVersion` function.\n * 3. Set the `chainId` to the current blockchain's chain ID.\n * 4. Set the `verifyingContract` to the address of this contract.\n * 5. Set the `salt` to the default value (`bytes32(0)`).\n * 6. Set the `extensions` to an empty array.\n */ "
        }
    ],
    "/root/solady/lib/solady/src/utils/ReentrancyGuardTransient.sol": [
        {
            "identifier": "nonReentrant",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier nonReentrant() virtual {\n        if (_useTransientReentrancyGuardOnlyOnMainnet()) {\n            uint256 s = _REENTRANCY_GUARD_SLOT;\n            if (block.chainid == 1) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    if tload(s) {\n                        mstore(0x00, s) // `Reentrancy()`.\n                        revert(0x1c, 0x04)\n                    }\n                    tstore(s, address())\n                }\n            } else {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    if eq(sload(s), address()) {\n                        mstore(0x00, s) // `Reentrancy()`.\n                        revert(0x1c, 0x04)\n                    }\n                    sstore(s, address())\n                }\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                if tload(_REENTRANCY_GUARD_SLOT) {\n                    mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                    revert(0x1c, 0x04)\n                }\n                tstore(_REENTRANCY_GUARD_SLOT, address())\n            }\n        }\n        _;\n        if (_useTransientReentrancyGuardOnlyOnMainnet()) {\n            uint256 s = _REENTRANCY_GUARD_SLOT;\n            if (block.chainid == 1) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    tstore(s, 0)\n                }\n            } else {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    sstore(s, s)\n                }\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                tstore(_REENTRANCY_GUARD_SLOT, 0)\n            }\n        }\n    }",
            "start": "31",
            "end": "83",
            "class": "ReentrancyGuardTransient",
            "signature": " nonReentrant",
            "full_signature": "function nonReentrant()  virtual",
            "class_method_signature": "ReentrancyGuardTransient.nonReentrant",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A reentrancy guard modifier to prevent reentrant calls.\n *\n * This modifier uses a transient storage slot to store the reentrancy guard state.\n * It checks if the current chain is Ethereum mainnet (chain ID 1) and uses different\n * storage mechanisms accordingly. If the guard is already active, it reverts with\n * a `Reentrancy()` error. Otherwise, it sets the guard and proceeds with the function.\n * After the function execution, it resets the guard state.\n *\n * Steps:\n * 1. Check if the transient reentrancy guard should be used only on mainnet.\n * 2. If on mainnet:\n *    a. Use transient storage (`tload` and `tstore`) to manage the reentrancy guard.\n *    b. If the guard is already active, revert with `Reentrancy()`.\n *    c. Otherwise, set the guard to the current contract's address.\n * 3. If not on mainnet:\n *    a. Use regular storage (`sload` and `sstore`) to manage the reentrancy guard.\n *    b. If the guard is already active, revert with `Reentrancy()`.\n *    c. Otherwise, set the guard to the current contract's address.\n * 4. Execute the function body.\n * 5. After execution, reset the reentrancy guard state.\n *    a. On mainnet, use transient storage to reset the guard.\n *    b. On other chains, use regular storage to reset the guard.\n */"
        },
        {
            "identifier": "nonReadReentrant",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "modifier nonReadReentrant() virtual {\n        if (_useTransientReentrancyGuardOnlyOnMainnet()) {\n            uint256 s = _REENTRANCY_GUARD_SLOT;\n            if (block.chainid == 1) {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    if tload(s) {\n                        mstore(0x00, s) // `Reentrancy()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n            } else {\n                /// @solidity memory-safe-assembly\n                assembly {\n                    if eq(sload(s), address()) {\n                        mstore(0x00, s) // `Reentrancy()`.\n                        revert(0x1c, 0x04)\n                    }\n                }\n            }\n        } else {\n            /// @solidity memory-safe-assembly\n            assembly {\n                if tload(_REENTRANCY_GUARD_SLOT) {\n                    mstore(0x00, 0xab143c06) // `Reentrancy()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n        _;\n    }",
            "start": "86",
            "end": "116",
            "class": "ReentrancyGuardTransient",
            "signature": " nonReadReentrant",
            "full_signature": "function nonReadReentrant()  virtual",
            "class_method_signature": "ReentrancyGuardTransient.nonReadReentrant",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "virtual",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice A modifier to prevent reentrancy attacks, with special handling for the mainnet (chain ID 1).\n *\n * Steps:\n * 1. Check if the transient reentrancy guard should be used on the mainnet.\n * 2. If on the mainnet:\n *    a. Load the reentrancy guard slot.\n *    b. If the slot is already occupied, revert with a `Reentrancy()` error.\n * 3. If not on the mainnet:\n *    a. Load the reentrancy guard slot.\n *    b. If the slot contains the contract's own address, revert with a `Reentrancy()` error.\n * 4. If the transient reentrancy guard is not used:\n *    a. Load the reentrancy guard slot.\n *    b. If the slot is already occupied, revert with a `Reentrancy()` error.\n * 5. Allow the function to proceed if no reentrancy is detected.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibClone.sol": [
        {
            "identifier": "clone",
            "parameters": "uint256 value, address implementation",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function clone(uint256 value, address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * --------------------------------------------------------------------------+\n             * CREATION (9 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                       |\n             * --------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize     | r         |                              |\n             * 3d         | RETURNDATASIZE    | 0 r       |                              |\n             * 81         | DUP2              | r 0 r     |                              |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                              |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                              |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code   |\n             * f3         | RETURN            |           | [0..runSize): runtime code   |\n             * --------------------------------------------------------------------------|\n             * RUNTIME (44 bytes)                                                        |\n             * --------------------------------------------------------------------------|\n             * Opcode  | Mnemonic       | Stack                  | Memory                |\n             * --------------------------------------------------------------------------|\n             *                                                                           |\n             * ::: keep some values in stack ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | 0                      |                       |\n             * 3d      | RETURNDATASIZE | 0 0                    |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0                  |                       |\n             * 3d      | RETURNDATASIZE | 0 0 0 0                |                       |\n             *                                                                           |\n             * ::: copy calldata to memory ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            |                       |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          |                       |\n             * 3d      | RETURNDATASIZE | 0 0 cds 0 0 0 0        |                       |\n             * 37      | CALLDATACOPY   | 0 0 0 0                | [0..cds): calldata    |\n             *                                                                           |\n             * ::: delegate call to the implementation contract :::::::::::::::::::::::: |\n             * 36      | CALLDATASIZE   | cds 0 0 0 0            | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a      | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4      | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                           |\n             * ::: copy return data to memory :::::::::::::::::::::::::::::::::::::::::: |\n             * 3d      | RETURNDATASIZE | rds success 0 0        | [0..cds): calldata    |\n             * 3d      | RETURNDATASIZE | rds rds success 0 0    | [0..cds): calldata    |\n             * 93      | SWAP4          | 0 rds success 0 rds    | [0..cds): calldata    |\n             * 80      | DUP1           | 0 0 rds success 0 rds  | [0..cds): calldata    |\n             * 3e      | RETURNDATACOPY | success 0 rds          | [0..rds): returndata  |\n             *                                                                           |\n             * 60 0x2a | PUSH1 0x2a     | 0x2a success 0 rds     | [0..rds): returndata  |\n             * 57      | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                           |\n             * ::: revert :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd      | REVERT         |                        | [0..rds): returndata  |\n             *                                                                           |\n             * ::: return :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b      | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3      | RETURN         |                        | [0..rds): returndata  |\n             * --------------------------------------------------------------------------+\n             */\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create(value, 0x0c, 0x35)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "129",
            "end": "198",
            "class": "LibClone",
            "signature": "returns (address instance) cloneuint256 value, address implementation",
            "full_signature": "function clone(uint256 value, address implementation) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneuint256 value, address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract using the provided implementation address and value.\n *\n * @param value The amount of Ether to send with the contract creation.\n * @param implementation The address of the contract implementation to clone.\n * @return instance The address of the newly created contract instance.\n *\n * Steps:\n * 1. Store the initialization code and implementation address in memory.\n * 2. Use the `create` opcode to deploy the new contract instance with the provided value.\n * 3. If the deployment fails, revert with a `DeploymentFailed` error.\n * 4. Restore the overwritten part of the free memory pointer.\n * 5. Return the address of the newly created contract instance.\n *\n * Assembly Details:\n * - The assembly block handles low-level EVM operations to clone the contract.\n * - It uses `mstore` to store the initialization code and implementation address.\n * - The `create` opcode is used to deploy the contract with the specified value.\n * - If the deployment fails, it reverts with a custom error.\n * - Finally, it restores the free memory pointer and returns the instance address.\n */"
        },
        {
            "identifier": "cloneDeterministic",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, salt);\n    }",
            "start": "201",
            "end": "206",
            "class": "LibClone",
            "signature": "returns (address instance) cloneDeterministicaddress implementation, bytes32 salt",
            "full_signature": "function cloneDeterministic(address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneDeterministicaddress implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using a given implementation and salt.\n *\n * @param implementation The address of the contract implementation to clone.\n * @param salt A unique identifier (bytes32) used to deterministically generate the clone's address.\n * @return instance The address of the newly created clone.\n *\n * Steps:\n * 1. Calls the internal `cloneDeterministic` function with a value of 0, the provided implementation, and salt.\n * 2. Returns the address of the cloned contract instance.\n */"
        },
        {
            "identifier": "cloneDeterministic",
            "parameters": "uint256 value, address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            instance := create2(value, 0x0c, 0x35, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "210",
            "end": "226",
            "class": "LibClone",
            "signature": "returns (address instance) cloneDeterministicuint256 value, address implementation, bytes32 salt",
            "full_signature": "function cloneDeterministic(uint256 value, address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneDeterministicuint256 value, address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using the `create2` opcode.\n *\n * @param value The amount of Ether to send with the contract creation.\n * @param implementation The address of the implementation contract to clone.\n * @param salt A unique salt to ensure deterministic address generation.\n * @return instance The address of the newly created contract instance.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level operations.\n * 2. Store the necessary bytecode and implementation address in memory.\n * 3. Use `create2` to deploy the contract with the provided value, memory offset, and salt.\n * 4. If the deployment fails, revert with a custom error message (`DeploymentFailed`).\n * 5. Restore the overwritten part of the free memory pointer to maintain memory safety.\n */"
        },
        {
            "identifier": "initCode",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCode(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d3d93803e602a57fd5bf30000000000000000000000)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            mstore(c, 0x35) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }",
            "start": "229",
            "end": "239",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeaddress implementation",
            "full_signature": "function initCode(address implementation) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeaddress implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Generates initialization code for a proxy contract using the provided implementation address.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @return c The bytecode for the proxy initialization.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the proxy initialization code template in memory.\n * 3. Store the implementation address in memory at the appropriate offset.\n * 4. Store the proxy initialization code prefix in memory.\n * 5. Store the length of the initialization code.\n * 6. Update the free memory pointer to allocate memory for the initialization code.\n *\n * The generated bytecode is used to deploy a proxy contract that delegates calls to the specified implementation.\n */"
        },
        {
            "identifier": "initCodeHash",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHash(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x21, 0x5af43d3d93803e602a57fd5bf3)\n            mstore(0x14, implementation)\n            mstore(0x00, 0x602c3d8160093d39f33d3d3d3d363d3d37363d73)\n            hash := keccak256(0x0c, 0x35)\n            mstore(0x21, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "242",
            "end": "251",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashaddress implementation",
            "full_signature": "function initCodeHash(address implementation) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashaddress implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for a contract with a given implementation address.\n *\n * @param implementation The address of the contract implementation.\n * @return hash The computed initialization code hash.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level memory operations.\n * 2. Store specific byte sequences in memory to construct the initialization code.\n * 3. Compute the Keccak-256 hash of the constructed initialization code.\n * 4. Restore the overwritten part of the free memory pointer to avoid memory corruption.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "address implementation, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress(address implementation, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        bytes32 hash = initCodeHash(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "255",
            "end": "262",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressaddress implementation, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress(address implementation, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressaddress implementation, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using CREATE2.\n *\n * @param implementation The address of the implementation contract.\n * @param salt A unique salt used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the contract.\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Compute the init code hash for the implementation contract.\n * 2. Use the init code hash, salt, and deployer address to predict the deterministic address.\n * 3. Return the predicted address.\n */"
        },
        {
            "identifier": "initCode_PUSH0",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCode_PUSH0(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x40), 0x5af43d5f5f3e6029573d5ffd5b3d5ff300000000000000000000) // 16\n            mstore(add(c, 0x26), implementation) // 20\n            mstore(add(c, 0x12), 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            mstore(c, 0x36) // Store the length.\n            mstore(0x40, add(c, 0x60)) // Allocate memory.\n        }\n    }",
            "start": "379",
            "end": "389",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCode_PUSH0address implementation",
            "full_signature": "function initCode_PUSH0(address implementation) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCode_PUSH0address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Generates initialization code for a contract using the PUSH0 opcode.\n *\n * @param implementation The address of the implementation contract to be used in the initialization code.\n * @return c The generated initialization code as a bytes array.\n *\n * Steps:\n * 1. Load the free memory pointer (`0x40`) into `c`.\n * 2. Store the first part of the initialization code (16 bytes) at `c + 0x40`.\n * 3. Store the `implementation` address (20 bytes) at `c + 0x26`.\n * 4. Store the second part of the initialization code (18 bytes) at `c + 0x12`.\n * 5. Store the length of the initialization code (0x36 bytes) at the start of `c`.\n * 6. Update the free memory pointer to allocate memory for the initialization code.\n *\n * The generated code is used to initialize a contract with the provided implementation address.\n */"
        },
        {
            "identifier": "initCodeHash_PUSH0",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHash_PUSH0(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x24, 0x5af43d5f5f3e6029573d5ffd5b3d5ff3) // 16\n            mstore(0x14, implementation) // 20\n            mstore(0x00, 0x602d5f8160095f39f35f5f365f5f37365f73) // 9 + 9\n            hash := keccak256(0x0e, 0x36)\n            mstore(0x24, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "392",
            "end": "401",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHash_PUSH0address implementation",
            "full_signature": "function initCodeHash_PUSH0(address implementation) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHash_PUSH0address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the init code hash for a contract using the PUSH0 opcode.\n *\n * @param implementation The address of the implementation contract.\n * @return hash The computed init code hash.\n *\n * Steps:\n * 1. Store specific byte sequences in memory to construct the init code.\n * 2. Store the implementation address in memory.\n * 3. Compute the keccak256 hash of the constructed init code.\n * 4. Restore the overwritten part of the free memory pointer to avoid memory corruption.\n *\n * Note: This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "clone",
            "parameters": "uint256 value, address implementation, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function clone(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------+\n             * CREATION (10 bytes)                                                        |\n             * ---------------------------------------------------------------------------|\n             * Opcode     | Mnemonic          | Stack     | Memory                        |\n             * ---------------------------------------------------------------------------|\n             * 61 runSize | PUSH2 runSize     | r         |                               |\n             * 3d         | RETURNDATASIZE    | 0 r       |                               |\n             * 81         | DUP2              | r 0 r     |                               |\n             * 60 offset  | PUSH1 offset      | o r 0 r   |                               |\n             * 3d         | RETURNDATASIZE    | 0 o r 0 r |                               |\n             * 39         | CODECOPY          | 0 r       | [0..runSize): runtime code    |\n             * f3         | RETURN            |           | [0..runSize): runtime code    |\n             * ---------------------------------------------------------------------------|\n             * RUNTIME (45 bytes + extraLength)                                           |\n             * ---------------------------------------------------------------------------|\n             * Opcode   | Mnemonic       | Stack                  | Memory                |\n             * ---------------------------------------------------------------------------|\n             *                                                                            |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36       | CALLDATASIZE   | cds                    |                       |\n             * 3d       | RETURNDATASIZE | 0 cds                  |                       |\n             * 3d       | RETURNDATASIZE | 0 0 cds                |                       |\n             * 37       | CALLDATACOPY   |                        | [0..cds): calldata    |\n             *                                                                            |\n             * ::: delegate call to the implementation contract ::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | 0                      | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0                    | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 0 0                  | [0..cds): calldata    |\n             * 36       | CALLDATASIZE   | cds 0 0 0              | [0..cds): calldata    |\n             * 3d       | RETURNDATASIZE | 0 cds 0 0 0 0          | [0..cds): calldata    |\n             * 73 addr  | PUSH20 addr    | addr 0 cds 0 0 0 0     | [0..cds): calldata    |\n             * 5a       | GAS            | gas addr 0 cds 0 0 0 0 | [0..cds): calldata    |\n             * f4       | DELEGATECALL   | success 0 0            | [0..cds): calldata    |\n             *                                                                            |\n             * ::: copy return data to memory ::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d       | RETURNDATASIZE | rds success 0          | [0..cds): calldata    |\n             * 82       | DUP3           | 0 rds success 0         | [0..cds): calldata   |\n             * 80       | DUP1           | 0 0 rds success 0      | [0..cds): calldata    |\n             * 3e       | RETURNDATACOPY | success 0              | [0..rds): returndata  |\n             * 90       | SWAP1          | 0 success              | [0..rds): returndata  |\n             * 3d       | RETURNDATASIZE | rds 0 success          | [0..rds): returndata  |\n             * 91       | SWAP2          | success 0 rds          | [0..rds): returndata  |\n             *                                                                            |\n             * 60 0x2b  | PUSH1 0x2b     | 0x2b success 0 rds     | [0..rds): returndata  |\n             * 57       | JUMPI          | 0 rds                  | [0..rds): returndata  |\n             *                                                                            |\n             * ::: revert ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * fd       | REVERT         |                        | [0..rds): returndata  |\n             *                                                                            |\n             * ::: return ::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b       | JUMPDEST       | 0 rds                  | [0..rds): returndata  |\n             * f3       | RETURN         |                        | [0..rds): returndata  |\n             * ---------------------------------------------------------------------------+\n             */\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "425",
            "end": "499",
            "class": "LibClone",
            "signature": "returns (address instance) cloneuint256 value, address implementation, bytes memory args",
            "full_signature": "function clone(uint256 value, address implementation, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneuint256 value, address implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract using the provided implementation and arguments.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract to clone.\n * @param args The encoded arguments to pass to the implementation contract.\n * @return instance The address of the newly created contract instance.\n *\n * Steps:\n * 1. Load the memory pointer and the length of the arguments.\n * 2. Perform a static call to copy the arguments into memory.\n * 3. Store the necessary opcodes and implementation address in memory.\n * 4. Create a new contract instance using the `create` opcode, passing the value, memory pointer, and length.\n * 5. If the deployment fails, revert with a `DeploymentFailed` error.\n * 6. Return the address of the newly created instance.\n *\n * Assembly Details:\n * - The assembly block handles low-level operations to clone the contract.\n * - It uses `CODECOPY` to copy the runtime code and `DELEGATECALL` to delegate the call to the implementation.\n * - It handles memory allocation, copying calldata, and managing return data.\n * - If the deployment fails, it reverts with a custom error.\n */"
        },
        {
            "identifier": "cloneDeterministic",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = cloneDeterministic(0, implementation, args, salt);\n    }",
            "start": "503",
            "end": "508",
            "class": "LibClone",
            "signature": "returns (address instance) cloneDeterministicaddress implementation, bytes memory args, bytes32 salt",
            "full_signature": "function cloneDeterministic(address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneDeterministicaddress implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using a given implementation, arguments, and salt.\n *\n * @param implementation The address of the contract implementation to clone.\n * @param args The encoded arguments to initialize the cloned contract.\n * @param salt A unique value to ensure deterministic deployment.\n * @return instance The address of the newly cloned contract instance.\n *\n * Steps:\n * 1. Call the internal `cloneDeterministic` function with a value of 0, the provided implementation, arguments, and salt.\n * 2. Return the address of the cloned contract instance.\n */"
        },
        {
            "identifier": "cloneDeterministic",
            "parameters": "uint256 value, address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function cloneDeterministic(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            instance := create2(value, add(m, add(0x0b, lt(n, 0xffd3))), add(n, 0x37), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "512",
            "end": "533",
            "class": "LibClone",
            "signature": "returns (address instance) cloneDeterministicuint256 value, address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function cloneDeterministic(uint256 value, address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.cloneDeterministicuint256 value, address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Clones a contract deterministically using `create2` with a given implementation, arguments, and salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract to clone.\n * @param args The encoded arguments to pass to the implementation contract.\n * @param salt A unique salt to ensure deterministic address generation.\n *\n * @return instance The address of the newly deployed contract instance.\n *\n * Steps:\n * 1. Load the free memory pointer (`mload(0x40)`) and the length of the arguments (`mload(args)`).\n * 2. Perform a static call to copy the arguments into memory.\n * 3. Store the deployment bytecode and implementation address in memory.\n * 4. Use `create2` to deploy the contract with the provided value, memory offset, and salt.\n * 5. If the deployment fails, revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "createDeterministicClone",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicClone(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicClone(0, implementation, args, salt);\n    }",
            "start": "538",
            "end": "543",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicCloneaddress implementation, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicClone(address implementation, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicCloneaddress implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic clone of a given implementation contract with specified arguments and salt.\n *\n * @param implementation The address of the implementation contract to clone.\n * @param args The encoded arguments to pass to the clone during deployment.\n * @param salt A unique salt to ensure deterministic address generation for the clone.\n *\n * @return alreadyDeployed A boolean indicating whether the clone was already deployed.\n * @return instance The address of the newly created or existing clone.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicClone` function with a value of 0 (no Ether sent).\n * 2. Returns the result of the internal function call, which includes whether the clone was already deployed and its address.\n */"
        },
        {
            "identifier": "createDeterministicClone",
            "parameters": "uint256 value, address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicClone(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x43), n))\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            // forgefmt: disable-next-item\n            mstore(add(m, gt(n, 0xffd2)), add(0xfe61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x0c), add(n, 0x37)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x0c), add(n, 0x37), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "548",
            "end": "589",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicCloneuint256 value, address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicClone(uint256 value, address implementation, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicCloneuint256 value, address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic clone of a contract using the `create2` opcode.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract to clone.\n * @param args The encoded arguments to pass to the clone during deployment.\n * @param salt A unique salt to ensure deterministic address generation.\n *\n * @return alreadyDeployed A boolean indicating whether the clone was already deployed.\n * @return instance The address of the newly deployed or existing clone.\n *\n * Steps:\n * 1. Load the memory pointer and the length of the arguments.\n * 2. Perform a static call to copy the arguments into memory.\n * 3. Store the deployment bytecode and implementation address in memory.\n * 4. Check if the length of the arguments exceeds the allowed limit and revert if necessary.\n * 5. Compute and store the bytecode hash for the clone.\n * 6. Use the `create2` opcode to deploy the clone with the provided salt.\n * 7. If the deployment fails, revert with a `DeploymentFailed` error.\n * 8. If the clone already exists, mark it as already deployed and optionally send Ether to it.\n * 9. If the Ether transfer fails, revert with an `ETHTransferFailed` error.\n * 10. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "initCode",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCode(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x57), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x37), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(c, 0x28), implementation)\n            mstore(add(c, 0x14), add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            mstore(c, add(0x37, n)) // Store the length.\n            mstore(add(c, add(n, 0x57)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0x77))) // Allocate memory.\n        }\n    }",
            "start": "593",
            "end": "614",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeaddress implementation, bytes memory args",
            "full_signature": "function initCode(address implementation, bytes memory args) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeaddress implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Generates initialization code for a contract using the provided implementation address and arguments.\n *\n * @param implementation The address of the contract implementation.\n * @param args The arguments to be passed to the initialization code.\n * @return c The generated initialization code as a byte array.\n *\n * Steps:\n * 1. Load the length of the arguments (`n`).\n * 2. Perform an out-of-gas revert if `n` exceeds the maximum allowed size (`0xffd2`).\n * 3. Copy the arguments into the initialization code.\n * 4. Append the necessary bytecode for contract initialization, including the implementation address.\n * 5. Store the length of the initialization code.\n * 6. Zeroize the memory slot after the initialization code.\n * 7. Allocate memory for the initialization code.\n *\n * @dev This function uses low-level assembly to construct the initialization code efficiently.\n */"
        },
        {
            "identifier": "initCodeHash",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHash(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x2d = 0xffd2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffd2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x43), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x23), 0x5af43d82803e903d91602b57fd5bf3)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0x61002d3d81600a3d39f3363d3d373d3d3d363d73, shl(136, n)))\n            hash := keccak256(add(m, 0x0c), add(n, 0x37))\n        }\n    }",
            "start": "618",
            "end": "637",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashaddress implementation, bytes memory args",
            "full_signature": "function initCodeHash(address implementation, bytes memory args) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashaddress implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the code hash for a contract with a given implementation and initialization arguments.\n *\n * @param implementation The address of the contract implementation.\n * @param args The initialization arguments for the contract.\n * @return hash The computed code hash.\n *\n * Steps:\n * 1. Load the memory pointer (`m`) to the free memory location.\n * 2. Load the length of the initialization arguments (`n`).\n * 3. Perform a gas check to revert if `n` exceeds the maximum allowed size (`0xffd2`).\n * 4. Copy the initialization arguments into memory.\n * 5. Store the contract creation code prefix in memory.\n * 6. Store the implementation address in memory.\n * 7. Store the contract creation code suffix in memory, adjusted for the length of the arguments.\n * 8. Compute the keccak256 hash of the memory segment containing the contract creation code and arguments.\n * 9. Return the computed hash.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "address implementation, bytes memory data, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress(\n        address implementation,\n        bytes memory data,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHash(implementation, data);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "642",
            "end": "650",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressaddress implementation, bytes memory data, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress(address implementation, bytes memory data, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressaddress implementation, bytes memory data, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using CREATE2.\n *\n * @param implementation The address of the implementation contract.\n * @param data The initialization data for the contract.\n * @param salt A unique salt to ensure the address is deterministic.\n * @param deployer The address of the deployer who will deploy the contract.\n *\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Compute the hash of the initialization code using the `initCodeHash` function.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address.\n * 3. Return the predicted address.\n */"
        },
        {
            "identifier": "argsOnClone",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnClone(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x2d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x2d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "653",
            "end": "661",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnCloneaddress instance",
            "full_signature": "function argsOnClone(address instance) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnCloneaddress instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments passed to a cloned contract instance.\n *\n * @param instance The address of the cloned contract instance.\n * @return args The arguments passed to the cloned contract instance, stored as a byte array.\n *\n * Steps:\n * 1. Allocate memory for the arguments (`args`) using the free memory pointer (`0x40`).\n * 2. Calculate the length of the arguments by subtracting 0x2d from the size of the contract code (`extcodesize`).\n * 3. Copy the arguments from the contract code into the allocated memory using `extcodecopy`.\n * 4. Update the free memory pointer to allocate memory for the next operation.\n *\n * Note: This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "argsOnClone",
            "parameters": "address instance, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnClone(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x2d))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x2d), add(l, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "start": "664",
            "end": "678",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnCloneaddress instance, uint256 start",
            "full_signature": "function argsOnClone(address instance, uint256 start) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnCloneaddress instance, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves arguments from the code of a cloned contract instance.\n *\n * @param instance The address of the cloned contract instance.\n * @param start The starting position in the code from which to retrieve arguments.\n * @return args The extracted arguments as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the arguments using `mload(0x40)`.\n * 2. Calculate the length of the code to copy, considering the starting position.\n * 3. Copy the relevant portion of the code from the instance into the allocated memory.\n * 4. Store the length of the copied arguments in the first 32 bytes of the memory.\n * 5. Update the free memory pointer (`0x40`) to allocate additional memory for the arguments.\n *\n * Note: This function uses low-level assembly to directly interact with the contract's code and memory.\n */"
        },
        {
            "identifier": "argsOnClone",
            "parameters": "address instance, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnClone(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x0d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x2d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "start": "685",
            "end": "705",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnCloneaddress instance, uint256 start, uint256 end",
            "full_signature": "function argsOnClone(address instance, uint256 start, uint256 end) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnCloneaddress instance, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves a specific range of bytes from the code of a given contract instance.\n *\n * @param instance The address of the contract instance from which to retrieve the code.\n * @param start The starting position in the contract's code from which to begin copying.\n * @param end The ending position in the contract's code up to which to copy.\n * @return args The bytes of code copied from the contract instance, within the specified range.\n *\n * Steps:\n * 1. Allocate memory for the `args` variable.\n * 2. Ensure `end` does not exceed the maximum allowed value (0xffff).\n * 3. Calculate the length of the data to be copied (`d`).\n * 4. Copy the specified range of code from the contract instance into the `args` variable.\n * 5. Handle edge cases where the copied data might need adjustment (e.g., zero padding).\n * 6. Store the length of the copied data in the `args` variable.\n * 7. Zeroize the memory slot after the copied data to ensure no leftover data.\n * 8. Update the free memory pointer to allocate memory for the copied data.\n *\n * @dev This function uses low-level assembly to directly interact with the contract's code and memory.\n */"
        },
        {
            "identifier": "deployERC1967",
            "parameters": "uint256 value, address implementation",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (61 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x38    | PUSH1 0x38     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create(value, 0x21, 0x5f)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "721",
            "end": "802",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967uint256 value, address implementation",
            "full_signature": "function deployERC1967(uint256 value, address implementation) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967uint256 value, address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 proxy contract with the specified implementation address.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @return instance The address of the newly deployed proxy contract.\n *\n * Steps:\n * 1. Cache the current free memory pointer.\n * 2. Store the runtime code and initialization code in memory.\n * 3. Use the `create` opcode to deploy the contract with the provided value and memory offset.\n * 4. Check if the deployment was successful. If not, revert with a `DeploymentFailed` error.\n * 5. Restore the free memory pointer and zero slot to their original states.\n *\n * Assembly Details:\n * - The assembly block contains the low-level EVM instructions to deploy the proxy contract.\n * - The runtime code is designed to delegate calls to the implementation contract.\n * - The initialization code sets up the proxy to use the provided implementation address.\n * - The contract deployment is handled using the `create` opcode, which creates a new contract with the specified code and value.\n * - If the deployment fails, the function reverts with a custom error message.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, salt);\n    }",
            "start": "805",
            "end": "810",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967address implementation, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967(address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 proxy contract using the provided implementation address and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param salt A unique identifier (bytes32) used to deterministically compute the address of the deployed proxy.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls an internal function `deployDeterministicERC1967` with a value of 0, the provided implementation address, and the salt.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967",
            "parameters": "uint256 value, address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            instance := create2(value, 0x21, 0x5f, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "814",
            "end": "834",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967uint256 value, address implementation, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967(uint256 value, address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967uint256 value, address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 proxy contract using `create2` with a specified salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract for the proxy.\n * @param salt A unique salt to ensure deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the necessary bytecode and implementation address in memory.\n * 3. Use `create2` to deploy the proxy contract with the provided value, memory offset, and salt.\n * 4. If deployment fails, revert with the `DeploymentFailed()` error.\n * 5. Restore the free memory pointer and zero slot after deployment.\n */"
        },
        {
            "identifier": "createDeterministicERC1967",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, salt);\n    }",
            "start": "839",
            "end": "844",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967address implementation, bytes32 salt",
            "full_signature": "function createDeterministicERC1967(address implementation, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy contract with a given implementation and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param salt A unique identifier (bytes32) used to deterministically compute the address of the deployed proxy.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicERC1967` function with a value of 0, the provided implementation address, and the salt.\n * 2. Returns the deployment status and the address of the proxy contract.\n */"
        },
        {
            "identifier": "createDeterministicERC1967",
            "parameters": "uint256 value, address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x21, 0x5f))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x21, 0x5f, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "850",
            "end": "888",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967uint256 value, address implementation, bytes32 salt",
            "full_signature": "function createDeterministicERC1967(uint256 value, address implementation, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967uint256 value, address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 proxy contract using `create2` with a given salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract for the proxy.\n * @param salt A unique salt used to deterministically compute the contract address.\n * @return alreadyDeployed A boolean indicating whether the contract was already deployed.\n * @return instance The address of the deployed or existing contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the necessary bytecode and implementation address in memory.\n * 3. Compute and store the bytecode hash.\n * 4. Use the `create2` opcode to deploy the contract with the provided salt.\n * 5. If the contract is already deployed, check if the provided value is zero. If not, attempt to send Ether to the existing contract.\n * 6. Handle deployment failures or Ether transfer failures by reverting with appropriate error messages.\n * 7. Restore the free memory pointer and zero slot after deployment.\n *\n * Notes:\n * - The function uses inline assembly for low-level memory manipulation and contract deployment.\n * - The deterministic address is computed using the `create2` opcode, which ensures the same address is generated for the same salt and bytecode.\n * - If the contract is already deployed, the function will return `true` for `alreadyDeployed` and the existing contract address.\n */"
        },
        {
            "identifier": "initCodeERC1967",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x60), 0x3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f300)\n            mstore(add(c, 0x40), 0x55f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076cc)\n            mstore(add(c, 0x20), or(shl(24, implementation), 0x600951))\n            mstore(add(c, 0x09), 0x603d3d8160223d3973)\n            mstore(c, 0x5f) // Store the length.\n            mstore(0x40, add(c, 0x80)) // Allocate memory.\n        }\n    }",
            "start": "891",
            "end": "902",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967address implementation",
            "full_signature": "function initCodeERC1967(address implementation) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Generates the initialization code for an ERC1967 proxy contract.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @return c The bytecode representing the initialization code for the proxy contract.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the proxy contract's initialization code in memory.\n * 3. Store the implementation address in memory, shifted and combined with a specific byte sequence.\n * 4. Store the length of the initialization code.\n * 5. Update the free memory pointer to allocate memory for the initialization code.\n *\n * The initialization code is constructed using inline assembly to ensure memory safety and efficiency.\n */"
        },
        {
            "identifier": "initCodeHashERC1967",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(0x40, 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x20, 0x6009)\n            mstore(0x1e, implementation)\n            mstore(0x0a, 0x603d3d8160223d3973)\n            hash := keccak256(0x21, 0x5f)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "905",
            "end": "918",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967address implementation",
            "full_signature": "function initCodeHashERC1967(address implementation) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for an ERC1967 proxy contract.\n *\n * @param implementation The address of the implementation contract.\n * @return hash The computed initialization code hash.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store specific bytecode patterns in memory to construct the initialization code.\n * 3. Store the implementation address in memory.\n * 4. Compute the Keccak-256 hash of the constructed initialization code.\n * 5. Restore the free memory pointer and zero slot.\n *\n * @dev This function uses inline assembly to manipulate memory and compute the hash.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967",
            "parameters": "address implementation, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "922",
            "end": "929",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967address implementation, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967(address implementation, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967address implementation, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address of a contract to be deployed using the ERC1967 proxy pattern.\n *\n * @param implementation The address of the implementation contract.\n * @param salt A unique salt used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the contract.\n *\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 proxy using the provided implementation address.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address of the contract.\n */"
        },
        {
            "identifier": "deployERC1967",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967(address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967(0, implementation, args);\n    }",
            "start": "936",
            "end": "941",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967address implementation, bytes memory args",
            "full_signature": "function deployERC1967(address implementation, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967address implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 proxy contract with the specified implementation and initialization arguments.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param args The initialization arguments to be passed to the implementation contract.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the `deployERC1967` function with a value of 0 (indicating no Ether is sent), the provided implementation address, and the initialization arguments.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployERC1967",
            "parameters": "uint256 value, address implementation, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create(value, m, add(n, 0x60))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "945",
            "end": "967",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967uint256 value, address implementation, bytes memory args",
            "full_signature": "function deployERC1967(uint256 value, address implementation, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967uint256 value, address implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 proxy contract with the specified implementation and constructor arguments.\n *\n * @param value The amount of Ether to send with the deployment transaction.\n * @param implementation The address of the implementation contract.\n * @param args The encoded constructor arguments for the implementation contract.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Load the free memory pointer and the length of the constructor arguments.\n * 2. Perform a static call to copy the constructor arguments into memory.\n * 3. Store the ERC1967 proxy initialization code in memory.\n * 4. Store the implementation address and other necessary data in memory.\n * 5. Check if the length of the constructor arguments exceeds the allowed limit (0xffc2).\n * 6. Create the proxy contract using the `create` opcode with the provided value, memory pointer, and length.\n * 7. If the deployment fails, revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967(0, implementation, args, salt);\n    }",
            "start": "970",
            "end": "975",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967(address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a new ERC1967 proxy contract deterministically using the provided implementation, arguments, and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param args The encoded arguments to be passed to the implementation contract during deployment.\n * @param salt A unique value to ensure deterministic deployment of the proxy contract.\n *\n * @return instance The address of the newly deployed ERC1967 proxy contract.\n *\n * Steps:\n * 1. Call the internal `deployDeterministicERC1967` function with a value of 0, the provided implementation, arguments, and salt.\n * 2. Return the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967",
            "parameters": "uint256 value, address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            instance := create2(value, m, add(n, 0x60), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "979",
            "end": "1003",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967uint256 value, address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967(uint256 value, address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967uint256 value, address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a new ERC1967 proxy contract deterministically using `create2`.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract.\n * @param args The encoded arguments for the proxy initialization.\n * @param salt The salt used for deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Load the memory pointer and the length of the `args` into `m` and `n` respectively.\n * 2. Perform a static call to copy the `args` into memory.\n * 3. Store the ERC1967 proxy initialization code in memory.\n * 4. Store the implementation address and other necessary data in memory.\n * 5. Check if the length of `args` exceeds the allowed limit (0xffc2). If so, revert with an out-of-gas error.\n * 6. Use `create2` to deploy the contract with the provided `value`, memory data, and `salt`.\n * 7. If the deployment fails, revert with a `DeploymentFailed` error.\n * 8. Return the address of the deployed contract.\n */"
        },
        {
            "identifier": "createDeterministicERC1967",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967(0, implementation, args, salt);\n    }",
            "start": "1008",
            "end": "1013",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967(address implementation, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy contract with the specified implementation, constructor arguments, and salt.\n *\n * @param implementation The address of the implementation contract.\n * @param args The constructor arguments to be passed to the implementation contract.\n * @param salt A unique salt value to ensure deterministic deployment.\n *\n * @return alreadyDeployed A boolean indicating whether the contract was already deployed.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicERC1967` function with a value of 0, the provided implementation, arguments, and salt.\n * 2. Returns the deployment status and the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "createDeterministicERC1967",
            "parameters": "uint256 value, address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x60), n))\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            mstore(gt(n, 0xffc2), add(0xfe61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x60)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(n, 0x60), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "1019",
            "end": "1062",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967uint256 value, address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967(uint256 value, address implementation, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967uint256 value, address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy contract using `create2` with a given salt.\n * \n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract.\n * @param args The encoded arguments to pass to the proxy constructor.\n * @param salt The salt used to deterministically compute the contract address.\n * \n * @return alreadyDeployed A boolean indicating whether the contract was already deployed.\n * @return instance The address of the deployed or existing contract.\n *\n * Steps:\n * 1. Load the memory pointer and the length of the arguments.\n * 2. Perform a static call to copy the arguments into memory.\n * 3. Store the ERC1967 proxy initialization code in memory.\n * 4. Check if the length of the arguments exceeds the allowed limit and revert if it does.\n * 5. Compute and store the bytecode hash for the proxy contract.\n * 6. Use `create2` to deploy the contract if it doesn't already exist.\n * 7. If the contract is already deployed, check if the provided value can be sent to the contract.\n * 8. Revert if the deployment or Ether transfer fails.\n * 9. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "initCodeERC1967",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x80), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x60), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(c, 0x40), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(add(c, 0x20), 0x6009)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x60)) // Store the length.\n            mstore(add(c, add(n, 0x80)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xa0))) // Allocate memory.\n        }\n    }",
            "start": "1065",
            "end": "1088",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967address implementation, bytes memory args",
            "full_signature": "function initCodeERC1967(address implementation, bytes memory args) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967address implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Initializes the code for an ERC1967 proxy contract with a given implementation and arguments.\n *\n * @param implementation The address of the implementation contract.\n * @param args The arguments to be passed to the implementation contract.\n * @return c The bytecode for the ERC1967 proxy contract.\n *\n * Steps:\n * 1. Load the memory pointer for the code.\n * 2. Check if the length of the arguments (`n`) exceeds the maximum allowed size (0xffc2).\n *    If it does, revert with an out-of-gas error.\n * 3. Copy the arguments into the memory location for the code.\n * 4. Store the ERC1967 proxy initialization code in memory.\n * 5. Store the implementation address in memory.\n * 6. Calculate and store the length of the code.\n * 7. Zeroize the memory slot after the code to ensure no leftover data.\n * 8. Allocate memory for the code and return the bytecode.\n *\n * @dev This function uses inline assembly to optimize memory operations and ensure gas efficiency.\n */"
        },
        {
            "identifier": "initCodeHashERC1967",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x3d = 0xffc2`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffc2))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x60), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x40), 0xcc3735a920a3ca505d382bbc545af43d6000803e6038573d6000fd5b3d6000f3)\n            mstore(add(m, 0x20), 0x5155f3363d3d373d3d363d7f360894a13ba1a3210667c828492db98dca3e2076)\n            mstore(0x16, 0x6009)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x61003d3d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(n, 0x60))\n        }\n    }",
            "start": "1091",
            "end": "1113",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967address implementation, bytes memory args",
            "full_signature": "function initCodeHashERC1967(address implementation, bytes memory args) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967address implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for an ERC1967 proxy contract.\n *\n * @param implementation The address of the implementation contract.\n * @param args The byte array containing the constructor arguments for the proxy.\n * @return hash The computed initialization code hash.\n *\n * Steps:\n * 1. Load the memory pointer (`m`) and the length of the arguments (`n`).\n * 2. Perform a gas check to ensure `n` does not exceed the maximum allowed size.\n * 3. Copy the constructor arguments into memory.\n * 4. Store the ERC1967-specific initialization code in memory.\n * 5. Compute the keccak256 hash of the initialization code and return it.\n *\n * @dev This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967",
            "parameters": "address implementation, bytes memory args, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "1117",
            "end": "1125",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967address implementation, bytes memory args, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967(address implementation, bytes memory args, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967address implementation, bytes memory args, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployed using the ERC1967 proxy pattern.\n *\n * @param implementation The address of the implementation contract.\n * @param args The encoded arguments for the initialization of the contract.\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the contract.\n *\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 proxy using the implementation address and arguments.\n * 2. Predict the deterministic address using the computed hash, salt, and deployer address.\n */"
        },
        {
            "identifier": "argsOnERC1967",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x3d))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x3d, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "1128",
            "end": "1136",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967address instance",
            "full_signature": "function argsOnERC1967(address instance) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967address instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments used during the deployment of an ERC1967 proxy contract.\n *\n * @param instance The address of the ERC1967 proxy contract instance.\n * @return args The byte array containing the arguments used during the deployment of the proxy contract.\n *\n * Steps:\n * 1. Allocate memory for the arguments using `mload(0x40)`.\n * 2. Calculate the length of the arguments by subtracting 0x3d from the size of the contract code and masking it to 40 bits.\n * 3. Copy the relevant portion of the contract code (starting from 0x3d) into the allocated memory.\n * 4. Update the free memory pointer to account for the newly allocated memory.\n *\n * @dev This function uses inline assembly to directly interact with the EVM memory and contract code.\n */"
        },
        {
            "identifier": "argsOnERC1967",
            "parameters": "address instance, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x3d))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x3d), add(l, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "start": "1139",
            "end": "1153",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967address instance, uint256 start",
            "full_signature": "function argsOnERC1967(address instance, uint256 start) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967address instance, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves arguments from the ERC1967 implementation contract's bytecode.\n *\n * @param instance The address of the ERC1967 implementation contract.\n * @param start The starting position in the bytecode from which to read the arguments.\n * @return args The extracted arguments as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the arguments using `mload(0x40)`.\n * 2. Calculate the length of the arguments by subtracting the start position from the total bytecode size.\n * 3. Copy the relevant portion of the bytecode into the allocated memory.\n * 4. Store the length of the arguments in the first 32 bytes of the allocated memory.\n * 5. Update the free memory pointer (`0x40`) to account for the allocated memory.\n *\n * Note: This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "argsOnERC1967",
            "parameters": "address instance, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x1d), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x3d)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "start": "1160",
            "end": "1180",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967address instance, uint256 start, uint256 end",
            "full_signature": "function argsOnERC1967(address instance, uint256 start, uint256 end) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967address instance, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to extract and return a specific range of bytes from the code of a given instance.\n *\n * @param instance The address of the contract instance from which to extract the code.\n * @param start The starting position in the code from which to begin extraction.\n * @param end The ending position in the code up to which extraction should occur.\n * @return args The extracted bytes from the specified range of the contract's code.\n *\n * Steps:\n * 1. Allocate memory for the `args` variable.\n * 2. Ensure the `end` value does not exceed 0xffff.\n * 3. Calculate the length of the data to be copied (`d`).\n * 4. Use `extcodecopy` to copy the specified range of bytes from the contract's code into the `args` variable.\n * 5. Handle edge cases where the extracted data might need adjustment.\n * 6. Store the length of the extracted data in the first 32 bytes of `args`.\n * 7. Zeroize the memory slot immediately after the extracted data.\n * 8. Update the free memory pointer to allocate memory for the extracted data.\n *\n * @dev This function uses low-level assembly to directly interact with the contract's bytecode.\n */"
        },
        {
            "identifier": "deployERC1967I",
            "parameters": "uint256 value, address implementation",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967I(uint256 value, address implementation)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 impl    | PUSH20 impl    | impl 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos impl 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot impl 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: check calldatasize ::::::::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 58         | PC             | 1 cds            |                                 |\n             * 14         | EQ             | eqs              |                                 |\n             * 60 0x43    | PUSH1 0x43     | dest eqs         |                                 |\n             * 57         | JUMPI          |                  |                                 |\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             * 7f slot    | PUSH32 slot    | s 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 54         | SLOAD          | i 0 cds 0 0      | [0..calldatasize): calldata     |\n             * 5a         | GAS            | g i 0 cds 0 0    | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x3E    | PUSH1 0x3E     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: implementation , return :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  |                                 |\n             * 60 0x20    | PUSH1 0x20     | 32               |                                 |\n             * 60 0x0F    | PUSH1 0x0F     | o 32             |                                 |\n             * 3d         | RETURNDATASIZE | 0 o 32           |                                 |\n             * 39         | CODECOPY       |                  | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0                | [0..32): implementation slot    |\n             * 51         | MLOAD          | slot             | [0..32): implementation slot    |\n             * 54         | SLOAD          | impl             | [0..32): implementation slot    |\n             * 3d         | RETURNDATASIZE | 0 impl           | [0..32): implementation slot    |\n             * 52         | MSTORE         |                  | [0..32): implementation address |\n             * 59         | MSIZE          | 32               | [0..32): implementation address |\n             * 3d         | RETURNDATASIZE | 0 32             | [0..32): implementation address |\n             * f3         | RETURN         |                  | [0..32): implementation address |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1198",
            "end": "1300",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967Iuint256 value, address implementation",
            "full_signature": "function deployERC1967I(uint256 value, address implementation) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967Iuint256 value, address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 proxy contract with the given implementation address and value.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @return instance The address of the newly deployed proxy contract.\n *\n * Steps:\n * 1. Cache the current free memory pointer.\n * 2. Store the runtime bytecode in memory, which includes the logic for the proxy contract.\n * 3. Store the creation code in memory, which includes the initialization of the proxy contract.\n * 4. Combine the implementation address with the creation code and store it in memory.\n * 5. Use the `create` opcode to deploy the contract with the specified value and bytecode.\n * 6. Check if the deployment was successful. If not, revert with a `DeploymentFailed` error.\n * 7. Restore the free memory pointer and zero slot to their original states.\n * 8. Return the address of the deployed proxy contract.\n *\n * The deployed proxy contract will delegate all calls to the provided implementation address.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967I",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, salt);\n    }",
            "start": "1303",
            "end": "1308",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967Iaddress implementation, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967I(address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967Iaddress implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 proxy instance with a given implementation and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param salt A unique identifier (bytes32) used to deterministically generate the proxy address.\n * @return instance The address of the deployed proxy instance.\n *\n * Steps:\n * 1. Calls the `deployDeterministicERC1967I` function with a value of 0, the provided implementation address, and the salt.\n * 2. Returns the address of the deployed proxy instance.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967I",
            "parameters": "uint256 value, address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1312",
            "end": "1331",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967Iuint256 value, address implementation, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967I(uint256 value, address implementation, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967Iuint256 value, address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 proxy instance using `create2` with a given salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract.\n * @param salt A unique salt to ensure deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Load the precompiled bytecode for the ERC1967 proxy into memory.\n * 3. Store the implementation address in the appropriate memory location.\n * 4. Use `create2` to deploy the proxy contract with the provided value and salt.\n * 5. If deployment fails, revert with the `DeploymentFailed()` error.\n * 6. Restore the free memory pointer and zero slot after deployment.\n *\n * @dev This function uses inline assembly to optimize gas usage and ensure deterministic deployment.\n */ "
        },
        {
            "identifier": "createDeterministicERC1967I",
            "parameters": "address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967I(address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, salt);\n    }",
            "start": "1336",
            "end": "1341",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967Iaddress implementation, bytes32 salt",
            "full_signature": "function createDeterministicERC1967I(address implementation, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967Iaddress implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy instance with a given implementation and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param salt A unique identifier (bytes32) used to deterministically generate the proxy address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the newly created or existing proxy instance.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicERC1967I` function with a value of 0, the provided implementation, and salt.\n * 2. Returns whether the proxy was already deployed and the address of the proxy instance.\n */"
        },
        {
            "identifier": "createDeterministicERC1967I",
            "parameters": "uint256 value, address implementation, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1347",
            "end": "1384",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967Iuint256 value, address implementation, bytes32 salt",
            "full_signature": "function createDeterministicERC1967I(uint256 value, address implementation, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967Iuint256 value, address implementation, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy instance using CREATE2, ensuring the same salt produces the same address.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract for the proxy.\n * @param salt A unique salt to ensure deterministic address generation.\n *\n * @return alreadyDeployed A boolean indicating if the instance was already deployed.\n * @return instance The address of the deployed or existing proxy instance.\n *\n * Steps:\n * 1. Cache the free memory pointer and prepare the bytecode for the proxy.\n * 2. Compute and store the bytecode hash.\n * 3. Generate the deterministic address using the salt and bytecode hash.\n * 4. Check if the instance already exists by verifying its code size.\n * 5. If the instance does not exist, deploy it using CREATE2 with the provided value and salt.\n * 6. If the deployment fails, revert with a `DeploymentFailed` error.\n * 7. If the instance already exists, mark it as `alreadyDeployed`.\n * 8. If Ether is sent with the call, attempt to transfer it to the instance.\n * 9. If the Ether transfer fails, revert with an `ETHTransferFailed` error.\n * 10. Restore the free memory pointer and zero slot after the operation.\n *\n * @dev This function uses low-level assembly to handle the deployment logic efficiently.\n */"
        },
        {
            "identifier": "initCodeERC1967I",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967I(address implementation) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x54), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x34), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1d), implementation)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }",
            "start": "1387",
            "end": "1400",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967Iaddress implementation",
            "full_signature": "function initCodeERC1967I(address implementation) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967Iaddress implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Generates the initialization code for an ERC1967 proxy contract with the given implementation address.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @return c The bytecode for the initialization code.\n *\n * Steps:\n * 1. Allocate memory for the initialization code.\n * 2. Use inline assembly to construct the initialization code:\n *    - Store the proxy contract's initialization bytecode at specific memory offsets.\n *    - Store the implementation address at the appropriate offset.\n *    - Store the length of the initialization code.\n *    - Allocate additional memory to ensure proper memory management.\n * 3. Return the generated initialization code as a byte array.\n *\n * Note: This function is marked as `internal pure` and uses low-level assembly to construct the bytecode.\n */"
        },
        {
            "identifier": "initCodeHashERC1967I",
            "parameters": "address implementation",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967I(address implementation) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(0x40, 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(0x20, 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, implementation))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1403",
            "end": "1415",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967Iaddress implementation",
            "full_signature": "function initCodeHashERC1967I(address implementation) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967Iaddress implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the code hash for an ERC1967 implementation contract using inline assembly.\n *\n * @param implementation The address of the implementation contract.\n * @return hash The computed code hash.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store pre-defined bytecode in memory at specific offsets.\n * 3. Combine the implementation address with the bytecode.\n * 4. Compute the keccak256 hash of the combined data.\n * 5. Restore the free memory pointer and zero slot.\n *\n * Note: This function uses low-level assembly to optimize gas usage and memory management.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967I",
            "parameters": "address implementation, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "1419",
            "end": "1426",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967Iaddress implementation, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967I(address implementation, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967Iaddress implementation, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployed using the ERC1967 proxy pattern.\n *\n * @param implementation The address of the implementation contract.\n * @param salt A unique salt used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the contract.\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 implementation.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address.\n */"
        },
        {
            "identifier": "deployERC1967I",
            "parameters": "uint256 value, address implementation, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967I(uint256 value, address implementation, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "1439",
            "end": "1462",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967Iuint256 value, address implementation, bytes memory args",
            "full_signature": "function deployERC1967I(uint256 value, address implementation, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967Iuint256 value, address implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 proxy contract with a specified implementation and initialization arguments.\n *\n * @param value The amount of Ether (in wei) to send with the deployment transaction.\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param args The initialization arguments to be passed to the implementation contract.\n * @return instance The address of the newly deployed proxy contract.\n *\n * Steps:\n * 1. Load the free memory pointer and the length of the initialization arguments.\n * 2. Perform a static call to copy the initialization arguments into memory.\n * 3. Store the proxy contract's initialization code in memory.\n * 4. Store the implementation address in memory.\n * 5. Store the length of the initialization arguments in memory.\n * 6. Create the proxy contract using the `create` opcode, passing the value, memory offset, and length.\n * 7. If the deployment fails (instance is zero), revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967I",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967I(0, implementation, args, salt);\n    }",
            "start": "1465",
            "end": "1470",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967Iaddress implementation, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967Iaddress implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a new ERC1967 proxy contract deterministically using the provided implementation, arguments, and salt.\n *\n * @param implementation The address of the implementation contract to be used by the proxy.\n * @param args The encoded arguments to be passed to the implementation contract during deployment.\n * @param salt A unique salt value to ensure deterministic deployment.\n * @return instance The address of the newly deployed proxy contract.\n *\n * Steps:\n * 1. Calls the `deployDeterministicERC1967I` function with a value of 0, the provided implementation, arguments, and salt.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967I",
            "parameters": "uint256 value, address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n\n            mstore(add(m, 0x6b), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x4b), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x2b), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(m, 0x14), implementation)\n            mstore(m, add(0xfe6100523d8160233d3973, shl(56, n)))\n\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            instance := create2(value, add(m, add(0x15, lt(n, 0xffae))), add(0x75, n), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "1474",
            "end": "1499",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967Iuint256 value, address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967I(uint256 value, address implementation, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967Iuint256 value, address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 proxy contract using the `create2` opcode.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract.\n * @param args The encoded arguments to pass to the implementation contract.\n * @param salt The salt used to deterministically generate the contract address.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Load the free memory pointer and the length of the `args` into memory.\n * 2. Perform a static call to copy the `args` into memory.\n * 3. Store the proxy contract's initialization code in memory.\n * 4. Store the implementation address in memory.\n * 5. Store the length of the `args` in memory.\n * 6. Use `create2` to deploy the contract with the provided `value`, memory offset, length, and `salt`.\n * 7. If the deployment fails, revert with a `DeploymentFailed` error.\n * 8. Return the address of the deployed contract.\n */"
        },
        {
            "identifier": "createDeterministicERC1967I",
            "parameters": "address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967I(0, implementation, args, salt);\n    }",
            "start": "1504",
            "end": "1509",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967Iaddress implementation, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967I(address implementation, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967Iaddress implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy instance with the given implementation, constructor arguments, and salt.\n *\n * @param implementation The address of the implementation contract.\n * @param args The constructor arguments to be passed to the implementation contract.\n * @param salt A unique salt value to ensure deterministic deployment.\n *\n * @return alreadyDeployed A boolean indicating whether the instance was already deployed.\n * @return instance The address of the deployed proxy instance.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicERC1967I` function with a value of 0, the provided implementation, args, and salt.\n * 2. Returns the result of the internal function call, which includes whether the instance was already deployed and the instance address.\n */"
        },
        {
            "identifier": "createDeterministicERC1967I",
            "parameters": "uint256 value, address implementation, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967I(\n        uint256 value,\n        address implementation,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x75), n))\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(gt(n, 0xffad), add(0xfe6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(m, add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, m, add(0x75, n), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "1515",
            "end": "1559",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967Iuint256 value, address implementation, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967I(uint256 value, address implementation, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967Iuint256 value, address implementation, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy instance using `create2` with a given salt.\n * \n * @param value The amount of Ether to send with the deployment.\n * @param implementation The address of the implementation contract for the proxy.\n * @param args The encoded arguments to pass to the proxy constructor.\n * @param salt The salt used to deterministically compute the address of the proxy.\n * \n * @return alreadyDeployed A boolean indicating whether the instance was already deployed.\n * @return instance The address of the deployed proxy instance.\n * \n * Steps:\n * 1. Load the memory pointer and the length of the arguments.\n * 2. Perform a static call to copy the arguments into memory.\n * 3. Store the proxy initialization code and implementation address in memory.\n * 4. Compute the bytecode hash and store it in memory.\n * 5. Compute the deterministic address using `keccak256` with the salt.\n * 6. Check if the instance already exists by checking its code size.\n * 7. If the instance does not exist, deploy it using `create2` with the provided value, bytecode, and salt.\n * 8. If the deployment fails, revert with a `DeploymentFailed` error.\n * 9. If the instance already exists, mark it as already deployed.\n * 10. If Ether is sent, attempt to transfer it to the instance. If the transfer fails, revert with an `ETHTransferFailed` error.\n * 11. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "initCodeERC1967I",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(c, 0x75), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(c, 0x55), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(c, 0x35), 0x600f5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(add(c, 0x1e), implementation)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x95)), 0)\n            mstore(c, add(0x75, n)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }",
            "start": "1562",
            "end": "1586",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967Iaddress implementation, bytes memory args",
            "full_signature": "function initCodeERC1967I(address implementation, bytes memory args) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967Iaddress implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Generates and returns the initialization code for an ERC1967 proxy contract.\n *\n * @param implementation The address of the implementation contract.\n * @param args The arguments to be passed to the implementation contract during initialization.\n * @return c The generated initialization code as a byte array.\n *\n * Steps:\n * 1. Load the memory pointer for the code.\n * 2. Retrieve the length of the `args` byte array.\n * 3. Perform an out-of-gas revert if the length of `args` exceeds the allowed limit (0xffad).\n * 4. Copy the `args` data into the initialization code.\n * 5. Store the necessary opcodes and implementation address in the initialization code.\n * 6. Store the length of the initialization code.\n * 7. Allocate memory for the initialization code.\n * 8. Return the generated initialization code.\n *\n * @dev This function uses inline assembly to construct the initialization code for an ERC1967 proxy.\n * The code includes the implementation address and the arguments for the proxy's initialization.\n */"
        },
        {
            "identifier": "initCodeHashERC1967I",
            "parameters": "address implementation, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967I(address implementation, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x75), i), mload(add(add(args, 0x20), i)))\n            }\n\n            mstore(add(m, 0x55), 0x3d6000803e603e573d6000fd5b3d6000f35b6020600f3d393d51543d52593df3)\n            mstore(add(m, 0x35), 0xa13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545af4)\n            mstore(add(m, 0x15), 0x5155f3365814604357363d3d373d3d363d7f360894)\n            mstore(0x16, 0x600f)\n            mstore(0x14, implementation)\n            mstore(0x00, add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(m, mload(0x16))\n            hash := keccak256(m, add(0x75, n))\n        }\n    }",
            "start": "1589",
            "end": "1614",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967Iaddress implementation, bytes memory args",
            "full_signature": "function initCodeHashERC1967I(address implementation, bytes memory args) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967Iaddress implementation, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the code hash for an ERC1967 proxy implementation with given initialization arguments.\n *\n * @param implementation The address of the implementation contract.\n * @param args The initialization arguments to be passed to the implementation contract.\n * @return hash The computed code hash.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Load the length of the initialization arguments (`args`).\n * 3. Perform an out-of-gas revert if the length of `args` exceeds the allowed limit (`0xffad`).\n * 4. Copy the initialization arguments into memory.\n * 5. Store the ERC1967 proxy initialization code in memory.\n * 6. Store the implementation address in memory.\n * 7. Compute the code hash using the stored memory data and the length of the initialization arguments.\n *\n * @dev This function uses inline assembly to optimize memory operations and ensure gas efficiency.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967I",
            "parameters": "address implementation, bytes memory args, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967I(\n        address implementation,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967I(implementation, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "1618",
            "end": "1626",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967Iaddress implementation, bytes memory args, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967I(address implementation, bytes memory args, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967Iaddress implementation, bytes memory args, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address of a contract to be deployed using the ERC1967 proxy pattern.\n *\n * @param implementation The address of the implementation contract.\n * @param args The encoded arguments for the initialization of the contract.\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the contract.\n * @return predicted The predicted address of the contract that will be deployed.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 proxy pattern using the implementation address and arguments.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address of the contract.\n */"
        },
        {
            "identifier": "argsOnERC1967I",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967I(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "1629",
            "end": "1637",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967Iaddress instance",
            "full_signature": "function argsOnERC1967I(address instance) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967Iaddress instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to retrieve the arguments from an ERC1967 implementation contract.\n *\n * @param instance The address of the ERC1967 implementation contract.\n * @return args The bytes array containing the arguments retrieved from the contract.\n *\n * Steps:\n * 1. Allocate memory for the `args` array.\n * 2. Calculate the length of the arguments by subtracting 0x52 from the contract's code size and masking it.\n * 3. Copy the contract's code starting from offset 0x52 into the `args` array.\n * 4. Update the free memory pointer to allocate memory for the next operation.\n *\n * @dev This function uses inline assembly to directly interact with memory and contract code.\n */"
        },
        {
            "identifier": "argsOnERC1967I",
            "parameters": "address instance, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967I(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x52), add(l, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "1640",
            "end": "1654",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967Iaddress instance, uint256 start",
            "full_signature": "function argsOnERC1967I(address instance, uint256 start) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967Iaddress instance, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves arguments from the ERC1967 interface of a given contract instance starting from a specified position.\n *\n * @param instance The address of the contract instance from which to retrieve the arguments.\n * @param start The starting position in the contract's code from which to begin reading the arguments.\n * @return args A bytes array containing the retrieved arguments.\n *\n * Steps:\n * 1. Allocate memory for the `args` array.\n * 2. Calculate the length of the code to be copied, considering the `start` position.\n * 3. Copy the relevant portion of the contract's code into the `args` array.\n * 4. Store the length of the copied code in the `args` array.\n * 5. Update the free memory pointer to account for the allocated memory.\n *\n * @dev This function uses inline assembly to directly interact with the contract's code and memory.\n */"
        },
        {
            "identifier": "argsOnERC1967I",
            "parameters": "address instance, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967I(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "start": "1661",
            "end": "1681",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967Iaddress instance, uint256 start, uint256 end",
            "full_signature": "function argsOnERC1967I(address instance, uint256 start, uint256 end) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967Iaddress instance, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to retrieve arguments from an ERC1967-compatible contract instance.\n *\n * @param instance The address of the ERC1967-compatible contract instance.\n * @param start The starting position in the contract's code to begin copying.\n * @param end The ending position in the contract's code to stop copying.\n * @return args A bytes array containing the copied data from the contract's code.\n *\n * Steps:\n * 1. Allocate memory for the `args` array.\n * 2. Ensure `end` does not exceed the maximum allowed value (0xffff).\n * 3. Calculate the length of the data to be copied (`d`).\n * 4. Use `extcodecopy` to copy the specified range of code from the contract instance into the `args` array.\n * 5. Check if the last byte of the copied data is zero, and adjust the length if necessary.\n * 6. Store the length of the copied data in the `args` array.\n * 7. Zeroize the memory slot after the copied data to prevent data leakage.\n * 8. Update the free memory pointer to allocate memory for the `args` array.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and is marked as memory-safe.\n */"
        },
        {
            "identifier": "erc1967Bootstrap",
            "parameters": "address authorizedUpgrader",
            "modifiers": "",
            "return": "returns (address bootstrap)",
            "body": "function erc1967Bootstrap(address authorizedUpgrader) internal returns (address bootstrap) {\n        bytes memory c = initCodeERC1967Bootstrap(authorizedUpgrader);\n        bootstrap = predictDeterministicAddress(keccak256(c), bytes32(0), address(this));\n        /// @solidity memory-safe-assembly\n        assembly {\n            if iszero(extcodesize(bootstrap)) {\n                if iszero(create2(0, add(c, 0x20), mload(c), 0)) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n        }\n    }",
            "start": "1702",
            "end": "1714",
            "class": "LibClone",
            "signature": "returns (address bootstrap) erc1967Bootstrapaddress authorizedUpgrader",
            "full_signature": "function erc1967Bootstrap(address authorizedUpgrader) internal   returns (address bootstrap)",
            "class_method_signature": "LibClone.erc1967Bootstrapaddress authorizedUpgrader",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Bootstraps an ERC1967 proxy by deploying a new contract using `create2` with deterministic address calculation.\n *\n * @param authorizedUpgrader The address authorized to upgrade the proxy.\n * @return bootstrap The address of the newly deployed bootstrap contract.\n *\n * Steps:\n * 1. Generate the initialization code for the ERC1967 bootstrap contract using `initCodeERC1967Bootstrap`.\n * 2. Predict the deterministic address of the bootstrap contract using `predictDeterministicAddress`.\n * 3. Check if the bootstrap contract already exists at the predicted address using `extcodesize`.\n * 4. If the contract does not exist, deploy it using `create2` with the generated initialization code.\n * 5. If the deployment fails, revert with the error `DeploymentFailed()`.\n * 6. Return the address of the deployed bootstrap contract.\n */"
        },
        {
            "identifier": "bootstrapERC1967",
            "parameters": "address instance, address implementation",
            "modifiers": "",
            "return": "",
            "body": "function bootstrapERC1967(address instance, address implementation) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, implementation)\n            if iszero(call(gas(), instance, 0, 0x0c, 0x14, codesize(), 0x00)) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "1717",
            "end": "1726",
            "class": "LibClone",
            "signature": " bootstrapERC1967address instance, address implementation",
            "full_signature": "function bootstrapERC1967(address instance, address implementation) internal",
            "class_method_signature": "LibClone.bootstrapERC1967address instance, address implementation",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Bootstraps an ERC1967 proxy by setting its implementation address.\n *\n * @dev This function uses low-level assembly to interact with the proxy contract.\n * It stores the implementation address in memory and attempts to call the proxy\n * contract to set the implementation. If the call fails, it reverts with a custom\n * error `DeploymentFailed()`.\n *\n * @param instance The address of the proxy contract.\n * @param implementation The address of the implementation contract to be set.\n *\n * Steps:\n * 1. Store the implementation address in memory at position 0x00.\n * 2. Attempt to call the proxy contract with the implementation data.\n * 3. If the call fails, revert with the custom error `DeploymentFailed()`.\n */"
        },
        {
            "identifier": "bootstrapERC1967AndCall",
            "parameters": "address instance, address implementation, bytes memory data",
            "modifiers": "",
            "return": "",
            "body": "function bootstrapERC1967AndCall(address instance, address implementation, bytes memory data)\n        internal\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mload(data)\n            mstore(data, implementation)\n            if iszero(call(gas(), instance, 0, add(data, 0x0c), add(n, 0x14), codesize(), 0x00)) {\n                if iszero(returndatasize()) {\n                    mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                returndatacopy(mload(0x40), 0x00, returndatasize())\n                revert(mload(0x40), returndatasize())\n            }\n            mstore(data, n) // Restore the length of `data`.\n        }\n    }",
            "start": "1729",
            "end": "1746",
            "class": "LibClone",
            "signature": " bootstrapERC1967AndCalladdress instance, address implementation, bytes memory data",
            "full_signature": "function bootstrapERC1967AndCall(address instance, address implementation, bytes memory data) internal",
            "class_method_signature": "LibClone.bootstrapERC1967AndCalladdress instance, address implementation, bytes memory data",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Bootstraps an ERC1967 proxy contract and calls a function on it.\n *\n * @param instance The address of the proxy contract instance.\n * @param implementation The address of the implementation contract to be set in the proxy.\n * @param data The calldata to be passed to the proxy contract after setting the implementation.\n *\n * Steps:\n * 1. Load the length of the `data` into memory.\n * 2. Store the `implementation` address at the beginning of the `data` in memory.\n * 3. Perform a low-level call to the `instance` address with the modified `data`.\n * 4. If the call fails:\n *    a. If there is no return data, revert with a custom error `DeploymentFailed()`.\n *    b. If there is return data, copy it to memory and revert with the return data.\n * 5. Restore the original length of `data` in memory.\n *\n * @dev This function uses inline assembly to manipulate memory and perform low-level calls.\n *      It is designed to be memory-safe and handles reverts gracefully.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967Bootstrap",
            "parameters": "address authorizedUpgrader, address deployer",
            "modifiers": "pure",
            "return": "returns (address)",
            "body": "function predictDeterministicAddressERC1967Bootstrap(\n        address authorizedUpgrader,\n        address deployer\n    ) internal pure returns (address) {\n        bytes32 hash = initCodeHashERC1967Bootstrap(authorizedUpgrader);\n        return predictDeterministicAddress(hash, bytes32(0), deployer);\n    }",
            "start": "1754",
            "end": "1760",
            "class": "LibClone",
            "signature": "returns (address) predictDeterministicAddressERC1967Bootstrapaddress authorizedUpgrader, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967Bootstrap(address authorizedUpgrader, address deployer) internal  pure returns (address)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967Bootstrapaddress authorizedUpgrader, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for an ERC1967 Bootstrap contract.\n *\n * @param authorizedUpgrader The address of the authorized upgrader.\n * @param deployer The address of the deployer.\n * @return The predicted deterministic address for the ERC1967 Bootstrap contract.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 Bootstrap contract using the authorized upgrader's address.\n * 2. Predict the deterministic address using the computed hash, a salt of `bytes32(0)`, and the deployer's address.\n * 3. Return the predicted address.\n */"
        },
        {
            "identifier": "initCodeERC1967Bootstrap",
            "parameters": "address authorizedUpgrader",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967Bootstrap(address authorizedUpgrader)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x80), 0x3d3560601c5af46047573d6000383e3d38fd0000000000000000000000000000)\n            mstore(add(c, 0x60), 0xa920a3ca505d382bbc55601436116049575b005b363d3d373d3d601436036014)\n            mstore(add(c, 0x40), 0x0338573d3560601c7f360894a13ba1a3210667c828492db98dca3e2076cc3735)\n            mstore(add(c, 0x20), authorizedUpgrader)\n            mstore(add(c, 0x0c), 0x606880600a3d393df3fe3373)\n            mstore(c, 0x72)\n            mstore(0x40, add(c, 0xa0))\n        }\n    }",
            "start": "1763",
            "end": "1779",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967Bootstrapaddress authorizedUpgrader",
            "full_signature": "function initCodeERC1967Bootstrap(address authorizedUpgrader) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967Bootstrapaddress authorizedUpgrader",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Generates the initialization code for an ERC1967 proxy contract with a bootstrap mechanism.\n *\n * @param authorizedUpgrader The address authorized to upgrade the proxy contract.\n * @return c The generated initialization code as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the initialization code.\n * 2. Use inline assembly to construct the initialization code:\n *    - Store specific bytecode patterns in memory to set up the proxy contract.\n *    - Store the `authorizedUpgrader` address in the appropriate memory location.\n *    - Adjust the memory pointer to account for the stored data.\n * 3. Return the generated initialization code.\n *\n * Note: This function uses low-level assembly to construct the initialization code, which is typically used in proxy patterns.\n */"
        },
        {
            "identifier": "deployERC1967BeaconProxy",
            "parameters": "uint256 value, address beacon",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967BeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (82 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * 50            | POP              |                             | impl            |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 80         | DUP1           | 0 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x4d    | PUSH1 0x4d     | dest succ        | [0..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * fd         | REVERT         |                  | [0..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [0..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [0..returndatasize): returndata |\n             * 60 0x00    | PUSH1 0x00     | 0 rds            | [0..returndatasize): returndata |\n             * f3         | RETURN         |                  | [0..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x0c, 0x74)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1807",
            "end": "1904",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967BeaconProxyuint256 value, address beacon",
            "full_signature": "function deployERC1967BeaconProxy(uint256 value, address beacon) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967BeaconProxyuint256 value, address beacon",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 Beacon Proxy contract using low-level assembly.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that will provide the implementation logic.\n * @return instance The address of the newly deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer to restore it later.\n * 2. Store the runtime code and initialization code in memory.\n * 3. Use the `create` opcode to deploy the proxy contract with the provided value and code.\n * 4. Check if the deployment was successful. If not, revert with a `DeploymentFailed` error.\n * 5. Restore the free memory pointer and zero slot to their original states.\n *\n * The proxy contract delegates calls to the implementation provided by the beacon contract.\n * The assembly code handles the creation of the proxy, including copying calldata, performing a static call to the beacon,\n * and managing the return data and execution flow.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967BeaconProxy",
            "parameters": "address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }",
            "start": "1907",
            "end": "1912",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967BeaconProxyaddress beacon, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967BeaconProxy(address beacon, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967BeaconProxyaddress beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 Beacon Proxy contract using the provided beacon address and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param salt A unique identifier (bytes32) used to deterministically compute the address of the deployed proxy.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `deployDeterministicERC1967BeaconProxy` function with a value of `0` (no Ether sent), \n *    the provided beacon address, and the salt.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967BeaconProxy",
            "parameters": "uint256 value, address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x0c, 0x74, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1916",
            "end": "1935",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 Beacon Proxy using `create2` with a specified salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract to be used by the proxy.\n * @param salt A unique salt to ensure deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the precomputed bytecode for the ERC1967 Beacon Proxy in memory.\n * 3. Use `create2` to deploy the proxy contract with the provided value, bytecode, and salt.\n * 4. If deployment fails, revert with the error `DeploymentFailed()`.\n * 5. Restore the free memory pointer and zero slot after deployment.\n *\n * Assembly Details:\n * - The bytecode is constructed in memory using `mstore` and `shl`/`shr` operations.\n * - The `create2` opcode is used to deploy the contract with deterministic address generation.\n * - The function ensures memory safety by restoring the free memory pointer and zero slot.\n */"
        },
        {
            "identifier": "createDeterministicERC1967BeaconProxy",
            "parameters": "address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, salt);\n    }",
            "start": "1940",
            "end": "1945",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967BeaconProxyaddress beacon, bytes32 salt",
            "full_signature": "function createDeterministicERC1967BeaconProxy(address beacon, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967BeaconProxyaddress beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 beacon proxy using the provided beacon address and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param salt A unique identifier used to deterministically compute the proxy's address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the newly created or existing proxy instance.\n *\n * Steps:\n * 1. Calls an internal function `createDeterministicERC1967BeaconProxy` with a value of `0` for the first parameter,\n *    along with the provided `beacon` and `salt`.\n * 2. Returns the result of the internal function call, which includes whether the proxy was already deployed and its address.\n */"
        },
        {
            "identifier": "createDeterministicERC1967BeaconProxy",
            "parameters": "uint256 value, address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x0c, 0x74))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x0c, 0x74, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "1951",
            "end": "1988",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes32 salt",
            "full_signature": "function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 beacon proxy using CREATE2.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract.\n * @param salt The salt used to deterministically generate the proxy address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the deployed or existing proxy.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the precomputed bytecode for the proxy in memory.\n * 3. Compute and store the bytecode hash.\n * 4. Prepare the CREATE2 deployment parameters, including the salt and the deployer address.\n * 5. Compute the expected address of the proxy using the salt and bytecode hash.\n * 6. Check if the proxy is already deployed by checking the code size at the computed address.\n * 7. If not deployed, create the proxy using CREATE2 with the provided value, bytecode, and salt.\n * 8. If the deployment fails, revert with a `DeploymentFailed` error.\n * 9. If the proxy is already deployed, set `alreadyDeployed` to true.\n * 10. If Ether is sent with the call, attempt to transfer it to the proxy.\n * 11. If the Ether transfer fails, revert with an `ETHTransferFailed` error.\n * 12. Restore the free memory pointer and zero slot.\n */"
        },
        {
            "identifier": "initCodeERC1967BeaconProxy",
            "parameters": "address beacon",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967BeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x74), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x54), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x34), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60523d8160223d3973)\n            mstore(add(c, 0x94), 0)\n            mstore(c, 0x74) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }",
            "start": "1991",
            "end": "2004",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967BeaconProxyaddress beacon",
            "full_signature": "function initCodeERC1967BeaconProxy(address beacon) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967BeaconProxyaddress beacon",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Generates the initialization code for an ERC1967 Beacon Proxy contract.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @return c The bytecode for the proxy initialization.\n *\n * Steps:\n * 1. Allocate memory for the bytecode.\n * 2. Store the precomputed bytecode segments in the allocated memory.\n * 3. Store the beacon address in the appropriate position within the bytecode.\n * 4. Store the length of the bytecode.\n * 5. Allocate additional memory for the bytecode.\n * 6. Return the generated bytecode.\n *\n * Note: This function uses inline assembly to construct the bytecode for the proxy initialization.\n */"
        },
        {
            "identifier": "initCodeHashERC1967BeaconProxy",
            "parameters": "address beacon",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967BeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(0x40, 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(0x09, or(shl(160, 0x60523d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x0c, 0x74)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "2007",
            "end": "2019",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967BeaconProxyaddress beacon",
            "full_signature": "function initCodeHashERC1967BeaconProxy(address beacon) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967BeaconProxyaddress beacon",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for an ERC1967 Beacon Proxy.\n *\n * @param beacon The address of the beacon contract to be used by the proxy.\n * @return hash The computed initialization code hash.\n *\n * Steps:\n * 1. Cache the current free memory pointer.\n * 2. Store the pre-defined bytecode for the ERC1967 Beacon Proxy in memory.\n * 3. Store the beacon address in the appropriate memory location.\n * 4. Compute the keccak256 hash of the initialization code.\n * 5. Restore the free memory pointer and zero slot to their original states.\n * 6. Return the computed hash.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967BeaconProxy",
            "parameters": "address beacon, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "2023",
            "end": "2030",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967BeaconProxyaddress beacon, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967BeaconProxy(address beacon, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967BeaconProxyaddress beacon, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for an ERC1967 Beacon Proxy contract.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param salt A unique salt used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the proxy contract.\n * @return predicted The predicted address of the ERC1967 Beacon Proxy contract.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 Beacon Proxy using the provided beacon address.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address of the proxy.\n */"
        },
        {
            "identifier": "deployERC1967BeaconProxy",
            "parameters": "address beacon, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967BeaconProxy(0, beacon, args);\n    }",
            "start": "2037",
            "end": "2042",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967BeaconProxyaddress beacon, bytes memory args",
            "full_signature": "function deployERC1967BeaconProxy(address beacon, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967BeaconProxyaddress beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 Beacon Proxy contract with the specified beacon and initialization arguments.\n *\n * @param beacon The address of the beacon contract that will provide the implementation logic.\n * @param args The initialization arguments to be passed to the proxy contract.\n * @return instance The address of the deployed ERC1967 Beacon Proxy contract.\n *\n * Steps:\n * 1. Calls the internal `deployERC1967BeaconProxy` function with a value of 0 (indicating no Ether is sent).\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployERC1967BeaconProxy",
            "parameters": "uint256 value, address beacon, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967BeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x75))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "2046",
            "end": "2067",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967BeaconProxyuint256 value, address beacon, bytes memory args",
            "full_signature": "function deployERC1967BeaconProxy(uint256 value, address beacon, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967BeaconProxyuint256 value, address beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 Beacon Proxy contract using low-level assembly.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The encoded arguments to pass to the proxy initialization.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Load the free memory pointer and the length of the `args` data.\n * 2. Perform a static call to copy the `args` data into memory.\n * 3. Store the necessary bytecode and beacon address in memory.\n * 4. Check if the length of `args` exceeds the allowed limit (0xffad) and revert if it does.\n * 5. Use the `create` opcode to deploy the proxy contract with the provided value, memory offset, and length.\n * 6. If the deployment fails, revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967BeaconProxy",
            "parameters": "address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }",
            "start": "2070",
            "end": "2075",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967BeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967BeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 Beacon Proxy contract with the specified beacon, initialization arguments, and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy contract.\n * @param salt A unique salt value to ensure deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `deployDeterministicERC1967BeaconProxy` function with a value of 0, the provided beacon address, initialization arguments, and salt.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967BeaconProxy",
            "parameters": "uint256 value, address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "2079",
            "end": "2102",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 beacon proxy contract using `create2` with a specified salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The encoded arguments for the proxy initialization.\n * @param salt The salt used to deterministically compute the address of the deployed proxy.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Load the free memory pointer and the length of the `args` byte array.\n * 2. Perform a static call to copy the `args` data into memory.\n * 3. Store the precomputed bytecode for the ERC1967 beacon proxy in memory.\n * 4. Store the beacon address in memory.\n * 5. Perform a gas check to ensure the `args` length does not exceed the allowed limit.\n * 6. Use `create2` to deploy the proxy contract with the specified value, memory offset, and salt.\n * 7. If the deployment fails, revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "createDeterministicERC1967BeaconProxy",
            "parameters": "address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967BeaconProxy(0, beacon, args, salt);\n    }",
            "start": "2107",
            "end": "2112",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967BeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967BeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 beacon proxy using the provided beacon address, initialization arguments, and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy.\n * @param salt A unique salt value used to deterministically compute the proxy's address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the deployed or existing proxy instance.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicERC1967BeaconProxy` function with a value of 0, the provided beacon address, initialization arguments, and salt.\n * 2. Returns the deployment status and the address of the proxy.\n */"
        },
        {
            "identifier": "createDeterministicERC1967BeaconProxy",
            "parameters": "uint256 value, address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967BeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x8b), n))\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            mstore(add(m, gt(n, 0xffad)), add(0xfe6100523d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x75)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x75), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "2118",
            "end": "2160",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967BeaconProxy(uint256 value, address beacon, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967BeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 beacon proxy using `create2` with a given salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments for the proxy contract.\n * @param salt The salt used to deterministically compute the proxy address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the deployed or existing proxy contract.\n *\n * Steps:\n * 1. Load the memory pointer and the length of the initialization arguments.\n * 2. Perform a static call to prepare the initialization data.\n * 3. Store the proxy creation bytecode and beacon address in memory.\n * 4. Compute the deterministic address using `keccak256` with the provided salt.\n * 5. Check if the proxy is already deployed by verifying its code size.\n * 6. If not deployed, use `create2` to deploy the proxy with the provided value and salt.\n * 7. If deployment fails, revert with a `DeploymentFailed` error.\n * 8. If the proxy is already deployed, check if the provided value is non-zero and attempt to transfer Ether to the proxy.\n * 9. If the Ether transfer fails, revert with an `ETHTransferFailed` error.\n * 10. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "initCodeERC1967BeaconProxy",
            "parameters": "address beacon, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x95), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x75), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(c, 0x55), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(c, 0x35), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100523d8160233d3973, shl(56, n)))\n            mstore(c, add(n, 0x75)) // Store the length.\n            mstore(add(c, add(n, 0x95)), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(c, add(n, 0xb5))) // Allocate memory.\n        }\n    }",
            "start": "2163",
            "end": "2186",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967BeaconProxyaddress beacon, bytes memory args",
            "full_signature": "function initCodeERC1967BeaconProxy(address beacon, bytes memory args) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967BeaconProxyaddress beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Initializes the code for an ERC1967 Beacon Proxy contract.\n *\n * @param beacon The address of the beacon contract that will provide the implementation logic.\n * @param args The initialization arguments to be passed to the proxy.\n * @return c The bytecode for the ERC1967 Beacon Proxy contract.\n *\n * Steps:\n * 1. Load the memory pointer for the code.\n * 2. Check if the length of `args` exceeds the maximum allowed size (0xffad bytes). If it does, revert with an out-of-gas error.\n * 3. Copy the initialization arguments (`args`) into the memory location for the proxy code.\n * 4. Store the pre-defined proxy initialization code in memory.\n * 5. Store the beacon address in the appropriate memory location.\n * 6. Calculate and store the length of the bytecode.\n * 7. Zeroize the memory slot after the bytecode to ensure clean memory allocation.\n * 8. Allocate memory for the final bytecode and return it.\n *\n * @dev This function uses inline assembly to optimize memory operations and ensure gas efficiency.\n */"
        },
        {
            "identifier": "initCodeHashERC1967BeaconProxy",
            "parameters": "address beacon, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967BeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x52 = 0xffad`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffad))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(m, 0x8b), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(m, 0x6b), 0xb3582b35133d50545afa5036515af43d6000803e604d573d6000fd5b3d6000f3)\n            mstore(add(m, 0x4b), 0x1b60e01b36527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6c)\n            mstore(add(m, 0x2b), 0x60195155f3363d3d373d3d363d602036600436635c60da)\n            mstore(add(m, 0x14), beacon)\n            mstore(m, add(0x6100523d8160233d3973, shl(56, n)))\n            hash := keccak256(add(m, 0x16), add(n, 0x75))\n        }\n    }",
            "start": "2189",
            "end": "2210",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967BeaconProxyaddress beacon, bytes memory args",
            "full_signature": "function initCodeHashERC1967BeaconProxy(address beacon, bytes memory args) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967BeaconProxyaddress beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for an ERC1967 Beacon Proxy.\n *\n * @param beacon The address of the beacon contract.\n * @param args The initialization arguments for the proxy.\n * @return hash The computed initialization code hash.\n *\n * Steps:\n * 1. Load the memory pointer (`m`) and the length of the arguments (`n`).\n * 2. Perform a gas check to revert if `n` exceeds the allowed size.\n * 3. Copy the arguments into memory.\n * 4. Store the precomputed bytecode for the proxy initialization.\n * 5. Store the beacon address in memory.\n * 6. Compute the keccak256 hash of the initialization code.\n *\n * Assembly Details:\n * - The function uses inline assembly to optimize memory operations and gas usage.\n * - The bytecode is constructed in memory and then hashed to produce the initialization code hash.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967BeaconProxy",
            "parameters": "address beacon, bytes memory args, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967BeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967BeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "2214",
            "end": "2222",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967BeaconProxyaddress beacon, bytes memory args, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967BeaconProxy(address beacon, bytes memory args, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967BeaconProxyaddress beacon, bytes memory args, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address of an ERC1967 Beacon Proxy contract.\n *\n * @param beacon The address of the beacon contract that will be used by the proxy.\n * @param args The initialization arguments for the proxy contract.\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the proxy contract.\n *\n * @return predicted The predicted deterministic address of the ERC1967 Beacon Proxy contract.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 Beacon Proxy using the provided beacon address and initialization arguments.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address of the proxy contract.\n */"
        },
        {
            "identifier": "argsOnERC1967BeaconProxy",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967BeaconProxy(address instance) internal view returns (bytes memory args) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x52))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x52, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "2225",
            "end": "2233",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967BeaconProxyaddress instance",
            "full_signature": "function argsOnERC1967BeaconProxy(address instance) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967BeaconProxyaddress instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments used to initialize an ERC1967 Beacon Proxy.\n *\n * @param instance The address of the ERC1967 Beacon Proxy instance.\n * @return args The encoded arguments used to initialize the proxy.\n *\n * Steps:\n * 1. Allocate memory for the arguments.\n * 2. Calculate the length of the arguments by subtracting 0x52 from the size of the instance's code.\n * 3. Copy the relevant portion of the instance's code (starting from 0x52) into the allocated memory.\n * 4. Adjust the free memory pointer to account for the allocated memory.\n *\n * @dev This function uses inline assembly to directly interact with memory and the EVM.\n */"
        },
        {
            "identifier": "argsOnERC1967BeaconProxy",
            "parameters": "address instance, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967BeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x52))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x52), add(l, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "start": "2236",
            "end": "2250",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967BeaconProxyaddress instance, uint256 start",
            "full_signature": "function argsOnERC1967BeaconProxy(address instance, uint256 start) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967BeaconProxyaddress instance, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments stored in the code of an ERC1967 beacon proxy contract.\n *\n * @param instance The address of the ERC1967 beacon proxy contract.\n * @param start The starting position in the code from which to read the arguments.\n * @return args The extracted arguments as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the arguments.\n * 2. Calculate the length of the code to be copied, considering the start position.\n * 3. Copy the relevant portion of the code from the proxy contract into the allocated memory.\n * 4. Store the length of the copied arguments in memory.\n * 5. Adjust the free memory pointer to account for the allocated memory.\n *\n * @dev This function uses inline assembly to directly interact with the contract's bytecode.\n */"
        },
        {
            "identifier": "argsOnERC1967BeaconProxy",
            "parameters": "address instance, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967BeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x32), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x52)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "start": "2257",
            "end": "2277",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967BeaconProxyaddress instance, uint256 start, uint256 end",
            "full_signature": "function argsOnERC1967BeaconProxy(address instance, uint256 start, uint256 end) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967BeaconProxyaddress instance, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves arguments from the code of an ERC1967 Beacon Proxy contract.\n *\n * @param instance The address of the ERC1967 Beacon Proxy contract.\n * @param start The starting position in the contract's code to begin reading arguments.\n * @param end The ending position in the contract's code to stop reading arguments.\n * @return args The extracted arguments as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the arguments.\n * 2. Ensure the `end` value does not exceed 0xffff.\n * 3. Calculate the length of the data to be copied.\n * 4. Copy the specified range of code from the contract instance into the allocated memory.\n * 5. Handle edge cases where the data might be truncated or invalid.\n * 6. Store the length of the extracted arguments.\n * 7. Zeroize the memory slot after the arguments to ensure no residual data.\n * 8. Update the free memory pointer to allocate memory for the arguments.\n *\n * @dev This function uses low-level assembly to interact with the contract's code directly.\n */"
        },
        {
            "identifier": "deployERC1967IBeaconProxy",
            "parameters": "uint256 value, address beacon",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967IBeaconProxy(uint256 value, address beacon)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            /**\n             * ---------------------------------------------------------------------------------+\n             * CREATION (34 bytes)                                                              |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             * 60 runSize | PUSH1 runSize  | r                |                                 |\n             * 3d         | RETURNDATASIZE | 0 r              |                                 |\n             * 81         | DUP2           | r 0 r            |                                 |\n             * 60 offset  | PUSH1 offset   | o r 0 r          |                                 |\n             * 3d         | RETURNDATASIZE | 0 o r 0 r        |                                 |\n             * 39         | CODECOPY       | 0 r              | [0..runSize): runtime code      |\n             * 73 beac    | PUSH20 beac    | beac 0 r         | [0..runSize): runtime code      |\n             * 60 slotPos | PUSH1 slotPos  | slotPos beac 0 r | [0..runSize): runtime code      |\n             * 51         | MLOAD          | slot beac 0 r    | [0..runSize): runtime code      |\n             * 55         | SSTORE         | 0 r              | [0..runSize): runtime code      |\n             * f3         | RETURN         |                  | [0..runSize): runtime code      |\n             * ---------------------------------------------------------------------------------|\n             * RUNTIME (87 bytes)                                                               |\n             * ---------------------------------------------------------------------------------|\n             * Opcode     | Mnemonic       | Stack            | Memory                          |\n             * ---------------------------------------------------------------------------------|\n             *                                                                                  |\n             * ::: copy calldata to memory :::::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 36         | CALLDATASIZE   | cds              |                                 |\n             * 3d         | RETURNDATASIZE | 0 cds            |                                 |\n             * 3d         | RETURNDATASIZE | 0 0 cds          |                                 |\n             * 37         | CALLDATACOPY   |                  | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: delegatecall to implementation ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | 0                |                                 |\n             * 3d         | RETURNDATASIZE | 0 0              |                                 |\n             * 36         | CALLDATASIZE   | cds 0 0          | [0..calldatasize): calldata     |\n             * 3d         | RETURNDATASIZE | 0 cds 0 0        | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ~~~~~~~ beacon staticcall sub procedure ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 60 0x20       | PUSH1 0x20       | 32                          |                 |\n             * 36            | CALLDATASIZE     | cds 32                      |                 |\n             * 60 0x04       | PUSH1 0x04       | 4 cds 32                    |                 |\n             * 36            | CALLDATASIZE     | cds 4 cds 32                |                 |\n             * 63 0x5c60da1b | PUSH4 0x5c60da1b | 0x5c60da1b cds 4 cds 32     |                 |\n             * 60 0xe0       | PUSH1 0xe0       | 224 0x5c60da1b cds 4 cds 32 |                 |\n             * 1b            | SHL              | sel cds 4 cds 32            |                 |\n             * 36            | CALLDATASIZE     | cds sel cds 4 cds 32        |                 |\n             * 52            | MSTORE           | cds 4 cds 32                | sel             |\n             * 7f slot       | PUSH32 slot      | s cds 4 cds 32              | sel             |\n             * 54            | SLOAD            | beac cds 4 cds 32           | sel             |\n             * 5a            | GAS              | g beac cds 4 cds 32         | sel             |\n             * fa            | STATICCALL       | succ                        | impl            |\n             * ~~~~~~ check calldatasize ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds succ                    |                 |\n             * 14            | EQ               |                             | impl            |\n             * 60 0x52       | PUSH1 0x52       |                             | impl            |\n             * 57            | JUMPI            |                             | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 36            | CALLDATASIZE     | cds                         | impl            |\n             * 51            | MLOAD            | impl                        | impl            |\n             * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ |\n             * 5a         | GAS            | g impl 0 cds 0 0 | [0..calldatasize): calldata     |\n             * f4         | DELEGATECALL   | succ             | [0..calldatasize): calldata     |\n             *                                                                                  |\n             * ::: copy returndata to memory :::::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds succ         | [0..calldatasize): calldata     |\n             * 60 0x00    | PUSH1 0x00     | 0 rds succ       | [0..calldatasize): calldata     |\n             * 60 0x01    | PUSH1 0x01     | 1 0 rds succ     | [0..calldatasize): calldata     |\n             * 3e         | RETURNDATACOPY | succ             | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: branch on delegatecall status :::::::::::::::::::::::::::::::::::::::::::::: |\n             * 60 0x52    | PUSH1 0x52     | dest succ        | [1..returndatasize): returndata |\n             * 57         | JUMPI          |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall failed, revert :::::::::::::::::::::::::::::::::::::::::::::::: |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * fd         | REVERT         |                  | [1..returndatasize): returndata |\n             *                                                                                  |\n             * ::: delegatecall succeeded, return ::::::::::::::::::::::::::::::::::::::::::::: |\n             * 5b         | JUMPDEST       |                  | [1..returndatasize): returndata |\n             * 3d         | RETURNDATASIZE | rds              | [1..returndatasize): returndata |\n             * 60 0x01    | PUSH1 0x01     | 1 rds            | [1..returndatasize): returndata |\n             * f3         | RETURN         |                  | [1..returndatasize): returndata |\n             * ---------------------------------------------------------------------------------+\n             */\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create(value, 0x07, 0x79)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "2301",
            "end": "2403",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967IBeaconProxyuint256 value, address beacon",
            "full_signature": "function deployERC1967IBeaconProxy(uint256 value, address beacon) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967IBeaconProxyuint256 value, address beacon",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 IBeacon proxy contract using low-level assembly.\n *\n * @param value The amount of Ether to send with the deployment (if any).\n * @param beacon The address of the beacon contract that will provide the implementation.\n * @return instance The address of the newly deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer to restore it later.\n * 2. Store the runtime code and initialization code in memory.\n * 3. Use the `create` opcode to deploy the contract with the provided value and code.\n * 4. Check if the deployment was successful. If not, revert with a `DeploymentFailed` error.\n * 5. Restore the free memory pointer and zero slot after deployment.\n *\n * The assembly block handles the following:\n * - Copies the runtime code and initialization code into memory.\n * - Deploys the contract using the `create` opcode.\n * - Handles reverts if the deployment fails.\n * - Restores memory state after deployment.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967IBeaconProxy",
            "parameters": "address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }",
            "start": "2406",
            "end": "2411",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967IBeaconProxyaddress beacon, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967IBeaconProxyaddress beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 IBeacon proxy contract with the provided beacon address and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param salt A unique salt value used to deterministically compute the address of the deployed proxy.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `deployDeterministicERC1967IBeaconProxy` function with a value of 0, the provided beacon address, and salt.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967IBeaconProxy",
            "parameters": "uint256 value, address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            instance := create2(value, 0x07, 0x79, salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "2415",
            "end": "2434",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 IBeacon proxy contract using `create2`.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract to be associated with the proxy.\n * @param salt A unique salt value to ensure deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Store the bytecode for the proxy contract in memory.\n * 3. Use `create2` to deploy the proxy contract with the provided value, bytecode, and salt.\n * 4. If deployment fails, revert with the `DeploymentFailed()` error.\n * 5. Restore the free memory pointer and zero slot after deployment.\n *\n * Assembly Details:\n * - The bytecode is constructed in memory using `mstore` instructions.\n * - The `create2` opcode is used to deploy the contract with deterministic address generation.\n * - The function ensures memory safety by restoring the free memory pointer and zero slot.\n */"
        },
        {
            "identifier": "createDeterministicERC1967IBeaconProxy",
            "parameters": "address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, salt);\n    }",
            "start": "2439",
            "end": "2444",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967IBeaconProxyaddress beacon, bytes32 salt",
            "full_signature": "function createDeterministicERC1967IBeaconProxy(address beacon, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967IBeaconProxyaddress beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 IBeacon proxy with the specified beacon and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param salt A unique identifier (bytes32) used to deterministically generate the proxy's address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the newly created or existing proxy instance.\n *\n * Steps:\n * 1. Calls an internal function `createDeterministicERC1967IBeaconProxy` with a value of 0, the provided beacon address, and salt.\n * 2. Returns the deployment status and the address of the proxy.\n */"
        },
        {
            "identifier": "createDeterministicERC1967IBeaconProxy",
            "parameters": "uint256 value, address beacon, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            // Compute and store the bytecode hash.\n            mstore(add(m, 0x35), keccak256(0x07, 0x79))\n            mstore(m, shl(88, address()))\n            mstore8(m, 0xff) // Write the prefix.\n            mstore(add(m, 0x15), salt)\n            instance := keccak256(m, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, 0x07, 0x79, salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "2450",
            "end": "2487",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes32 salt",
            "full_signature": "function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 proxy for a beacon contract using `create2`.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param salt A unique salt value used to deterministically compute the proxy address.\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the deployed or existing proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer and prepare the memory layout for the deployment.\n * 2. Store the precomputed bytecode and beacon address in memory.\n * 3. Compute the bytecode hash and store it in memory.\n * 4. Prepare the `create2` deployment parameters, including the salt.\n * 5. Compute the deterministic address for the proxy using the salt.\n * 6. Check if the proxy is already deployed by verifying its code size.\n *    - If not deployed, create the proxy using `create2`.\n *    - If deployment fails, revert with `DeploymentFailed()`.\n * 7. If the proxy is already deployed:\n *    - If `value` is non-zero, attempt to send Ether to the proxy.\n *    - If the Ether transfer fails, revert with `ETHTransferFailed()`.\n * 8. Restore the free memory pointer and zero slot.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and deployment logic.\n */"
        },
        {
            "identifier": "initCodeERC1967IBeaconProxy",
            "parameters": "address beacon",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967IBeaconProxy(address beacon) internal pure returns (bytes memory c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            mstore(add(c, 0x79), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x59), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x39), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1d), beacon)\n            mstore(add(c, 0x09), 0x60573d8160223d3973)\n            mstore(add(c, 0x99), 0)\n            mstore(c, 0x79) // Store the length.\n            mstore(0x40, add(c, 0xa0)) // Allocate memory.\n        }\n    }",
            "start": "2490",
            "end": "2503",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967IBeaconProxyaddress beacon",
            "full_signature": "function initCodeERC1967IBeaconProxy(address beacon) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967IBeaconProxyaddress beacon",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Generates the initialization code for an ERC1967-compliant beacon proxy.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @return c The bytecode representing the initialization code for the beacon proxy.\n *\n * Steps:\n * 1. Load the free memory pointer.\n * 2. Store the pre-defined bytecode for the beacon proxy initialization.\n * 3. Store the provided beacon address in the appropriate memory location.\n * 4. Store additional pre-defined bytecode for the proxy initialization.\n * 5. Store the length of the initialization code.\n * 6. Update the free memory pointer to allocate memory for the initialization code.\n * 7. Return the generated initialization code.\n *\n * Note: This function uses inline assembly to directly manipulate memory and generate the bytecode.\n */"
        },
        {
            "identifier": "initCodeHashERC1967IBeaconProxy",
            "parameters": "address beacon",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967IBeaconProxy(address beacon) internal pure returns (bytes32 hash) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            mstore(0x60, 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(0x40, 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(0x20, 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(0x04, or(shl(160, 0x60573d8160223d3973), shr(96, shl(96, beacon))))\n            hash := keccak256(0x07, 0x79)\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero slot.\n        }\n    }",
            "start": "2506",
            "end": "2518",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967IBeaconProxyaddress beacon",
            "full_signature": "function initCodeHashERC1967IBeaconProxy(address beacon) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967IBeaconProxyaddress beacon",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for an ERC1967-compliant beacon proxy.\n *\n * @param beacon The address of the beacon contract to be used by the proxy.\n * @return hash The computed initialization code hash for the beacon proxy.\n *\n * Steps:\n * 1. Cache the current free memory pointer.\n * 2. Store the precomputed bytecode for the proxy initialization in memory.\n * 3. Combine the beacon address with the bytecode to form the initialization code.\n * 4. Compute the Keccak-256 hash of the initialization code.\n * 5. Restore the free memory pointer and zero slot to their original states.\n *\n * Note: This function uses inline assembly for low-level memory manipulation.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967IBeaconProxy",
            "parameters": "address beacon, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "2522",
            "end": "2529",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967IBeaconProxyaddress beacon, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967IBeaconProxy(address beacon, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967IBeaconProxyaddress beacon, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for an ERC1967 IBeaconProxy contract.\n *\n * @param beacon The address of the beacon contract that will be used by the proxy.\n * @param salt A unique salt value used to generate the deterministic address.\n * @param deployer The address of the deployer who will deploy the proxy contract.\n *\n * @return predicted The predicted deterministic address of the ERC1967 IBeaconProxy contract.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 IBeaconProxy using the provided beacon address.\n * 2. Use the computed hash, salt, and deployer address to predict the deterministic address of the proxy contract.\n */"
        },
        {
            "identifier": "deployERC1967IBeaconProxy",
            "parameters": "address beacon, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        instance = deployERC1967IBeaconProxy(0, beacon, args);\n    }",
            "start": "2536",
            "end": "2541",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967IBeaconProxyaddress beacon, bytes memory args",
            "full_signature": "function deployERC1967IBeaconProxy(address beacon, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967IBeaconProxyaddress beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 IBeacon proxy contract with the provided beacon address and initialization arguments.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy contract.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `deployERC1967IBeaconProxy` function with a value of 0, the provided beacon address, and initialization arguments.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployERC1967IBeaconProxy",
            "parameters": "uint256 value, address beacon, bytes memory args",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args)\n        internal\n        returns (address instance)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create(value, add(m, 0x16), add(n, 0x7a))\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "2545",
            "end": "2566",
            "class": "LibClone",
            "signature": "returns (address instance) deployERC1967IBeaconProxyuint256 value, address beacon, bytes memory args",
            "full_signature": "function deployERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployERC1967IBeaconProxyuint256 value, address beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys an ERC1967 IBeacon Proxy contract using low-level assembly.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The encoded arguments to pass to the proxy's initialization function.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Load the length of the `args` byte array.\n * 3. Perform a static call to copy the `args` data into memory.\n * 4. Store the precomputed bytecode for the proxy contract in memory.\n * 5. Store the beacon address in memory.\n * 6. Ensure that the length of `args` does not exceed the maximum allowed size.\n * 7. Deploy the proxy contract using the `create` opcode, passing the value, memory offset, and size.\n * 8. If the deployment fails, revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967IBeaconProxy",
            "parameters": "address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (address instance)\n    {\n        instance = deployDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }",
            "start": "2569",
            "end": "2574",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967IBeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967IBeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 IBeacon proxy contract with the specified beacon, initialization arguments, and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy contract.\n * @param salt A unique salt value used to deterministically compute the address of the deployed proxy.\n *\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Calls the internal `deployDeterministicERC1967IBeaconProxy` function with a value of 0, the provided beacon address, initialization arguments, and salt.\n * 2. Returns the address of the deployed proxy contract.\n */"
        },
        {
            "identifier": "deployDeterministicERC1967IBeaconProxy",
            "parameters": "uint256 value, address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (address instance)",
            "body": "function deployDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n            if iszero(instance) {\n                mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "2578",
            "end": "2601",
            "class": "LibClone",
            "signature": "returns (address instance) deployDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "full_signature": "function deployDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args, bytes32 salt) internal   returns (address instance)",
            "class_method_signature": "LibClone.deployDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Deploys a deterministic ERC1967 IBeacon proxy contract using `create2` with a specified salt.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The encoded arguments to pass to the proxy initialization.\n * @param salt A unique salt to ensure deterministic deployment.\n * @return instance The address of the deployed proxy contract.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Load the length of the `args` byte array.\n * 3. Perform a static call to copy the `args` data into memory.\n * 4. Store the proxy initialization code in memory.\n * 5. Store the beacon address in memory.\n * 6. Check if the length of `args` exceeds the allowed limit (0xffa8) and revert if it does.\n * 7. Use `create2` to deploy the proxy contract with the specified salt.\n * 8. If deployment fails, revert with a `DeploymentFailed` error.\n */"
        },
        {
            "identifier": "createDeterministicERC1967IBeaconProxy",
            "parameters": "address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt)\n        internal\n        returns (bool alreadyDeployed, address instance)\n    {\n        return createDeterministicERC1967IBeaconProxy(0, beacon, args, salt);\n    }",
            "start": "2606",
            "end": "2611",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967IBeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967IBeaconProxyaddress beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 IBeacon proxy with the provided beacon, initialization arguments, and salt.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy.\n * @param salt A unique salt value used to deterministically compute the proxy's address.\n *\n * @return alreadyDeployed A boolean indicating whether the proxy was already deployed.\n * @return instance The address of the deployed proxy instance.\n *\n * Steps:\n * 1. Calls the internal `createDeterministicERC1967IBeaconProxy` function with a value of 0, the provided beacon, args, and salt.\n * 2. Returns the deployment status and the address of the proxy instance.\n */"
        },
        {
            "identifier": "createDeterministicERC1967IBeaconProxy",
            "parameters": "uint256 value, address beacon, bytes memory args, bytes32 salt",
            "modifiers": "",
            "return": "returns (bool alreadyDeployed, address instance)",
            "body": "function createDeterministicERC1967IBeaconProxy(\n        uint256 value,\n        address beacon,\n        bytes memory args,\n        bytes32 salt\n    ) internal returns (bool alreadyDeployed, address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mload(args)\n            pop(staticcall(gas(), 4, add(args, 0x20), n, add(m, 0x90), n))\n            mstore(add(m, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(m, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(m, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(m, 0x14), beacon)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            mstore(add(m, gt(n, 0xffa8)), add(0xfe6100573d8160233d3973, shl(56, n)))\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, keccak256(add(m, 0x16), add(n, 0x7a)))\n            mstore(0x01, shl(96, address()))\n            mstore(0x15, salt)\n            instance := keccak256(0x00, 0x55)\n            for {} 1 {} {\n                if iszero(extcodesize(instance)) {\n                    instance := create2(value, add(m, 0x16), add(n, 0x7a), salt)\n                    if iszero(instance) {\n                        mstore(0x00, 0x30116425) // `DeploymentFailed()`.\n                        revert(0x1c, 0x04)\n                    }\n                    break\n                }\n                alreadyDeployed := 1\n                if iszero(value) { break }\n                if iszero(call(gas(), instance, value, codesize(), 0x00, codesize(), 0x00)) {\n                    mstore(0x00, 0xb12d13eb) // `ETHTransferFailed()`.\n                    revert(0x1c, 0x04)\n                }\n                break\n            }\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "2617",
            "end": "2659",
            "class": "LibClone",
            "signature": "returns (bool alreadyDeployed, address instance) createDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "full_signature": "function createDeterministicERC1967IBeaconProxy(uint256 value, address beacon, bytes memory args, bytes32 salt) internal   returns (bool alreadyDeployed, address instance)",
            "class_method_signature": "LibClone.createDeterministicERC1967IBeaconProxyuint256 value, address beacon, bytes memory args, bytes32 salt",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Creates a deterministic ERC1967 IBeacon proxy using the CREATE2 opcode.\n *\n * @param value The amount of Ether to send with the deployment.\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The arguments to pass to the proxy constructor.\n * @param salt A unique salt to ensure deterministic deployment.\n *\n * @return alreadyDeployed A boolean indicating if the proxy was already deployed.\n * @return instance The address of the deployed proxy.\n *\n * Steps:\n * 1. Load the memory pointer and the length of the arguments.\n * 2. Perform a static call to copy the arguments into memory.\n * 3. Store the precomputed bytecode for the proxy in memory.\n * 4. Store the beacon address and other necessary data in memory.\n * 5. Compute the bytecode hash and store it in memory.\n * 6. Use the CREATE2 opcode to deploy the proxy contract.\n * 7. If the deployment fails, revert with a `DeploymentFailed` error.\n * 8. If the proxy is already deployed, check if the value is non-zero and attempt to transfer Ether.\n * 9. If the Ether transfer fails, revert with an `ETHTransferFailed` error.\n * 10. Restore the overwritten part of the free memory pointer.\n */"
        },
        {
            "identifier": "initCodeERC1967IBeaconProxy",
            "parameters": "address beacon, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes memory c)",
            "body": "function initCodeERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes memory c)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            c := mload(0x40)\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x9a), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x7a), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x5a), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x3a), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x1e), beacon)\n            mstore(add(c, 0x0a), add(0x6100573d8160233d3973, shl(56, n)))\n            mstore(add(c, add(n, 0x9a)), 0)\n            mstore(c, add(n, 0x7a)) // Store the length.\n            mstore(0x40, add(c, add(n, 0xba))) // Allocate memory.\n        }\n    }",
            "start": "2662",
            "end": "2685",
            "class": "LibClone",
            "signature": "returns (bytes memory c) initCodeERC1967IBeaconProxyaddress beacon, bytes memory args",
            "full_signature": "function initCodeERC1967IBeaconProxy(address beacon, bytes memory args) internal  pure returns (bytes memory c)",
            "class_method_signature": "LibClone.initCodeERC1967IBeaconProxyaddress beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Initializes the code for an ERC1967 IBeacon proxy contract.\n *\n * @dev This function constructs the initialization code for a proxy contract that uses the ERC1967 beacon pattern.\n * The function is marked as `internal` and `pure`, meaning it does not modify state and is only callable within the contract.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy contract.\n * @return c The bytecode representing the initialization code for the proxy contract.\n *\n * Steps:\n * 1. Load the memory pointer for the code (`c`).\n * 2. Retrieve the length of the `args` byte array (`n`).\n * 3. Perform a gas check to ensure `n` does not exceed the maximum allowed size (`0xffa8`).\n * 4. Copy the `args` data into the appropriate location in the code.\n * 5. Store the precomputed bytecode for the proxy initialization.\n * 6. Store the beacon address in the code.\n * 7. Store the length of the code and allocate memory for the final bytecode.\n * 8. Return the constructed bytecode.\n *\n * @notice The function uses inline assembly for low-level memory manipulation, ensuring efficient bytecode generation.\n */"
        },
        {
            "identifier": "initCodeHashERC1967IBeaconProxy",
            "parameters": "address beacon, bytes memory args",
            "modifiers": "pure",
            "return": "returns (bytes32 hash)",
            "body": "function initCodeHashERC1967IBeaconProxy(address beacon, bytes memory args)\n        internal\n        pure\n        returns (bytes32 hash)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let c := mload(0x40) // Cache the free memory pointer.\n            let n := mload(args)\n            // Do a out-of-gas revert if `n` is greater than `0xffff - 0x57 = 0xffa8`.\n            returndatacopy(returndatasize(), returndatasize(), gt(n, 0xffa8))\n            for { let i := 0 } lt(i, n) { i := add(i, 0x20) } {\n                mstore(add(add(c, 0x90), i), mload(add(add(args, 0x20), i)))\n            }\n            mstore(add(c, 0x70), 0x3d50545afa361460525736515af43d600060013e6052573d6001fd5b3d6001f3)\n            mstore(add(c, 0x50), 0x527fa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b3513)\n            mstore(add(c, 0x30), 0x60195155f3363d3d373d3d363d602036600436635c60da1b60e01b36)\n            mstore(add(c, 0x14), beacon)\n            mstore(c, add(0x6100573d8160233d3973, shl(56, n)))\n            hash := keccak256(add(c, 0x16), add(n, 0x7a))\n        }\n    }",
            "start": "2688",
            "end": "2709",
            "class": "LibClone",
            "signature": "returns (bytes32 hash) initCodeHashERC1967IBeaconProxyaddress beacon, bytes memory args",
            "full_signature": "function initCodeHashERC1967IBeaconProxy(address beacon, bytes memory args) internal  pure returns (bytes32 hash)",
            "class_method_signature": "LibClone.initCodeHashERC1967IBeaconProxyaddress beacon, bytes memory args",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Computes the initialization code hash for an ERC1967 IBeacon proxy contract.\n *\n * @dev This function is used to generate the hash of the initialization code for a proxy contract\n *      that uses the ERC1967 beacon pattern. The hash is computed based on the provided beacon address\n *      and initialization arguments.\n *\n * @param beacon The address of the beacon contract that the proxy will point to.\n * @param args The initialization arguments to be passed to the proxy contract.\n * @return hash The computed hash of the initialization code.\n *\n * Steps:\n * 1. Cache the free memory pointer.\n * 2. Load the length of the initialization arguments (`args`).\n * 3. Perform an out-of-gas revert if the length of `args` exceeds the maximum allowed size.\n * 4. Copy the initialization arguments into memory.\n * 5. Store the precomputed bytecode for the proxy contract in memory.\n * 6. Store the beacon address in memory.\n * 7. Compute the hash of the initialization code using the keccak256 function.\n * 8. Return the computed hash.\n */"
        },
        {
            "identifier": "predictDeterministicAddressERC1967IBeaconProxy",
            "parameters": "address beacon, bytes memory args, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddressERC1967IBeaconProxy(\n        address beacon,\n        bytes memory args,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        bytes32 hash = initCodeHashERC1967IBeaconProxy(beacon, args);\n        predicted = predictDeterministicAddress(hash, salt, deployer);\n    }",
            "start": "2713",
            "end": "2721",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressERC1967IBeaconProxyaddress beacon, bytes memory args, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddressERC1967IBeaconProxy(address beacon, bytes memory args, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressERC1967IBeaconProxyaddress beacon, bytes memory args, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for an ERC1967 IBeaconProxy contract.\n *\n * @param beacon The address of the beacon contract.\n * @param args The initialization arguments for the proxy.\n * @param salt The salt used to generate the deterministic address.\n * @param deployer The address of the deployer.\n * @return predicted The predicted deterministic address of the proxy.\n *\n * Steps:\n * 1. Compute the initialization code hash for the ERC1967 IBeaconProxy using the beacon address and initialization arguments.\n * 2. Predict the deterministic address using the computed hash, salt, and deployer address.\n */"
        },
        {
            "identifier": "argsOnERC1967IBeaconProxy",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967IBeaconProxy(address instance)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            mstore(args, and(0xffffffffff, sub(extcodesize(instance), 0x57))) // Store the length.\n            extcodecopy(instance, add(args, 0x20), 0x57, add(mload(args), 0x20))\n            mstore(0x40, add(mload(args), add(args, 0x40))) // Allocate memory.\n        }\n    }",
            "start": "2724",
            "end": "2736",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967IBeaconProxyaddress instance",
            "full_signature": "function argsOnERC1967IBeaconProxy(address instance) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967IBeaconProxyaddress instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments used in the initialization of an ERC1967 beacon proxy.\n *\n * @param instance The address of the beacon proxy instance.\n * @return args The encoded arguments used during the proxy's initialization.\n *\n * Steps:\n * 1. Allocate memory for the arguments.\n * 2. Calculate the length of the arguments by subtracting 0x57 from the size of the contract code at the instance address.\n * 3. Copy the relevant portion of the contract code (starting from 0x57) into the allocated memory.\n * 4. Update the free memory pointer to account for the allocated memory.\n *\n * @dev This function uses inline assembly to directly interact with memory and contract code.\n */"
        },
        {
            "identifier": "argsOnERC1967IBeaconProxy",
            "parameters": "address instance, uint256 start",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967IBeaconProxy(address instance, uint256 start)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            let n := and(0xffffffffff, sub(extcodesize(instance), 0x57))\n            let l := sub(n, and(0xffffff, mul(lt(start, n), start)))\n            extcodecopy(instance, add(args, 0x20), add(start, 0x57), add(l, 0x20))\n            mstore(args, mul(sub(n, start), lt(start, n))) // Store the length.\n            mstore(0x40, add(args, add(0x40, mload(args)))) // Allocate memory.\n        }\n    }",
            "start": "2739",
            "end": "2753",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967IBeaconProxyaddress instance, uint256 start",
            "full_signature": "function argsOnERC1967IBeaconProxy(address instance, uint256 start) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967IBeaconProxyaddress instance, uint256 start",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments used in the ERC1967 beacon proxy initialization.\n *\n * @param instance The address of the beacon proxy instance.\n * @param start The starting position in the bytecode from which to read the arguments.\n * @return args The bytes containing the arguments used in the proxy initialization.\n *\n * Steps:\n * 1. Allocate memory for the arguments.\n * 2. Calculate the length of the arguments based on the instance's bytecode size.\n * 3. Copy the relevant portion of the bytecode into the allocated memory.\n * 4. Store the length of the arguments in the allocated memory.\n * 5. Update the free memory pointer to account for the allocated memory.\n *\n * @dev This function uses low-level assembly to directly interact with the contract's bytecode.\n */"
        },
        {
            "identifier": "argsOnERC1967IBeaconProxy",
            "parameters": "address instance, uint256 start, uint256 end",
            "modifiers": "view",
            "return": "returns (bytes memory args)",
            "body": "function argsOnERC1967IBeaconProxy(address instance, uint256 start, uint256 end)\n        internal\n        view\n        returns (bytes memory args)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            args := mload(0x40)\n            if iszero(lt(end, 0xffff)) { end := 0xffff }\n            let d := mul(sub(end, start), lt(start, end))\n            extcodecopy(instance, args, add(start, 0x37), add(d, 0x20))\n            if iszero(and(0xff, mload(add(args, d)))) {\n                let n := sub(extcodesize(instance), 0x57)\n                returndatacopy(returndatasize(), returndatasize(), shr(40, n))\n                d := mul(gt(n, start), sub(d, mul(gt(end, n), sub(end, n))))\n            }\n            mstore(args, d) // Store the length.\n            mstore(add(add(args, 0x20), d), 0) // Zeroize the slot after the bytes.\n            mstore(0x40, add(add(args, 0x40), d)) // Allocate memory.\n        }\n    }",
            "start": "2760",
            "end": "2780",
            "class": "LibClone",
            "signature": "returns (bytes memory args) argsOnERC1967IBeaconProxyaddress instance, uint256 start, uint256 end",
            "full_signature": "function argsOnERC1967IBeaconProxy(address instance, uint256 start, uint256 end) internal  view returns (bytes memory args)",
            "class_method_signature": "LibClone.argsOnERC1967IBeaconProxyaddress instance, uint256 start, uint256 end",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the arguments from an ERC1967 beacon proxy's code at a specific range.\n *\n * @param instance The address of the ERC1967 beacon proxy instance.\n * @param start The starting position in the code to begin copying.\n * @param end The ending position in the code to stop copying.\n * @return args The extracted arguments as a bytes array.\n *\n * Steps:\n * 1. Allocate memory for the `args` array.\n * 2. Ensure `end` does not exceed the maximum allowed value (0xffff).\n * 3. Calculate the length of the data to be copied (`d`).\n * 4. Copy the code from the instance's address into the `args` array, starting at `start + 0x37`.\n * 5. Check if the last byte of the copied data is zero, and adjust the length if necessary.\n * 6. Store the length of the copied data in the `args` array.\n * 7. Zeroize the slot after the copied data to ensure memory safety.\n * 8. Allocate additional memory for the `args` array to accommodate the copied data.\n *\n * @dev This function uses low-level assembly to interact with the contract's code directly.\n */"
        },
        {
            "identifier": "implementationOf",
            "parameters": "address instance",
            "modifiers": "view",
            "return": "returns (address result)",
            "body": "function implementationOf(address instance) internal view returns (address result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { extcodecopy(instance, 0x00, 0x00, 0x57) } 1 {} {\n                if mload(0x2d) {\n                    // ERC1967I and ERC1967IBeaconProxy detection.\n                    if or(\n                        eq(keccak256(0x00, 0x52), ERC1967I_CODE_HASH),\n                        eq(keccak256(0x00, 0x57), ERC1967I_BEACON_PROXY_CODE_HASH)\n                    ) {\n                        pop(staticcall(gas(), instance, 0x00, 0x01, 0x00, 0x20))\n                        result := mload(0x0c)\n                        break\n                    }\n                }\n                // 0age clone detection.\n                result := mload(0x0b)\n                codecopy(0x0b, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2c), CLONE_CODE_HASH)) { break }\n                mstore(0x0b, result) // Restore the zeroized memory.\n                // CWIA detection.\n                result := mload(0x0a)\n                codecopy(0x0a, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                if iszero(xor(keccak256(0x00, 0x2d), CWIA_CODE_HASH)) { break }\n                mstore(0x0a, result) // Restore the zeroized memory.\n                // PUSH0 clone detection.\n                result := mload(0x09)\n                codecopy(0x09, codesize(), 0x14) // Zeroize the 20 bytes for the address.\n                result := shr(xor(keccak256(0x00, 0x2d), PUSH0_CLONE_CODE_HASH), result)\n                break\n            }\n            result := shr(96, result)\n            mstore(0x37, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "2787",
            "end": "2821",
            "class": "LibClone",
            "signature": "returns (address result) implementationOfaddress instance",
            "full_signature": "function implementationOf(address instance) internal  view returns (address result)",
            "class_method_signature": "LibClone.implementationOfaddress instance",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Retrieves the implementation address of a given contract instance by analyzing its bytecode.\n *\n * @dev This function uses low-level assembly to inspect the bytecode of the provided instance and\n *      detect specific patterns to identify the implementation address. It supports detection for:\n *      - ERC1967I and ERC1967IBeaconProxy contracts.\n *      - 0age clones.\n *      - CWIA (Create2 With Initialization Arguments) contracts.\n *      - PUSH0 clones.\n *\n * @param instance The address of the contract instance to analyze.\n * @return result The address of the implementation contract.\n *\n * Steps:\n * 1. Use `extcodecopy` to copy the bytecode of the instance into memory.\n * 2. Check for specific bytecode patterns to determine the type of contract:\n *    - ERC1967I and ERC1967IBeaconProxy: Use `staticcall` to retrieve the implementation address.\n *    - 0age clones: Compare the bytecode hash with the expected clone hash.\n *    - CWIA contracts: Compare the bytecode hash with the expected CWIA hash.\n *    - PUSH0 clones: Compare the bytecode hash with the expected PUSH0 clone hash.\n * 3. Return the detected implementation address.\n * 4. Restore any overwritten memory to ensure memory safety.\n */"
        },
        {
            "identifier": "predictDeterministicAddress",
            "parameters": "bytes32 hash, bytes32 salt, address deployer",
            "modifiers": "pure",
            "return": "returns (address predicted)",
            "body": "function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer)\n        internal\n        pure\n        returns (address predicted)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Compute and store the bytecode hash.\n            mstore8(0x00, 0xff) // Write the prefix.\n            mstore(0x35, hash)\n            mstore(0x01, shl(96, deployer))\n            mstore(0x15, salt)\n            predicted := keccak256(0x00, 0x55)\n            mstore(0x35, 0) // Restore the overwritten part of the free memory pointer.\n        }\n    }",
            "start": "2826",
            "end": "2841",
            "class": "LibClone",
            "signature": "returns (address predicted) predictDeterministicAddressbytes32 hash, bytes32 salt, address deployer",
            "full_signature": "function predictDeterministicAddress(bytes32 hash, bytes32 salt, address deployer) internal  pure returns (address predicted)",
            "class_method_signature": "LibClone.predictDeterministicAddressbytes32 hash, bytes32 salt, address deployer",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Predicts the deterministic address for a contract deployment using CREATE2.\n *\n * @param hash The keccak256 hash of the contract's bytecode.\n * @param salt A unique salt value to ensure different addresses for the same bytecode.\n * @param deployer The address of the deployer who will deploy the contract.\n * @return predicted The predicted address of the contract if deployed using CREATE2.\n *\n * Steps:\n * 1. Write the prefix `0xff` to memory at position `0x00`.\n * 2. Store the provided `hash` at memory position `0x35`.\n * 3. Store the deployer's address (shifted left by 96 bits) at memory position `0x01`.\n * 4. Store the provided `salt` at memory position `0x15`.\n * 5. Compute the keccak256 hash of the memory range `0x00` to `0x55` to predict the address.\n * 6. Restore the overwritten part of the free memory pointer by setting `0x35` to `0`.\n * 7. Return the predicted address.\n */"
        },
        {
            "identifier": "checkStartsWith",
            "parameters": "bytes32 salt, address by",
            "modifiers": "pure",
            "return": "",
            "body": "function checkStartsWith(bytes32 salt, address by) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the salt does not start with the zero address or `by`.\n            if iszero(or(iszero(shr(96, salt)), eq(shr(96, shl(96, by)), shr(96, salt)))) {\n                mstore(0x00, 0x0c4549ef) // `SaltDoesNotStartWith()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "2844",
            "end": "2853",
            "class": "LibClone",
            "signature": " checkStartsWithbytes32 salt, address by",
            "full_signature": "function checkStartsWith(bytes32 salt, address by) internal  pure",
            "class_method_signature": "LibClone.checkStartsWithbytes32 salt, address by",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if the provided `salt` starts with the zero address or the address `by`.\n *\n * @param salt The bytes32 value to check.\n * @param by The address to compare against the first 20 bytes of `salt`.\n *\n * Steps:\n * 1. Use inline assembly to perform low-level checks on the `salt`.\n * 2. Shift and compare the first 20 bytes of `salt` with the zero address or the address `by`.\n * 3. If the `salt` does not start with either the zero address or `by`, revert with the error `SaltDoesNotStartWith()`.\n *\n * @dev This function uses assembly for gas optimization and precise control over memory and storage.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibBitmap.sol": [
        {
            "identifier": "get",
            "parameters": "Bitmap storage bitmap, uint256 index",
            "modifiers": "view",
            "return": "returns (bool isSet)",
            "body": "function get(Bitmap storage bitmap, uint256 index) internal view returns (bool isSet) {\n        // It is better to set `isSet` to either 0 or 1, than zero vs non-zero.\n        // Both cost the same amount of gas, but the former allows the returned value\n        // to be reused without cleaning the upper bits.\n        uint256 b = (bitmap.map[index >> 8] >> (index & 0xff)) & 1;\n        /// @solidity memory-safe-assembly\n        assembly {\n            isSet := b\n        }\n    }",
            "start": "32",
            "end": "41",
            "class": "LibBitmap",
            "signature": "returns (bool isSet) getBitmap storage bitmap, uint256 index",
            "full_signature": "function get(Bitmap storage bitmap, uint256 index) internal  view returns (bool isSet)",
            "class_method_signature": "LibBitmap.getBitmap storage bitmap, uint256 index",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a specific bit in a bitmap is set.\n *\n * @param bitmap The storage reference to the bitmap.\n * @param index The index of the bit to check.\n * @return isSet A boolean indicating whether the bit is set (1) or not (0).\n *\n * Steps:\n * 1. Calculate the byte and bit position within the bitmap for the given index.\n * 2. Extract the bit value from the calculated position.\n * 3. Use assembly to assign the bit value to the `isSet` variable, ensuring it is either 0 or 1.\n *\n * Note: The function is optimized to return a clean boolean value (0 or 1) for efficient reuse.\n */"
        },
        {
            "identifier": "toggle",
            "parameters": "Bitmap storage bitmap, uint256 index",
            "modifiers": "",
            "return": "returns (bool newIsSet)",
            "body": "function toggle(Bitmap storage bitmap, uint256 index) internal returns (bool newIsSet) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let shift := and(index, 0xff)\n            let storageValue := xor(sload(storageSlot), shl(shift, 1))\n            // It makes sense to return the `newIsSet`,\n            // as it allow us to skip an additional warm `sload`,\n            // and it costs minimal gas (about 15),\n            // which may be optimized away if the returned value is unused.\n            newIsSet := and(1, shr(shift, storageValue))\n            sstore(storageSlot, storageValue)\n        }\n    }",
            "start": "55",
            "end": "70",
            "class": "LibBitmap",
            "signature": "returns (bool newIsSet) toggleBitmap storage bitmap, uint256 index",
            "full_signature": "function toggle(Bitmap storage bitmap, uint256 index) internal   returns (bool newIsSet)",
            "class_method_signature": "LibBitmap.toggleBitmap storage bitmap, uint256 index",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function and(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Toggles the state of a specific bit in a bitmap storage and returns the new state.\n *\n * @dev This function uses inline assembly to efficiently manipulate the bitmap storage.\n * The function calculates the storage slot and bit position for the given index, toggles the bit,\n * and returns the new state of the bit.\n *\n * @param bitmap The bitmap storage reference where the bit is to be toggled.\n * @param index The index of the bit to toggle.\n * @return newIsSet The new state of the bit after toggling (1 if set, 0 if not set).\n *\n * Steps:\n * 1. Calculate the storage slot and bit position for the given index.\n * 2. Load the current value from the storage slot.\n * 3. Toggle the bit at the calculated position using XOR.\n * 4. Determine the new state of the bit by shifting and masking.\n * 5. Store the updated value back into the storage slot.\n * 6. Return the new state of the bit.\n */"
        },
        {
            "identifier": "setTo",
            "parameters": "Bitmap storage bitmap, uint256 index, bool shouldSet",
            "modifiers": "",
            "return": "",
            "body": "function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, index))\n            let storageSlot := keccak256(0x00, 0x40)\n            let storageValue := sload(storageSlot)\n            let shift := and(index, 0xff)\n            sstore(\n                storageSlot,\n                // Unsets the bit at `shift` via `and`, then sets its new value via `or`.\n                or(and(storageValue, not(shl(shift, 1))), shl(shift, iszero(iszero(shouldSet))))\n            )\n        }\n    }",
            "start": "73",
            "end": "87",
            "class": "LibBitmap",
            "signature": " setToBitmap storage bitmap, uint256 index, bool shouldSet",
            "full_signature": "function setTo(Bitmap storage bitmap, uint256 index, bool shouldSet) internal",
            "class_method_signature": "LibBitmap.setToBitmap storage bitmap, uint256 index, bool shouldSet",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function and(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets or unsets a bit at a specific index in a bitmap storage.\n *\n * @param bitmap The storage reference to the bitmap.\n * @param index The index of the bit to set or unset.\n * @param shouldSet A boolean indicating whether to set (true) or unset (false) the bit.\n *\n * Steps:\n * 1. Calculate the storage slot for the bitmap using the provided index.\n * 2. Load the current value from the calculated storage slot.\n * 3. Determine the bit position within the storage slot using the lower 8 bits of the index.\n * 4. Update the storage slot value by:\n *    - Clearing the bit at the calculated position using a bitwise AND operation.\n *    - Setting the bit to the desired value (1 if `shouldSet` is true, 0 otherwise) using a bitwise OR operation.\n * 5. Store the updated value back into the storage slot.\n *\n * @dev This function uses inline assembly for low-level storage manipulation.\n */"
        },
        {
            "identifier": "setBatch",
            "parameters": "Bitmap storage bitmap, uint256 start, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, or(sload(storageSlot), shl(shift, max)))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), max)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(storageSlot, or(sload(storageSlot), shl(shift, shr(sub(256, amount), max))))\n        }\n    }",
            "start": "90",
            "end": "113",
            "class": "LibBitmap",
            "signature": " setBatchBitmap storage bitmap, uint256 start, uint256 amount",
            "full_signature": "function setBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal",
            "class_method_signature": "LibBitmap.setBatchBitmap storage bitmap, uint256 start, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function and(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Sets a batch of bits in a bitmap starting from a specific position.\n *\n * @param bitmap The storage reference to the bitmap where bits will be set.\n * @param start The starting position in the bitmap where the batch of bits will be set.\n * @param amount The number of bits to set starting from the `start` position.\n *\n * Steps:\n * 1. Calculate the maximum value (all bits set to 1) using `not(0)`.\n * 2. Determine the shift value based on the starting position (`start & 0xff`).\n * 3. Store the bitmap's storage slot and the starting bucket in memory.\n *\n * 4. If the batch of bits to set spans multiple buckets:\n *    a. Set the bits in the current bucket using bitwise operations.\n *    b. Calculate the range of buckets that need to be fully set (all bits to 1).\n *    c. Iterate through the buckets and set all bits to 1.\n *    d. Adjust the `amount` and `shift` values for the remaining bits in the last bucket.\n *\n * 5. If the batch of bits fits within a single bucket:\n *    a. Set the bits in the current bucket using bitwise operations, ensuring only the specified bits are set.\n *\n * Note: This function uses low-level assembly for efficient bit manipulation.\n */"
        },
        {
            "identifier": "unsetBatch",
            "parameters": "Bitmap storage bitmap, uint256 start, uint256 amount",
            "modifiers": "",
            "return": "",
            "body": "function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let shift := and(start, 0xff)\n            mstore(0x20, bitmap.slot)\n            mstore(0x00, shr(8, start))\n            if iszero(lt(add(shift, amount), 257)) {\n                let storageSlot := keccak256(0x00, 0x40)\n                sstore(storageSlot, and(sload(storageSlot), not(shl(shift, not(0)))))\n                let bucket := add(mload(0x00), 1)\n                let bucketEnd := add(mload(0x00), shr(8, add(amount, shift)))\n                amount := and(add(amount, shift), 0xff)\n                shift := 0\n                for {} iszero(eq(bucket, bucketEnd)) { bucket := add(bucket, 1) } {\n                    mstore(0x00, bucket)\n                    sstore(keccak256(0x00, 0x40), 0)\n                }\n                mstore(0x00, bucket)\n            }\n            let storageSlot := keccak256(0x00, 0x40)\n            sstore(\n                storageSlot, and(sload(storageSlot), not(shl(shift, shr(sub(256, amount), not(0)))))\n            )\n        }\n    }",
            "start": "116",
            "end": "140",
            "class": "LibBitmap",
            "signature": " unsetBatchBitmap storage bitmap, uint256 start, uint256 amount",
            "full_signature": "function unsetBatch(Bitmap storage bitmap, uint256 start, uint256 amount) internal",
            "class_method_signature": "LibBitmap.unsetBatchBitmap storage bitmap, uint256 start, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function and(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Unsets a batch of bits in a bitmap starting from a specific position.\n *\n * @param bitmap The storage reference to the bitmap.\n * @param start The starting bit position from which to unset bits.\n * @param amount The number of bits to unset.\n *\n * Steps:\n * 1. Calculate the shift value based on the starting position.\n * 2. Load the bitmap's storage slot into memory.\n * 3. If the range of bits to unset spans multiple storage slots:\n *    - Unset the bits in the current slot.\n *    - Calculate the range of affected storage slots.\n *    - Iterate through the affected slots and set them to 0.\n * 4. If the range of bits to unset is within a single storage slot:\n *    - Unset the bits in the current slot using a bitmask.\n *\n * @dev This function uses low-level assembly for efficient bit manipulation.\n */"
        },
        {
            "identifier": "popCount",
            "parameters": "Bitmap storage bitmap, uint256 start, uint256 amount",
            "modifiers": "view",
            "return": "returns (uint256 count)",
            "body": "function popCount(Bitmap storage bitmap, uint256 start, uint256 amount)\n        internal\n        view\n        returns (uint256 count)\n    {\n        unchecked {\n            uint256 bucket = start >> 8;\n            uint256 shift = start & 0xff;\n            if (!(amount + shift < 257)) {\n                count = LibBit.popCount(bitmap.map[bucket] >> shift);\n                uint256 bucketEnd = bucket + ((amount + shift) >> 8);\n                amount = (amount + shift) & 0xff;\n                shift = 0;\n                for (++bucket; bucket != bucketEnd; ++bucket) {\n                    count += LibBit.popCount(bitmap.map[bucket]);\n                }\n            }\n            count += LibBit.popCount((bitmap.map[bucket] >> shift) << (256 - amount));\n        }\n    }",
            "start": "144",
            "end": "163",
            "class": "LibBitmap",
            "signature": "returns (uint256 count) popCountBitmap storage bitmap, uint256 start, uint256 amount",
            "full_signature": "function popCount(Bitmap storage bitmap, uint256 start, uint256 amount) internal  view returns (uint256 count)",
            "class_method_signature": "LibBitmap.popCountBitmap storage bitmap, uint256 start, uint256 amount",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function popCount(uint256 x) internal  pure returns (uint256 c)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Calculates the number of set bits (pop count) in a bitmap over a specified range.\n *\n * @param bitmap The storage reference to the bitmap.\n * @param start The starting index from which to begin counting set bits.\n * @param amount The number of bits to consider for counting.\n * @return count The total number of set bits within the specified range.\n *\n * Steps:\n * 1. Calculate the bucket index by dividing the start index by 256 (shift right by 8).\n * 2. Calculate the shift amount within the bucket by taking the start index modulo 256.\n * 3. Check if the range (amount + shift) exceeds 256 bits.\n *    - If it does, calculate the pop count for the remaining bits in the current bucket.\n *    - Increment the bucket index and calculate the pop count for full buckets until the end of the range.\n *    - Adjust the amount and shift for the final bucket.\n * 4. Calculate the pop count for the remaining bits in the final bucket.\n * 5. Return the total count of set bits.\n *\n * Note: The function uses unchecked arithmetic for gas optimization.\n */"
        },
        {
            "identifier": "findLastSet",
            "parameters": "Bitmap storage bitmap, uint256 upTo",
            "modifiers": "view",
            "return": "returns (uint256 setBitIndex)",
            "body": "function findLastSet(Bitmap storage bitmap, uint256 upTo)\n        internal\n        view\n        returns (uint256 setBitIndex)\n    {\n        setBitIndex = NOT_FOUND;\n        uint256 bucket = upTo >> 8;\n        uint256 bits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, not(upTo)) // `256 - (255 & upTo) - 1`.\n            bits := shr(offset, shl(offset, sload(keccak256(0x00, 0x40))))\n            if iszero(or(bits, iszero(bucket))) {\n                for {} 1 {} {\n                    bucket := add(bucket, setBitIndex) // `sub(bucket, 1)`.\n                    mstore(0x00, bucket)\n                    bits := sload(keccak256(0x00, 0x40))\n                    if or(bits, iszero(bucket)) { break }\n                }\n            }\n        }\n        if (bits != 0) {\n            setBitIndex = (bucket << 8) | LibBit.fls(bits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                setBitIndex := or(setBitIndex, sub(0, gt(setBitIndex, upTo)))\n            }\n        }\n    }",
            "start": "167",
            "end": "197",
            "class": "LibBitmap",
            "signature": "returns (uint256 setBitIndex) findLastSetBitmap storage bitmap, uint256 upTo",
            "full_signature": "function findLastSet(Bitmap storage bitmap, uint256 upTo) internal  view returns (uint256 setBitIndex)",
            "class_method_signature": "LibBitmap.findLastSetBitmap storage bitmap, uint256 upTo",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function fls(uint256 x) internal  pure returns (uint256 r)', 'function ffs(uint256 x) internal  pure returns (uint256 r)', 'function and(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the index of the last set bit in a bitmap up to a specified index.\n *\n * @param bitmap The storage reference to the bitmap.\n * @param upTo The maximum index to search for the last set bit.\n * @return setBitIndex The index of the last set bit, or `NOT_FOUND` if no set bit is found.\n *\n * Steps:\n * 1. Initialize `setBitIndex` to `NOT_FOUND`.\n * 2. Calculate the bucket index by shifting `upTo` right by 8 bits.\n * 3. Use assembly to:\n *    - Load the bucket and bitmap slot into memory.\n *    - Calculate the offset within the bucket.\n *    - Extract the relevant bits from the bitmap.\n *    - If no bits are set in the current bucket, iterate backward through previous buckets until a set bit is found or the first bucket is reached.\n * 4. If a set bit is found, calculate its index by combining the bucket index and the position of the highest set bit within the bucket.\n * 5. Adjust the index if it exceeds `upTo` by setting it to `NOT_FOUND`.\n */"
        },
        {
            "identifier": "findFirstUnset",
            "parameters": "Bitmap storage bitmap, uint256 begin, uint256 upTo",
            "modifiers": "view",
            "return": "returns (uint256 unsetBitIndex)",
            "body": "function findFirstUnset(Bitmap storage bitmap, uint256 begin, uint256 upTo)\n        internal\n        view\n        returns (uint256 unsetBitIndex)\n    {\n        unsetBitIndex = NOT_FOUND;\n        uint256 bucket = begin >> 8;\n        uint256 negBits;\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, bucket)\n            mstore(0x20, bitmap.slot)\n            let offset := and(0xff, begin)\n            negBits := shl(offset, shr(offset, not(sload(keccak256(0x00, 0x40)))))\n            if iszero(negBits) {\n                let lastBucket := shr(8, upTo)\n                for {} 1 {} {\n                    bucket := add(bucket, 1)\n                    mstore(0x00, bucket)\n                    negBits := not(sload(keccak256(0x00, 0x40)))\n                    if or(negBits, gt(bucket, lastBucket)) { break }\n                }\n                if gt(bucket, lastBucket) {\n                    negBits := shl(and(0xff, not(upTo)), shr(and(0xff, not(upTo)), negBits))\n                }\n            }\n        }\n        if (negBits != 0) {\n            uint256 r = (bucket << 8) | LibBit.ffs(negBits);\n            /// @solidity memory-safe-assembly\n            assembly {\n                unsetBitIndex := or(r, sub(0, or(gt(r, upTo), lt(r, begin))))\n            }\n        }\n    }",
            "start": "201",
            "end": "235",
            "class": "LibBitmap",
            "signature": "returns (uint256 unsetBitIndex) findFirstUnsetBitmap storage bitmap, uint256 begin, uint256 upTo",
            "full_signature": "function findFirstUnset(Bitmap storage bitmap, uint256 begin, uint256 upTo) internal  view returns (uint256 unsetBitIndex)",
            "class_method_signature": "LibBitmap.findFirstUnsetBitmap storage bitmap, uint256 begin, uint256 upTo",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {LibBit} from \"./LibBit.sol\";"
            ],
            "context": "{'function or(bool x, bool y) internal  pure returns (bool z)', 'function ffs(uint256 x) internal  pure returns (uint256 r)', 'function and(bool x, bool y) internal  pure returns (bool z)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Finds the first unset bit in a bitmap within a specified range.\n *\n * @param bitmap The storage reference to the bitmap.\n * @param begin The starting index to begin searching for an unset bit.\n * @param upTo The upper limit (exclusive) for the search range.\n * @return unsetBitIndex The index of the first unset bit found, or `NOT_FOUND` if no unset bit is found within the range.\n *\n * Steps:\n * 1. Initialize `unsetBitIndex` to `NOT_FOUND`.\n * 2. Calculate the starting bucket based on the `begin` index.\n * 3. Use assembly to efficiently search for the first unset bit:\n *    - Load the bitmap data for the current bucket.\n *    - Check for unset bits in the current bucket.\n *    - If no unset bits are found, iterate through subsequent buckets until an unset bit is found or the range limit is reached.\n *    - Adjust the search for the last bucket if necessary.\n * 4. If an unset bit is found, calculate its index and ensure it falls within the specified range.\n * 5. Return the index of the first unset bit or `NOT_FOUND` if no unset bit is found.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/WebAuthn.sol": [
        {
            "identifier": "WebAuthnAuth",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct WebAuthnAuth {\n        // The WebAuthn authenticator data.\n        // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorassertionresponse-authenticatordata.\n        bytes authenticatorData;\n        // The WebAuthn client data JSON.\n        // See: https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson.\n        string clientDataJSON;\n        // Start index of \"challenge\":\"...\" in `clientDataJSON`.\n        uint256 challengeIndex;\n        // Start index of \"type\":\"...\" in `clientDataJSON`.\n        uint256 typeIndex;\n        // The r value of secp256r1 signature.\n        bytes32 r;\n        // The s value of secp256r1 signature.\n        bytes32 s;\n    }",
            "start": "17",
            "end": "32",
            "class": "WebAuthn",
            "signature": " WebAuthnAuth",
            "full_signature": "function WebAuthnAuth()",
            "class_method_signature": "WebAuthn.WebAuthnAuth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct for WebAuthn authentication data.\n *\n * @dev This struct is used to store WebAuthn authentication details, including:\n * - `authenticatorData`: The WebAuthn authenticator data as per the WebAuthn specification.\n * - `clientDataJSON`: The WebAuthn client data JSON as per the WebAuthn specification.\n * - `challengeIndex`: The start index of the \"challenge\":\"...\" substring within `clientDataJSON`.\n * - `typeIndex`: The start index of the \"type\":\"...\" substring within `clientDataJSON`.\n * - `r`: The r value of the secp256r1 signature.\n * - `s`: The s value of the secp256r1 signature.\n *\n * This struct is typically used in WebAuthn-based authentication mechanisms.\n */"
        },
        {
            "identifier": "verify",
            "parameters": "bytes memory challenge, bool requireUserVerification, WebAuthnAuth memory auth, bytes32 x, bytes32 y",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        WebAuthnAuth memory auth,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool result) {\n        bytes32 messageHash;\n        string memory encoded = Base64.encode(challenge, true, true);\n        /// @solidity memory-safe-assembly\n        assembly {\n            let clientDataJSON := mload(add(auth, 0x20))\n            let n := mload(clientDataJSON) // `clientDataJSON`'s length.\n            let o := add(clientDataJSON, 0x20) // Start of `clientData`'s bytes.\n            {\n                let c := mload(add(auth, 0x40)) // Challenge index in `clientDataJSON`.\n                let t := mload(add(auth, 0x60)) // Type index in `clientDataJSON`.\n                let l := mload(encoded) // Cache `encoded`'s length.\n                let q := add(l, 0x0d) // Length of `encoded` prefixed with '\"challenge\":\"'.\n                mstore(encoded, shr(152, '\"challenge\":\"')) // Temp prefix with '\"challenge\":\"'.\n                result :=\n                    and(\n                        // 11. Verify JSON's type. Also checks for possible addition overflows.\n                        and(\n                            eq(shr(88, mload(add(o, t))), shr(88, '\"type\":\"webauthn.get\"')),\n                            lt(shr(128, or(t, c)), lt(add(0x14, t), n))\n                        ),\n                        // 12. Verify JSON's challenge. Includes a check for the closing '\"'.\n                        and(\n                            eq(keccak256(add(o, c), q), keccak256(add(encoded, 0x13), q)),\n                            and(eq(byte(0, mload(add(add(o, c), q))), 34), lt(add(q, c), n))\n                        )\n                    )\n                mstore(encoded, l) // Restore `encoded`'s length, in case of string interning.\n            }\n            // Skip 13., 14., 15.\n            let l := mload(mload(auth)) // Length of `authenticatorData`.\n            // 16. Verify that the \"User Present\" flag is set (bit 0).\n            // 17. Verify that the \"User Verified\" flag is set (bit 2), if required.\n            // See: https://www.w3.org/TR/webauthn-2/#flags.\n            let u := or(1, shl(2, iszero(iszero(requireUserVerification))))\n            result := and(and(result, gt(l, 0x20)), eq(and(mload(add(mload(auth), 0x21)), u), u))\n            if result {\n                let p := add(mload(auth), 0x20) // Start of `authenticatorData`'s bytes.\n                let e := add(p, l) // Location of the word after `authenticatorData`.\n                let w := mload(e) // Cache the word after `authenticatorData`.\n                // 19. Compute `sha256(clientDataJSON)`.\n                // 20. Compute `sha256(authenticatorData \u2016 sha256(clientDataJSON))`.\n                // forgefmt: disable-next-item\n                messageHash := mload(staticcall(gas(),\n                    shl(1, staticcall(gas(), 2, o, n, e, 0x20)), p, add(l, 0x20), 0x01, 0x20))\n                mstore(e, w) // Restore the word after `authenticatorData`, in case of reuse.\n                // `returndatasize()` is `0x20` on `sha256` success, and `0x00` otherwise.\n                if iszero(returndatasize()) { invalid() }\n            }\n        }\n        // `P256.verifySignature` returns false if `s > N/2` due to the malleability check.\n        if (result) result = P256.verifySignature(messageHash, auth.r, auth.s, x, y);\n    }",
            "start": "86",
            "end": "144",
            "class": "WebAuthn",
            "signature": "returns (bool result) verifybytes memory challenge, bool requireUserVerification, WebAuthnAuth memory auth, bytes32 x, bytes32 y",
            "full_signature": "function verify(bytes memory challenge, bool requireUserVerification, WebAuthnAuth memory auth, bytes32 x, bytes32 y) internal  view returns (bool result)",
            "class_method_signature": "WebAuthn.verifybytes memory challenge, bool requireUserVerification, WebAuthnAuth memory auth, bytes32 x, bytes32 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A', 'uint256 internal constant B', 'function verifySignature(bytes32 hash, bytes32 r, bytes32 s, bytes32 x, bytes32 y) internal  view returns (bool isValid)', 'function encode(bytes memory data) internal  pure returns (string memory)', 'function encode(bytes memory data) internal  pure returns (string memory result)', 'function encode(bytes memory data, bool fileSafe, bool noPadding) internal  pure returns (string memory result)', 'uint256 internal constant P', 'function encode(bytes memory data, bool fileSafe) internal  pure returns (string memory result)', 'function verify(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal  view returns (bool)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a WebAuthn authentication challenge using the provided parameters.\n *\n * @param challenge The challenge bytes to be verified.\n * @param requireUserVerification A boolean indicating whether user verification is required.\n * @param auth A WebAuthnAuth struct containing authentication data.\n * @param x The x-coordinate of the public key.\n * @param y The y-coordinate of the public key.\n * @return result A boolean indicating whether the verification was successful.\n *\n * Steps:\n * 1. Encode the challenge using Base64 encoding.\n * 2. Use inline assembly to perform low-level operations:\n *    - Extract and verify the type and challenge from the clientDataJSON.\n *    - Ensure the JSON type is \"webauthn.get\" and the challenge matches the encoded challenge.\n *    - Verify the \"User Present\" and \"User Verified\" flags in the authenticatorData.\n *    - Compute the SHA-256 hash of the clientDataJSON and authenticatorData.\n * 3. If all checks pass, verify the signature using the P256 elliptic curve.\n * 4. Return the result of the verification.\n *\n * Note: The function includes checks for JSON structure, flags, and cryptographic signatures.\n */"
        },
        {
            "identifier": "verify",
            "parameters": "bytes memory challenge, bool requireUserVerification, bytes memory authenticatorData, string memory clientDataJSON, uint256 challengeIndex, uint256 typeIndex, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "modifiers": "view",
            "return": "returns (bool)",
            "body": "function verify(\n        bytes memory challenge,\n        bool requireUserVerification,\n        bytes memory authenticatorData,\n        string memory clientDataJSON,\n        uint256 challengeIndex,\n        uint256 typeIndex,\n        bytes32 r,\n        bytes32 s,\n        bytes32 x,\n        bytes32 y\n    ) internal view returns (bool) {\n        return verify(\n            challenge,\n            requireUserVerification,\n            WebAuthnAuth(authenticatorData, clientDataJSON, challengeIndex, typeIndex, r, s),\n            x,\n            y\n        );\n    }",
            "start": "147",
            "end": "166",
            "class": "WebAuthn",
            "signature": "returns (bool) verifybytes memory challenge, bool requireUserVerification, bytes memory authenticatorData, string memory clientDataJSON, uint256 challengeIndex, uint256 typeIndex, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "full_signature": "function verify(bytes memory challenge, bool requireUserVerification, bytes memory authenticatorData, string memory clientDataJSON, uint256 challengeIndex, uint256 typeIndex, bytes32 r, bytes32 s, bytes32 x, bytes32 y) internal  view returns (bool)",
            "class_method_signature": "WebAuthn.verifybytes memory challenge, bool requireUserVerification, bytes memory authenticatorData, string memory clientDataJSON, uint256 challengeIndex, uint256 typeIndex, bytes32 r, bytes32 s, bytes32 x, bytes32 y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A', 'function verify(bytes32 h, bytes32 r, bytes32 s, bytes32 qx, bytes32 qy) internal  view returns (bool)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a WebAuthn authentication challenge using the provided parameters.\n *\n * @param challenge The challenge bytes to be verified.\n * @param requireUserVerification A boolean indicating whether user verification is required.\n * @param authenticatorData The authenticator data bytes.\n * @param clientDataJSON The client data JSON string.\n * @param challengeIndex The index of the challenge in the authenticator data.\n * @param typeIndex The index of the type in the authenticator data.\n * @param r The `r` component of the signature.\n * @param s The `s` component of the signature.\n * @param x The `x` coordinate of the public key.\n * @param y The `y` coordinate of the public key.\n *\n * @return A boolean indicating whether the verification was successful.\n *\n * Steps:\n * 1. Call the internal `verify` function with the provided parameters, including the WebAuthnAuth struct.\n * 2. Return the result of the verification.\n */"
        },
        {
            "identifier": "tryDecodeAuth",
            "parameters": "bytes memory encodedAuth",
            "modifiers": "pure",
            "return": "returns (WebAuthnAuth memory decoded)",
            "body": "function tryDecodeAuth(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            for { let n := mload(encodedAuth) } iszero(lt(n, 0xc0)) {} {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                let p := add(mload(o), o) // Start of `encodedAuth`.\n                if or(gt(add(p, 0xc0), e), lt(p, o)) { break }\n                let authenticatorData := add(mload(p), p)\n                let clientDataJSON := add(mload(add(p, 0x20)), p)\n                if or(\n                    or(gt(authenticatorData, e), lt(authenticatorData, p)),\n                    or(gt(clientDataJSON, e), lt(clientDataJSON, p))\n                ) { break }\n                if or(\n                    gt(add(add(authenticatorData, 0x20), mload(authenticatorData)), e),\n                    gt(add(add(clientDataJSON, 0x20), mload(clientDataJSON)), e)\n                ) { break }\n                mstore(decoded, authenticatorData) // `authenticatorData`.\n                mstore(add(decoded, 0x20), clientDataJSON) // `clientDataJSON`.\n                mstore(add(decoded, 0x40), mload(add(p, 0x40))) // `challengeIndex`.\n                mstore(add(decoded, 0x60), mload(add(p, 0x60))) // `typeIndex`.\n                mstore(add(decoded, 0x80), mload(add(p, 0x80))) // `r`.\n                mstore(add(decoded, 0xa0), mload(add(p, 0xa0))) // `s`.\n                break\n            }\n        }\n    }",
            "start": "180",
            "end": "211",
            "class": "WebAuthn",
            "signature": "returns (WebAuthnAuth memory decoded) tryDecodeAuthbytes memory encodedAuth",
            "full_signature": "function tryDecodeAuth(bytes memory encodedAuth) internal  pure returns (WebAuthnAuth memory decoded)",
            "class_method_signature": "WebAuthn.tryDecodeAuthbytes memory encodedAuth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A', 'function encode(bytes memory data) internal  pure returns (string memory)', 'function encode(bytes memory data, bool fileSafe) internal  pure returns (string memory result)', 'function encode(bytes memory data) internal  pure returns (string memory result)', 'function encode(bytes memory data, bool fileSafe, bool noPadding) internal  pure returns (string memory result)', 'function decode(string memory data) internal  pure returns (bytes memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Attempts to decode WebAuthn authentication data from the provided encoded bytes.\n *\n * @param encodedAuth The encoded authentication data to be decoded.\n * @return decoded A `WebAuthnAuth` struct containing the decoded authentication data.\n *\n * Steps:\n * 1. Use inline assembly to manually decode the `encodedAuth` bytes.\n * 2. Calculate the start (`o`) and end (`e`) of the `encodedAuth` in memory.\n * 3. Extract the start of the encoded data (`p`).\n * 4. Validate that the `authenticatorData` and `clientDataJSON` pointers are within bounds.\n * 5. Validate that the lengths of `authenticatorData` and `clientDataJSON` do not exceed memory bounds.\n * 6. Store the decoded `authenticatorData`, `clientDataJSON`, `challengeIndex`, `typeIndex`, `r`, and `s` into the `decoded` struct.\n * 7. Break the loop once decoding is complete.\n *\n * @dev This function uses low-level assembly for memory-safe decoding of WebAuthn authentication data.\n */"
        },
        {
            "identifier": "tryEncodeAuthCompact",
            "parameters": "WebAuthnAuth memory auth",
            "modifiers": "pure",
            "return": "returns (bytes memory result)",
            "body": "function tryEncodeAuthCompact(WebAuthnAuth memory auth)\n        internal\n        pure\n        returns (bytes memory result)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function copyBytes(o_, s_, c_) -> _e {\n                mstore(o_, shl(240, mload(s_)))\n                o_ := add(o_, c_)\n                _e := add(o_, mload(s_)) // The end of the bytes.\n                for { let d_ := sub(add(0x20, s_), o_) } 1 {} {\n                    mstore(o_, mload(add(d_, o_)))\n                    o_ := add(o_, 0x20)\n                    if iszero(lt(o_, _e)) { break }\n                }\n            }\n            let clientDataJSON := mload(add(0x20, auth))\n            let c := mload(add(0x40, auth)) // `challengeIndex`.\n            let t := mload(add(0x60, auth)) // `typeIndex`.\n            // If none of the lengths are more than `0xffff`.\n            if iszero(shr(16, or(or(t, c), or(mload(mload(auth)), mload(clientDataJSON))))) {\n                result := mload(0x40)\n                // `authenticatorData`, `clientDataJSON`.\n                let o := copyBytes(copyBytes(add(result, 0x20), mload(auth), 2), clientDataJSON, 0)\n                mstore(o, or(shl(240, c), shl(224, t))) // `challengeIndex`, `typeIndex`.\n                mstore(add(o, 0x04), mload(add(0x80, auth))) // `r`.\n                mstore(add(o, 0x24), mload(add(0xa0, auth))) // `s`.\n                mstore(result, sub(add(o, 0x24), result)) // Store the length.\n                mstore(add(o, 0x44), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(o, 0x64)) // Allocate memory .\n            }\n        }\n    }",
            "start": "226",
            "end": "259",
            "class": "WebAuthn",
            "signature": "returns (bytes memory result) tryEncodeAuthCompactWebAuthnAuth memory auth",
            "full_signature": "function tryEncodeAuthCompact(WebAuthnAuth memory auth) internal  pure returns (bytes memory result)",
            "class_method_signature": "WebAuthn.tryEncodeAuthCompactWebAuthnAuth memory auth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A', 'uint256 internal constant B'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Encodes a WebAuthnAuth struct into a compact byte array representation.\n *\n * @param auth The WebAuthnAuth struct containing the following fields:\n *             - `authenticatorData`: The authenticator data bytes.\n *             - `clientDataJSON`: The client data JSON bytes.\n *             - `challengeIndex`: The index of the challenge in the client data JSON.\n *             - `typeIndex`: The index of the type in the client data JSON.\n *             - `r`: The `r` value of the signature.\n *             - `s`: The `s` value of the signature.\n *\n * @return result The compact byte array representation of the WebAuthnAuth struct.\n *\n * Steps:\n * 1. Check if the lengths of `authenticatorData`, `clientDataJSON`, `challengeIndex`, and `typeIndex` are within the limit of `0xffff`.\n * 2. If valid, allocate memory for the result.\n * 3. Copy `authenticatorData` and `clientDataJSON` into the result.\n * 4. Encode `challengeIndex` and `typeIndex` into the result.\n * 5. Append the `r` and `s` values of the signature to the result.\n * 6. Store the length of the result.\n * 7. Zeroize the memory slot after the result to ensure no leftover data.\n * 8. Allocate additional memory for the result.\n *\n * Note: This function uses low-level assembly for memory manipulation to optimize gas usage.\n */"
        },
        {
            "identifier": "tryDecodeAuthCompact",
            "parameters": "bytes memory encodedAuth",
            "modifiers": "pure",
            "return": "returns (WebAuthnAuth memory decoded)",
            "body": "function tryDecodeAuthCompact(bytes memory encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                for { let i_ := 0 } 1 {} {\n                    mstore(add(s_, i_), mload(add(o_, i_)))\n                    i_ := add(i_, 0x20)\n                    if iszero(lt(i_, l_)) { break }\n                }\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            let n := mload(encodedAuth)\n            if iszero(lt(n, 0x46)) {\n                let o := add(encodedAuth, 0x20) // Start of `encodedAuth`'s bytes.\n                let e := add(o, n) // End of `encodedAuth` in memory.\n                n := shr(240, mload(o)) // Length of `authenticatorData`.\n                let a := add(o, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, mload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, mload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), mload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), mload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }",
            "start": "264",
            "end": "301",
            "class": "WebAuthn",
            "signature": "returns (WebAuthnAuth memory decoded) tryDecodeAuthCompactbytes memory encodedAuth",
            "full_signature": "function tryDecodeAuthCompact(bytes memory encodedAuth) internal  pure returns (WebAuthnAuth memory decoded)",
            "class_method_signature": "WebAuthn.tryDecodeAuthCompactbytes memory encodedAuth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A', 'uint256 internal constant B', 'function encode(bytes memory data) internal  pure returns (string memory)', 'function encode(bytes memory data, bool fileSafe) internal  pure returns (string memory result)', 'function encode(bytes memory data) internal  pure returns (string memory result)', 'function encode(bytes memory data, bool fileSafe, bool noPadding) internal  pure returns (string memory result)', 'function decode(string memory data) internal  pure returns (bytes memory result)'}",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Decodes a compact WebAuthn authentication structure from a byte array.\n *\n * @param encodedAuth The byte array containing the encoded WebAuthn authentication data.\n * @return decoded A `WebAuthnAuth` struct containing the decoded authentication data.\n *\n * Steps:\n * 1. Check if the length of `encodedAuth` is at least 0x46 bytes (70 bytes).\n * 2. Extract the length of the `authenticatorData` from the first 2 bytes of `encodedAuth`.\n * 3. Extract the `authenticatorData` from the encoded bytes.\n * 4. Extract the `clientDataJSON` from the encoded bytes.\n * 5. Extract the `challengeIndex` and `typeIndex` from the encoded bytes.\n * 6. Extract the `r` and `s` values (signature components) from the encoded bytes.\n * 7. Store the extracted data into the `decoded` struct.\n *\n * Note: This function uses inline assembly for low-level memory manipulation to efficiently decode the data.\n */"
        },
        {
            "identifier": "tryDecodeAuthCompactCalldata",
            "parameters": "bytes calldata encodedAuth",
            "modifiers": "pure",
            "return": "returns (WebAuthnAuth memory decoded)",
            "body": "function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth)\n        internal\n        pure\n        returns (WebAuthnAuth memory decoded)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            function extractBytes(o_, l_) -> _m {\n                _m := mload(0x40) // Grab the free memory pointer.\n                let s_ := add(_m, 0x20)\n                calldatacopy(s_, o_, l_)\n                mstore(_m, l_) // Store the length.\n                mstore(add(l_, s_), 0) // Zeroize the slot after the string.\n                mstore(0x40, add(0x20, add(l_, s_))) // Allocate memory.\n            }\n            if iszero(lt(encodedAuth.length, 0x46)) {\n                let e := add(encodedAuth.offset, encodedAuth.length) // End of `encodedAuth`.\n                let n := shr(240, calldataload(encodedAuth.offset)) // Length of `authenticatorData`.\n                let a := add(encodedAuth.offset, 0x02) // Start of `authenticatorData`.\n                let c := add(a, n) // Start of `clientDataJSON`.\n                let j := sub(e, 0x44) // Start of `challengeIndex`.\n                if iszero(gt(c, j)) {\n                    mstore(decoded, extractBytes(a, n)) // `authenticatorData`.\n                    mstore(add(decoded, 0x20), extractBytes(c, sub(j, c))) // `clientDataJSON`.\n                    mstore(add(decoded, 0x40), shr(240, calldataload(j))) // `challengeIndex`.\n                    mstore(add(decoded, 0x60), shr(240, calldataload(add(j, 0x02)))) // `typeIndex`.\n                    mstore(add(decoded, 0x80), calldataload(add(j, 0x04))) // `r`.\n                    mstore(add(decoded, 0xa0), calldataload(add(j, 0x24))) // `s`.\n                }\n            }\n        }\n    }",
            "start": "304",
            "end": "335",
            "class": "WebAuthn",
            "signature": "returns (WebAuthnAuth memory decoded) tryDecodeAuthCompactCalldatabytes calldata encodedAuth",
            "full_signature": "function tryDecodeAuthCompactCalldata(bytes calldata encodedAuth) internal  pure returns (WebAuthnAuth memory decoded)",
            "class_method_signature": "WebAuthn.tryDecodeAuthCompactCalldatabytes calldata encodedAuth",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": [
                "import {Base64} from \"./Base64.sol\";",
                "import {P256} from \"./P256.sol\";"
            ],
            "context": "{'uint256 internal constant N', 'uint256 internal constant A', 'uint256 internal constant B', 'function encode(bytes memory data) internal  pure returns (string memory)', 'function encode(bytes memory data, bool fileSafe) internal  pure returns (string memory result)', 'function encode(bytes memory data) internal  pure returns (string memory result)', 'function encode(bytes memory data, bool fileSafe, bool noPadding) internal  pure returns (string memory result)', 'function decode(string memory data) internal  pure returns (bytes memory result)'}",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Decodes a compact WebAuthn authentication data structure from calldata.\n *\n * @param encodedAuth The encoded authentication data passed as calldata.\n * @return decoded A `WebAuthnAuth` struct containing the decoded authentication data.\n *\n * Steps:\n * 1. Check if the length of `encodedAuth` is at least 0x46 bytes (minimum required length).\n * 2. Calculate the end of `encodedAuth` and the start of `authenticatorData`.\n * 3. Extract the length of `authenticatorData` from the first 2 bytes of `encodedAuth`.\n * 4. Calculate the start of `clientDataJSON` and the start of `challengeIndex`.\n * 5. Ensure that `clientDataJSON` does not overlap with `challengeIndex`.\n * 6. Decode and store the following fields in the `decoded` struct:\n *    - `authenticatorData`: Extracted from the specified offset and length.\n *    - `clientDataJSON`: Extracted from the calculated offset and length.\n *    - `challengeIndex`: Extracted from the specified offset.\n *    - `typeIndex`: Extracted from the specified offset.\n *    - `r`: Extracted from the specified offset.\n *    - `s`: Extracted from the specified offset.\n *\n * @dev This function uses inline assembly for low-level memory manipulation to efficiently decode the calldata.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/MerkleProofLib.sol": [
        {
            "identifier": "verify",
            "parameters": "bytes32[] memory proof, bytes32 root, bytes32 leaf",
            "modifiers": "pure",
            "return": "returns (bool isValid)",
            "body": "function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if mload(proof) {\n                // Initialize `offset` to the offset of `proof` elements in memory.\n                let offset := add(proof, 0x20)\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(offset, shl(5, mload(proof)))\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, mload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), mload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }",
            "start": "14",
            "end": "43",
            "class": "MerkleProofLib",
            "signature": "returns (bool isValid) verifybytes32[] memory proof, bytes32 root, bytes32 leaf",
            "full_signature": "function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal  pure returns (bool isValid)",
            "class_method_signature": "MerkleProofLib.verifybytes32[] memory proof, bytes32 root, bytes32 leaf",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a Merkle proof by computing the root hash from the provided proof and leaf.\n *\n * @param proof An array of bytes32 values representing the Merkle proof.\n * @param root The expected root hash of the Merkle tree.\n * @param leaf The leaf node to verify against the Merkle proof.\n * @return isValid A boolean indicating whether the computed root matches the provided root.\n *\n * Steps:\n * 1. Check if the proof array is not empty.\n * 2. Initialize the offset to the start of the proof array in memory.\n * 3. Calculate the end of the proof array in memory.\n * 4. Iterate over each element in the proof array:\n *    a. Compare the current leaf with the proof element.\n *    b. Store the leaf and proof element in scratch space for hashing.\n *    c. Compute the hash of the concatenated leaf and proof element.\n *    d. Update the leaf to the computed hash.\n *    e. Move to the next proof element.\n * 5. After processing all proof elements, compare the final computed leaf with the provided root.\n * 6. Return true if they match, otherwise false.\n *\n * @dev This function uses low-level assembly for efficient memory manipulation and hashing.\n */"
        },
        {
            "identifier": "verifyCalldata",
            "parameters": "bytes32[] calldata proof, bytes32 root, bytes32 leaf",
            "modifiers": "pure",
            "return": "returns (bool isValid)",
            "body": "function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf)\n        internal\n        pure\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            if proof.length {\n                // Left shift by 5 is equivalent to multiplying by 0x20.\n                let end := add(proof.offset, shl(5, proof.length))\n                // Initialize `offset` to the offset of `proof` in the calldata.\n                let offset := proof.offset\n                // Iterate over proof elements to compute root hash.\n                for {} 1 {} {\n                    // Slot of `leaf` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(leaf, calldataload(offset)))\n                    // Store elements to hash contiguously in scratch space.\n                    // Scratch space is 64 bytes (0x00 - 0x3f) and both elements are 32 bytes.\n                    mstore(scratch, leaf)\n                    mstore(xor(scratch, 0x20), calldataload(offset))\n                    // Reuse `leaf` to store the hash to reduce stack operations.\n                    leaf := keccak256(0x00, 0x40)\n                    offset := add(offset, 0x20)\n                    if iszero(lt(offset, end)) { break }\n                }\n            }\n            isValid := eq(leaf, root)\n        }\n    }",
            "start": "46",
            "end": "75",
            "class": "MerkleProofLib",
            "signature": "returns (bool isValid) verifyCalldatabytes32[] calldata proof, bytes32 root, bytes32 leaf",
            "full_signature": "function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal  pure returns (bool isValid)",
            "class_method_signature": "MerkleProofLib.verifyCalldatabytes32[] calldata proof, bytes32 root, bytes32 leaf",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a Merkle proof by reconstructing the root hash from the provided proof and leaf.\n *\n * @param proof An array of bytes32 representing the Merkle proof.\n * @param root The expected root hash of the Merkle tree.\n * @param leaf The leaf node to be verified against the root.\n * @return isValid A boolean indicating whether the reconstructed root matches the provided root.\n *\n * Steps:\n * 1. Check if the proof array is non-empty.\n * 2. Calculate the end offset of the proof array in calldata.\n * 3. Initialize the offset to the start of the proof array in calldata.\n * 4. Iterate over each element in the proof array:\n *    a. Determine the position in scratch space to store the leaf and proof element.\n *    b. Store the leaf and proof element contiguously in scratch space.\n *    c. Compute the hash of the concatenated leaf and proof element.\n *    d. Update the leaf to the computed hash for the next iteration.\n *    e. Increment the offset to process the next proof element.\n *    f. Break the loop if the end of the proof array is reached.\n * 5. Compare the final computed leaf with the provided root.\n * 6. Return true if they match, otherwise false.\n *\n * @dev This function uses low-level assembly for efficient memory and stack operations.\n */"
        },
        {
            "identifier": "verifyMultiProof",
            "parameters": "bytes32[] memory proof, bytes32 root, bytes32[] memory leaves, bool[] memory flags",
            "modifiers": "pure",
            "return": "returns (bool isValid)",
            "body": "function verifyMultiProof(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32[] memory leaves,\n        bool[] memory flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cache the lengths of the arrays.\n            let leavesLength := mload(leaves)\n            let proofLength := mload(proof)\n            let flagsLength := mload(flags)\n\n            // Advance the pointers of the arrays to point to the data.\n            leaves := add(0x20, leaves)\n            proof := add(0x20, proof)\n            flags := add(0x20, flags)\n\n            // If the number of flags is correct.\n            for {} eq(add(leavesLength, proofLength), add(flagsLength, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flagsLength) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    isValid := eq(mload(xor(leaves, mul(xor(proof, leaves), proofLength))), root)\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof, shl(5, proofLength))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                leavesLength := shl(5, leavesLength)\n                for { let i := 0 } iszero(eq(i, leavesLength)) { i := add(i, 0x20) } {\n                    mstore(add(hashesFront, i), mload(add(leaves, i)))\n                }\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, leavesLength)\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flagsLength := add(hashesBack, shl(5, flagsLength))\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(mload(flags)) {\n                        // Loads the next proof.\n                        b := mload(proof)\n                        proof := add(proof, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag.\n                    flags := add(flags, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flagsLength)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof)\n                    )\n                break\n            }\n        }\n    }",
            "start": "87",
            "end": "180",
            "class": "MerkleProofLib",
            "signature": "returns (bool isValid) verifyMultiProofbytes32[] memory proof, bytes32 root, bytes32[] memory leaves, bool[] memory flags",
            "full_signature": "function verifyMultiProof(bytes32[] memory proof, bytes32 root, bytes32[] memory leaves, bool[] memory flags) internal  pure returns (bool isValid)",
            "class_method_signature": "MerkleProofLib.verifyMultiProofbytes32[] memory proof, bytes32 root, bytes32[] memory leaves, bool[] memory flags",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a multi-proof for a Merkle tree using a given set of leaves, proof, and flags.\n *\n * @param proof An array of proof elements used to verify the Merkle tree.\n * @param root The root of the Merkle tree to verify against.\n * @param leaves An array of leaves to be verified.\n * @param flags An array of boolean flags indicating whether to pop from the queue or the proof.\n * @return isValid A boolean indicating whether the multi-proof is valid.\n *\n * Steps:\n * 1. Cache the lengths of the input arrays (proof, leaves, flags).\n * 2. Advance the pointers of the arrays to point to their respective data.\n * 3. Check if the number of flags is correct relative to the lengths of the proof and leaves.\n * 4. If the number of flags is zero, validate the proof or leaf directly against the root.\n * 5. Otherwise, compute the required final proof offset and initialize the queue for hashes.\n * 6. Copy the leaves into the hashes queue.\n * 7. Iterate through the flags to process the proof and queue:\n *    - Pop elements from the hashes queue or proof based on the flag.\n *    - Hash the elements and push the result back onto the queue.\n * 8. Validate the last element in the queue against the root and ensure all proofs are used.\n * 9. Return whether the multi-proof is valid.\n *\n * @dev This function uses low-level assembly for gas optimization and memory safety.\n */"
        },
        {
            "identifier": "verifyMultiProofCalldata",
            "parameters": "bytes32[] calldata proof, bytes32 root, bytes32[] calldata leaves, bool[] calldata flags",
            "modifiers": "pure",
            "return": "returns (bool isValid)",
            "body": "function verifyMultiProofCalldata(\n        bytes32[] calldata proof,\n        bytes32 root,\n        bytes32[] calldata leaves,\n        bool[] calldata flags\n    ) internal pure returns (bool isValid) {\n        // Rebuilds the root by consuming and producing values on a queue.\n        // The queue starts with the `leaves` array, and goes into a `hashes` array.\n        // After the process, the last element on the queue is verified\n        // to be equal to the `root`.\n        //\n        // The `flags` array denotes whether the sibling\n        // should be popped from the queue (`flag == true`), or\n        // should be popped from the `proof` (`flag == false`).\n        /// @solidity memory-safe-assembly\n        assembly {\n            // If the number of flags is correct.\n            for {} eq(add(leaves.length, proof.length), add(flags.length, 1)) {} {\n                // For the case where `proof.length + leaves.length == 1`.\n                if iszero(flags.length) {\n                    // `isValid = (proof.length == 1 ? proof[0] : leaves[0]) == root`.\n                    // forgefmt: disable-next-item\n                    isValid := eq(\n                        calldataload(\n                            xor(leaves.offset, mul(xor(proof.offset, leaves.offset), proof.length))\n                        ),\n                        root\n                    )\n                    break\n                }\n\n                // The required final proof offset if `flagsLength` is not zero, otherwise zero.\n                let proofEnd := add(proof.offset, shl(5, proof.length))\n                // We can use the free memory space for the queue.\n                // We don't need to allocate, since the queue is temporary.\n                let hashesFront := mload(0x40)\n                // Copy the leaves into the hashes.\n                // Sometimes, a little memory expansion costs less than branching.\n                // Should cost less, even with a high free memory offset of 0x7d00.\n                calldatacopy(hashesFront, leaves.offset, shl(5, leaves.length))\n                // Compute the back of the hashes.\n                let hashesBack := add(hashesFront, shl(5, leaves.length))\n                // This is the end of the memory for the queue.\n                // We recycle `flagsLength` to save on stack variables (sometimes save gas).\n                flags.length := add(hashesBack, shl(5, flags.length))\n\n                // We don't need to make a copy of `proof.offset` or `flags.offset`,\n                // as they are pass-by-value (this trick may not always save gas).\n\n                for {} 1 {} {\n                    // Pop from `hashes`.\n                    let a := mload(hashesFront)\n                    // Pop from `hashes`.\n                    let b := mload(add(hashesFront, 0x20))\n                    hashesFront := add(hashesFront, 0x40)\n\n                    // If the flag is false, load the next proof,\n                    // else, pops from the queue.\n                    if iszero(calldataload(flags.offset)) {\n                        // Loads the next proof.\n                        b := calldataload(proof.offset)\n                        proof.offset := add(proof.offset, 0x20)\n                        // Unpop from `hashes`.\n                        hashesFront := sub(hashesFront, 0x20)\n                    }\n\n                    // Advance to the next flag offset.\n                    flags.offset := add(flags.offset, 0x20)\n\n                    // Slot of `a` in scratch space.\n                    // If the condition is true: 0x20, otherwise: 0x00.\n                    let scratch := shl(5, gt(a, b))\n                    // Hash the scratch space and push the result onto the queue.\n                    mstore(scratch, a)\n                    mstore(xor(scratch, 0x20), b)\n                    mstore(hashesBack, keccak256(0x00, 0x40))\n                    hashesBack := add(hashesBack, 0x20)\n                    if iszero(lt(hashesBack, flags.length)) { break }\n                }\n                isValid :=\n                    and(\n                        // Checks if the last value in the queue is same as the root.\n                        eq(mload(sub(hashesBack, 0x20)), root),\n                        // And whether all the proofs are used, if required.\n                        eq(proofEnd, proof.offset)\n                    )\n                break\n            }\n        }\n    }",
            "start": "191",
            "end": "280",
            "class": "MerkleProofLib",
            "signature": "returns (bool isValid) verifyMultiProofCalldatabytes32[] calldata proof, bytes32 root, bytes32[] calldata leaves, bool[] calldata flags",
            "full_signature": "function verifyMultiProofCalldata(bytes32[] calldata proof, bytes32 root, bytes32[] calldata leaves, bool[] calldata flags) internal  pure returns (bool isValid)",
            "class_method_signature": "MerkleProofLib.verifyMultiProofCalldatabytes32[] calldata proof, bytes32 root, bytes32[] calldata leaves, bool[] calldata flags",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Verifies a Merkle multi-proof using calldata for efficiency.\n *\n * @param proof An array of Merkle proof elements.\n * @param root The Merkle root to verify against.\n * @param leaves An array of leaf nodes to verify.\n * @param flags An array of boolean flags indicating whether to pop from the queue or the proof.\n * @return isValid A boolean indicating whether the proof is valid.\n *\n * Steps:\n * 1. Check if the number of flags matches the expected value (leaves.length + proof.length == flags.length + 1).\n * 2. If there are no flags, validate the single leaf or proof against the root.\n * 3. Otherwise, initialize the queue with the leaves and process the proof and flags:\n *    - Pop two elements from the queue.\n *    - If the flag is false, use the next proof element; otherwise, use the next queue element.\n *    - Hash the two elements and push the result back into the queue.\n * 4. Verify that the last element in the queue matches the root and that all proof elements were used.\n * 5. Return the validity of the proof.\n *\n * @dev This function uses low-level assembly for gas efficiency and memory safety.\n */"
        },
        {
            "identifier": "emptyProof",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes32[] calldata proof)",
            "body": "function emptyProof() internal pure returns (bytes32[] calldata proof) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            proof.length := 0\n        }\n    }",
            "start": "287",
            "end": "292",
            "class": "MerkleProofLib",
            "signature": "returns (bytes32[] calldata proof) emptyProof",
            "full_signature": "function emptyProof() internal  pure returns (bytes32[] calldata proof)",
            "class_method_signature": "MerkleProofLib.emptyProof",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns an empty proof array.\n *\n * @dev This function uses inline assembly to set the length of the proof array to 0.\n * It is marked as `internal pure` and returns a `bytes32[] calldata` array.\n *\n * Steps:\n * 1. Use inline assembly to set the length of the `proof` array to 0.\n * 2. Return the empty `proof` array.\n */"
        },
        {
            "identifier": "emptyLeaves",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bytes32[] calldata leaves)",
            "body": "function emptyLeaves() internal pure returns (bytes32[] calldata leaves) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            leaves.length := 0\n        }\n    }",
            "start": "295",
            "end": "300",
            "class": "MerkleProofLib",
            "signature": "returns (bytes32[] calldata leaves) emptyLeaves",
            "full_signature": "function emptyLeaves() internal  pure returns (bytes32[] calldata leaves)",
            "class_method_signature": "MerkleProofLib.emptyLeaves",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Returns an empty array of `bytes32` leaves.\n *\n * @return leaves An empty array of `bytes32` elements.\n *\n * Steps:\n * 1. Use inline assembly to set the length of the `leaves` array to 0.\n * 2. Return the empty array.\n */"
        },
        {
            "identifier": "emptyFlags",
            "parameters": "",
            "modifiers": "pure",
            "return": "returns (bool[] calldata flags)",
            "body": "function emptyFlags() internal pure returns (bool[] calldata flags) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            flags.length := 0\n        }\n    }",
            "start": "303",
            "end": "308",
            "class": "MerkleProofLib",
            "signature": "returns (bool[] calldata flags) emptyFlags",
            "full_signature": "function emptyFlags() internal  pure returns (bool[] calldata flags)",
            "class_method_signature": "MerkleProofLib.emptyFlags",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Returns an empty array of boolean flags.\n *\n * @return flags An empty array of boolean flags.\n *\n * Steps:\n * 1. Use inline assembly to set the length of the `flags` array to 0.\n * 2. Return the empty array.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/LibBit.sol": [
        {
            "identifier": "fls",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function fls(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := or(shl(8, iszero(x)), shl(7, lt(0xffffffffffffffffffffffffffffffff, x)))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0x0706060506020504060203020504030106050205030304010505030400000000))\n        }\n    }",
            "start": "16",
            "end": "28",
            "class": "LibBit",
            "signature": "returns (uint256 r) flsuint256 x",
            "full_signature": "function fls(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "LibBit.flsuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Computes the floor log2 of a given unsigned integer `x` using bitwise operations.\n *\n * @dev This function uses inline assembly to efficiently calculate the floor of the base-2 logarithm of `x`.\n * The result is the largest integer `r` such that `2^r <= x`.\n *\n * @param x The unsigned integer for which to compute the floor log2.\n * @return r The floor log2 of `x`.\n *\n * Steps:\n * 1. Use bitwise operations to determine the highest set bit in `x`.\n * 2. Combine the results of multiple shifts and comparisons to narrow down the value of `r`.\n * 3. Use a lookup table (encoded in a byte sequence) to finalize the result.\n *\n * Note: This function is marked as `internal pure`, meaning it can only be called internally and does not modify the state.\n */"
        },
        {
            "identifier": "clz",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function clz(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := add(xor(r, byte(and(0x1f, shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)),\n                0xf8f9f9faf9fdfafbf9fdfcfdfafbfcfef9fafdfafcfcfbfefafafcfbffffffff)), iszero(x))\n        }\n    }",
            "start": "33",
            "end": "45",
            "class": "LibBit",
            "signature": "returns (uint256 r) clzuint256 x",
            "full_signature": "function clz(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "LibBit.clzuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Counts the leading zeros in a 256-bit unsigned integer.\n *\n * @param x The 256-bit unsigned integer to count leading zeros for.\n * @return r The number of leading zeros in `x`.\n *\n * Steps:\n * 1. Use assembly to perform bitwise operations to count leading zeros.\n * 2. Shift and compare bits to determine the number of leading zeros.\n * 3. Return the count of leading zeros.\n *\n * Note: This function uses low-level assembly for optimization and is memory-safe.\n */"
        },
        {
            "identifier": "ffs",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function ffs(uint256 x) internal pure returns (uint256 r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Isolate the least significant bit.\n            x := and(x, add(not(x), 1))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(5, shr(252, shl(shl(2, shr(250, mul(x,\n                0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff))),\n                0x8040405543005266443200005020610674053026020000107506200176117077)))\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(r, byte(and(div(0xd76453e0, shr(r, x)), 0x1f),\n                0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405))\n        }\n    }",
            "start": "53",
            "end": "69",
            "class": "LibBit",
            "signature": "returns (uint256 r) ffsuint256 x",
            "full_signature": "function ffs(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "LibBit.ffsuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Finds the position of the least significant bit set to 1 in a 256-bit unsigned integer.\n * @dev This function uses assembly for optimized performance and employs a De Bruijn sequence-based lookup.\n * \n * @param x The input 256-bit unsigned integer.\n * @return r The position of the least significant bit set to 1 (0-indexed).\n * \n * Steps:\n * 1. Isolate the least significant bit set to 1 in `x` using bitwise operations.\n * 2. Use a De Bruijn-like lookup for the upper 3 bits of the result.\n * 3. Use a De Bruijn lookup for the lower 5 bits of the result.\n * 4. Combine the results to get the final position of the least significant bit.\n */"
        },
        {
            "identifier": "popCount",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 c)",
            "body": "function popCount(uint256 x) internal pure returns (uint256 c) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let max := not(0)\n            let isMax := eq(x, max)\n            x := sub(x, and(shr(1, x), div(max, 3)))\n            x := add(and(x, div(max, 5)), and(shr(2, x), div(max, 5)))\n            x := and(add(x, shr(4, x)), div(max, 17))\n            c := or(shl(8, isMax), shr(248, mul(x, div(max, 255))))\n        }\n    }",
            "start": "72",
            "end": "82",
            "class": "LibBit",
            "signature": "returns (uint256 c) popCountuint256 x",
            "full_signature": "function popCount(uint256 x) internal  pure returns (uint256 c)",
            "class_method_signature": "LibBit.popCountuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Calculates the number of set bits (population count) in a 256-bit unsigned integer.\n *\n * @param x The input 256-bit unsigned integer for which the population count is calculated.\n * @return c The number of set bits in the input integer.\n *\n * Steps:\n * 1. Initialize `max` as the maximum value for a 256-bit unsigned integer (all bits set to 1).\n * 2. Check if `x` is equal to `max`. If true, set `isMax` to 1, otherwise 0.\n * 3. Reduce `x` by removing every second bit using bitwise operations.\n * 4. Further reduce `x` by combining bits in groups of 2 and 4.\n * 5. Calculate the final population count by combining the results of the previous steps.\n * 6. Return the population count, adjusting for the case where `x` was initially `max`.\n *\n * @dev This function uses low-level assembly for optimized performance.\n */"
        },
        {
            "identifier": "isPo2",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (bool result)",
            "body": "function isPo2(uint256 x) internal pure returns (bool result) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Equivalent to `x && !(x & (x - 1))`.\n            result := iszero(add(and(x, sub(x, 1)), iszero(x)))\n        }\n    }",
            "start": "85",
            "end": "91",
            "class": "LibBit",
            "signature": "returns (bool result) isPo2uint256 x",
            "full_signature": "function isPo2(uint256 x) internal  pure returns (bool result)",
            "class_method_signature": "LibBit.isPo2uint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a given number is a power of two.\n *\n * @param x The number to check.\n * @return result A boolean indicating whether the number is a power of two.\n *\n * Steps:\n * 1. Use inline assembly to perform the check.\n * 2. The assembly logic checks if `x` is non-zero and if `x & (x - 1)` is zero.\n * 3. If both conditions are true, the number is a power of two.\n *\n * Note: This function uses low-level assembly for optimization.\n */"
        },
        {
            "identifier": "reverseBits",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function reverseBits(uint256 x) internal pure returns (uint256 r) {\n        uint256 m0 = 0x0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f0f;\n        uint256 m1 = m0 ^ (m0 << 2);\n        uint256 m2 = m1 ^ (m1 << 1);\n        r = reverseBytes(x);\n        r = (m2 & (r >> 1)) | ((m2 & r) << 1);\n        r = (m1 & (r >> 2)) | ((m1 & r) << 2);\n        r = (m0 & (r >> 4)) | ((m0 & r) << 4);\n    }",
            "start": "94",
            "end": "102",
            "class": "LibBit",
            "signature": "returns (uint256 r) reverseBitsuint256 x",
            "full_signature": "function reverseBits(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "LibBit.reverseBitsuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reverses the bits of a given 256-bit unsigned integer.\n *\n * @param x The input 256-bit unsigned integer whose bits are to be reversed.\n * @return r The resulting 256-bit unsigned integer with reversed bits.\n *\n * Steps:\n * 1. Define a mask `m0` with alternating 4-bit patterns.\n * 2. Create mask `m1` by XORing `m0` with a left-shifted version of itself by 2 bits.\n * 3. Create mask `m2` by XORing `m1` with a left-shifted version of itself by 1 bit.\n * 4. Reverse the bytes of the input `x` using the `reverseBytes` function.\n * 5. Use masks `m2`, `m1`, and `m0` to reverse the bits of the input in stages:\n *    - First, reverse pairs of bits using `m2`.\n *    - Then, reverse groups of 2 bits using `m1`.\n *    - Finally, reverse groups of 4 bits using `m0`.\n * 6. Return the final result `r` with all bits reversed.\n */"
        },
        {
            "identifier": "reverseBytes",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "returns (uint256 r)",
            "body": "function reverseBytes(uint256 x) internal pure returns (uint256 r) {\n        unchecked {\n            // Computing masks on-the-fly reduces bytecode size by about 200 bytes.\n            uint256 m0 = 0x100000000000000000000000000000001 * (~toUint(x == uint256(0)) >> 192);\n            uint256 m1 = m0 ^ (m0 << 32);\n            uint256 m2 = m1 ^ (m1 << 16);\n            uint256 m3 = m2 ^ (m2 << 8);\n            r = (m3 & (x >> 8)) | ((m3 & x) << 8);\n            r = (m2 & (r >> 16)) | ((m2 & r) << 16);\n            r = (m1 & (r >> 32)) | ((m1 & r) << 32);\n            r = (m0 & (r >> 64)) | ((m0 & r) << 64);\n            r = (r >> 128) | (r << 128);\n        }\n    }",
            "start": "105",
            "end": "118",
            "class": "LibBit",
            "signature": "returns (uint256 r) reverseBytesuint256 x",
            "full_signature": "function reverseBytes(uint256 x) internal  pure returns (uint256 r)",
            "class_method_signature": "LibBit.reverseBytesuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Reverses the byte order of a 256-bit unsigned integer.\n *\n * @param x The input 256-bit unsigned integer whose byte order is to be reversed.\n * @return r The resulting 256-bit unsigned integer with reversed byte order.\n *\n * Steps:\n * 1. Compute masks dynamically to reduce bytecode size.\n * 2. Create a mask `m0` based on the input value `x`.\n * 3. Generate subsequent masks `m1`, `m2`, and `m3` by shifting and XORing the previous masks.\n * 4. Reverse the byte order of `x` by applying the masks and shifting operations.\n * 5. Return the final reversed value `r`.\n *\n * Note: The function uses unchecked arithmetic to optimize gas usage.\n */"
        },
        {
            "identifier": "rawAnd",
            "parameters": "bool x, bool y",
            "modifiers": "pure",
            "return": "returns (bool z)",
            "body": "function rawAnd(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(x, y)\n        }\n    }",
            "start": "134",
            "end": "139",
            "class": "LibBit",
            "signature": "returns (bool z) rawAndbool x, bool y",
            "full_signature": "function rawAnd(bool x, bool y) internal  pure returns (bool z)",
            "class_method_signature": "LibBit.rawAndbool x, bool y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a bitwise AND operation on two boolean values using inline assembly.\n *\n * @param x The first boolean value.\n * @param y The second boolean value.\n * @return z The result of the bitwise AND operation between `x` and `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the bitwise AND operation on `x` and `y`.\n * 2. Store the result in `z` and return it.\n *\n * @dev This function is marked as `internal pure` and uses `memory-safe-assembly` to ensure safety.\n */"
        },
        {
            "identifier": "and",
            "parameters": "bool x, bool y",
            "modifiers": "pure",
            "return": "returns (bool z)",
            "body": "function and(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := and(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }",
            "start": "142",
            "end": "147",
            "class": "LibBit",
            "signature": "returns (bool z) andbool x, bool y",
            "full_signature": "function and(bool x, bool y) internal  pure returns (bool z)",
            "class_method_signature": "LibBit.andbool x, bool y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a logical AND operation on two boolean values using inline assembly.\n *\n * @param x The first boolean value.\n * @param y The second boolean value.\n * @return z The result of the logical AND operation between `x` and `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the AND operation.\n * 2. Convert `x` and `y` to non-zero values using `iszero(iszero(...))`.\n * 3. Perform the AND operation on the converted values.\n * 4. Return the result as a boolean.\n */"
        },
        {
            "identifier": "rawOr",
            "parameters": "bool x, bool y",
            "modifiers": "pure",
            "return": "returns (bool z)",
            "body": "function rawOr(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(x, y)\n        }\n    }",
            "start": "150",
            "end": "155",
            "class": "LibBit",
            "signature": "returns (bool z) rawOrbool x, bool y",
            "full_signature": "function rawOr(bool x, bool y) internal  pure returns (bool z)",
            "class_method_signature": "LibBit.rawOrbool x, bool y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a logical OR operation on two boolean values using low-level assembly.\n *\n * @param x The first boolean value.\n * @param y The second boolean value.\n * @return z The result of the logical OR operation between `x` and `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the OR operation on the two boolean values.\n * 2. Return the result of the OR operation.\n *\n * @dev This function uses `assembly` for gas optimization and memory safety.\n */"
        },
        {
            "identifier": "or",
            "parameters": "bool x, bool y",
            "modifiers": "pure",
            "return": "returns (bool z)",
            "body": "function or(bool x, bool y) internal pure returns (bool z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := or(iszero(iszero(x)), iszero(iszero(y)))\n        }\n    }",
            "start": "158",
            "end": "163",
            "class": "LibBit",
            "signature": "returns (bool z) orbool x, bool y",
            "full_signature": "function or(bool x, bool y) internal  pure returns (bool z)",
            "class_method_signature": "LibBit.orbool x, bool y",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Performs a logical OR operation on two boolean values using inline assembly.\n *\n * @param x The first boolean value.\n * @param y The second boolean value.\n * @return z The result of the logical OR operation between `x` and `y`.\n *\n * Steps:\n * 1. Use inline assembly to perform the logical OR operation.\n * 2. Convert `x` and `y` to non-zero values using `iszero(iszero(...))`.\n * 3. Perform the OR operation on the converted values.\n * 4. Return the result as a boolean.\n */"
        },
        {
            "identifier": "rawToUint",
            "parameters": "bool b",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function rawToUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := b\n        }\n    }",
            "start": "166",
            "end": "171",
            "class": "LibBit",
            "signature": "returns (uint256 z) rawToUintbool b",
            "full_signature": "function rawToUint(bool b) internal  pure returns (uint256 z)",
            "class_method_signature": "LibBit.rawToUintbool b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Converts a boolean value to a uint256 representation.\n *\n * @dev This function uses inline assembly to convert a boolean value (`true` or `false`) \n *      into a uint256 value. In Solidity, `true` is represented as `1` and `false` as `0`.\n *\n * @param b The boolean value to convert.\n * @return z The uint256 representation of the boolean value (1 for `true`, 0 for `false`).\n *\n * Steps:\n * 1. Use inline assembly to directly assign the boolean value to the uint256 variable `z`.\n */"
        },
        {
            "identifier": "toUint",
            "parameters": "bool b",
            "modifiers": "pure",
            "return": "returns (uint256 z)",
            "body": "function toUint(bool b) internal pure returns (uint256 z) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            z := iszero(iszero(b))\n        }\n    }",
            "start": "174",
            "end": "179",
            "class": "LibBit",
            "signature": "returns (uint256 z) toUintbool b",
            "full_signature": "function toUint(bool b) internal  pure returns (uint256 z)",
            "class_method_signature": "LibBit.toUintbool b",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts a boolean value to a uint256 representation.\n *\n * @param b The boolean value to convert.\n * @return z The uint256 representation of the boolean value (1 for true, 0 for false).\n *\n * Steps:\n * 1. Use inline assembly to check if the boolean value is true or false.\n * 2. If the boolean is true, return 1; otherwise, return 0.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/GasBurnerLib.sol": [
        {
            "identifier": "burnPure",
            "parameters": "uint256 x",
            "modifiers": "pure",
            "return": "",
            "body": "function burnPure(uint256 x) internal pure {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x10, or(1, x))\n            let n := mul(gt(x, 120), div(x, 91))\n            // We use keccak256 instead of blake2f precompile for better widespread compatibility.\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                mstore(0x10, keccak256(0x10, 0x10)) // Yes.\n            }\n            if iszero(mload(0x10)) { invalid() }\n        }\n    }",
            "start": "15",
            "end": "26",
            "class": "GasBurnerLib",
            "signature": " burnPureuint256 x",
            "full_signature": "function burnPure(uint256 x) internal  pure",
            "class_method_signature": "GasBurnerLib.burnPureuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Internal pure function to perform a burn operation using low-level assembly.\n *\n * @param x The input value used in the burn operation.\n *\n * Steps:\n * 1. Store the value `or(1, x)` at memory location `0x10`.\n * 2. Calculate `n` as the result of `mul(gt(x, 120), div(x, 91))`. This determines the number of iterations.\n * 3. Iterate `n` times, updating the value at memory location `0x10` using the `keccak256` hash function.\n * 4. If the final value at memory location `0x10` is zero, trigger an invalid operation (revert).\n *\n * Notes:\n * - The function uses inline assembly for low-level memory manipulation.\n * - The `keccak256` hash function is used instead of the `blake2f` precompile for better compatibility.\n */"
        },
        {
            "identifier": "burnView",
            "parameters": "uint256 x",
            "modifiers": "view",
            "return": "",
            "body": "function burnView(uint256 x) internal view {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let n := mul(gt(x, 3500), div(x, 3200))\n            let m := mload(0x40)\n            mstore(0x00, xor(address(), xor(origin(), timestamp())))\n            mstore(0x00, keccak256(0x00, 0x20))\n            mstore(0x20, 27) // `v`.\n            mstore(0x40, 45) // `r`.\n            mstore(0x60, 10) // `s`.\n            for { let i := 0 } iszero(eq(i, n)) { i := add(i, 1) } {\n                pop(staticcall(gas(), 1, 0x00, 0x81, 0x00, 0x20))\n            }\n            if iszero(mload(0x10)) { invalid() }\n            mstore(0x60, 0) // Restore the zero slot.\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "29",
            "end": "46",
            "class": "GasBurnerLib",
            "signature": " burnViewuint256 x",
            "full_signature": "function burnView(uint256 x) internal  view",
            "class_method_signature": "GasBurnerLib.burnViewuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice A view function that performs a series of low-level assembly operations.\n *\n * Steps:\n * 1. Calculate `n` based on the input `x`. If `x` is greater than 3500, `n` is set to `x / 3200`; otherwise, `n` is 0.\n * 2. Store the current free memory pointer in `m`.\n * 3. Perform a series of memory operations:\n *    - Store a computed value at memory location 0x00.\n *    - Compute the keccak256 hash of the first 32 bytes of memory and store it back at 0x00.\n *    - Store predefined values at memory locations 0x20, 0x40, and 0x60.\n * 4. Execute a loop `n` times, performing a static call to address 1 (Ethereum precompile) with the data in memory.\n * 5. If the value at memory location 0x10 is zero, trigger an invalid opcode to revert the transaction.\n * 6. Restore the zero slot and free memory pointer to their original values.\n *\n * @param x The input value used to determine the number of loop iterations.\n *\n * @dev This function uses inline assembly and is marked as `view`, meaning it does not modify the state.\n */"
        },
        {
            "identifier": "burn",
            "parameters": "uint256 x",
            "modifiers": "",
            "return": "",
            "body": "function burn(uint256 x) internal {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            let n := mul(gt(x, 18000), div(x, 17700))\n            mstore(m, xor(address(), xor(origin(), timestamp())))\n            codecopy(add(m, 0x20), and(keccak256(m, 0x20), 0xff), 2080)\n            for { let i := 0 } 1 { i := add(i, 1) } {\n                let h := keccak256(m, 0x21)\n                mstore(m, h)\n                codecopy(add(m, and(h, 0x7ff)), and(0xff, h), 0xff)\n                mstore(add(m, 2048), not(h))\n                if eq(i, n) {\n                    n := shr(3, mod(x, 17700))\n                    n := mul(gt(n, 0x30), sub(n, 0x30))\n                    mstore(add(m, n), h)\n                    log0(m, add(n, 0x20))\n                    break\n                }\n                log0(m, 2080)\n            }\n        }\n    }",
            "start": "49",
            "end": "71",
            "class": "GasBurnerLib",
            "signature": " burnuint256 x",
            "full_signature": "function burn(uint256 x) internal",
            "class_method_signature": "GasBurnerLib.burnuint256 x",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Internal function to perform a custom burn operation using low-level assembly.\n *\n * Steps:\n * 1. Load the free memory pointer (`mload(0x40)`) into `m`.\n * 2. Calculate `n` based on the input `x`. If `x` is greater than 18000, `n` is set to `x / 17700`; otherwise, it is 0.\n * 3. Store a combination of the contract's address, transaction origin, and current timestamp in memory at `m`.\n * 4. Copy a portion of the contract's code (2080 bytes) into memory starting at `m + 0x20`, using a keccak256 hash as a selector.\n * 5. Enter a loop that continues indefinitely:\n *    a. Calculate a new hash `h` based on the current memory content.\n *    b. Store `h` in memory at `m`.\n *    c. Copy a portion of the contract's code into memory at `m + (h & 0x7ff)`, using `h` as a selector.\n *    d. Store the bitwise negation of `h` in memory at `m + 2048`.\n *    e. If the loop counter `i` equals `n`:\n *       i. Adjust `n` based on `x % 17700` and ensure it is greater than 0x30.\n *       ii. Store `h` in memory at `m + n`.\n *       iii. Emit a log0 event with the memory content from `m` to `m + n + 0x20`.\n *       iv. Break the loop.\n *    f. Emit a log0 event with the memory content from `m` to `m + 2080`.\n *\n * Note: This function uses low-level assembly and is highly optimized for specific use cases. It may not be immediately clear without additional context.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ext/ithaca/BLS.sol": [
        {
            "identifier": "Fp",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Fp {\n        bytes32 a; // Upper 32 bytes.\n        bytes32 b; // Lower 32 bytes.\n    }",
            "start": "30",
            "end": "33",
            "class": "BLS",
            "signature": " Fp",
            "full_signature": "function Fp()",
            "class_method_signature": "BLS.Fp",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct `Fp` representing a fixed-point number or a large integer split into two parts.\n *\n * @param a The upper 32 bytes of the value.\n * @param b The lower 32 bytes of the value.\n *\n * This struct is typically used to handle large numbers or fixed-point arithmetic by splitting the value into two 32-byte chunks.\n */ "
        },
        {
            "identifier": "Fp2",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct Fp2 {\n        bytes32 c0_a;\n        bytes32 c0_b;\n        bytes32 c1_a;\n        bytes32 c1_b;\n    }",
            "start": "36",
            "end": "41",
            "class": "BLS",
            "signature": " Fp2",
            "full_signature": "function Fp2()",
            "class_method_signature": "BLS.Fp2",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct `Fp2` representing a field element in the Fp2 field.\n *\n * The struct contains four `bytes32` fields:\n * - `c0_a`: The first component of the first coefficient.\n * - `c0_b`: The second component of the first coefficient.\n * - `c1_a`: The first component of the second coefficient.\n * - `c1_b`: The second component of the second coefficient.\n *\n * This struct is typically used in cryptographic operations involving field elements in the Fp2 field.\n */ "
        },
        {
            "identifier": "G1Point",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct G1Point {\n        bytes32 x_a;\n        bytes32 x_b;\n        bytes32 y_a;\n        bytes32 y_b;\n    }",
            "start": "44",
            "end": "49",
            "class": "BLS",
            "signature": " G1Point",
            "full_signature": "function G1Point()",
            "class_method_signature": "BLS.G1Point",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Defines a struct `G1Point` representing a point in a cryptographic curve (likely related to elliptic curve cryptography).\n *\n * The struct contains four fields:\n * 1. `x_a`: The first part of the x-coordinate of the point.\n * 2. `x_b`: The second part of the x-coordinate of the point.\n * 3. `y_a`: The first part of the y-coordinate of the point.\n * 4. `y_b`: The second part of the y-coordinate of the point.\n *\n * This structure is typically used in cryptographic operations where points on a curve are represented in a split format.\n */ "
        },
        {
            "identifier": "G2Point",
            "parameters": "",
            "modifiers": "",
            "return": "",
            "body": "struct G2Point {\n        bytes32 x_c0_a;\n        bytes32 x_c0_b;\n        bytes32 x_c1_a;\n        bytes32 x_c1_b;\n        bytes32 y_c0_a;\n        bytes32 y_c0_b;\n        bytes32 y_c1_a;\n        bytes32 y_c1_b;\n    }",
            "start": "52",
            "end": "61",
            "class": "BLS",
            "signature": " G2Point",
            "full_signature": "function G2Point()",
            "class_method_signature": "BLS.G2Point",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Defines a struct representing a G2Point, which is used in cryptographic operations.\n *\n * The struct contains the following fields:\n * - x_c0_a: The first component of the x-coordinate (part 1).\n * - x_c0_b: The second component of the x-coordinate (part 1).\n * - x_c1_a: The first component of the x-coordinate (part 2).\n * - x_c1_b: The second component of the x-coordinate (part 2).\n * - y_c0_a: The first component of the y-coordinate (part 1).\n * - y_c0_b: The second component of the y-coordinate (part 1).\n * - y_c1_a: The first component of the y-coordinate (part 2).\n * - y_c1_b: The second component of the y-coordinate (part 2).\n *\n * This struct is typically used in pairing-based cryptography, such as zk-SNARKs or zk-STARKs.\n */"
        },
        {
            "identifier": "add",
            "parameters": "G1Point memory point0, G1Point memory point1",
            "modifiers": "view",
            "return": "returns (G1Point memory result)",
            "body": "function add(G1Point memory point0, G1Point memory point1)\n        internal\n        view\n        returns (G1Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            mcopy(result, point0, 0x80)\n            mcopy(add(result, 0x80), point1, 0x80)\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x80),\n                    staticcall(gas(), BLS12_G1ADD, result, 0x100, result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0xd6cc76eb) // `G1AddFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "132",
            "end": "150",
            "class": "BLS",
            "signature": "returns (G1Point memory result) addG1Point memory point0, G1Point memory point1",
            "full_signature": "function add(G1Point memory point0, G1Point memory point1) internal  view returns (G1Point memory result)",
            "class_method_signature": "BLS.addG1Point memory point0, G1Point memory point1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Adds two G1 elliptic curve points using the BLS12-381 curve's G1 addition operation.\n *\n * @param point0 The first G1 point to be added.\n * @param point1 The second G1 point to be added.\n * @return result The resulting G1 point after addition.\n *\n * Steps:\n * 1. Copy the first G1 point (`point0`) into the result memory location.\n * 2. Copy the second G1 point (`point1`) into the memory location immediately following the first point.\n * 3. Perform a static call to the BLS12-381 G1 addition precompile (`BLS12_G1ADD`) with the combined points as input.\n * 4. Check if the static call was successful:\n *    - If successful, the result is stored in the `result` memory location.\n *    - If unsuccessful, revert with the error `G1AddFailed()`.\n *\n * @dev This function uses inline assembly for low-level memory operations and interacts with the BLS12-381 precompile.\n *      The function assumes the input points are valid G1 points on the BLS12-381 curve.\n */"
        },
        {
            "identifier": "mul",
            "parameters": "G1Point memory point, bytes32 scalar",
            "modifiers": "view",
            "return": "returns (G1Point memory result)",
            "body": "function mul(G1Point memory point, bytes32 scalar)\n        internal\n        view\n        returns (G1Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            mcopy(result, point, 0x80)\n            mstore(add(result, 0x80), scalar)\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x80),\n                    staticcall(gas(), BLS12_G1MUL, result, 0xa0, result, 0x80)\n                )\n            ) {\n                mstore(0x00, 0x82e1cf54) // `G1MulFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "153",
            "end": "171",
            "class": "BLS",
            "signature": "returns (G1Point memory result) mulG1Point memory point, bytes32 scalar",
            "full_signature": "function mul(G1Point memory point, bytes32 scalar) internal  view returns (G1Point memory result)",
            "class_method_signature": "BLS.mulG1Point memory point, bytes32 scalar",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Multiplies a G1 elliptic curve point by a scalar value using the BLS12_G1MUL precompile.\n *\n * @param point The G1Point to be multiplied.\n * @param scalar The scalar value to multiply the G1Point by.\n * @return result The resulting G1Point after multiplication.\n *\n * Steps:\n * 1. Copy the input G1Point into the result memory location.\n * 2. Store the scalar value in the memory location adjacent to the G1Point.\n * 3. Perform a static call to the BLS12_G1MUL precompile to multiply the G1Point by the scalar.\n * 4. Check if the operation was successful by verifying the return data size and the call result.\n * 5. If the operation fails, revert with the error `G1MulFailed()`.\n *\n * @dev This function uses inline assembly for low-level memory operations and precompile interaction.\n */"
        },
        {
            "identifier": "add",
            "parameters": "G2Point memory point0, G2Point memory point1",
            "modifiers": "view",
            "return": "returns (G2Point memory result)",
            "body": "function add(G2Point memory point0, G2Point memory point1)\n        internal\n        view\n        returns (G2Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            mcopy(result, point0, 0x100)\n            mcopy(add(result, 0x100), point1, 0x100)\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_G2ADD, result, 0x200, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0xc55e5e33) // `G2AddFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "201",
            "end": "219",
            "class": "BLS",
            "signature": "returns (G2Point memory result) addG2Point memory point0, G2Point memory point1",
            "full_signature": "function add(G2Point memory point0, G2Point memory point1) internal  view returns (G2Point memory result)",
            "class_method_signature": "BLS.addG2Point memory point0, G2Point memory point1",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Adds two G2 points together using a precompiled contract for BLS12-381 curve operations.\n *\n * @dev This function performs an elliptic curve addition on two G2 points using the BLS12_G2ADD precompiled contract.\n * The result is stored in the `result` variable. If the operation fails, the function reverts with the error `G2AddFailed()`.\n *\n * @param point0 The first G2 point to be added.\n * @param point1 The second G2 point to be added.\n * @return result The resulting G2 point after addition.\n *\n * Steps:\n * 1. Copy the first G2 point (`point0`) into the first half of the `result` memory.\n * 2. Copy the second G2 point (`point1`) into the second half of the `result` memory.\n * 3. Perform a static call to the BLS12_G2ADD precompiled contract to add the two G2 points.\n * 4. Check if the operation was successful by verifying the return data size and the success of the static call.\n * 5. If the operation fails, revert with the error `G2AddFailed()`.\n */"
        },
        {
            "identifier": "mul",
            "parameters": "G2Point memory point, bytes32 scalar",
            "modifiers": "view",
            "return": "returns (G2Point memory result)",
            "body": "function mul(G2Point memory point, bytes32 scalar)\n        internal\n        view\n        returns (G2Point memory result)\n    {\n        assembly (\"memory-safe\") {\n            mcopy(result, point, 0x100)\n            mstore(add(result, 0x100), scalar)\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_G2MUL, result, 0x120, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0x82e1cf54) // `G1MulFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "222",
            "end": "240",
            "class": "BLS",
            "signature": "returns (G2Point memory result) mulG2Point memory point, bytes32 scalar",
            "full_signature": "function mul(G2Point memory point, bytes32 scalar) internal  view returns (G2Point memory result)",
            "class_method_signature": "BLS.mulG2Point memory point, bytes32 scalar",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Multiplies a G2Point by a scalar using the BLS12_G2MUL precompile.\n *\n * @param point The G2Point to be multiplied.\n * @param scalar The scalar value to multiply the G2Point by.\n * @return result The resulting G2Point after multiplication.\n *\n * Steps:\n * 1. Copy the input G2Point into the result memory location.\n * 2. Store the scalar value in the appropriate memory location.\n * 3. Perform a static call to the BLS12_G2MUL precompile to perform the multiplication.\n * 4. Check if the operation was successful by verifying the return data size and the success of the static call.\n * 5. If the operation fails, revert with the error `G1MulFailed()`.\n *\n * @dev This function uses inline assembly for low-level memory manipulation and interaction with the BLS12_G2MUL precompile.\n */"
        },
        {
            "identifier": "pairing",
            "parameters": "G1Point[] memory g1Points, G2Point[] memory g2Points",
            "modifiers": "view",
            "return": "returns (bool result)",
            "body": "function pairing(G1Point[] memory g1Points, G2Point[] memory g2Points)\n        internal\n        view\n        returns (bool result)\n    {\n        assembly (\"memory-safe\") {\n            let k := mload(g1Points)\n            let m := mload(0x40)\n            let d := sub(g2Points, g1Points)\n            for { let i := 0 } iszero(eq(i, k)) { i := add(i, 1) } {\n                g1Points := add(g1Points, 0x20)\n                let o := add(m, mul(0x180, i))\n                mcopy(o, mload(g1Points), 0x80)\n                mcopy(add(o, 0x80), mload(add(d, g1Points)), 0x100)\n            }\n            if iszero(\n                and(\n                    and(eq(k, mload(g2Points)), eq(returndatasize(), 0x20)),\n                    staticcall(gas(), BLS12_PAIRING_CHECK, m, mul(0x180, k), 0x00, 0x20)\n                )\n            ) {\n                mstore(0x00, 0x4df45e2f) // `PairingFailed()`.\n                revert(0x1c, 0x04)\n            }\n            result := mload(0x00)\n        }\n    }",
            "start": "270",
            "end": "296",
            "class": "BLS",
            "signature": "returns (bool result) pairingG1Point[] memory g1Points, G2Point[] memory g2Points",
            "full_signature": "function pairing(G1Point[] memory g1Points, G2Point[] memory g2Points) internal  view returns (bool result)",
            "class_method_signature": "BLS.pairingG1Point[] memory g1Points, G2Point[] memory g2Points",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "False",
            "human_labeled_comment": "/**\n * @notice Performs a pairing operation on arrays of G1 and G2 points using BLS12-381 curve pairing.\n * \n * @param g1Points An array of G1 points to be paired.\n * @param g2Points An array of G2 points to be paired.\n * @return result A boolean indicating whether the pairing operation was successful.\n *\n * Steps:\n * 1. Load the length of the `g1Points` array.\n * 2. Allocate memory for the pairing operation.\n * 3. Calculate the offset between `g2Points` and `g1Points`.\n * 4. Iterate through the `g1Points` array:\n *    - Copy each G1 point and its corresponding G2 point into the allocated memory.\n * 5. Perform a static call to the BLS12-381 pairing check precompile:\n *    - Verify that the lengths of `g1Points` and `g2Points` match.\n *    - Ensure the return data size is 32 bytes.\n *    - Execute the pairing check.\n * 6. If the pairing check fails, revert with the `PairingFailed()` error.\n * 7. Return the result of the pairing operation.\n */"
        },
        {
            "identifier": "toG2",
            "parameters": "Fp2 memory element",
            "modifiers": "view",
            "return": "returns (G2Point memory result)",
            "body": "function toG2(Fp2 memory element) internal view returns (G2Point memory result) {\n        assembly (\"memory-safe\") {\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_MAP_FP2_TO_G2, element, 0x80, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0x89083b91) // `MapFp2ToG2Failed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "314",
            "end": "326",
            "class": "BLS",
            "signature": "returns (G2Point memory result) toG2Fp2 memory element",
            "full_signature": "function toG2(Fp2 memory element) internal  view returns (G2Point memory result)",
            "class_method_signature": "BLS.toG2Fp2 memory element",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Converts an Fp2 element to a G2 point using a precompiled BLS12-381 mapping function.\n *\n * @dev This function uses inline assembly to call a precompiled contract (BLS12_MAP_FP2_TO_G2) \n *      that maps an Fp2 element to a G2 point. The function checks if the call was successful \n *      by verifying the return data size and the success of the static call. If the call fails, \n *      it reverts with a custom error `MapFp2ToG2Failed()`.\n *\n * @param element The Fp2 element to be mapped to a G2 point.\n * @return result The resulting G2 point after the mapping.\n *\n * Steps:\n * 1. Perform a static call to the precompiled contract `BLS12_MAP_FP2_TO_G2` with the input `element`.\n * 2. Check if the return data size is 0x100 bytes and if the static call was successful.\n * 3. If the call fails, revert with the error `MapFp2ToG2Failed()`.\n * 4. Return the resulting G2 point.\n */"
        },
        {
            "identifier": "hashToG2",
            "parameters": "bytes memory message",
            "modifiers": "view",
            "return": "returns (G2Point memory result)",
            "body": "function hashToG2(bytes memory message) internal view returns (G2Point memory result) {\n        assembly (\"memory-safe\") {\n            function dstPrime(o_, i_) -> _o {\n                mstore8(o_, i_) // 1.\n                mstore(add(o_, 0x01), \"BLS_SIG_BLS12381G2_XMD:SHA-256_S\") // 32.\n                mstore(add(o_, 0x21), \"SWU_RO_NUL_\\x2b\") // 12.\n                _o := add(0x2d, o_)\n            }\n\n            function sha2(data_, n_) -> _h {\n                if iszero(\n                    and(eq(returndatasize(), 0x20), staticcall(gas(), 2, data_, n_, 0x00, 0x20))\n                ) { revert(calldatasize(), 0x00) }\n                _h := mload(0x00)\n            }\n\n            function modfield(s_, b_) {\n                mcopy(add(s_, 0x60), b_, 0x40)\n                if iszero(\n                    and(eq(returndatasize(), 0x40), staticcall(gas(), 5, s_, 0x100, b_, 0x40))\n                ) { revert(calldatasize(), 0x00) }\n            }\n\n            function mapToG2(s_, r_) {\n                if iszero(\n                    and(\n                        eq(returndatasize(), 0x100),\n                        staticcall(gas(), BLS12_MAP_FP2_TO_G2, s_, 0x80, r_, 0x100)\n                    )\n                ) {\n                    mstore(0x00, 0x89083b91) // `MapFp2ToG2Failed()`.\n                    revert(0x1c, 0x04)\n                }\n            }\n\n            let b := mload(0x40)\n            let s := add(b, 0x100)\n            calldatacopy(s, calldatasize(), 0x40)\n            mcopy(add(0x40, s), add(0x20, message), mload(message))\n            let o := add(add(0x40, s), mload(message))\n            mstore(o, shl(240, 256))\n            let b0 := sha2(s, sub(dstPrime(add(0x02, o), 0), s))\n            mstore(0x20, b0)\n            mstore(s, b0)\n            mstore(b, sha2(s, sub(dstPrime(add(0x20, s), 1), s)))\n            let j := b\n            for { let i := 2 } 1 {} {\n                mstore(s, xor(b0, mload(j)))\n                j := add(j, 0x20)\n                mstore(j, sha2(s, sub(dstPrime(add(0x20, s), i), s)))\n                i := add(i, 1)\n                if eq(i, 9) { break }\n            }\n\n            mstore(add(s, 0x00), 0x40)\n            mstore(add(s, 0x20), 0x20)\n            mstore(add(s, 0x40), 0x40)\n            mstore(add(s, 0xa0), 1)\n            mstore(add(s, 0xc0), 0x000000000000000000000000000000001a0111ea397fe69a4b1ba7b6434bacd7)\n            mstore(add(s, 0xe0), 0x64774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab)\n            modfield(s, add(b, 0x00))\n            modfield(s, add(b, 0x40))\n            modfield(s, add(b, 0x80))\n            modfield(s, add(b, 0xc0))\n\n            mapToG2(b, result)\n            mapToG2(add(0x80, b), add(0x100, result))\n\n            if iszero(\n                and(\n                    eq(returndatasize(), 0x100),\n                    staticcall(gas(), BLS12_G2ADD, result, 0x200, result, 0x100)\n                )\n            ) {\n                mstore(0x00, 0xc55e5e33) // `G2AddFailed()`.\n                revert(0x1c, 0x04)\n            }\n        }\n    }",
            "start": "329",
            "end": "407",
            "class": "BLS",
            "signature": "returns (G2Point memory result) hashToG2bytes memory message",
            "full_signature": "function hashToG2(bytes memory message) internal  view returns (G2Point memory result)",
            "class_method_signature": "BLS.hashToG2bytes memory message",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.24;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Hashes a message to a G2 point on the BLS12-381 curve using SHA-256 and domain separation.\n * @dev This function uses low-level assembly to perform cryptographic operations efficiently.\n * \n * Steps:\n * 1. Define helper functions for domain separation (`dstPrime`), SHA-256 hashing (`sha2`), \n *    modular field operations (`modfield`), and mapping to G2 (`mapToG2`).\n * 2. Allocate memory for intermediate calculations and copy the message into memory.\n * 3. Perform domain separation and hash the message using SHA-256.\n * 4. Generate multiple hash outputs by iterating over the domain separation counter.\n * 5. Prepare the input for modular field operations and map the hash outputs to G2 points.\n * 6. Combine the G2 points using elliptic curve addition.\n * 7. Revert if any operation fails, with appropriate error messages.\n * \n * @param message The input message to be hashed.\n * @return result The resulting G2 point on the BLS12-381 curve.\n */"
        }
    ],
    "/root/solady/lib/solady/src/utils/ext/delegatexyz/DelegateCheckerLib.sol": [
        {
            "identifier": "checkDelegateForAll",
            "parameters": "address to, address from",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function checkDelegateForAll(address to, address from) internal view returns (bool isValid) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            // `0x60` is already 0.\n            mstore(0x40, from)\n            mstore(0x2c, shl(96, to))\n            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.\n            isValid := eq(mload(staticcall(gas(), DELEGATE_REGISTRY_V2, 0x1c, 0x64, 0x01, 0x20)), 1)\n            if iszero(isValid) {\n                mstore(0x01, 0x9c395bc200) // `checkDelegateForAll(address,address)`.\n                isValid :=\n                    eq(mload(staticcall(gas(), DELEGATE_REGISTRY_V1, 0x1c, 0x44, 0x01, 0x20)), 1)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n        }\n    }",
            "start": "32",
            "end": "48",
            "class": "DelegateCheckerLib",
            "signature": "returns (bool isValid) checkDelegateForAlladdress to, address from",
            "full_signature": "function checkDelegateForAll(address to, address from) internal  view returns (bool isValid)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForAlladdress to, address from",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a delegate has been granted full permissions (delegateForAll) for a specific address.\n *\n * @param to The address of the delegate being checked.\n * @param from The address of the delegator (the one who granted permissions).\n * @return isValid A boolean indicating whether the delegate has full permissions.\n *\n * Steps:\n * 1. Load the free memory pointer (`0x40`) into `m`.\n * 2. Store the `from` address in memory at `0x40`.\n * 3. Store the `to` address (shifted left by 96 bits) in memory at `0x2c`.\n * 4. Store the function selector for `checkDelegateForAll(address,address,bytes32)` in memory at `0x0c`.\n * 5. Perform a static call to `DELEGATE_REGISTRY_V2` to check if the delegate has full permissions.\n *    - If the result is `1`, set `isValid` to `true`.\n * 6. If the result from `DELEGATE_REGISTRY_V2` is invalid, perform a static call to `DELEGATE_REGISTRY_V1` with a different function selector.\n *    - If the result is `1`, set `isValid` to `true`.\n * 7. Restore the free memory pointer to its original value.\n */"
        },
        {
            "identifier": "checkDelegateForAll",
            "parameters": "address to, address from, bytes32 rights",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function checkDelegateForAll(address to, address from, bytes32 rights)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(0x60, rights)\n            mstore(0x40, from)\n            mstore(0x2c, shl(96, to))\n            mstore(0x0c, 0xe839bd53000000000000000000000000) // `checkDelegateForAll(address,address,bytes32)`.\n            isValid := eq(mload(staticcall(gas(), DELEGATE_REGISTRY_V2, 0x1c, 0x64, 0x01, 0x20)), 1)\n            if iszero(or(rights, isValid)) {\n                mstore(0x01, 0x9c395bc200) // `checkDelegateForAll(address,address)`.\n                isValid :=\n                    eq(mload(staticcall(gas(), DELEGATE_REGISTRY_V1, 0x1c, 0x44, 0x01, 0x20)), 1)\n            }\n            mstore(0x40, m) // Restore the free memory pointer.\n            mstore(0x60, 0) // Restore the zero pointer.\n        }\n    }",
            "start": "55",
            "end": "76",
            "class": "DelegateCheckerLib",
            "signature": "returns (bool isValid) checkDelegateForAlladdress to, address from, bytes32 rights",
            "full_signature": "function checkDelegateForAll(address to, address from, bytes32 rights) internal  view returns (bool isValid)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForAlladdress to, address from, bytes32 rights",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a delegate has been granted specific rights for all tokens from a given address.\n *\n * @param to The address of the delegate to check.\n * @param from The address of the delegator.\n * @param rights The specific rights to check for.\n * @return isValid A boolean indicating whether the delegate has the specified rights.\n *\n * Steps:\n * 1. Load the free memory pointer and prepare memory for the delegate check.\n * 2. Store the `rights`, `from`, and `to` addresses in memory.\n * 3. Use the `checkDelegateForAll` function signature to call the DELEGATE_REGISTRY_V2 contract.\n * 4. Check if the delegate has the specified rights by comparing the result of the static call.\n * 5. If the rights are not granted or the result is invalid, fallback to checking with DELEGATE_REGISTRY_V1.\n * 6. Restore the free memory pointer and zero pointer to their original states.\n * 7. Return the result of the delegate check.\n */"
        },
        {
            "identifier": "checkDelegateForContract",
            "parameters": "address to, address from, address contract_",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function checkDelegateForContract(address to, address from, address contract_)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0x80, m), 0)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForContract(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(isValid) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "start": "84",
            "end": "106",
            "class": "DelegateCheckerLib",
            "signature": "returns (bool isValid) checkDelegateForContractaddress to, address from, address contract_",
            "full_signature": "function checkDelegateForContract(address to, address from, address contract_) internal  view returns (bool isValid)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForContractaddress to, address from, address contract_",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a delegate is authorized for a specific contract on behalf of a delegator.\n *\n * @param to The address of the delegate to check.\n * @param from The address of the delegator (the one who delegated the authority).\n * @param contract_ The address of the contract for which the delegation is being checked.\n * @return isValid A boolean indicating whether the delegate is authorized for the specified contract.\n *\n * Steps:\n * 1. Allocate memory for the function call.\n * 2. Prepare the function call data for `checkDelegateForContract` in both V2 and V1 of the DelegateRegistry.\n * 3. Perform a static call to the DelegateRegistry V2 contract to check delegation.\n * 4. If the V2 check fails, perform a static call to the DelegateRegistry V1 contract as a fallback.\n * 5. Return `true` if the delegate is authorized, otherwise `false`.\n *\n * @dev This function uses inline assembly to optimize gas usage and memory allocation.\n */"
        },
        {
            "identifier": "checkDelegateForContract",
            "parameters": "address to, address from, address contract_, bytes32 rights",
            "modifiers": "view",
            "return": "returns (bool isValid)",
            "body": "function checkDelegateForContract(address to, address from, address contract_, bytes32 rights)\n        internal\n        view\n        returns (bool isValid)\n    {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let m := mload(0x40)\n            mstore(add(0x80, m), rights)\n            mstore(add(0x60, m), contract_)\n            mstore(add(0x4c, m), shl(96, from))\n            mstore(add(0x2c, m), shl(96, to))\n            // `checkDelegateForContract(address,address,address,bytes32)`.\n            mstore(add(0x0c, m), 0x8988eea9000000000000000000000000)\n            isValid := staticcall(gas(), DELEGATE_REGISTRY_V2, add(m, 0x1c), 0x84, m, 0x20)\n            isValid := and(eq(mload(m), 1), isValid)\n            if iszero(or(rights, isValid)) {\n                mstore(m, 0x90c9a2d0) // `checkDelegateForContract(address,address,address)`.\n                isValid := staticcall(gas(), DELEGATE_REGISTRY_V1, add(m, 0x1c), 0x64, m, 0x20)\n                isValid := and(eq(mload(m), 1), isValid)\n            }\n        }\n    }",
            "start": "114",
            "end": "136",
            "class": "DelegateCheckerLib",
            "signature": "returns (bool isValid) checkDelegateForContractaddress to, address from, address contract_, bytes32 rights",
            "full_signature": "function checkDelegateForContract(address to, address from, address contract_, bytes32 rights) internal  view returns (bool isValid)",
            "class_method_signature": "DelegateCheckerLib.checkDelegateForContractaddress to, address from, address contract_, bytes32 rights",
            "testcase": "",
            "constructor": "False",
            "comment": "",
            "virtual": "",
            "id": [],
            "visibility": "internal",
            "type": "",
            "type_name": "",
            "constant": "",
            "invocations": [],
            "sol_version": [
                "pragma solidity ^0.8.4;"
            ],
            "import_directive": "",
            "context": "",
            "is_used": "True",
            "human_labeled_comment": "/**\n * @notice Checks if a delegate has specific rights for a given contract.\n *\n * @param to The address of the delegate to check.\n * @param from The address of the delegator.\n * @param contract_ The address of the contract for which the rights are being checked.\n * @param rights The specific rights to verify (e.g., a bytes32 value representing permissions).\n * @return isValid A boolean indicating whether the delegate has the specified rights for the contract.\n *\n * Steps:\n * 1. Allocate memory for the function call.\n * 2. Pack the function parameters into memory in the correct order.\n * 3. Call the `checkDelegateForContract` function on the `DELEGATE_REGISTRY_V2` contract.\n * 4. Validate the result of the call.\n * 5. If the rights are not valid or not specified, fallback to calling the `checkDelegateForContract` function on the `DELEGATE_REGISTRY_V1` contract.\n * 6. Return the final validation result.\n *\n * Note: This function uses low-level assembly to interact with the delegate registry contracts.\n */"
        }
    ]
}